/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/process/browser.js":
/*!**********************************************************************************************!*\
  !*** /Users/jnoh/Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/process/browser.js ***!
  \**********************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/setimmediate/setImmediate.js":
/*!********************************************************************************************************!*\
  !*** /Users/jnoh/Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/setimmediate/setImmediate.js ***!
  \********************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
      // Callback can either be a function or a string
      if (typeof callback !== "function") {
        callback = new Function("" + callback);
      }
      // Copy function arguments
      var args = new Array(arguments.length - 1);
      for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i + 1];
      }
      // Store and register the task
      var task = { callback: callback, args: args };
      tasksByHandle[nextHandle] = task;
      registerImmediate(nextHandle);
      return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
        case 0:
            callback();
            break;
        case 1:
            callback(args[0]);
            break;
        case 2:
            callback(args[0], args[1]);
            break;
        case 3:
            callback(args[0], args[1], args[2]);
            break;
        default:
            callback.apply(undefined, args);
            break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function(handle) {
            process.nextTick(function () { runIfPresent(handle); });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function() {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function(event) {
            if (event.source === global &&
                typeof event.data === "string" &&
                event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function(event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();

    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();

    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();

    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 6–8
        installReadyStateChangeImplementation();

    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/global.js"), __webpack_require__(/*! ./../process/browser.js */ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/process/browser.js")))

/***/ }),

/***/ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/timers-browserify/main.js":
/*!*****************************************************************************************************!*\
  !*** /Users/jnoh/Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/timers-browserify/main.js ***!
  \*****************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
            (typeof self !== "undefined" && self) ||
            window;
var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function() {
  return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
};
exports.setInterval = function() {
  return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
};
exports.clearTimeout =
exports.clearInterval = function(timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function() {};
Timeout.prototype.close = function() {
  this._clearFn.call(scope, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function(item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function(item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function(item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout)
        item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__(/*! setimmediate */ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/setimmediate/setImmediate.js");
// On some exotic environments, it's not clear which object `setimmediate` was
// able to install onto.  Search each possibility in the same order as the
// `setimmediate` library.
exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
                       (typeof global !== "undefined" && global.setImmediate) ||
                       (this && this.setImmediate);
exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
                         (typeof global !== "undefined" && global.clearImmediate) ||
                         (this && this.clearImmediate);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../webpack/buildin/global.js */ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/amd-options.js":
/*!****************************************!*\
  !*** (webpack)/buildin/amd-options.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* WEBPACK VAR INJECTION */(function(__webpack_amd_options__) {/* globals __webpack_amd_options__ */
module.exports = __webpack_amd_options__;

/* WEBPACK VAR INJECTION */}.call(this, {}))

/***/ }),

/***/ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/module.js":
/*!***********************************!*\
  !*** (webpack)/buildin/module.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function(module) {
	if (!module.webpackPolyfill) {
		module.deprecate = function() {};
		module.paths = [];
		// module.parent = undefined by default
		if (!module.children) module.children = [];
		Object.defineProperty(module, "loaded", {
			enumerable: true,
			get: function() {
				return module.l;
			}
		});
		Object.defineProperty(module, "id", {
			enumerable: true,
			get: function() {
				return module.i;
			}
		});
		module.webpackPolyfill = 1;
	}
	return module;
};


/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/_version.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/_version.js ***!
  \*************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "abi/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/abi-coder.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/abi-coder.js ***!
  \**************************************************************/
/*! exports provided: AbiCoder, defaultAbiCoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AbiCoder", function() { return AbiCoder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultAbiCoder", function() { return defaultAbiCoder; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/abi/lib.esm/_version.js");
/* harmony import */ var _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./coders/abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _coders_address__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./coders/address */ "./node_modules/@ethersproject/abi/lib.esm/coders/address.js");
/* harmony import */ var _coders_array__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./coders/array */ "./node_modules/@ethersproject/abi/lib.esm/coders/array.js");
/* harmony import */ var _coders_boolean__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/boolean */ "./node_modules/@ethersproject/abi/lib.esm/coders/boolean.js");
/* harmony import */ var _coders_bytes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./coders/bytes */ "./node_modules/@ethersproject/abi/lib.esm/coders/bytes.js");
/* harmony import */ var _coders_fixed_bytes__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./coders/fixed-bytes */ "./node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js");
/* harmony import */ var _coders_null__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./coders/null */ "./node_modules/@ethersproject/abi/lib.esm/coders/null.js");
/* harmony import */ var _coders_number__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./coders/number */ "./node_modules/@ethersproject/abi/lib.esm/coders/number.js");
/* harmony import */ var _coders_string__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./coders/string */ "./node_modules/@ethersproject/abi/lib.esm/coders/string.js");
/* harmony import */ var _coders_tuple__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./coders/tuple */ "./node_modules/@ethersproject/abi/lib.esm/coders/tuple.js");
/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./fragments */ "./node_modules/@ethersproject/abi/lib.esm/fragments.js");

// See: https://github.com/ethereum/wiki/wiki/Ethereum-Contract-ABI




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"](_version__WEBPACK_IMPORTED_MODULE_3__["version"]);











const paramTypeBytes = new RegExp(/^bytes([0-9]*)$/);
const paramTypeNumber = new RegExp(/^(u?int)([0-9]*)$/);
class AbiCoder {
    constructor(coerceFunc) {
        logger.checkNew(new.target, AbiCoder);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "coerceFunc", coerceFunc || null);
    }
    _getCoder(param) {
        switch (param.baseType) {
            case "address":
                return new _coders_address__WEBPACK_IMPORTED_MODULE_5__["AddressCoder"](param.name);
            case "bool":
                return new _coders_boolean__WEBPACK_IMPORTED_MODULE_7__["BooleanCoder"](param.name);
            case "string":
                return new _coders_string__WEBPACK_IMPORTED_MODULE_12__["StringCoder"](param.name);
            case "bytes":
                return new _coders_bytes__WEBPACK_IMPORTED_MODULE_8__["BytesCoder"](param.name);
            case "array":
                return new _coders_array__WEBPACK_IMPORTED_MODULE_6__["ArrayCoder"](this._getCoder(param.arrayChildren), param.arrayLength, param.name);
            case "tuple":
                return new _coders_tuple__WEBPACK_IMPORTED_MODULE_13__["TupleCoder"]((param.components || []).map((component) => {
                    return this._getCoder(component);
                }), param.name);
            case "":
                return new _coders_null__WEBPACK_IMPORTED_MODULE_10__["NullCoder"](param.name);
        }
        // u?int[0-9]*
        let match = param.type.match(paramTypeNumber);
        if (match) {
            let size = parseInt(match[2] || "256");
            if (size === 0 || size > 256 || (size % 8) !== 0) {
                logger.throwArgumentError("invalid " + match[1] + " bit length", "param", param);
            }
            return new _coders_number__WEBPACK_IMPORTED_MODULE_11__["NumberCoder"](size / 8, (match[1] === "int"), param.name);
        }
        // bytes[0-9]+
        match = param.type.match(paramTypeBytes);
        if (match) {
            let size = parseInt(match[1]);
            if (size === 0 || size > 32) {
                logger.throwArgumentError("invalid bytes length", "param", param);
            }
            return new _coders_fixed_bytes__WEBPACK_IMPORTED_MODULE_9__["FixedBytesCoder"](size, param.name);
        }
        return logger.throwArgumentError("invalid type", "type", param.type);
    }
    _getWordSize() { return 32; }
    _getReader(data, allowLoose) {
        return new _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_4__["Reader"](data, this._getWordSize(), this.coerceFunc, allowLoose);
    }
    _getWriter() {
        return new _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_4__["Writer"](this._getWordSize());
    }
    getDefaultValue(types) {
        const coders = types.map((type) => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_14__["ParamType"].from(type)));
        const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_13__["TupleCoder"](coders, "_");
        return coder.defaultValue();
    }
    encode(types, values) {
        if (types.length !== values.length) {
            logger.throwError("types/values length mismatch", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"].errors.INVALID_ARGUMENT, {
                count: { types: types.length, values: values.length },
                value: { types: types, values: values }
            });
        }
        const coders = types.map((type) => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_14__["ParamType"].from(type)));
        const coder = (new _coders_tuple__WEBPACK_IMPORTED_MODULE_13__["TupleCoder"](coders, "_"));
        const writer = this._getWriter();
        coder.encode(writer, values);
        return writer.data;
    }
    decode(types, data, loose) {
        const coders = types.map((type) => this._getCoder(_fragments__WEBPACK_IMPORTED_MODULE_14__["ParamType"].from(type)));
        const coder = new _coders_tuple__WEBPACK_IMPORTED_MODULE_13__["TupleCoder"](coders, "_");
        return coder.decode(this._getReader(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(data), loose));
    }
}
const defaultAbiCoder = new AbiCoder();
//# sourceMappingURL=abi-coder.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js ***!
  \**************************************************************************/
/*! exports provided: checkResultErrors, Coder, Writer, Reader */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkResultErrors", function() { return checkResultErrors; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Coder", function() { return Coder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Writer", function() { return Writer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Reader", function() { return Reader; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../_version */ "./node_modules/@ethersproject/abi/lib.esm/_version.js");






const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__["Logger"](_version__WEBPACK_IMPORTED_MODULE_4__["version"]);
function checkResultErrors(result) {
    // Find the first error (if any)
    const errors = [];
    const checkErrors = function (path, object) {
        if (!Array.isArray(object)) {
            return;
        }
        for (let key in object) {
            const childPath = path.slice();
            childPath.push(key);
            try {
                checkErrors(childPath, object[key]);
            }
            catch (error) {
                errors.push({ path: childPath, error: error });
            }
        }
    };
    checkErrors([], result);
    return errors;
}
class Coder {
    constructor(name, type, localName, dynamic) {
        // @TODO: defineReadOnly these
        this.name = name;
        this.type = type;
        this.localName = localName;
        this.dynamic = dynamic;
    }
    _throwError(message, value) {
        logger.throwArgumentError(message, this.localName, value);
    }
}
class Writer {
    constructor(wordSize) {
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["defineReadOnly"])(this, "wordSize", wordSize || 32);
        this._data = [];
        this._dataLength = 0;
        this._padding = new Uint8Array(wordSize);
    }
    get data() {
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexConcat"])(this._data);
    }
    get length() { return this._dataLength; }
    _writeData(data) {
        this._data.push(data);
        this._dataLength += data.length;
        return data.length;
    }
    appendWriter(writer) {
        return this._writeData(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["concat"])(writer._data));
    }
    // Arrayish items; padded on the right to wordSize
    writeBytes(value) {
        let bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(value);
        const paddingOffset = bytes.length % this.wordSize;
        if (paddingOffset) {
            bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["concat"])([bytes, this._padding.slice(paddingOffset)]);
        }
        return this._writeData(bytes);
    }
    _getValue(value) {
        let bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(value));
        if (bytes.length > this.wordSize) {
            logger.throwError("value out-of-bounds", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].errors.BUFFER_OVERRUN, {
                length: this.wordSize,
                offset: bytes.length
            });
        }
        if (bytes.length % this.wordSize) {
            bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["concat"])([this._padding.slice(bytes.length % this.wordSize), bytes]);
        }
        return bytes;
    }
    // BigNumberish items; padded on the left to wordSize
    writeValue(value) {
        return this._writeData(this._getValue(value));
    }
    writeUpdatableValue() {
        const offset = this._data.length;
        this._data.push(this._padding);
        this._dataLength += this.wordSize;
        return (value) => {
            this._data[offset] = this._getValue(value);
        };
    }
}
class Reader {
    constructor(data, wordSize, coerceFunc, allowLoose) {
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["defineReadOnly"])(this, "_data", Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(data));
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["defineReadOnly"])(this, "wordSize", wordSize || 32);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["defineReadOnly"])(this, "_coerceFunc", coerceFunc);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["defineReadOnly"])(this, "allowLoose", allowLoose);
        this._offset = 0;
    }
    get data() { return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexlify"])(this._data); }
    get consumed() { return this._offset; }
    // The default Coerce function
    static coerce(name, value) {
        let match = name.match("^u?int([0-9]+)$");
        if (match && parseInt(match[1]) <= 48) {
            value = value.toNumber();
        }
        return value;
    }
    coerce(name, value) {
        if (this._coerceFunc) {
            return this._coerceFunc(name, value);
        }
        return Reader.coerce(name, value);
    }
    _peekBytes(offset, length, loose) {
        let alignedLength = Math.ceil(length / this.wordSize) * this.wordSize;
        if (this._offset + alignedLength > this._data.length) {
            if (this.allowLoose && loose && this._offset + length <= this._data.length) {
                alignedLength = length;
            }
            else {
                logger.throwError("data out-of-bounds", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].errors.BUFFER_OVERRUN, {
                    length: this._data.length,
                    offset: this._offset + alignedLength
                });
            }
        }
        return this._data.slice(this._offset, this._offset + alignedLength);
    }
    subReader(offset) {
        return new Reader(this._data.slice(this._offset + offset), this.wordSize, this._coerceFunc, this.allowLoose);
    }
    readBytes(length, loose) {
        let bytes = this._peekBytes(0, length, !!loose);
        this._offset += bytes.length;
        // @TODO: Make sure the length..end bytes are all 0?
        return bytes.slice(0, length);
    }
    readValue() {
        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(this.readBytes(this.wordSize));
    }
}
//# sourceMappingURL=abstract-coder.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/address.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/address.js ***!
  \*******************************************************************/
/*! exports provided: AddressCoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddressCoder", function() { return AddressCoder; });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");




class AddressCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_2__["Coder"] {
    constructor(localName) {
        super("address", "address", localName, false);
    }
    defaultValue() {
        return "0x0000000000000000000000000000000000000000";
    }
    encode(writer, value) {
        try {
            value = Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(value);
        }
        catch (error) {
            this._throwError(error.message, value);
        }
        return writer.writeValue(value);
    }
    decode(reader) {
        return Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexZeroPad"])(reader.readValue().toHexString(), 20));
    }
}
//# sourceMappingURL=address.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js ***!
  \*********************************************************************/
/*! exports provided: AnonymousCoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnonymousCoder", function() { return AnonymousCoder; });
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");


// Clones the functionality of an existing Coder, but without a localName
class AnonymousCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__["Coder"] {
    constructor(coder) {
        super(coder.name, coder.type, undefined, coder.dynamic);
        this.coder = coder;
    }
    defaultValue() {
        return this.coder.defaultValue();
    }
    encode(writer, value) {
        return this.coder.encode(writer, value);
    }
    decode(reader) {
        return this.coder.decode(reader);
    }
}
//# sourceMappingURL=anonymous.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/array.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/array.js ***!
  \*****************************************************************/
/*! exports provided: pack, unpack, ArrayCoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pack", function() { return pack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "unpack", function() { return unpack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayCoder", function() { return ArrayCoder; });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_version */ "./node_modules/@ethersproject/abi/lib.esm/_version.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _anonymous__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./anonymous */ "./node_modules/@ethersproject/abi/lib.esm/coders/anonymous.js");



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__["Logger"](_version__WEBPACK_IMPORTED_MODULE_1__["version"]);


function pack(writer, coders, values) {
    let arrayValues = null;
    if (Array.isArray(values)) {
        arrayValues = values;
    }
    else if (values && typeof (values) === "object") {
        let unique = {};
        arrayValues = coders.map((coder) => {
            const name = coder.localName;
            if (!name) {
                logger.throwError("cannot encode object for signature with missing names", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            if (unique[name]) {
                logger.throwError("cannot encode object for signature with duplicate names", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].errors.INVALID_ARGUMENT, {
                    argument: "values",
                    coder: coder,
                    value: values
                });
            }
            unique[name] = true;
            return values[name];
        });
    }
    else {
        logger.throwArgumentError("invalid tuple value", "tuple", values);
    }
    if (coders.length !== arrayValues.length) {
        logger.throwArgumentError("types/value length mismatch", "tuple", values);
    }
    let staticWriter = new _abstract_coder__WEBPACK_IMPORTED_MODULE_2__["Writer"](writer.wordSize);
    let dynamicWriter = new _abstract_coder__WEBPACK_IMPORTED_MODULE_2__["Writer"](writer.wordSize);
    let updateFuncs = [];
    coders.forEach((coder, index) => {
        let value = arrayValues[index];
        if (coder.dynamic) {
            // Get current dynamic offset (for the future pointer)
            let dynamicOffset = dynamicWriter.length;
            // Encode the dynamic value into the dynamicWriter
            coder.encode(dynamicWriter, value);
            // Prepare to populate the correct offset once we are done
            let updateFunc = staticWriter.writeUpdatableValue();
            updateFuncs.push((baseOffset) => {
                updateFunc(baseOffset + dynamicOffset);
            });
        }
        else {
            coder.encode(staticWriter, value);
        }
    });
    // Backfill all the dynamic offsets, now that we know the static length
    updateFuncs.forEach((func) => { func(staticWriter.length); });
    let length = writer.appendWriter(staticWriter);
    length += writer.appendWriter(dynamicWriter);
    return length;
}
function unpack(reader, coders) {
    let values = [];
    // A reader anchored to this base
    let baseReader = reader.subReader(0);
    coders.forEach((coder) => {
        let value = null;
        if (coder.dynamic) {
            let offset = reader.readValue();
            let offsetReader = baseReader.subReader(offset.toNumber());
            try {
                value = coder.decode(offsetReader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        else {
            try {
                value = coder.decode(reader);
            }
            catch (error) {
                // Cannot recover from this
                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].errors.BUFFER_OVERRUN) {
                    throw error;
                }
                value = error;
                value.baseType = coder.name;
                value.name = coder.localName;
                value.type = coder.type;
            }
        }
        if (value != undefined) {
            values.push(value);
        }
    });
    // We only output named properties for uniquely named coders
    const uniqueNames = coders.reduce((accum, coder) => {
        const name = coder.localName;
        if (name) {
            if (!accum[name]) {
                accum[name] = 0;
            }
            accum[name]++;
        }
        return accum;
    }, {});
    // Add any named parameters (i.e. tuples)
    coders.forEach((coder, index) => {
        let name = coder.localName;
        if (!name || uniqueNames[name] !== 1) {
            return;
        }
        if (name === "length") {
            name = "_length";
        }
        if (values[name] != null) {
            return;
        }
        const value = values[index];
        if (value instanceof Error) {
            Object.defineProperty(values, name, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
        else {
            values[name] = value;
        }
    });
    for (let i = 0; i < values.length; i++) {
        const value = values[i];
        if (value instanceof Error) {
            Object.defineProperty(values, i, {
                enumerable: true,
                get: () => { throw value; }
            });
        }
    }
    return Object.freeze(values);
}
class ArrayCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_2__["Coder"] {
    constructor(coder, length, localName) {
        const type = (coder.type + "[" + (length >= 0 ? length : "") + "]");
        const dynamic = (length === -1 || coder.dynamic);
        super("array", type, localName, dynamic);
        this.coder = coder;
        this.length = length;
    }
    defaultValue() {
        // Verifies the child coder is valid (even if the array is dynamic or 0-length)
        const defaultChild = this.coder.defaultValue();
        const result = [];
        for (let i = 0; i < this.length; i++) {
            result.push(defaultChild);
        }
        return result;
    }
    encode(writer, value) {
        if (!Array.isArray(value)) {
            this._throwError("expected array value", value);
        }
        let count = this.length;
        if (count === -1) {
            count = value.length;
            writer.writeValue(value.length);
        }
        logger.checkArgumentCount(value.length, count, "coder array" + (this.localName ? (" " + this.localName) : ""));
        let coders = [];
        for (let i = 0; i < value.length; i++) {
            coders.push(this.coder);
        }
        return pack(writer, coders, value);
    }
    decode(reader) {
        let count = this.length;
        if (count === -1) {
            count = reader.readValue().toNumber();
            // Check that there is *roughly* enough data to ensure
            // stray random data is not being read as a length. Each
            // slot requires at least 32 bytes for their value (or 32
            // bytes as a link to the data). This could use a much
            // tighter bound, but we are erroring on the side of safety.
            if (count * 32 > reader._data.length) {
                logger.throwError("insufficient data length", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].errors.BUFFER_OVERRUN, {
                    length: reader._data.length,
                    count: count
                });
            }
        }
        let coders = [];
        for (let i = 0; i < count; i++) {
            coders.push(new _anonymous__WEBPACK_IMPORTED_MODULE_3__["AnonymousCoder"](this.coder));
        }
        return reader.coerce(this.name, unpack(reader, coders));
    }
}
//# sourceMappingURL=array.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/boolean.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/boolean.js ***!
  \*******************************************************************/
/*! exports provided: BooleanCoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanCoder", function() { return BooleanCoder; });
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");


class BooleanCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__["Coder"] {
    constructor(localName) {
        super("bool", "bool", localName, false);
    }
    defaultValue() {
        return false;
    }
    encode(writer, value) {
        return writer.writeValue(value ? 1 : 0);
    }
    decode(reader) {
        return reader.coerce(this.type, !reader.readValue().isZero());
    }
}
//# sourceMappingURL=boolean.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/bytes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/bytes.js ***!
  \*****************************************************************/
/*! exports provided: DynamicBytesCoder, BytesCoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicBytesCoder", function() { return DynamicBytesCoder; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BytesCoder", function() { return BytesCoder; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");



class DynamicBytesCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_1__["Coder"] {
    constructor(type, localName) {
        super(type, type, localName, true);
    }
    defaultValue() {
        return "0x";
    }
    encode(writer, value) {
        value = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(value);
        let length = writer.writeValue(value.length);
        length += writer.writeBytes(value);
        return length;
    }
    decode(reader) {
        return reader.readBytes(reader.readValue().toNumber(), true);
    }
}
class BytesCoder extends DynamicBytesCoder {
    constructor(localName) {
        super("bytes", localName);
    }
    decode(reader) {
        return reader.coerce(this.name, Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexlify"])(super.decode(reader)));
    }
}
//# sourceMappingURL=bytes.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/fixed-bytes.js ***!
  \***********************************************************************/
/*! exports provided: FixedBytesCoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FixedBytesCoder", function() { return FixedBytesCoder; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");



// @TODO: Merge this with bytes
class FixedBytesCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_1__["Coder"] {
    constructor(size, localName) {
        let name = "bytes" + String(size);
        super(name, name, localName, false);
        this.size = size;
    }
    defaultValue() {
        return ("0x0000000000000000000000000000000000000000000000000000000000000000").substring(0, 2 + this.size * 2);
    }
    encode(writer, value) {
        let data = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(value);
        if (data.length !== this.size) {
            this._throwError("incorrect data length", value);
        }
        return writer.writeBytes(data);
    }
    decode(reader) {
        return reader.coerce(this.name, Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexlify"])(reader.readBytes(this.size)));
    }
}
//# sourceMappingURL=fixed-bytes.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/null.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/null.js ***!
  \****************************************************************/
/*! exports provided: NullCoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NullCoder", function() { return NullCoder; });
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");


class NullCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__["Coder"] {
    constructor(localName) {
        super("null", "", localName, false);
    }
    defaultValue() {
        return null;
    }
    encode(writer, value) {
        if (value != null) {
            this._throwError("not null", value);
        }
        return writer.writeBytes([]);
    }
    decode(reader) {
        reader.readBytes(0);
        return reader.coerce(this.name, null);
    }
}
//# sourceMappingURL=null.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/number.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/number.js ***!
  \******************************************************************/
/*! exports provided: NumberCoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberCoder", function() { return NumberCoder; });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/constants */ "./node_modules/@ethersproject/constants/lib.esm/index.js");
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");




class NumberCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_2__["Coder"] {
    constructor(size, signed, localName) {
        const name = ((signed ? "int" : "uint") + (size * 8));
        super(name, name, localName, false);
        this.size = size;
        this.signed = signed;
    }
    defaultValue() {
        return 0;
    }
    encode(writer, value) {
        let v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(value);
        // Check bounds are safe for encoding
        let maxUintValue = _ethersproject_constants__WEBPACK_IMPORTED_MODULE_1__["MaxUint256"].mask(writer.wordSize * 8);
        if (this.signed) {
            let bounds = maxUintValue.mask(this.size * 8 - 1);
            if (v.gt(bounds) || v.lt(bounds.add(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_1__["One"]).mul(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_1__["NegativeOne"]))) {
                this._throwError("value out-of-bounds", value);
            }
        }
        else if (v.lt(_ethersproject_constants__WEBPACK_IMPORTED_MODULE_1__["Zero"]) || v.gt(maxUintValue.mask(this.size * 8))) {
            this._throwError("value out-of-bounds", value);
        }
        v = v.toTwos(this.size * 8).mask(this.size * 8);
        if (this.signed) {
            v = v.fromTwos(this.size * 8).toTwos(8 * writer.wordSize);
        }
        return writer.writeValue(v);
    }
    decode(reader) {
        let value = reader.readValue().mask(this.size * 8);
        if (this.signed) {
            value = value.fromTwos(this.size * 8);
        }
        return reader.coerce(this.name, value);
    }
}
//# sourceMappingURL=number.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/string.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/string.js ***!
  \******************************************************************/
/*! exports provided: StringCoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringCoder", function() { return StringCoder; });
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");
/* harmony import */ var _bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bytes */ "./node_modules/@ethersproject/abi/lib.esm/coders/bytes.js");



class StringCoder extends _bytes__WEBPACK_IMPORTED_MODULE_1__["DynamicBytesCoder"] {
    constructor(localName) {
        super("string", localName);
    }
    defaultValue() {
        return "";
    }
    encode(writer, value) {
        return super.encode(writer, Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_0__["toUtf8Bytes"])(value));
    }
    decode(reader) {
        return Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_0__["toUtf8String"])(super.decode(reader));
    }
}
//# sourceMappingURL=string.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/coders/tuple.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/coders/tuple.js ***!
  \*****************************************************************/
/*! exports provided: TupleCoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TupleCoder", function() { return TupleCoder; });
/* harmony import */ var _abstract_coder__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony import */ var _array__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./array */ "./node_modules/@ethersproject/abi/lib.esm/coders/array.js");



class TupleCoder extends _abstract_coder__WEBPACK_IMPORTED_MODULE_0__["Coder"] {
    constructor(coders, localName) {
        let dynamic = false;
        const types = [];
        coders.forEach((coder) => {
            if (coder.dynamic) {
                dynamic = true;
            }
            types.push(coder.type);
        });
        const type = ("tuple(" + types.join(",") + ")");
        super("tuple", type, localName, dynamic);
        this.coders = coders;
    }
    defaultValue() {
        const values = [];
        this.coders.forEach((coder) => {
            values.push(coder.defaultValue());
        });
        // We only output named properties for uniquely named coders
        const uniqueNames = this.coders.reduce((accum, coder) => {
            const name = coder.localName;
            if (name) {
                if (!accum[name]) {
                    accum[name] = 0;
                }
                accum[name]++;
            }
            return accum;
        }, {});
        // Add named values
        this.coders.forEach((coder, index) => {
            let name = coder.localName;
            if (!name || uniqueNames[name] !== 1) {
                return;
            }
            if (name === "length") {
                name = "_length";
            }
            if (values[name] != null) {
                return;
            }
            values[name] = values[index];
        });
        return Object.freeze(values);
    }
    encode(writer, value) {
        return Object(_array__WEBPACK_IMPORTED_MODULE_1__["pack"])(writer, this.coders, value);
    }
    decode(reader) {
        return reader.coerce(this.name, Object(_array__WEBPACK_IMPORTED_MODULE_1__["unpack"])(reader, this.coders));
    }
}
//# sourceMappingURL=tuple.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/fragments.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/fragments.js ***!
  \**************************************************************/
/*! exports provided: FormatTypes, ParamType, Fragment, EventFragment, ConstructorFragment, FunctionFragment, ErrorFragment */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FormatTypes", function() { return FormatTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParamType", function() { return ParamType; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return Fragment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventFragment", function() { return EventFragment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConstructorFragment", function() { return ConstructorFragment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FunctionFragment", function() { return FunctionFragment; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorFragment", function() { return ErrorFragment; });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/abi/lib.esm/_version.js");





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"](_version__WEBPACK_IMPORTED_MODULE_3__["version"]);
;
const _constructorGuard = {};
let ModifiersBytes = { calldata: true, memory: true, storage: true };
let ModifiersNest = { calldata: true, memory: true };
function checkModifier(type, name) {
    if (type === "bytes" || type === "string") {
        if (ModifiersBytes[name]) {
            return true;
        }
    }
    else if (type === "address") {
        if (name === "payable") {
            return true;
        }
    }
    else if (type.indexOf("[") >= 0 || type === "tuple") {
        if (ModifiersNest[name]) {
            return true;
        }
    }
    if (ModifiersBytes[name] || name === "payable") {
        logger.throwArgumentError("invalid modifier", "name", name);
    }
    return false;
}
// @TODO: Make sure that children of an indexed tuple are marked with a null indexed
function parseParamType(param, allowIndexed) {
    let originalParam = param;
    function throwError(i) {
        logger.throwArgumentError(`unexpected character at position ${i}`, "param", param);
    }
    param = param.replace(/\s/g, " ");
    function newNode(parent) {
        let node = { type: "", name: "", parent: parent, state: { allowType: true } };
        if (allowIndexed) {
            node.indexed = false;
        }
        return node;
    }
    let parent = { type: "", name: "", state: { allowType: true } };
    let node = parent;
    for (let i = 0; i < param.length; i++) {
        let c = param[i];
        switch (c) {
            case "(":
                if (node.state.allowType && node.type === "") {
                    node.type = "tuple";
                }
                else if (!node.state.allowParams) {
                    throwError(i);
                }
                node.state.allowType = false;
                node.type = verifyType(node.type);
                node.components = [newNode(node)];
                node = node.components[0];
                break;
            case ")":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let child = node;
                node = node.parent;
                if (!node) {
                    throwError(i);
                }
                delete child.parent;
                node.state.allowParams = false;
                node.state.allowName = true;
                node.state.allowArray = true;
                break;
            case ",":
                delete node.state;
                if (node.name === "indexed") {
                    if (!allowIndexed) {
                        throwError(i);
                    }
                    node.indexed = true;
                    node.name = "";
                }
                if (checkModifier(node.type, node.name)) {
                    node.name = "";
                }
                node.type = verifyType(node.type);
                let sibling = newNode(node.parent);
                //{ type: "", name: "", parent: node.parent, state: { allowType: true } };
                node.parent.components.push(sibling);
                delete node.parent;
                node = sibling;
                break;
            // Hit a space...
            case " ":
                // If reading type, the type is done and may read a param or name
                if (node.state.allowType) {
                    if (node.type !== "") {
                        node.type = verifyType(node.type);
                        delete node.state.allowType;
                        node.state.allowName = true;
                        node.state.allowParams = true;
                    }
                }
                // If reading name, the name is done
                if (node.state.allowName) {
                    if (node.name !== "") {
                        if (node.name === "indexed") {
                            if (!allowIndexed) {
                                throwError(i);
                            }
                            if (node.indexed) {
                                throwError(i);
                            }
                            node.indexed = true;
                            node.name = "";
                        }
                        else if (checkModifier(node.type, node.name)) {
                            node.name = "";
                        }
                        else {
                            node.state.allowName = false;
                        }
                    }
                }
                break;
            case "[":
                if (!node.state.allowArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.allowArray = false;
                node.state.allowName = false;
                node.state.readArray = true;
                break;
            case "]":
                if (!node.state.readArray) {
                    throwError(i);
                }
                node.type += c;
                node.state.readArray = false;
                node.state.allowArray = true;
                node.state.allowName = true;
                break;
            default:
                if (node.state.allowType) {
                    node.type += c;
                    node.state.allowParams = true;
                    node.state.allowArray = true;
                }
                else if (node.state.allowName) {
                    node.name += c;
                    delete node.state.allowArray;
                }
                else if (node.state.readArray) {
                    node.type += c;
                }
                else {
                    throwError(i);
                }
        }
    }
    if (node.parent) {
        logger.throwArgumentError("unexpected eof", "param", param);
    }
    delete parent.state;
    if (node.name === "indexed") {
        if (!allowIndexed) {
            throwError(originalParam.length - 7);
        }
        if (node.indexed) {
            throwError(originalParam.length - 7);
        }
        node.indexed = true;
        node.name = "";
    }
    else if (checkModifier(node.type, node.name)) {
        node.name = "";
    }
    parent.type = verifyType(parent.type);
    return parent;
}
function populate(object, params) {
    for (let key in params) {
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(object, key, params[key]);
    }
}
const FormatTypes = Object.freeze({
    // Bare formatting, as is needed for computing a sighash of an event or function
    sighash: "sighash",
    // Human-Readable with Minimal spacing and without names (compact human-readable)
    minimal: "minimal",
    // Human-Readable with nice spacing, including all names
    full: "full",
    // JSON-format a la Solidity
    json: "json"
});
const paramTypeArray = new RegExp(/^(.*)\[([0-9]*)\]$/);
class ParamType {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("use fromString", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "new ParamType()"
            });
        }
        populate(this, params);
        let match = this.type.match(paramTypeArray);
        if (match) {
            populate(this, {
                arrayLength: parseInt(match[2] || "-1"),
                arrayChildren: ParamType.fromObject({
                    type: match[1],
                    components: this.components
                }),
                baseType: "array"
            });
        }
        else {
            populate(this, {
                arrayLength: null,
                arrayChildren: null,
                baseType: ((this.components != null) ? "tuple" : this.type)
            });
        }
        this._isParamType = true;
        Object.freeze(this);
    }
    // Format the parameter fragment
    //   - sighash: "(uint256,address)"
    //   - minimal: "tuple(uint256,address) indexed"
    //   - full:    "tuple(uint256 foo, address bar) indexed baz"
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            let result = {
                type: ((this.baseType === "tuple") ? "tuple" : this.type),
                name: (this.name || undefined)
            };
            if (typeof (this.indexed) === "boolean") {
                result.indexed = this.indexed;
            }
            if (this.components) {
                result.components = this.components.map((comp) => JSON.parse(comp.format(format)));
            }
            return JSON.stringify(result);
        }
        let result = "";
        // Array
        if (this.baseType === "array") {
            result += this.arrayChildren.format(format);
            result += "[" + (this.arrayLength < 0 ? "" : String(this.arrayLength)) + "]";
        }
        else {
            if (this.baseType === "tuple") {
                if (format !== FormatTypes.sighash) {
                    result += this.type;
                }
                result += "(" + this.components.map((comp) => comp.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ")";
            }
            else {
                result += this.type;
            }
        }
        if (format !== FormatTypes.sighash) {
            if (this.indexed === true) {
                result += " indexed";
            }
            if (format === FormatTypes.full && this.name) {
                result += " " + this.name;
            }
        }
        return result;
    }
    static from(value, allowIndexed) {
        if (typeof (value) === "string") {
            return ParamType.fromString(value, allowIndexed);
        }
        return ParamType.fromObject(value);
    }
    static fromObject(value) {
        if (ParamType.isParamType(value)) {
            return value;
        }
        return new ParamType(_constructorGuard, {
            name: (value.name || null),
            type: verifyType(value.type),
            indexed: ((value.indexed == null) ? null : !!value.indexed),
            components: (value.components ? value.components.map(ParamType.fromObject) : null)
        });
    }
    static fromString(value, allowIndexed) {
        function ParamTypify(node) {
            return ParamType.fromObject({
                name: node.name,
                type: node.type,
                indexed: node.indexed,
                components: node.components
            });
        }
        return ParamTypify(parseParamType(value, !!allowIndexed));
    }
    static isParamType(value) {
        return !!(value != null && value._isParamType);
    }
}
;
function parseParams(value, allowIndex) {
    return splitNesting(value).map((param) => ParamType.fromString(param, allowIndex));
}
class Fragment {
    constructor(constructorGuard, params) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("use a static from method", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "new Fragment()"
            });
        }
        populate(this, params);
        this._isFragment = true;
        Object.freeze(this);
    }
    static from(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        if (typeof (value) === "string") {
            return Fragment.fromString(value);
        }
        return Fragment.fromObject(value);
    }
    static fromObject(value) {
        if (Fragment.isFragment(value)) {
            return value;
        }
        switch (value.type) {
            case "function":
                return FunctionFragment.fromObject(value);
            case "event":
                return EventFragment.fromObject(value);
            case "constructor":
                return ConstructorFragment.fromObject(value);
            case "error":
                return ErrorFragment.fromObject(value);
            case "fallback":
            case "receive":
                // @TODO: Something? Maybe return a FunctionFragment? A custom DefaultFunctionFragment?
                return null;
        }
        return logger.throwArgumentError("invalid fragment object", "value", value);
    }
    static fromString(value) {
        // Make sure the "returns" is surrounded by a space and all whitespace is exactly one space
        value = value.replace(/\s/g, " ");
        value = value.replace(/\(/g, " (").replace(/\)/g, ") ").replace(/\s+/g, " ");
        value = value.trim();
        if (value.split(" ")[0] === "event") {
            return EventFragment.fromString(value.substring(5).trim());
        }
        else if (value.split(" ")[0] === "function") {
            return FunctionFragment.fromString(value.substring(8).trim());
        }
        else if (value.split("(")[0].trim() === "constructor") {
            return ConstructorFragment.fromString(value.trim());
        }
        else if (value.split(" ")[0] === "error") {
            return ErrorFragment.fromString(value.substring(5).trim());
        }
        return logger.throwArgumentError("unsupported fragment", "value", value);
    }
    static isFragment(value) {
        return !!(value && value._isFragment);
    }
}
class EventFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "event",
                anonymous: this.anonymous,
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "event ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.anonymous) {
                result += "anonymous ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return EventFragment.fromString(value);
        }
        return EventFragment.fromObject(value);
    }
    static fromObject(value) {
        if (EventFragment.isEventFragment(value)) {
            return value;
        }
        if (value.type !== "event") {
            logger.throwArgumentError("invalid event object", "value", value);
        }
        const params = {
            name: verifyIdentifier(value.name),
            anonymous: value.anonymous,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            type: "event"
        };
        return new EventFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let match = value.match(regexParen);
        if (!match) {
            logger.throwArgumentError("invalid event string", "value", value);
        }
        let anonymous = false;
        match[3].split(" ").forEach((modifier) => {
            switch (modifier.trim()) {
                case "anonymous":
                    anonymous = true;
                    break;
                case "":
                    break;
                default:
                    logger.warn("unknown modifier: " + modifier);
            }
        });
        return EventFragment.fromObject({
            name: match[1].trim(),
            anonymous: anonymous,
            inputs: parseParams(match[2], true),
            type: "event"
        });
    }
    static isEventFragment(value) {
        return (value && value._isFragment && value.type === "event");
    }
}
function parseGas(value, params) {
    params.gas = null;
    let comps = value.split("@");
    if (comps.length !== 1) {
        if (comps.length > 2) {
            logger.throwArgumentError("invalid human-readable ABI signature", "value", value);
        }
        if (!comps[1].match(/^[0-9]+$/)) {
            logger.throwArgumentError("invalid human-readable ABI signature gas", "value", value);
        }
        params.gas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(comps[1]);
        return comps[0];
    }
    return value;
}
function parseModifiers(value, params) {
    params.constant = false;
    params.payable = false;
    params.stateMutability = "nonpayable";
    value.split(" ").forEach((modifier) => {
        switch (modifier.trim()) {
            case "constant":
                params.constant = true;
                break;
            case "payable":
                params.payable = true;
                params.stateMutability = "payable";
                break;
            case "nonpayable":
                params.payable = false;
                params.stateMutability = "nonpayable";
                break;
            case "pure":
                params.constant = true;
                params.stateMutability = "pure";
                break;
            case "view":
                params.constant = true;
                params.stateMutability = "view";
                break;
            case "external":
            case "public":
            case "":
                break;
            default:
                console.log("unknown modifier: " + modifier);
        }
    });
}
function verifyState(value) {
    let result = {
        constant: false,
        payable: true,
        stateMutability: "payable"
    };
    if (value.stateMutability != null) {
        result.stateMutability = value.stateMutability;
        // Set (and check things are consistent) the constant property
        result.constant = (result.stateMutability === "view" || result.stateMutability === "pure");
        if (value.constant != null) {
            if ((!!value.constant) !== result.constant) {
                logger.throwArgumentError("cannot have constant function with mutability " + result.stateMutability, "value", value);
            }
        }
        // Set (and check things are consistent) the payable property
        result.payable = (result.stateMutability === "payable");
        if (value.payable != null) {
            if ((!!value.payable) !== result.payable) {
                logger.throwArgumentError("cannot have payable function with mutability " + result.stateMutability, "value", value);
            }
        }
    }
    else if (value.payable != null) {
        result.payable = !!value.payable;
        // If payable we can assume non-constant; otherwise we can't assume
        if (value.constant == null && !result.payable && value.type !== "constructor") {
            logger.throwArgumentError("unable to determine stateMutability", "value", value);
        }
        result.constant = !!value.constant;
        if (result.constant) {
            result.stateMutability = "view";
        }
        else {
            result.stateMutability = (result.payable ? "payable" : "nonpayable");
        }
        if (result.payable && result.constant) {
            logger.throwArgumentError("cannot have constant payable function", "value", value);
        }
    }
    else if (value.constant != null) {
        result.constant = !!value.constant;
        result.payable = !result.constant;
        result.stateMutability = (result.constant ? "view" : "payable");
    }
    else if (value.type !== "constructor") {
        logger.throwArgumentError("unable to determine stateMutability", "value", value);
    }
    return result;
}
class ConstructorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "constructor",
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format)))
            });
        }
        if (format === FormatTypes.sighash) {
            logger.throwError("cannot format a constructor for sighash", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "format(sighash)"
            });
        }
        let result = "constructor(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (this.stateMutability && this.stateMutability !== "nonpayable") {
            result += this.stateMutability + " ";
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ConstructorFragment.fromString(value);
        }
        return ConstructorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ConstructorFragment.isConstructorFragment(value)) {
            return value;
        }
        if (value.type !== "constructor") {
            logger.throwArgumentError("invalid constructor object", "value", value);
        }
        let state = verifyState(value);
        if (state.constant) {
            logger.throwArgumentError("constructor cannot be constant", "value", value);
        }
        const params = {
            name: null,
            type: value.type,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(value.gas) : null)
        };
        return new ConstructorFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "constructor" };
        value = parseGas(value, params);
        let parens = value.match(regexParen);
        if (!parens || parens[1].trim() !== "constructor") {
            logger.throwArgumentError("invalid constructor string", "value", value);
        }
        params.inputs = parseParams(parens[2].trim(), false);
        parseModifiers(parens[3].trim(), params);
        return ConstructorFragment.fromObject(params);
    }
    static isConstructorFragment(value) {
        return (value && value._isFragment && value.type === "constructor");
    }
}
class FunctionFragment extends ConstructorFragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "function",
                name: this.name,
                constant: this.constant,
                stateMutability: ((this.stateMutability !== "nonpayable") ? this.stateMutability : undefined),
                payable: this.payable,
                gas: (this.gas ? this.gas.toNumber() : undefined),
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
                outputs: this.outputs.map((output) => JSON.parse(output.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "function ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        if (format !== FormatTypes.sighash) {
            if (this.stateMutability) {
                if (this.stateMutability !== "nonpayable") {
                    result += (this.stateMutability + " ");
                }
            }
            else if (this.constant) {
                result += "view ";
            }
            if (this.outputs && this.outputs.length) {
                result += "returns (" + this.outputs.map((output) => output.format(format)).join(", ") + ") ";
            }
            if (this.gas != null) {
                result += "@" + this.gas.toString() + " ";
            }
        }
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return FunctionFragment.fromString(value);
        }
        return FunctionFragment.fromObject(value);
    }
    static fromObject(value) {
        if (FunctionFragment.isFunctionFragment(value)) {
            return value;
        }
        if (value.type !== "function") {
            logger.throwArgumentError("invalid function object", "value", value);
        }
        let state = verifyState(value);
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            constant: state.constant,
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : []),
            outputs: (value.outputs ? value.outputs.map(ParamType.fromObject) : []),
            payable: state.payable,
            stateMutability: state.stateMutability,
            gas: (value.gas ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(value.gas) : null)
        };
        return new FunctionFragment(_constructorGuard, params);
    }
    static fromString(value) {
        let params = { type: "function" };
        value = parseGas(value, params);
        let comps = value.split(" returns ");
        if (comps.length > 2) {
            logger.throwArgumentError("invalid function string", "value", value);
        }
        let parens = comps[0].match(regexParen);
        if (!parens) {
            logger.throwArgumentError("invalid function signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        parseModifiers(parens[3].trim(), params);
        // We have outputs
        if (comps.length > 1) {
            let returns = comps[1].match(regexParen);
            if (returns[1].trim() != "" || returns[3].trim() != "") {
                logger.throwArgumentError("unexpected tokens", "value", value);
            }
            params.outputs = parseParams(returns[2], false);
        }
        else {
            params.outputs = [];
        }
        return FunctionFragment.fromObject(params);
    }
    static isFunctionFragment(value) {
        return (value && value._isFragment && value.type === "function");
    }
}
//export class StructFragment extends Fragment {
//}
function checkForbidden(fragment) {
    const sig = fragment.format();
    if (sig === "Error(string)" || sig === "Panic(uint256)") {
        logger.throwArgumentError(`cannot specify user defined ${sig} error`, "fragment", fragment);
    }
    return fragment;
}
class ErrorFragment extends Fragment {
    format(format) {
        if (!format) {
            format = FormatTypes.sighash;
        }
        if (!FormatTypes[format]) {
            logger.throwArgumentError("invalid format type", "format", format);
        }
        if (format === FormatTypes.json) {
            return JSON.stringify({
                type: "error",
                name: this.name,
                inputs: this.inputs.map((input) => JSON.parse(input.format(format))),
            });
        }
        let result = "";
        if (format !== FormatTypes.sighash) {
            result += "error ";
        }
        result += this.name + "(" + this.inputs.map((input) => input.format(format)).join((format === FormatTypes.full) ? ", " : ",") + ") ";
        return result.trim();
    }
    static from(value) {
        if (typeof (value) === "string") {
            return ErrorFragment.fromString(value);
        }
        return ErrorFragment.fromObject(value);
    }
    static fromObject(value) {
        if (ErrorFragment.isErrorFragment(value)) {
            return value;
        }
        if (value.type !== "error") {
            logger.throwArgumentError("invalid error object", "value", value);
        }
        const params = {
            type: value.type,
            name: verifyIdentifier(value.name),
            inputs: (value.inputs ? value.inputs.map(ParamType.fromObject) : [])
        };
        return checkForbidden(new ErrorFragment(_constructorGuard, params));
    }
    static fromString(value) {
        let params = { type: "error" };
        let parens = value.match(regexParen);
        if (!parens) {
            logger.throwArgumentError("invalid error signature", "value", value);
        }
        params.name = parens[1].trim();
        if (params.name) {
            verifyIdentifier(params.name);
        }
        params.inputs = parseParams(parens[2], false);
        return checkForbidden(ErrorFragment.fromObject(params));
    }
    static isErrorFragment(value) {
        return (value && value._isFragment && value.type === "error");
    }
}
function verifyType(type) {
    // These need to be transformed to their full description
    if (type.match(/^uint($|[^1-9])/)) {
        type = "uint256" + type.substring(4);
    }
    else if (type.match(/^int($|[^1-9])/)) {
        type = "int256" + type.substring(3);
    }
    // @TODO: more verification
    return type;
}
// See: https://github.com/ethereum/solidity/blob/1f8f1a3db93a548d0555e3e14cfc55a10e25b60e/docs/grammar/SolidityLexer.g4#L234
const regexIdentifier = new RegExp("^[a-zA-Z$_][a-zA-Z0-9$_]*$");
function verifyIdentifier(value) {
    if (!value || !value.match(regexIdentifier)) {
        logger.throwArgumentError(`invalid identifier "${value}"`, "value", value);
    }
    return value;
}
const regexParen = new RegExp("^([^)(]*)\\((.*)\\)([^)(]*)$");
function splitNesting(value) {
    value = value.trim();
    let result = [];
    let accum = "";
    let depth = 0;
    for (let offset = 0; offset < value.length; offset++) {
        let c = value[offset];
        if (c === "," && depth === 0) {
            result.push(accum);
            accum = "";
        }
        else {
            accum += c;
            if (c === "(") {
                depth++;
            }
            else if (c === ")") {
                depth--;
                if (depth === -1) {
                    logger.throwArgumentError("unbalanced parenthesis", "value", value);
                }
            }
        }
    }
    if (accum) {
        result.push(accum);
    }
    return result;
}
//# sourceMappingURL=fragments.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/index.js ***!
  \**********************************************************/
/*! exports provided: ConstructorFragment, ErrorFragment, EventFragment, Fragment, FunctionFragment, ParamType, FormatTypes, AbiCoder, defaultAbiCoder, Interface, Indexed, checkResultErrors, LogDescription, TransactionDescription */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./fragments */ "./node_modules/@ethersproject/abi/lib.esm/fragments.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConstructorFragment", function() { return _fragments__WEBPACK_IMPORTED_MODULE_0__["ConstructorFragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrorFragment", function() { return _fragments__WEBPACK_IMPORTED_MODULE_0__["ErrorFragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EventFragment", function() { return _fragments__WEBPACK_IMPORTED_MODULE_0__["EventFragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return _fragments__WEBPACK_IMPORTED_MODULE_0__["Fragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FunctionFragment", function() { return _fragments__WEBPACK_IMPORTED_MODULE_0__["FunctionFragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParamType", function() { return _fragments__WEBPACK_IMPORTED_MODULE_0__["ParamType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FormatTypes", function() { return _fragments__WEBPACK_IMPORTED_MODULE_0__["FormatTypes"]; });

/* harmony import */ var _abi_coder__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abi-coder */ "./node_modules/@ethersproject/abi/lib.esm/abi-coder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AbiCoder", function() { return _abi_coder__WEBPACK_IMPORTED_MODULE_1__["AbiCoder"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultAbiCoder", function() { return _abi_coder__WEBPACK_IMPORTED_MODULE_1__["defaultAbiCoder"]; });

/* harmony import */ var _interface__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./interface */ "./node_modules/@ethersproject/abi/lib.esm/interface.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interface", function() { return _interface__WEBPACK_IMPORTED_MODULE_2__["Interface"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Indexed", function() { return _interface__WEBPACK_IMPORTED_MODULE_2__["Indexed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkResultErrors", function() { return _interface__WEBPACK_IMPORTED_MODULE_2__["checkResultErrors"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LogDescription", function() { return _interface__WEBPACK_IMPORTED_MODULE_2__["LogDescription"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransactionDescription", function() { return _interface__WEBPACK_IMPORTED_MODULE_2__["TransactionDescription"]; });






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abi/lib.esm/interface.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/abi/lib.esm/interface.js ***!
  \**************************************************************/
/*! exports provided: checkResultErrors, LogDescription, TransactionDescription, ErrorDescription, Indexed, Interface */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogDescription", function() { return LogDescription; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransactionDescription", function() { return TransactionDescription; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorDescription", function() { return ErrorDescription; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Indexed", function() { return Indexed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interface", function() { return Interface; });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _abi_coder__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./abi-coder */ "./node_modules/@ethersproject/abi/lib.esm/abi-coder.js");
/* harmony import */ var _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./coders/abstract-coder */ "./node_modules/@ethersproject/abi/lib.esm/coders/abstract-coder.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkResultErrors", function() { return _coders_abstract_coder__WEBPACK_IMPORTED_MODULE_7__["checkResultErrors"]; });

/* harmony import */ var _fragments__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./fragments */ "./node_modules/@ethersproject/abi/lib.esm/fragments.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/abi/lib.esm/_version.js");












const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_9__["Logger"](_version__WEBPACK_IMPORTED_MODULE_10__["version"]);

class LogDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["Description"] {
}
class TransactionDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["Description"] {
}
class ErrorDescription extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["Description"] {
}
class Indexed extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["Description"] {
    static isIndexed(value) {
        return !!(value && value._isIndexed);
    }
}
const BuiltinErrors = {
    "0x08c379a0": { signature: "Error(string)", name: "Error", inputs: ["string"], reason: true },
    "0x4e487b71": { signature: "Panic(uint256)", name: "Panic", inputs: ["uint256"] }
};
function wrapAccessError(property, error) {
    const wrap = new Error(`deferred error during ABI decoding triggered accessing ${property}`);
    wrap.error = error;
    return wrap;
}
/*
function checkNames(fragment: Fragment, type: "input" | "output", params: Array<ParamType>): void {
    params.reduce((accum, param) => {
        if (param.name) {
            if (accum[param.name]) {
                logger.throwArgumentError(`duplicate ${ type } parameter ${ JSON.stringify(param.name) } in ${ fragment.format("full") }`, "fragment", fragment);
            }
            accum[param.name] = true;
        }
        return accum;
    }, <{ [ name: string ]: boolean }>{ });
}
*/
class Interface {
    constructor(fragments) {
        logger.checkNew(new.target, Interface);
        let abi = [];
        if (typeof (fragments) === "string") {
            abi = JSON.parse(fragments);
        }
        else {
            abi = fragments;
        }
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "fragments", abi.map((fragment) => {
            return _fragments__WEBPACK_IMPORTED_MODULE_8__["Fragment"].from(fragment);
        }).filter((fragment) => (fragment != null)));
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "_abiCoder", Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["getStatic"])(new.target, "getAbiCoder")());
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "functions", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "errors", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "events", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "structs", {});
        // Add all fragments by their signature
        this.fragments.forEach((fragment) => {
            let bucket = null;
            switch (fragment.type) {
                case "constructor":
                    if (this.deploy) {
                        logger.warn("duplicate definition - constructor");
                        return;
                    }
                    //checkNames(fragment, "input", fragment.inputs);
                    Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "deploy", fragment);
                    return;
                case "function":
                    //checkNames(fragment, "input", fragment.inputs);
                    //checkNames(fragment, "output", (<FunctionFragment>fragment).outputs);
                    bucket = this.functions;
                    break;
                case "event":
                    //checkNames(fragment, "input", fragment.inputs);
                    bucket = this.events;
                    break;
                case "error":
                    bucket = this.errors;
                    break;
                default:
                    return;
            }
            let signature = fragment.format();
            if (bucket[signature]) {
                logger.warn("duplicate definition - " + signature);
                return;
            }
            bucket[signature] = fragment;
        });
        // If we do not have a constructor add a default
        if (!this.deploy) {
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "deploy", _fragments__WEBPACK_IMPORTED_MODULE_8__["ConstructorFragment"].from({
                payable: false,
                type: "constructor"
            }));
        }
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "_isInterface", true);
    }
    format(format) {
        if (!format) {
            format = _fragments__WEBPACK_IMPORTED_MODULE_8__["FormatTypes"].full;
        }
        if (format === _fragments__WEBPACK_IMPORTED_MODULE_8__["FormatTypes"].sighash) {
            logger.throwArgumentError("interface does not support formatting sighash", "format", format);
        }
        const abi = this.fragments.map((fragment) => fragment.format(format));
        // We need to re-bundle the JSON fragments a bit
        if (format === _fragments__WEBPACK_IMPORTED_MODULE_8__["FormatTypes"].json) {
            return JSON.stringify(abi.map((j) => JSON.parse(j)));
        }
        return abi;
    }
    // Sub-classes can override these to handle other blockchains
    static getAbiCoder() {
        return _abi_coder__WEBPACK_IMPORTED_MODULE_6__["defaultAbiCoder"];
    }
    static getAddress(address) {
        return Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(address);
    }
    static getSighash(fragment) {
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexDataSlice"])(Object(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_3__["id"])(fragment.format()), 0, 4);
    }
    static getEventTopic(eventFragment) {
        return Object(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_3__["id"])(eventFragment.format());
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getFunction(nameOrSignatureOrSighash) {
        if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(nameOrSignatureOrSighash)) {
            for (const name in this.functions) {
                if (nameOrSignatureOrSighash === this.getSighash(name)) {
                    return this.functions[name];
                }
            }
            logger.throwArgumentError("no matching function", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.functions).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching function", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching functions", "name", name);
            }
            return this.functions[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.functions[_fragments__WEBPACK_IMPORTED_MODULE_8__["FunctionFragment"].fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger.throwArgumentError("no matching function", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Find an event definition by any means necessary (unless it is ambiguous)
    getEvent(nameOrSignatureOrTopic) {
        if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(nameOrSignatureOrTopic)) {
            const topichash = nameOrSignatureOrTopic.toLowerCase();
            for (const name in this.events) {
                if (topichash === this.getEventTopic(name)) {
                    return this.events[name];
                }
            }
            logger.throwArgumentError("no matching event", "topichash", topichash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrTopic.indexOf("(") === -1) {
            const name = nameOrSignatureOrTopic.trim();
            const matching = Object.keys(this.events).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching event", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching events", "name", name);
            }
            return this.events[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.events[_fragments__WEBPACK_IMPORTED_MODULE_8__["EventFragment"].fromString(nameOrSignatureOrTopic).format()];
        if (!result) {
            logger.throwArgumentError("no matching event", "signature", nameOrSignatureOrTopic);
        }
        return result;
    }
    // Find a function definition by any means necessary (unless it is ambiguous)
    getError(nameOrSignatureOrSighash) {
        if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(nameOrSignatureOrSighash)) {
            const getSighash = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["getStatic"])(this.constructor, "getSighash");
            for (const name in this.errors) {
                const error = this.errors[name];
                if (nameOrSignatureOrSighash === getSighash(error)) {
                    return this.errors[name];
                }
            }
            logger.throwArgumentError("no matching error", "sighash", nameOrSignatureOrSighash);
        }
        // It is a bare name, look up the function (will return null if ambiguous)
        if (nameOrSignatureOrSighash.indexOf("(") === -1) {
            const name = nameOrSignatureOrSighash.trim();
            const matching = Object.keys(this.errors).filter((f) => (f.split("(" /* fix:) */)[0] === name));
            if (matching.length === 0) {
                logger.throwArgumentError("no matching error", "name", name);
            }
            else if (matching.length > 1) {
                logger.throwArgumentError("multiple matching errors", "name", name);
            }
            return this.errors[matching[0]];
        }
        // Normalize the signature and lookup the function
        const result = this.errors[_fragments__WEBPACK_IMPORTED_MODULE_8__["FunctionFragment"].fromString(nameOrSignatureOrSighash).format()];
        if (!result) {
            logger.throwArgumentError("no matching error", "signature", nameOrSignatureOrSighash);
        }
        return result;
    }
    // Get the sighash (the bytes4 selector) used by Solidity to identify a function
    getSighash(fragment) {
        if (typeof (fragment) === "string") {
            try {
                fragment = this.getFunction(fragment);
            }
            catch (error) {
                try {
                    fragment = this.getError(fragment);
                }
                catch (_) {
                    throw error;
                }
            }
        }
        return Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["getStatic"])(this.constructor, "getSighash")(fragment);
    }
    // Get the topic (the bytes32 hash) used by Solidity to identify an event
    getEventTopic(eventFragment) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        return Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["getStatic"])(this.constructor, "getEventTopic")(eventFragment);
    }
    _decodeParams(params, data) {
        return this._abiCoder.decode(params, data);
    }
    _encodeParams(params, values) {
        return this._abiCoder.encode(params, values);
    }
    encodeDeploy(values) {
        return this._encodeParams(this.deploy.inputs, values || []);
    }
    decodeErrorResult(fragment, data) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        const bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(data);
        if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(bytes.slice(0, 4)) !== this.getSighash(fragment)) {
            logger.throwArgumentError(`data signature does not match error ${fragment.name}.`, "data", Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(bytes));
        }
        return this._decodeParams(fragment.inputs, bytes.slice(4));
    }
    encodeErrorResult(fragment, values) {
        if (typeof (fragment) === "string") {
            fragment = this.getError(fragment);
        }
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["concat"])([
            this.getSighash(fragment),
            this._encodeParams(fragment.inputs, values || [])
        ]));
    }
    // Decode the data for a function call (e.g. tx.data)
    decodeFunctionData(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        const bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(data);
        if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(bytes.slice(0, 4)) !== this.getSighash(functionFragment)) {
            logger.throwArgumentError(`data signature does not match function ${functionFragment.name}.`, "data", Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(bytes));
        }
        return this._decodeParams(functionFragment.inputs, bytes.slice(4));
    }
    // Encode the data for a function call (e.g. tx.data)
    encodeFunctionData(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["concat"])([
            this.getSighash(functionFragment),
            this._encodeParams(functionFragment.inputs, values || [])
        ]));
    }
    // Decode the result from a function call (e.g. from eth_call)
    decodeFunctionResult(functionFragment, data) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        let bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(data);
        let reason = null;
        let errorArgs = null;
        let errorName = null;
        let errorSignature = null;
        switch (bytes.length % this._abiCoder._getWordSize()) {
            case 0:
                try {
                    return this._abiCoder.decode(functionFragment.outputs, bytes);
                }
                catch (error) { }
                break;
            case 4: {
                const selector = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(bytes.slice(0, 4));
                const builtin = BuiltinErrors[selector];
                if (builtin) {
                    errorArgs = this._abiCoder.decode(builtin.inputs, bytes.slice(4));
                    errorName = builtin.name;
                    errorSignature = builtin.signature;
                    if (builtin.reason) {
                        reason = errorArgs[0];
                    }
                }
                else {
                    try {
                        const error = this.getError(selector);
                        errorArgs = this._abiCoder.decode(error.inputs, bytes.slice(4));
                        errorName = error.name;
                        errorSignature = error.format();
                    }
                    catch (error) {
                        console.log(error);
                    }
                }
                break;
            }
        }
        return logger.throwError("call revert exception", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_9__["Logger"].errors.CALL_EXCEPTION, {
            method: functionFragment.format(),
            errorArgs, errorName, errorSignature, reason
        });
    }
    // Encode the result for a function call (e.g. for eth_call)
    encodeFunctionResult(functionFragment, values) {
        if (typeof (functionFragment) === "string") {
            functionFragment = this.getFunction(functionFragment);
        }
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(this._abiCoder.encode(functionFragment.outputs, values || []));
    }
    // Create the filter for the event with search criteria (e.g. for eth_filterLog)
    encodeFilterTopics(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (values.length > eventFragment.inputs.length) {
            logger.throwError("too many arguments for " + eventFragment.format(), _ethersproject_logger__WEBPACK_IMPORTED_MODULE_9__["Logger"].errors.UNEXPECTED_ARGUMENT, {
                argument: "values",
                value: values
            });
        }
        let topics = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        const encodeTopic = (param, value) => {
            if (param.type === "string") {
                return Object(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_3__["id"])(value);
            }
            else if (param.type === "bytes") {
                return Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__["keccak256"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(value));
            }
            // Check addresses are valid
            if (param.type === "address") {
                this._abiCoder.encode(["address"], [value]);
            }
            return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexZeroPad"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(value), 32);
        };
        values.forEach((value, index) => {
            let param = eventFragment.inputs[index];
            if (!param.indexed) {
                if (value != null) {
                    logger.throwArgumentError("cannot filter non-indexed parameters; must be null", ("contract." + param.name), value);
                }
                return;
            }
            if (value == null) {
                topics.push(null);
            }
            else if (param.baseType === "array" || param.baseType === "tuple") {
                logger.throwArgumentError("filtering with tuples or arrays not supported", ("contract." + param.name), value);
            }
            else if (Array.isArray(value)) {
                topics.push(value.map((value) => encodeTopic(param, value)));
            }
            else {
                topics.push(encodeTopic(param, value));
            }
        });
        // Trim off trailing nulls
        while (topics.length && topics[topics.length - 1] === null) {
            topics.pop();
        }
        return topics;
    }
    encodeEventLog(eventFragment, values) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        const topics = [];
        const dataTypes = [];
        const dataValues = [];
        if (!eventFragment.anonymous) {
            topics.push(this.getEventTopic(eventFragment));
        }
        if (values.length !== eventFragment.inputs.length) {
            logger.throwArgumentError("event arguments/values mismatch", "values", values);
        }
        eventFragment.inputs.forEach((param, index) => {
            const value = values[index];
            if (param.indexed) {
                if (param.type === "string") {
                    topics.push(Object(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_3__["id"])(value));
                }
                else if (param.type === "bytes") {
                    topics.push(Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__["keccak256"])(value));
                }
                else if (param.baseType === "tuple" || param.baseType === "array") {
                    // @TODO
                    throw new Error("not implemented");
                }
                else {
                    topics.push(this._abiCoder.encode([param.type], [value]));
                }
            }
            else {
                dataTypes.push(param);
                dataValues.push(value);
            }
        });
        return {
            data: this._abiCoder.encode(dataTypes, dataValues),
            topics: topics
        };
    }
    // Decode a filter for the event and the search criteria
    decodeEventLog(eventFragment, data, topics) {
        if (typeof (eventFragment) === "string") {
            eventFragment = this.getEvent(eventFragment);
        }
        if (topics != null && !eventFragment.anonymous) {
            let topicHash = this.getEventTopic(eventFragment);
            if (!Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(topics[0], 32) || topics[0].toLowerCase() !== topicHash) {
                logger.throwError("fragment/topic mismatch", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_9__["Logger"].errors.INVALID_ARGUMENT, { argument: "topics[0]", expected: topicHash, value: topics[0] });
            }
            topics = topics.slice(1);
        }
        let indexed = [];
        let nonIndexed = [];
        let dynamic = [];
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (param.type === "string" || param.type === "bytes" || param.baseType === "tuple" || param.baseType === "array") {
                    indexed.push(_fragments__WEBPACK_IMPORTED_MODULE_8__["ParamType"].fromObject({ type: "bytes32", name: param.name }));
                    dynamic.push(true);
                }
                else {
                    indexed.push(param);
                    dynamic.push(false);
                }
            }
            else {
                nonIndexed.push(param);
                dynamic.push(false);
            }
        });
        let resultIndexed = (topics != null) ? this._abiCoder.decode(indexed, Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["concat"])(topics)) : null;
        let resultNonIndexed = this._abiCoder.decode(nonIndexed, data, true);
        let result = [];
        let nonIndexedIndex = 0, indexedIndex = 0;
        eventFragment.inputs.forEach((param, index) => {
            if (param.indexed) {
                if (resultIndexed == null) {
                    result[index] = new Indexed({ _isIndexed: true, hash: null });
                }
                else if (dynamic[index]) {
                    result[index] = new Indexed({ _isIndexed: true, hash: resultIndexed[indexedIndex++] });
                }
                else {
                    try {
                        result[index] = resultIndexed[indexedIndex++];
                    }
                    catch (error) {
                        result[index] = error;
                    }
                }
            }
            else {
                try {
                    result[index] = resultNonIndexed[nonIndexedIndex++];
                }
                catch (error) {
                    result[index] = error;
                }
            }
            // Add the keyword argument if named and safe
            if (param.name && result[param.name] == null) {
                const value = result[index];
                // Make error named values throw on access
                if (value instanceof Error) {
                    Object.defineProperty(result, param.name, {
                        enumerable: true,
                        get: () => { throw wrapAccessError(`property ${JSON.stringify(param.name)}`, value); }
                    });
                }
                else {
                    result[param.name] = value;
                }
            }
        });
        // Make all error indexed values throw on access
        for (let i = 0; i < result.length; i++) {
            const value = result[i];
            if (value instanceof Error) {
                Object.defineProperty(result, i, {
                    enumerable: true,
                    get: () => { throw wrapAccessError(`index ${i}`, value); }
                });
            }
        }
        return Object.freeze(result);
    }
    // Given a transaction, find the matching function fragment (if any) and
    // determine all its properties and call parameters
    parseTransaction(tx) {
        let fragment = this.getFunction(tx.data.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new TransactionDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + tx.data.substring(10)),
            functionFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
            value: _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(tx.value || "0"),
        });
    }
    // @TODO
    //parseCallResult(data: BytesLike): ??
    // Given an event log, find the matching event fragment (if any) and
    // determine all its properties and values
    parseLog(log) {
        let fragment = this.getEvent(log.topics[0]);
        if (!fragment || fragment.anonymous) {
            return null;
        }
        // @TODO: If anonymous, and the only method, and the input count matches, should we parse?
        //        Probably not, because just because it is the only event in the ABI does
        //        not mean we have the full ABI; maybe just a fragment?
        return new LogDescription({
            eventFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            topic: this.getEventTopic(fragment),
            args: this.decodeEventLog(fragment, log.data, log.topics)
        });
    }
    parseError(data) {
        const hexData = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(data);
        let fragment = this.getError(hexData.substring(0, 10).toLowerCase());
        if (!fragment) {
            return null;
        }
        return new ErrorDescription({
            args: this._abiCoder.decode(fragment.inputs, "0x" + hexData.substring(10)),
            errorFragment: fragment,
            name: fragment.name,
            signature: fragment.format(),
            sighash: this.getSighash(fragment),
        });
    }
    /*
    static from(value: Array<Fragment | string | JsonAbi> | string | Interface) {
        if (Interface.isInterface(value)) {
            return value;
        }
        if (typeof(value) === "string") {
            return new Interface(JSON.parse(value));
        }
        return new Interface(value);
    }
    */
    static isInterface(value) {
        return !!(value && value._isInterface);
    }
}
//# sourceMappingURL=interface.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abstract-provider/lib.esm/_version.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ethersproject/abstract-provider/lib.esm/_version.js ***!
  \***************************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "abstract-provider/5.5.1";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abstract-provider/lib.esm/index.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ethersproject/abstract-provider/lib.esm/index.js ***!
  \************************************************************************/
/*! exports provided: ForkEvent, BlockForkEvent, TransactionForkEvent, TransactionOrderForkEvent, Provider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ForkEvent", function() { return ForkEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BlockForkEvent", function() { return BlockForkEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransactionForkEvent", function() { return TransactionForkEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransactionOrderForkEvent", function() { return TransactionOrderForkEvent; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Provider", function() { return Provider; });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/abstract-provider/lib.esm/_version.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__["Logger"](_version__WEBPACK_IMPORTED_MODULE_4__["version"]);
;
;
//export type CallTransactionable = {
//    call(transaction: TransactionRequest): Promise<TransactionResponse>;
//};
class ForkEvent extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["Description"] {
    static isForkEvent(value) {
        return !!(value && value._isForkEvent);
    }
}
class BlockForkEvent extends ForkEvent {
    constructor(blockHash, expiry) {
        if (!Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["isHexString"])(blockHash, 32)) {
            logger.throwArgumentError("invalid blockHash", "blockHash", blockHash);
        }
        super({
            _isForkEvent: true,
            _isBlockForkEvent: true,
            expiry: (expiry || 0),
            blockHash: blockHash
        });
    }
}
class TransactionForkEvent extends ForkEvent {
    constructor(hash, expiry) {
        if (!Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["isHexString"])(hash, 32)) {
            logger.throwArgumentError("invalid transaction hash", "hash", hash);
        }
        super({
            _isForkEvent: true,
            _isTransactionForkEvent: true,
            expiry: (expiry || 0),
            hash: hash
        });
    }
}
class TransactionOrderForkEvent extends ForkEvent {
    constructor(beforeHash, afterHash, expiry) {
        if (!Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["isHexString"])(beforeHash, 32)) {
            logger.throwArgumentError("invalid transaction hash", "beforeHash", beforeHash);
        }
        if (!Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["isHexString"])(afterHash, 32)) {
            logger.throwArgumentError("invalid transaction hash", "afterHash", afterHash);
        }
        super({
            _isForkEvent: true,
            _isTransactionOrderForkEvent: true,
            expiry: (expiry || 0),
            beforeHash: beforeHash,
            afterHash: afterHash
        });
    }
}
///////////////////////////////
// Exported Abstracts
class Provider {
    constructor() {
        logger.checkAbstract(new.target, Provider);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["defineReadOnly"])(this, "_isProvider", true);
    }
    getFeeData() {
        return __awaiter(this, void 0, void 0, function* () {
            const { block, gasPrice } = yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["resolveProperties"])({
                block: this.getBlock("latest"),
                gasPrice: this.getGasPrice().catch((error) => {
                    // @TODO: Why is this now failing on Calaveras?
                    //console.log(error);
                    return null;
                })
            });
            let maxFeePerGas = null, maxPriorityFeePerGas = null;
            if (block && block.baseFeePerGas) {
                // We may want to compute this more accurately in the future,
                // using the formula "check if the base fee is correct".
                // See: https://eips.ethereum.org/EIPS/eip-1559
                maxPriorityFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from("2500000000");
                maxFeePerGas = block.baseFeePerGas.mul(2).add(maxPriorityFeePerGas);
            }
            return { maxFeePerGas, maxPriorityFeePerGas, gasPrice };
        });
    }
    // Alias for "on"
    addListener(eventName, listener) {
        return this.on(eventName, listener);
    }
    // Alias for "off"
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
    static isProvider(value) {
        return !!(value && value._isProvider);
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abstract-signer/lib.esm/_version.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@ethersproject/abstract-signer/lib.esm/_version.js ***!
  \*************************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "abstract-signer/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/abstract-signer/lib.esm/index.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/abstract-signer/lib.esm/index.js ***!
  \**********************************************************************/
/*! exports provided: Signer, VoidSigner */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Signer", function() { return Signer; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VoidSigner", function() { return VoidSigner; });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/abstract-signer/lib.esm/_version.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"](_version__WEBPACK_IMPORTED_MODULE_2__["version"]);
const allowedTransactionKeys = [
    "accessList", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value"
];
const forwardErrors = [
    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.INSUFFICIENT_FUNDS,
    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.NONCE_EXPIRED,
    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.REPLACEMENT_UNDERPRICED,
];
;
;
class Signer {
    ///////////////////
    // Sub-classes MUST call super
    constructor() {
        logger.checkAbstract(new.target, Signer);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["defineReadOnly"])(this, "_isSigner", true);
    }
    ///////////////////
    // Sub-classes MAY override these
    getBalance(blockTag) {
        return __awaiter(this, void 0, void 0, function* () {
            this._checkProvider("getBalance");
            return yield this.provider.getBalance(this.getAddress(), blockTag);
        });
    }
    getTransactionCount(blockTag) {
        return __awaiter(this, void 0, void 0, function* () {
            this._checkProvider("getTransactionCount");
            return yield this.provider.getTransactionCount(this.getAddress(), blockTag);
        });
    }
    // Populates "from" if unspecified, and estimates the gas for the transaction
    estimateGas(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            this._checkProvider("estimateGas");
            const tx = yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["resolveProperties"])(this.checkTransaction(transaction));
            return yield this.provider.estimateGas(tx);
        });
    }
    // Populates "from" if unspecified, and calls with the transaction
    call(transaction, blockTag) {
        return __awaiter(this, void 0, void 0, function* () {
            this._checkProvider("call");
            const tx = yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["resolveProperties"])(this.checkTransaction(transaction));
            return yield this.provider.call(tx, blockTag);
        });
    }
    // Populates all fields in a transaction, signs it and sends it to the network
    sendTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            this._checkProvider("sendTransaction");
            const tx = yield this.populateTransaction(transaction);
            const signedTx = yield this.signTransaction(tx);
            return yield this.provider.sendTransaction(signedTx);
        });
    }
    getChainId() {
        return __awaiter(this, void 0, void 0, function* () {
            this._checkProvider("getChainId");
            const network = yield this.provider.getNetwork();
            return network.chainId;
        });
    }
    getGasPrice() {
        return __awaiter(this, void 0, void 0, function* () {
            this._checkProvider("getGasPrice");
            return yield this.provider.getGasPrice();
        });
    }
    getFeeData() {
        return __awaiter(this, void 0, void 0, function* () {
            this._checkProvider("getFeeData");
            return yield this.provider.getFeeData();
        });
    }
    resolveName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            this._checkProvider("resolveName");
            return yield this.provider.resolveName(name);
        });
    }
    // Checks a transaction does not contain invalid keys and if
    // no "from" is provided, populates it.
    // - does NOT require a provider
    // - adds "from" is not present
    // - returns a COPY (safe to mutate the result)
    // By default called from: (overriding these prevents it)
    //   - call
    //   - estimateGas
    //   - populateTransaction (and therefor sendTransaction)
    checkTransaction(transaction) {
        for (const key in transaction) {
            if (allowedTransactionKeys.indexOf(key) === -1) {
                logger.throwArgumentError("invalid transaction key: " + key, "transaction", transaction);
            }
        }
        const tx = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["shallowCopy"])(transaction);
        if (tx.from == null) {
            tx.from = this.getAddress();
        }
        else {
            // Make sure any provided address matches this signer
            tx.from = Promise.all([
                Promise.resolve(tx.from),
                this.getAddress()
            ]).then((result) => {
                if (result[0].toLowerCase() !== result[1].toLowerCase()) {
                    logger.throwArgumentError("from address mismatch", "transaction", transaction);
                }
                return result[0];
            });
        }
        return tx;
    }
    // Populates ALL keys for a transaction and checks that "from" matches
    // this Signer. Should be used by sendTransaction but NOT by signTransaction.
    // By default called from: (overriding these prevents it)
    //   - sendTransaction
    //
    // Notes:
    //  - We allow gasPrice for EIP-1559 as long as it matches maxFeePerGas
    populateTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const tx = yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["resolveProperties"])(this.checkTransaction(transaction));
            if (tx.to != null) {
                tx.to = Promise.resolve(tx.to).then((to) => __awaiter(this, void 0, void 0, function* () {
                    if (to == null) {
                        return null;
                    }
                    const address = yield this.resolveName(to);
                    if (address == null) {
                        logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                    }
                    return address;
                }));
                // Prevent this error from causing an UnhandledPromiseException
                tx.to.catch((error) => { });
            }
            // Do not allow mixing pre-eip-1559 and eip-1559 properties
            const hasEip1559 = (tx.maxFeePerGas != null || tx.maxPriorityFeePerGas != null);
            if (tx.gasPrice != null && (tx.type === 2 || hasEip1559)) {
                logger.throwArgumentError("eip-1559 transaction do not support gasPrice", "transaction", transaction);
            }
            else if ((tx.type === 0 || tx.type === 1) && hasEip1559) {
                logger.throwArgumentError("pre-eip-1559 transaction do not support maxFeePerGas/maxPriorityFeePerGas", "transaction", transaction);
            }
            if ((tx.type === 2 || tx.type == null) && (tx.maxFeePerGas != null && tx.maxPriorityFeePerGas != null)) {
                // Fully-formed EIP-1559 transaction (skip getFeeData)
                tx.type = 2;
            }
            else if (tx.type === 0 || tx.type === 1) {
                // Explicit Legacy or EIP-2930 transaction
                // Populate missing gasPrice
                if (tx.gasPrice == null) {
                    tx.gasPrice = this.getGasPrice();
                }
            }
            else {
                // We need to get fee data to determine things
                const feeData = yield this.getFeeData();
                if (tx.type == null) {
                    // We need to auto-detect the intended type of this transaction...
                    if (feeData.maxFeePerGas != null && feeData.maxPriorityFeePerGas != null) {
                        // The network supports EIP-1559!
                        // Upgrade transaction from null to eip-1559
                        tx.type = 2;
                        if (tx.gasPrice != null) {
                            // Using legacy gasPrice property on an eip-1559 network,
                            // so use gasPrice as both fee properties
                            const gasPrice = tx.gasPrice;
                            delete tx.gasPrice;
                            tx.maxFeePerGas = gasPrice;
                            tx.maxPriorityFeePerGas = gasPrice;
                        }
                        else {
                            // Populate missing fee data
                            if (tx.maxFeePerGas == null) {
                                tx.maxFeePerGas = feeData.maxFeePerGas;
                            }
                            if (tx.maxPriorityFeePerGas == null) {
                                tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                            }
                        }
                    }
                    else if (feeData.gasPrice != null) {
                        // Network doesn't support EIP-1559...
                        // ...but they are trying to use EIP-1559 properties
                        if (hasEip1559) {
                            logger.throwError("network does not support EIP-1559", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.UNSUPPORTED_OPERATION, {
                                operation: "populateTransaction"
                            });
                        }
                        // Populate missing fee data
                        if (tx.gasPrice == null) {
                            tx.gasPrice = feeData.gasPrice;
                        }
                        // Explicitly set untyped transaction to legacy
                        tx.type = 0;
                    }
                    else {
                        // getFeeData has failed us.
                        logger.throwError("failed to get consistent fee data", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.UNSUPPORTED_OPERATION, {
                            operation: "signer.getFeeData"
                        });
                    }
                }
                else if (tx.type === 2) {
                    // Explicitly using EIP-1559
                    // Populate missing fee data
                    if (tx.maxFeePerGas == null) {
                        tx.maxFeePerGas = feeData.maxFeePerGas;
                    }
                    if (tx.maxPriorityFeePerGas == null) {
                        tx.maxPriorityFeePerGas = feeData.maxPriorityFeePerGas;
                    }
                }
            }
            if (tx.nonce == null) {
                tx.nonce = this.getTransactionCount("pending");
            }
            if (tx.gasLimit == null) {
                tx.gasLimit = this.estimateGas(tx).catch((error) => {
                    if (forwardErrors.indexOf(error.code) >= 0) {
                        throw error;
                    }
                    return logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.UNPREDICTABLE_GAS_LIMIT, {
                        error: error,
                        tx: tx
                    });
                });
            }
            if (tx.chainId == null) {
                tx.chainId = this.getChainId();
            }
            else {
                tx.chainId = Promise.all([
                    Promise.resolve(tx.chainId),
                    this.getChainId()
                ]).then((results) => {
                    if (results[1] !== 0 && results[0] !== results[1]) {
                        logger.throwArgumentError("chainId address mismatch", "transaction", transaction);
                    }
                    return results[0];
                });
            }
            return yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["resolveProperties"])(tx);
        });
    }
    ///////////////////
    // Sub-classes SHOULD leave these alone
    _checkProvider(operation) {
        if (!this.provider) {
            logger.throwError("missing provider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: (operation || "_checkProvider")
            });
        }
    }
    static isSigner(value) {
        return !!(value && value._isSigner);
    }
}
class VoidSigner extends Signer {
    constructor(address, provider) {
        logger.checkNew(new.target, VoidSigner);
        super();
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["defineReadOnly"])(this, "address", address);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["defineReadOnly"])(this, "provider", provider || null);
    }
    getAddress() {
        return Promise.resolve(this.address);
    }
    _fail(message, operation) {
        return Promise.resolve().then(() => {
            logger.throwError(message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.UNSUPPORTED_OPERATION, { operation: operation });
        });
    }
    signMessage(message) {
        return this._fail("VoidSigner cannot sign messages", "signMessage");
    }
    signTransaction(transaction) {
        return this._fail("VoidSigner cannot sign transactions", "signTransaction");
    }
    _signTypedData(domain, types, value) {
        return this._fail("VoidSigner cannot sign typed data", "signTypedData");
    }
    connect(provider) {
        return new VoidSigner(this.address, provider);
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/address/lib.esm/_version.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/address/lib.esm/_version.js ***!
  \*****************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "address/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/address/lib.esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/address/lib.esm/index.js ***!
  \**************************************************************/
/*! exports provided: getAddress, isAddress, getIcapAddress, getContractAddress, getCreate2Address */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAddress", function() { return getAddress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isAddress", function() { return isAddress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getIcapAddress", function() { return getIcapAddress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getContractAddress", function() { return getContractAddress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCreate2Address", function() { return getCreate2Address; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/rlp */ "./node_modules/@ethersproject/rlp/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/address/lib.esm/_version.js");







const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"](_version__WEBPACK_IMPORTED_MODULE_5__["version"]);
function getChecksumAddress(address) {
    if (!Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["isHexString"])(address, 20)) {
        logger.throwArgumentError("invalid address", "address", address);
    }
    address = address.toLowerCase();
    const chars = address.substring(2).split("");
    const expanded = new Uint8Array(40);
    for (let i = 0; i < 40; i++) {
        expanded[i] = chars[i].charCodeAt(0);
    }
    const hashed = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_2__["keccak256"])(expanded));
    for (let i = 0; i < 40; i += 2) {
        if ((hashed[i >> 1] >> 4) >= 8) {
            chars[i] = chars[i].toUpperCase();
        }
        if ((hashed[i >> 1] & 0x0f) >= 8) {
            chars[i + 1] = chars[i + 1].toUpperCase();
        }
    }
    return "0x" + chars.join("");
}
// Shims for environments that are missing some required constants and functions
const MAX_SAFE_INTEGER = 0x1fffffffffffff;
function log10(x) {
    if (Math.log10) {
        return Math.log10(x);
    }
    return Math.log(x) / Math.LN10;
}
// See: https://en.wikipedia.org/wiki/International_Bank_Account_Number
// Create lookup table
const ibanLookup = {};
for (let i = 0; i < 10; i++) {
    ibanLookup[String(i)] = String(i);
}
for (let i = 0; i < 26; i++) {
    ibanLookup[String.fromCharCode(65 + i)] = String(10 + i);
}
// How many decimal digits can we process? (for 64-bit float, this is 15)
const safeDigits = Math.floor(log10(MAX_SAFE_INTEGER));
function ibanChecksum(address) {
    address = address.toUpperCase();
    address = address.substring(4) + address.substring(0, 2) + "00";
    let expanded = address.split("").map((c) => { return ibanLookup[c]; }).join("");
    // Javascript can handle integers safely up to 15 (decimal) digits
    while (expanded.length >= safeDigits) {
        let block = expanded.substring(0, safeDigits);
        expanded = parseInt(block, 10) % 97 + expanded.substring(block.length);
    }
    let checksum = String(98 - (parseInt(expanded, 10) % 97));
    while (checksum.length < 2) {
        checksum = "0" + checksum;
    }
    return checksum;
}
;
function getAddress(address) {
    let result = null;
    if (typeof (address) !== "string") {
        logger.throwArgumentError("invalid address", "address", address);
    }
    if (address.match(/^(0x)?[0-9a-fA-F]{40}$/)) {
        // Missing the 0x prefix
        if (address.substring(0, 2) !== "0x") {
            address = "0x" + address;
        }
        result = getChecksumAddress(address);
        // It is a checksummed address with a bad checksum
        if (address.match(/([A-F].*[a-f])|([a-f].*[A-F])/) && result !== address) {
            logger.throwArgumentError("bad address checksum", "address", address);
        }
        // Maybe ICAP? (we only support direct mode)
    }
    else if (address.match(/^XE[0-9]{2}[0-9A-Za-z]{30,31}$/)) {
        // It is an ICAP address with a bad checksum
        if (address.substring(2, 4) !== ibanChecksum(address)) {
            logger.throwArgumentError("bad icap checksum", "address", address);
        }
        result = Object(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["_base36To16"])(address.substring(4));
        while (result.length < 40) {
            result = "0" + result;
        }
        result = getChecksumAddress("0x" + result);
    }
    else {
        logger.throwArgumentError("invalid address", "address", address);
    }
    return result;
}
function isAddress(address) {
    try {
        getAddress(address);
        return true;
    }
    catch (error) { }
    return false;
}
function getIcapAddress(address) {
    let base36 = Object(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["_base16To36"])(getAddress(address).substring(2)).toUpperCase();
    while (base36.length < 30) {
        base36 = "0" + base36;
    }
    return "XE" + ibanChecksum("XE00" + base36) + base36;
}
// http://ethereum.stackexchange.com/questions/760/how-is-the-address-of-an-ethereum-contract-computed
function getContractAddress(transaction) {
    let from = null;
    try {
        from = getAddress(transaction.from);
    }
    catch (error) {
        logger.throwArgumentError("missing from address", "transaction", transaction);
    }
    const nonce = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["stripZeros"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(transaction.nonce).toHexString()));
    return getAddress(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexDataSlice"])(Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_2__["keccak256"])(Object(_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_3__["encode"])([from, nonce])), 12));
}
function getCreate2Address(from, salt, initCodeHash) {
    if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexDataLength"])(salt) !== 32) {
        logger.throwArgumentError("salt must be 32 bytes", "salt", salt);
    }
    if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexDataLength"])(initCodeHash) !== 32) {
        logger.throwArgumentError("initCodeHash must be 32 bytes", "initCodeHash", initCodeHash);
    }
    return getAddress(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexDataSlice"])(Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_2__["keccak256"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["concat"])(["0xff", getAddress(from), salt, initCodeHash])), 12));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/base64/lib.esm/base64.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/base64/lib.esm/base64.js ***!
  \**************************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");


function decode(textData) {
    textData = atob(textData);
    const data = [];
    for (let i = 0; i < textData.length; i++) {
        data.push(textData.charCodeAt(i));
    }
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(data);
}
function encode(data) {
    data = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(data);
    let textData = "";
    for (let i = 0; i < data.length; i++) {
        textData += String.fromCharCode(data[i]);
    }
    return btoa(textData);
}
//# sourceMappingURL=base64.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/base64/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/base64/lib.esm/index.js ***!
  \*************************************************************/
/*! exports provided: decode, encode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./base64 */ "./node_modules/@ethersproject/base64/lib.esm/base64.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return _base64__WEBPACK_IMPORTED_MODULE_0__["decode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return _base64__WEBPACK_IMPORTED_MODULE_0__["encode"]; });



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/basex/lib.esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ethersproject/basex/lib.esm/index.js ***!
  \************************************************************/
/*! exports provided: BaseX, Base32, Base58 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseX", function() { return BaseX; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Base32", function() { return Base32; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Base58", function() { return Base58; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/**
 * var basex = require("base-x");
 *
 * This implementation is heavily based on base-x. The main reason to
 * deviate was to prevent the dependency of Buffer.
 *
 * Contributors:
 *
 * base-x encoding
 * Forked from https://github.com/cryptocoinjs/bs58
 * Originally written by Mike Hearn for BitcoinJ
 * Copyright (c) 2011 Google Inc
 * Ported to JavaScript by Stefan Thomas
 * Merged Buffer refactorings from base58-native by Stephen Pair
 * Copyright (c) 2013 BitPay Inc
 *
 * The MIT License (MIT)
 *
 * Copyright base-x contributors (c) 2016
 *
 * Permission is hereby granted, free of charge, to any person obtaining a
 * copy of this software and associated documentation files (the "Software"),
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense,
 * and/or sell copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.

 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS
 * IN THE SOFTWARE.
 *
 */


class BaseX {
    constructor(alphabet) {
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "alphabet", alphabet);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "base", alphabet.length);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "_alphabetMap", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "_leader", alphabet.charAt(0));
        // pre-compute lookup table
        for (let i = 0; i < alphabet.length; i++) {
            this._alphabetMap[alphabet.charAt(i)] = i;
        }
    }
    encode(value) {
        let source = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(value);
        if (source.length === 0) {
            return "";
        }
        let digits = [0];
        for (let i = 0; i < source.length; ++i) {
            let carry = source[i];
            for (let j = 0; j < digits.length; ++j) {
                carry += digits[j] << 8;
                digits[j] = carry % this.base;
                carry = (carry / this.base) | 0;
            }
            while (carry > 0) {
                digits.push(carry % this.base);
                carry = (carry / this.base) | 0;
            }
        }
        let string = "";
        // deal with leading zeros
        for (let k = 0; source[k] === 0 && k < source.length - 1; ++k) {
            string += this._leader;
        }
        // convert digits to a string
        for (let q = digits.length - 1; q >= 0; --q) {
            string += this.alphabet[digits[q]];
        }
        return string;
    }
    decode(value) {
        if (typeof (value) !== "string") {
            throw new TypeError("Expected String");
        }
        let bytes = [];
        if (value.length === 0) {
            return new Uint8Array(bytes);
        }
        bytes.push(0);
        for (let i = 0; i < value.length; i++) {
            let byte = this._alphabetMap[value[i]];
            if (byte === undefined) {
                throw new Error("Non-base" + this.base + " character");
            }
            let carry = byte;
            for (let j = 0; j < bytes.length; ++j) {
                carry += bytes[j] * this.base;
                bytes[j] = carry & 0xff;
                carry >>= 8;
            }
            while (carry > 0) {
                bytes.push(carry & 0xff);
                carry >>= 8;
            }
        }
        // deal with leading zeros
        for (let k = 0; value[k] === this._leader && k < value.length - 1; ++k) {
            bytes.push(0);
        }
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(new Uint8Array(bytes.reverse()));
    }
}
const Base32 = new BaseX("abcdefghijklmnopqrstuvwxyz234567");
const Base58 = new BaseX("123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz");

//console.log(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj"))
//console.log(Base58.encode(Base58.decode("Qmd2V777o5XvJbYMeMb8k2nU5f8d3ciUQ5YpYuWhzv8iDj")))
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/bignumber/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/bignumber/lib.esm/_version.js ***!
  \*******************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "bignumber/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js ***!
  \********************************************************************/
/*! exports provided: isBigNumberish, BigNumber, _base36To16, _base16To36 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBigNumberish", function() { return isBigNumberish; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BigNumber", function() { return BigNumber; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_base36To16", function() { return _base36To16; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_base16To36", function() { return _base16To36; });
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/bignumber/lib.esm/_version.js");

/**
 *  BigNumber
 *
 *  A wrapper around the BN.js object. We use the BN.js library
 *  because it is used by elliptic, so it is required regardless.
 *
 */

var BN = bn_js__WEBPACK_IMPORTED_MODULE_0___default.a.BN;



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"](_version__WEBPACK_IMPORTED_MODULE_3__["version"]);
const _constructorGuard = {};
const MAX_SAFE = 0x1fffffffffffff;
function isBigNumberish(value) {
    return (value != null) && (BigNumber.isBigNumber(value) ||
        (typeof (value) === "number" && (value % 1) === 0) ||
        (typeof (value) === "string" && !!value.match(/^-?[0-9]+$/)) ||
        Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["isHexString"])(value) ||
        (typeof (value) === "bigint") ||
        Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["isBytes"])(value));
}
// Only warn about passing 10 into radix once
let _warnedToStringRadix = false;
class BigNumber {
    constructor(constructorGuard, hex) {
        logger.checkNew(new.target, BigNumber);
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("cannot call constructor directly; use BigNumber.from", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "new (BigNumber)"
            });
        }
        this._hex = hex;
        this._isBigNumber = true;
        Object.freeze(this);
    }
    fromTwos(value) {
        return toBigNumber(toBN(this).fromTwos(value));
    }
    toTwos(value) {
        return toBigNumber(toBN(this).toTwos(value));
    }
    abs() {
        if (this._hex[0] === "-") {
            return BigNumber.from(this._hex.substring(1));
        }
        return this;
    }
    add(other) {
        return toBigNumber(toBN(this).add(toBN(other)));
    }
    sub(other) {
        return toBigNumber(toBN(this).sub(toBN(other)));
    }
    div(other) {
        const o = BigNumber.from(other);
        if (o.isZero()) {
            throwFault("division by zero", "div");
        }
        return toBigNumber(toBN(this).div(toBN(other)));
    }
    mul(other) {
        return toBigNumber(toBN(this).mul(toBN(other)));
    }
    mod(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("cannot modulo negative values", "mod");
        }
        return toBigNumber(toBN(this).umod(value));
    }
    pow(other) {
        const value = toBN(other);
        if (value.isNeg()) {
            throwFault("cannot raise to negative values", "pow");
        }
        return toBigNumber(toBN(this).pow(value));
    }
    and(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("cannot 'and' negative values", "and");
        }
        return toBigNumber(toBN(this).and(value));
    }
    or(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("cannot 'or' negative values", "or");
        }
        return toBigNumber(toBN(this).or(value));
    }
    xor(other) {
        const value = toBN(other);
        if (this.isNegative() || value.isNeg()) {
            throwFault("cannot 'xor' negative values", "xor");
        }
        return toBigNumber(toBN(this).xor(value));
    }
    mask(value) {
        if (this.isNegative() || value < 0) {
            throwFault("cannot mask negative values", "mask");
        }
        return toBigNumber(toBN(this).maskn(value));
    }
    shl(value) {
        if (this.isNegative() || value < 0) {
            throwFault("cannot shift negative values", "shl");
        }
        return toBigNumber(toBN(this).shln(value));
    }
    shr(value) {
        if (this.isNegative() || value < 0) {
            throwFault("cannot shift negative values", "shr");
        }
        return toBigNumber(toBN(this).shrn(value));
    }
    eq(other) {
        return toBN(this).eq(toBN(other));
    }
    lt(other) {
        return toBN(this).lt(toBN(other));
    }
    lte(other) {
        return toBN(this).lte(toBN(other));
    }
    gt(other) {
        return toBN(this).gt(toBN(other));
    }
    gte(other) {
        return toBN(this).gte(toBN(other));
    }
    isNegative() {
        return (this._hex[0] === "-");
    }
    isZero() {
        return toBN(this).isZero();
    }
    toNumber() {
        try {
            return toBN(this).toNumber();
        }
        catch (error) {
            throwFault("overflow", "toNumber", this.toString());
        }
        return null;
    }
    toBigInt() {
        try {
            return BigInt(this.toString());
        }
        catch (e) { }
        return logger.throwError("this platform does not support BigInt", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"].errors.UNSUPPORTED_OPERATION, {
            value: this.toString()
        });
    }
    toString() {
        // Lots of people expect this, which we do not support, so check (See: #889)
        if (arguments.length > 0) {
            if (arguments[0] === 10) {
                if (!_warnedToStringRadix) {
                    _warnedToStringRadix = true;
                    logger.warn("BigNumber.toString does not accept any parameters; base-10 is assumed");
                }
            }
            else if (arguments[0] === 16) {
                logger.throwError("BigNumber.toString does not accept any parameters; use bigNumber.toHexString()", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"].errors.UNEXPECTED_ARGUMENT, {});
            }
            else {
                logger.throwError("BigNumber.toString does not accept parameters", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"].errors.UNEXPECTED_ARGUMENT, {});
            }
        }
        return toBN(this).toString(10);
    }
    toHexString() {
        return this._hex;
    }
    toJSON(key) {
        return { type: "BigNumber", hex: this.toHexString() };
    }
    static from(value) {
        if (value instanceof BigNumber) {
            return value;
        }
        if (typeof (value) === "string") {
            if (value.match(/^-?0x[0-9a-f]+$/i)) {
                return new BigNumber(_constructorGuard, toHex(value));
            }
            if (value.match(/^-?[0-9]+$/)) {
                return new BigNumber(_constructorGuard, toHex(new BN(value)));
            }
            return logger.throwArgumentError("invalid BigNumber string", "value", value);
        }
        if (typeof (value) === "number") {
            if (value % 1) {
                throwFault("underflow", "BigNumber.from", value);
            }
            if (value >= MAX_SAFE || value <= -MAX_SAFE) {
                throwFault("overflow", "BigNumber.from", value);
            }
            return BigNumber.from(String(value));
        }
        const anyValue = value;
        if (typeof (anyValue) === "bigint") {
            return BigNumber.from(anyValue.toString());
        }
        if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["isBytes"])(anyValue)) {
            return BigNumber.from(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(anyValue));
        }
        if (anyValue) {
            // Hexable interface (takes priority)
            if (anyValue.toHexString) {
                const hex = anyValue.toHexString();
                if (typeof (hex) === "string") {
                    return BigNumber.from(hex);
                }
            }
            else {
                // For now, handle legacy JSON-ified values (goes away in v6)
                let hex = anyValue._hex;
                // New-form JSON
                if (hex == null && anyValue.type === "BigNumber") {
                    hex = anyValue.hex;
                }
                if (typeof (hex) === "string") {
                    if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["isHexString"])(hex) || (hex[0] === "-" && Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["isHexString"])(hex.substring(1)))) {
                        return BigNumber.from(hex);
                    }
                }
            }
        }
        return logger.throwArgumentError("invalid BigNumber value", "value", value);
    }
    static isBigNumber(value) {
        return !!(value && value._isBigNumber);
    }
}
// Normalize the hex string
function toHex(value) {
    // For BN, call on the hex string
    if (typeof (value) !== "string") {
        return toHex(value.toString(16));
    }
    // If negative, prepend the negative sign to the normalized positive value
    if (value[0] === "-") {
        // Strip off the negative sign
        value = value.substring(1);
        // Cannot have multiple negative signs (e.g. "--0x04")
        if (value[0] === "-") {
            logger.throwArgumentError("invalid hex", "value", value);
        }
        // Call toHex on the positive component
        value = toHex(value);
        // Do not allow "-0x00"
        if (value === "0x00") {
            return value;
        }
        // Negate the value
        return "-" + value;
    }
    // Add a "0x" prefix if missing
    if (value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    // Normalize zero
    if (value === "0x") {
        return "0x00";
    }
    // Make the string even length
    if (value.length % 2) {
        value = "0x0" + value.substring(2);
    }
    // Trim to smallest even-length string
    while (value.length > 4 && value.substring(0, 4) === "0x00") {
        value = "0x" + value.substring(4);
    }
    return value;
}
function toBigNumber(value) {
    return BigNumber.from(toHex(value));
}
function toBN(value) {
    const hex = BigNumber.from(value).toHexString();
    if (hex[0] === "-") {
        return (new BN("-" + hex.substring(3), 16));
    }
    return new BN(hex.substring(2), 16);
}
function throwFault(fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value != null) {
        params.value = value;
    }
    return logger.throwError(fault, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"].errors.NUMERIC_FAULT, params);
}
// value should have no prefix
function _base36To16(value) {
    return (new BN(value, 36)).toString(16);
}
// value should have no prefix
function _base16To36(value) {
    return (new BN(value, 16)).toString(36);
}
//# sourceMappingURL=bignumber.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js ***!
  \**********************************************************************/
/*! exports provided: formatFixed, parseFixed, FixedFormat, FixedNumber */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatFixed", function() { return formatFixed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseFixed", function() { return parseFixed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FixedFormat", function() { return FixedFormat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FixedNumber", function() { return FixedNumber; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/bignumber/lib.esm/_version.js");
/* harmony import */ var _bignumber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"](_version__WEBPACK_IMPORTED_MODULE_2__["version"]);

const _constructorGuard = {};
const Zero = _bignumber__WEBPACK_IMPORTED_MODULE_3__["BigNumber"].from(0);
const NegativeOne = _bignumber__WEBPACK_IMPORTED_MODULE_3__["BigNumber"].from(-1);
function throwFault(message, fault, operation, value) {
    const params = { fault: fault, operation: operation };
    if (value !== undefined) {
        params.value = value;
    }
    return logger.throwError(message, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.NUMERIC_FAULT, params);
}
// Constant to pull zeros from for multipliers
let zeros = "0";
while (zeros.length < 256) {
    zeros += zeros;
}
// Returns a string "1" followed by decimal "0"s
function getMultiplier(decimals) {
    if (typeof (decimals) !== "number") {
        try {
            decimals = _bignumber__WEBPACK_IMPORTED_MODULE_3__["BigNumber"].from(decimals).toNumber();
        }
        catch (e) { }
    }
    if (typeof (decimals) === "number" && decimals >= 0 && decimals <= 256 && !(decimals % 1)) {
        return ("1" + zeros.substring(0, decimals));
    }
    return logger.throwArgumentError("invalid decimal size", "decimals", decimals);
}
function formatFixed(value, decimals) {
    if (decimals == null) {
        decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    // Make sure wei is a big number (convert as necessary)
    value = _bignumber__WEBPACK_IMPORTED_MODULE_3__["BigNumber"].from(value);
    const negative = value.lt(Zero);
    if (negative) {
        value = value.mul(NegativeOne);
    }
    let fraction = value.mod(multiplier).toString();
    while (fraction.length < multiplier.length - 1) {
        fraction = "0" + fraction;
    }
    // Strip training 0
    fraction = fraction.match(/^([0-9]*[1-9]|0)(0*)/)[1];
    const whole = value.div(multiplier).toString();
    if (multiplier.length === 1) {
        value = whole;
    }
    else {
        value = whole + "." + fraction;
    }
    if (negative) {
        value = "-" + value;
    }
    return value;
}
function parseFixed(value, decimals) {
    if (decimals == null) {
        decimals = 0;
    }
    const multiplier = getMultiplier(decimals);
    if (typeof (value) !== "string" || !value.match(/^-?[0-9.]+$/)) {
        logger.throwArgumentError("invalid decimal value", "value", value);
    }
    // Is it negative?
    const negative = (value.substring(0, 1) === "-");
    if (negative) {
        value = value.substring(1);
    }
    if (value === ".") {
        logger.throwArgumentError("missing value", "value", value);
    }
    // Split it into a whole and fractional part
    const comps = value.split(".");
    if (comps.length > 2) {
        logger.throwArgumentError("too many decimal points", "value", value);
    }
    let whole = comps[0], fraction = comps[1];
    if (!whole) {
        whole = "0";
    }
    if (!fraction) {
        fraction = "0";
    }
    // Trim trailing zeros
    while (fraction[fraction.length - 1] === "0") {
        fraction = fraction.substring(0, fraction.length - 1);
    }
    // Check the fraction doesn't exceed our decimals size
    if (fraction.length > multiplier.length - 1) {
        throwFault("fractional component exceeds decimals", "underflow", "parseFixed");
    }
    // If decimals is 0, we have an empty string for fraction
    if (fraction === "") {
        fraction = "0";
    }
    // Fully pad the string with zeros to get to wei
    while (fraction.length < multiplier.length - 1) {
        fraction += "0";
    }
    const wholeValue = _bignumber__WEBPACK_IMPORTED_MODULE_3__["BigNumber"].from(whole);
    const fractionValue = _bignumber__WEBPACK_IMPORTED_MODULE_3__["BigNumber"].from(fraction);
    let wei = (wholeValue.mul(multiplier)).add(fractionValue);
    if (negative) {
        wei = wei.mul(NegativeOne);
    }
    return wei;
}
class FixedFormat {
    constructor(constructorGuard, signed, width, decimals) {
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("cannot use FixedFormat constructor; use FixedFormat.from", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
            });
        }
        this.signed = signed;
        this.width = width;
        this.decimals = decimals;
        this.name = (signed ? "" : "u") + "fixed" + String(width) + "x" + String(decimals);
        this._multiplier = getMultiplier(decimals);
        Object.freeze(this);
    }
    static from(value) {
        if (value instanceof FixedFormat) {
            return value;
        }
        if (typeof (value) === "number") {
            value = `fixed128x${value}`;
        }
        let signed = true;
        let width = 128;
        let decimals = 18;
        if (typeof (value) === "string") {
            if (value === "fixed") {
                // defaults...
            }
            else if (value === "ufixed") {
                signed = false;
            }
            else {
                const match = value.match(/^(u?)fixed([0-9]+)x([0-9]+)$/);
                if (!match) {
                    logger.throwArgumentError("invalid fixed format", "format", value);
                }
                signed = (match[1] !== "u");
                width = parseInt(match[2]);
                decimals = parseInt(match[3]);
            }
        }
        else if (value) {
            const check = (key, type, defaultValue) => {
                if (value[key] == null) {
                    return defaultValue;
                }
                if (typeof (value[key]) !== type) {
                    logger.throwArgumentError("invalid fixed format (" + key + " not " + type + ")", "format." + key, value[key]);
                }
                return value[key];
            };
            signed = check("signed", "boolean", signed);
            width = check("width", "number", width);
            decimals = check("decimals", "number", decimals);
        }
        if (width % 8) {
            logger.throwArgumentError("invalid fixed format width (not byte aligned)", "format.width", width);
        }
        if (decimals > 80) {
            logger.throwArgumentError("invalid fixed format (decimals too large)", "format.decimals", decimals);
        }
        return new FixedFormat(_constructorGuard, signed, width, decimals);
    }
}
class FixedNumber {
    constructor(constructorGuard, hex, value, format) {
        logger.checkNew(new.target, FixedNumber);
        if (constructorGuard !== _constructorGuard) {
            logger.throwError("cannot use FixedNumber constructor; use FixedNumber.from", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "new FixedFormat"
            });
        }
        this.format = format;
        this._hex = hex;
        this._value = value;
        this._isFixedNumber = true;
        Object.freeze(this);
    }
    _checkFormat(other) {
        if (this.format.name !== other.format.name) {
            logger.throwArgumentError("incompatible format; use fixedNumber.toFormat", "other", other);
        }
    }
    addUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.add(b), this.format.decimals, this.format);
    }
    subUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.sub(b), this.format.decimals, this.format);
    }
    mulUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(b).div(this.format._multiplier), this.format.decimals, this.format);
    }
    divUnsafe(other) {
        this._checkFormat(other);
        const a = parseFixed(this._value, this.format.decimals);
        const b = parseFixed(other._value, other.format.decimals);
        return FixedNumber.fromValue(a.mul(this.format._multiplier).div(b), this.format.decimals, this.format);
    }
    floor() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (this.isNegative() && hasFraction) {
            result = result.subUnsafe(ONE.toFormat(result.format));
        }
        return result;
    }
    ceiling() {
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        let result = FixedNumber.from(comps[0], this.format);
        const hasFraction = !comps[1].match(/^(0*)$/);
        if (!this.isNegative() && hasFraction) {
            result = result.addUnsafe(ONE.toFormat(result.format));
        }
        return result;
    }
    // @TODO: Support other rounding algorithms
    round(decimals) {
        if (decimals == null) {
            decimals = 0;
        }
        // If we are already in range, we're done
        const comps = this.toString().split(".");
        if (comps.length === 1) {
            comps.push("0");
        }
        if (decimals < 0 || decimals > 80 || (decimals % 1)) {
            logger.throwArgumentError("invalid decimal count", "decimals", decimals);
        }
        if (comps[1].length <= decimals) {
            return this;
        }
        const factor = FixedNumber.from("1" + zeros.substring(0, decimals), this.format);
        const bump = BUMP.toFormat(this.format);
        return this.mulUnsafe(factor).addUnsafe(bump).floor().divUnsafe(factor);
    }
    isZero() {
        return (this._value === "0.0" || this._value === "0");
    }
    isNegative() {
        return (this._value[0] === "-");
    }
    toString() { return this._value; }
    toHexString(width) {
        if (width == null) {
            return this._hex;
        }
        if (width % 8) {
            logger.throwArgumentError("invalid byte width", "width", width);
        }
        const hex = _bignumber__WEBPACK_IMPORTED_MODULE_3__["BigNumber"].from(this._hex).fromTwos(this.format.width).toTwos(width).toHexString();
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexZeroPad"])(hex, width / 8);
    }
    toUnsafeFloat() { return parseFloat(this.toString()); }
    toFormat(format) {
        return FixedNumber.fromString(this._value, format);
    }
    static fromValue(value, decimals, format) {
        // If decimals looks more like a format, and there is no format, shift the parameters
        if (format == null && decimals != null && !Object(_bignumber__WEBPACK_IMPORTED_MODULE_3__["isBigNumberish"])(decimals)) {
            format = decimals;
            decimals = null;
        }
        if (decimals == null) {
            decimals = 0;
        }
        if (format == null) {
            format = "fixed";
        }
        return FixedNumber.fromString(formatFixed(value, decimals), FixedFormat.from(format));
    }
    static fromString(value, format) {
        if (format == null) {
            format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        const numeric = parseFixed(value, fixedFormat.decimals);
        if (!fixedFormat.signed && numeric.lt(Zero)) {
            throwFault("unsigned value cannot be negative", "overflow", "value", value);
        }
        let hex = null;
        if (fixedFormat.signed) {
            hex = numeric.toTwos(fixedFormat.width).toHexString();
        }
        else {
            hex = numeric.toHexString();
            hex = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexZeroPad"])(hex, fixedFormat.width / 8);
        }
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
    }
    static fromBytes(value, format) {
        if (format == null) {
            format = "fixed";
        }
        const fixedFormat = FixedFormat.from(format);
        if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(value).length > fixedFormat.width / 8) {
            throw new Error("overflow");
        }
        let numeric = _bignumber__WEBPACK_IMPORTED_MODULE_3__["BigNumber"].from(value);
        if (fixedFormat.signed) {
            numeric = numeric.fromTwos(fixedFormat.width);
        }
        const hex = numeric.toTwos((fixedFormat.signed ? 0 : 1) + fixedFormat.width).toHexString();
        const decimal = formatFixed(numeric, fixedFormat.decimals);
        return new FixedNumber(_constructorGuard, hex, decimal, fixedFormat);
    }
    static from(value, format) {
        if (typeof (value) === "string") {
            return FixedNumber.fromString(value, format);
        }
        if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["isBytes"])(value)) {
            return FixedNumber.fromBytes(value, format);
        }
        try {
            return FixedNumber.fromValue(value, 0, format);
        }
        catch (error) {
            // Allow NUMERIC_FAULT to bubble up
            if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.INVALID_ARGUMENT) {
                throw error;
            }
        }
        return logger.throwArgumentError("invalid FixedNumber value", "value", value);
    }
    static isFixedNumber(value) {
        return !!(value && value._isFixedNumber);
    }
}
const ONE = FixedNumber.from(1);
const BUMP = FixedNumber.from("0.5");
//# sourceMappingURL=fixednumber.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/bignumber/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/bignumber/lib.esm/index.js ***!
  \****************************************************************/
/*! exports provided: BigNumber, formatFixed, FixedFormat, FixedNumber, parseFixed, _base16To36, _base36To16 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/bignumber.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BigNumber", function() { return _bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"]; });

/* harmony import */ var _fixednumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./fixednumber */ "./node_modules/@ethersproject/bignumber/lib.esm/fixednumber.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatFixed", function() { return _fixednumber__WEBPACK_IMPORTED_MODULE_1__["formatFixed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FixedFormat", function() { return _fixednumber__WEBPACK_IMPORTED_MODULE_1__["FixedFormat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FixedNumber", function() { return _fixednumber__WEBPACK_IMPORTED_MODULE_1__["FixedNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseFixed", function() { return _fixednumber__WEBPACK_IMPORTED_MODULE_1__["parseFixed"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_base16To36", function() { return _bignumber__WEBPACK_IMPORTED_MODULE_0__["_base16To36"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_base36To16", function() { return _bignumber__WEBPACK_IMPORTED_MODULE_0__["_base36To16"]; });



// Internal methods used by address

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/bytes/lib.esm/_version.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/bytes/lib.esm/_version.js ***!
  \***************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "bytes/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/bytes/lib.esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ethersproject/bytes/lib.esm/index.js ***!
  \************************************************************/
/*! exports provided: isBytesLike, isBytes, arrayify, concat, stripZeros, zeroPad, isHexString, hexlify, hexDataLength, hexDataSlice, hexConcat, hexValue, hexStripZeros, hexZeroPad, splitSignature, joinSignature */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBytesLike", function() { return isBytesLike; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isBytes", function() { return isBytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "arrayify", function() { return arrayify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return concat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "stripZeros", function() { return stripZeros; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zeroPad", function() { return zeroPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isHexString", function() { return isHexString; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexlify", function() { return hexlify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexDataLength", function() { return hexDataLength; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexDataSlice", function() { return hexDataSlice; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexConcat", function() { return hexConcat; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexValue", function() { return hexValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexStripZeros", function() { return hexStripZeros; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hexZeroPad", function() { return hexZeroPad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "splitSignature", function() { return splitSignature; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "joinSignature", function() { return joinSignature; });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/bytes/lib.esm/_version.js");



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__["Logger"](_version__WEBPACK_IMPORTED_MODULE_1__["version"]);
///////////////////////////////
function isHexable(value) {
    return !!(value.toHexString);
}
function addSlice(array) {
    if (array.slice) {
        return array;
    }
    array.slice = function () {
        const args = Array.prototype.slice.call(arguments);
        return addSlice(new Uint8Array(Array.prototype.slice.apply(array, args)));
    };
    return array;
}
function isBytesLike(value) {
    return ((isHexString(value) && !(value.length % 2)) || isBytes(value));
}
function isInteger(value) {
    return (typeof (value) === "number" && value == value && (value % 1) === 0);
}
function isBytes(value) {
    if (value == null) {
        return false;
    }
    if (value.constructor === Uint8Array) {
        return true;
    }
    if (typeof (value) === "string") {
        return false;
    }
    if (!isInteger(value.length) || value.length < 0) {
        return false;
    }
    for (let i = 0; i < value.length; i++) {
        const v = value[i];
        if (!isInteger(v) || v < 0 || v >= 256) {
            return false;
        }
    }
    return true;
}
function arrayify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger.checkSafeUint53(value, "invalid arrayify value");
        const result = [];
        while (value) {
            result.unshift(value & 0xff);
            value = parseInt(String(value / 256));
        }
        if (result.length === 0) {
            result.push(0);
        }
        return addSlice(new Uint8Array(result));
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        value = value.toHexString();
    }
    if (isHexString(value)) {
        let hex = value.substring(2);
        if (hex.length % 2) {
            if (options.hexPad === "left") {
                hex = "0x0" + hex.substring(2);
            }
            else if (options.hexPad === "right") {
                hex += "0";
            }
            else {
                logger.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        const result = [];
        for (let i = 0; i < hex.length; i += 2) {
            result.push(parseInt(hex.substring(i, i + 2), 16));
        }
        return addSlice(new Uint8Array(result));
    }
    if (isBytes(value)) {
        return addSlice(new Uint8Array(value));
    }
    return logger.throwArgumentError("invalid arrayify value", "value", value);
}
function concat(items) {
    const objects = items.map(item => arrayify(item));
    const length = objects.reduce((accum, item) => (accum + item.length), 0);
    const result = new Uint8Array(length);
    objects.reduce((offset, object) => {
        result.set(object, offset);
        return offset + object.length;
    }, 0);
    return addSlice(result);
}
function stripZeros(value) {
    let result = arrayify(value);
    if (result.length === 0) {
        return result;
    }
    // Find the first non-zero entry
    let start = 0;
    while (start < result.length && result[start] === 0) {
        start++;
    }
    // If we started with zeros, strip them
    if (start) {
        result = result.slice(start);
    }
    return result;
}
function zeroPad(value, length) {
    value = arrayify(value);
    if (value.length > length) {
        logger.throwArgumentError("value out of range", "value", arguments[0]);
    }
    const result = new Uint8Array(length);
    result.set(value, length - value.length);
    return addSlice(result);
}
function isHexString(value, length) {
    if (typeof (value) !== "string" || !value.match(/^0x[0-9A-Fa-f]*$/)) {
        return false;
    }
    if (length && value.length !== 2 + 2 * length) {
        return false;
    }
    return true;
}
const HexCharacters = "0123456789abcdef";
function hexlify(value, options) {
    if (!options) {
        options = {};
    }
    if (typeof (value) === "number") {
        logger.checkSafeUint53(value, "invalid hexlify value");
        let hex = "";
        while (value) {
            hex = HexCharacters[value & 0xf] + hex;
            value = Math.floor(value / 16);
        }
        if (hex.length) {
            if (hex.length % 2) {
                hex = "0" + hex;
            }
            return "0x" + hex;
        }
        return "0x00";
    }
    if (typeof (value) === "bigint") {
        value = value.toString(16);
        if (value.length % 2) {
            return ("0x0" + value);
        }
        return "0x" + value;
    }
    if (options.allowMissingPrefix && typeof (value) === "string" && value.substring(0, 2) !== "0x") {
        value = "0x" + value;
    }
    if (isHexable(value)) {
        return value.toHexString();
    }
    if (isHexString(value)) {
        if (value.length % 2) {
            if (options.hexPad === "left") {
                value = "0x0" + value.substring(2);
            }
            else if (options.hexPad === "right") {
                value += "0";
            }
            else {
                logger.throwArgumentError("hex data is odd-length", "value", value);
            }
        }
        return value.toLowerCase();
    }
    if (isBytes(value)) {
        let result = "0x";
        for (let i = 0; i < value.length; i++) {
            let v = value[i];
            result += HexCharacters[(v & 0xf0) >> 4] + HexCharacters[v & 0x0f];
        }
        return result;
    }
    return logger.throwArgumentError("invalid hexlify value", "value", value);
}
/*
function unoddify(value: BytesLike | Hexable | number): BytesLike | Hexable | number {
    if (typeof(value) === "string" && value.length % 2 && value.substring(0, 2) === "0x") {
        return "0x0" + value.substring(2);
    }
    return value;
}
*/
function hexDataLength(data) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        return null;
    }
    return (data.length - 2) / 2;
}
function hexDataSlice(data, offset, endOffset) {
    if (typeof (data) !== "string") {
        data = hexlify(data);
    }
    else if (!isHexString(data) || (data.length % 2)) {
        logger.throwArgumentError("invalid hexData", "value", data);
    }
    offset = 2 + 2 * offset;
    if (endOffset != null) {
        return "0x" + data.substring(offset, 2 + 2 * endOffset);
    }
    return "0x" + data.substring(offset);
}
function hexConcat(items) {
    let result = "0x";
    items.forEach((item) => {
        result += hexlify(item).substring(2);
    });
    return result;
}
function hexValue(value) {
    const trimmed = hexStripZeros(hexlify(value, { hexPad: "left" }));
    if (trimmed === "0x") {
        return "0x0";
    }
    return trimmed;
}
function hexStripZeros(value) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    if (!isHexString(value)) {
        logger.throwArgumentError("invalid hex string", "value", value);
    }
    value = value.substring(2);
    let offset = 0;
    while (offset < value.length && value[offset] === "0") {
        offset++;
    }
    return "0x" + value.substring(offset);
}
function hexZeroPad(value, length) {
    if (typeof (value) !== "string") {
        value = hexlify(value);
    }
    else if (!isHexString(value)) {
        logger.throwArgumentError("invalid hex string", "value", value);
    }
    if (value.length > 2 * length + 2) {
        logger.throwArgumentError("value out of range", "value", arguments[1]);
    }
    while (value.length < 2 * length + 2) {
        value = "0x0" + value.substring(2);
    }
    return value;
}
function splitSignature(signature) {
    const result = {
        r: "0x",
        s: "0x",
        _vs: "0x",
        recoveryParam: 0,
        v: 0
    };
    if (isBytesLike(signature)) {
        const bytes = arrayify(signature);
        if (bytes.length !== 65) {
            logger.throwArgumentError("invalid signature string; must be 65 bytes", "signature", signature);
        }
        // Get the r, s and v
        result.r = hexlify(bytes.slice(0, 32));
        result.s = hexlify(bytes.slice(32, 64));
        result.v = bytes[64];
        // Allow a recid to be used as the v
        if (result.v < 27) {
            if (result.v === 0 || result.v === 1) {
                result.v += 27;
            }
            else {
                logger.throwArgumentError("signature invalid v byte", "signature", signature);
            }
        }
        // Compute recoveryParam from v
        result.recoveryParam = 1 - (result.v % 2);
        // Compute _vs from recoveryParam and s
        if (result.recoveryParam) {
            bytes[32] |= 0x80;
        }
        result._vs = hexlify(bytes.slice(32, 64));
    }
    else {
        result.r = signature.r;
        result.s = signature.s;
        result.v = signature.v;
        result.recoveryParam = signature.recoveryParam;
        result._vs = signature._vs;
        // If the _vs is available, use it to populate missing s, v and recoveryParam
        // and verify non-missing s, v and recoveryParam
        if (result._vs != null) {
            const vs = zeroPad(arrayify(result._vs), 32);
            result._vs = hexlify(vs);
            // Set or check the recid
            const recoveryParam = ((vs[0] >= 128) ? 1 : 0);
            if (result.recoveryParam == null) {
                result.recoveryParam = recoveryParam;
            }
            else if (result.recoveryParam !== recoveryParam) {
                logger.throwArgumentError("signature recoveryParam mismatch _vs", "signature", signature);
            }
            // Set or check the s
            vs[0] &= 0x7f;
            const s = hexlify(vs);
            if (result.s == null) {
                result.s = s;
            }
            else if (result.s !== s) {
                logger.throwArgumentError("signature v mismatch _vs", "signature", signature);
            }
        }
        // Use recid and v to populate each other
        if (result.recoveryParam == null) {
            if (result.v == null) {
                logger.throwArgumentError("signature missing v and recoveryParam", "signature", signature);
            }
            else if (result.v === 0 || result.v === 1) {
                result.recoveryParam = result.v;
            }
            else {
                result.recoveryParam = 1 - (result.v % 2);
            }
        }
        else {
            if (result.v == null) {
                result.v = 27 + result.recoveryParam;
            }
            else {
                const recId = (result.v === 0 || result.v === 1) ? result.v : (1 - (result.v % 2));
                if (result.recoveryParam !== recId) {
                    logger.throwArgumentError("signature recoveryParam mismatch v", "signature", signature);
                }
            }
        }
        if (result.r == null || !isHexString(result.r)) {
            logger.throwArgumentError("signature missing or invalid r", "signature", signature);
        }
        else {
            result.r = hexZeroPad(result.r, 32);
        }
        if (result.s == null || !isHexString(result.s)) {
            logger.throwArgumentError("signature missing or invalid s", "signature", signature);
        }
        else {
            result.s = hexZeroPad(result.s, 32);
        }
        const vs = arrayify(result.s);
        if (vs[0] >= 128) {
            logger.throwArgumentError("signature s out of range", "signature", signature);
        }
        if (result.recoveryParam) {
            vs[0] |= 0x80;
        }
        const _vs = hexlify(vs);
        if (result._vs) {
            if (!isHexString(result._vs)) {
                logger.throwArgumentError("signature invalid _vs", "signature", signature);
            }
            result._vs = hexZeroPad(result._vs, 32);
        }
        // Set or check the _vs
        if (result._vs == null) {
            result._vs = _vs;
        }
        else if (result._vs !== _vs) {
            logger.throwArgumentError("signature _vs mismatch v and s", "signature", signature);
        }
    }
    return result;
}
function joinSignature(signature) {
    signature = splitSignature(signature);
    return hexlify(concat([
        signature.r,
        signature.s,
        (signature.recoveryParam ? "0x1c" : "0x1b")
    ]));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/constants/lib.esm/addresses.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/addresses.js ***!
  \********************************************************************/
/*! exports provided: AddressZero */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddressZero", function() { return AddressZero; });
const AddressZero = "0x0000000000000000000000000000000000000000";
//# sourceMappingURL=addresses.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/constants/lib.esm/bignumbers.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/bignumbers.js ***!
  \*********************************************************************/
/*! exports provided: NegativeOne, Zero, One, Two, WeiPerEther, MaxUint256, MinInt256, MaxInt256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NegativeOne", function() { return NegativeOne; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Zero", function() { return Zero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "One", function() { return One; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Two", function() { return Two; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WeiPerEther", function() { return WeiPerEther; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxUint256", function() { return MaxUint256; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinInt256", function() { return MinInt256; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxInt256", function() { return MaxInt256; });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");

const NegativeOne = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(-1));
const Zero = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(0));
const One = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(1));
const Two = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(2));
const WeiPerEther = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from("1000000000000000000"));
const MaxUint256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));
const MinInt256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from("-0x8000000000000000000000000000000000000000000000000000000000000000"));
const MaxInt256 = ( /*#__PURE__*/_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from("0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff"));

//# sourceMappingURL=bignumbers.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/constants/lib.esm/hashes.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/hashes.js ***!
  \*****************************************************************/
/*! exports provided: HashZero */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HashZero", function() { return HashZero; });
const HashZero = "0x0000000000000000000000000000000000000000000000000000000000000000";
//# sourceMappingURL=hashes.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/constants/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/index.js ***!
  \****************************************************************/
/*! exports provided: AddressZero, NegativeOne, Zero, One, Two, WeiPerEther, MaxUint256, MinInt256, MaxInt256, HashZero, EtherSymbol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _addresses__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./addresses */ "./node_modules/@ethersproject/constants/lib.esm/addresses.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AddressZero", function() { return _addresses__WEBPACK_IMPORTED_MODULE_0__["AddressZero"]; });

/* harmony import */ var _bignumbers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./bignumbers */ "./node_modules/@ethersproject/constants/lib.esm/bignumbers.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NegativeOne", function() { return _bignumbers__WEBPACK_IMPORTED_MODULE_1__["NegativeOne"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Zero", function() { return _bignumbers__WEBPACK_IMPORTED_MODULE_1__["Zero"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "One", function() { return _bignumbers__WEBPACK_IMPORTED_MODULE_1__["One"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Two", function() { return _bignumbers__WEBPACK_IMPORTED_MODULE_1__["Two"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WeiPerEther", function() { return _bignumbers__WEBPACK_IMPORTED_MODULE_1__["WeiPerEther"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MaxUint256", function() { return _bignumbers__WEBPACK_IMPORTED_MODULE_1__["MaxUint256"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MinInt256", function() { return _bignumbers__WEBPACK_IMPORTED_MODULE_1__["MinInt256"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "MaxInt256", function() { return _bignumbers__WEBPACK_IMPORTED_MODULE_1__["MaxInt256"]; });

/* harmony import */ var _hashes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hashes */ "./node_modules/@ethersproject/constants/lib.esm/hashes.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HashZero", function() { return _hashes__WEBPACK_IMPORTED_MODULE_2__["HashZero"]; });

/* harmony import */ var _strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./strings */ "./node_modules/@ethersproject/constants/lib.esm/strings.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EtherSymbol", function() { return _strings__WEBPACK_IMPORTED_MODULE_3__["EtherSymbol"]; });






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/constants/lib.esm/strings.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/constants/lib.esm/strings.js ***!
  \******************************************************************/
/*! exports provided: EtherSymbol */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EtherSymbol", function() { return EtherSymbol; });
// NFKC (composed)             // (decomposed)
const EtherSymbol = "\u039e"; // "\uD835\uDF63";
//# sourceMappingURL=strings.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/contracts/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/contracts/lib.esm/_version.js ***!
  \*******************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "contracts/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/contracts/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/contracts/lib.esm/index.js ***!
  \****************************************************************/
/*! exports provided: BaseContract, Contract, ContractFactory */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseContract", function() { return BaseContract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Contract", function() { return Contract; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ContractFactory", function() { return ContractFactory; });
/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/abi */ "./node_modules/@ethersproject/abi/lib.esm/index.js");
/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/abstract-provider */ "./node_modules/@ethersproject/abstract-provider/lib.esm/index.js");
/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/abstract-signer */ "./node_modules/@ethersproject/abstract-signer/lib.esm/index.js");
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/contracts/lib.esm/_version.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};










const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"](_version__WEBPACK_IMPORTED_MODULE_9__["version"]);
;
;
///////////////////////////////
const allowedTransactionKeys = {
    chainId: true, data: true, from: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,
    type: true, accessList: true,
    maxFeePerGas: true, maxPriorityFeePerGas: true,
    customData: true
};
function resolveName(resolver, nameOrPromise) {
    return __awaiter(this, void 0, void 0, function* () {
        const name = yield nameOrPromise;
        if (typeof (name) !== "string") {
            logger.throwArgumentError("invalid address or ENS name", "name", name);
        }
        // If it is already an address, just use it (after adding checksum)
        try {
            return Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_3__["getAddress"])(name);
        }
        catch (error) { }
        if (!resolver) {
            logger.throwError("a provider or signer is needed to resolve ENS names", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "resolveName"
            });
        }
        const address = yield resolver.resolveName(name);
        if (address == null) {
            logger.throwArgumentError("resolver or addr is not configured for ENS name", "name", name);
        }
        return address;
    });
}
// Recursively replaces ENS names with promises to resolve the name and resolves all properties
function resolveAddresses(resolver, value, paramType) {
    return __awaiter(this, void 0, void 0, function* () {
        if (Array.isArray(paramType)) {
            return yield Promise.all(paramType.map((paramType, index) => {
                return resolveAddresses(resolver, ((Array.isArray(value)) ? value[index] : value[paramType.name]), paramType);
            }));
        }
        if (paramType.type === "address") {
            return yield resolveName(resolver, value);
        }
        if (paramType.type === "tuple") {
            return yield resolveAddresses(resolver, value, paramType.components);
        }
        if (paramType.baseType === "array") {
            if (!Array.isArray(value)) {
                return Promise.reject(logger.makeError("invalid value for array", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.INVALID_ARGUMENT, {
                    argument: "value",
                    value
                }));
            }
            return yield Promise.all(value.map((v) => resolveAddresses(resolver, v, paramType.arrayChildren)));
        }
        return value;
    });
}
function populateTransaction(contract, fragment, args) {
    return __awaiter(this, void 0, void 0, function* () {
        // If an extra argument is given, it is overrides
        let overrides = {};
        if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === "object") {
            overrides = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["shallowCopy"])(args.pop());
        }
        // Make sure the parameter count matches
        logger.checkArgumentCount(args.length, fragment.inputs.length, "passed to contract");
        // Populate "from" override (allow promises)
        if (contract.signer) {
            if (overrides.from) {
                // Contracts with a Signer are from the Signer's frame-of-reference;
                // but we allow overriding "from" if it matches the signer
                overrides.from = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["resolveProperties"])({
                    override: resolveName(contract.signer, overrides.from),
                    signer: contract.signer.getAddress()
                }).then((check) => __awaiter(this, void 0, void 0, function* () {
                    if (Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_3__["getAddress"])(check.signer) !== check.override) {
                        logger.throwError("Contract with a Signer cannot override from", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
                            operation: "overrides.from"
                        });
                    }
                    return check.override;
                }));
            }
            else {
                overrides.from = contract.signer.getAddress();
            }
        }
        else if (overrides.from) {
            overrides.from = resolveName(contract.provider, overrides.from);
            //} else {
            // Contracts without a signer can override "from", and if
            // unspecified the zero address is used
            //overrides.from = AddressZero;
        }
        // Wait for all dependencies to be resolved (prefer the signer over the provider)
        const resolved = yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["resolveProperties"])({
            args: resolveAddresses(contract.signer || contract.provider, args, fragment.inputs),
            address: contract.resolvedAddress,
            overrides: (Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["resolveProperties"])(overrides) || {})
        });
        // The ABI coded transaction
        const data = contract.interface.encodeFunctionData(fragment, resolved.args);
        const tx = {
            data: data,
            to: resolved.address
        };
        // Resolved Overrides
        const ro = resolved.overrides;
        // Populate simple overrides
        if (ro.nonce != null) {
            tx.nonce = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__["BigNumber"].from(ro.nonce).toNumber();
        }
        if (ro.gasLimit != null) {
            tx.gasLimit = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__["BigNumber"].from(ro.gasLimit);
        }
        if (ro.gasPrice != null) {
            tx.gasPrice = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__["BigNumber"].from(ro.gasPrice);
        }
        if (ro.maxFeePerGas != null) {
            tx.maxFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__["BigNumber"].from(ro.maxFeePerGas);
        }
        if (ro.maxPriorityFeePerGas != null) {
            tx.maxPriorityFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__["BigNumber"].from(ro.maxPriorityFeePerGas);
        }
        if (ro.from != null) {
            tx.from = ro.from;
        }
        if (ro.type != null) {
            tx.type = ro.type;
        }
        if (ro.accessList != null) {
            tx.accessList = Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_7__["accessListify"])(ro.accessList);
        }
        // If there was no "gasLimit" override, but the ABI specifies a default, use it
        if (tx.gasLimit == null && fragment.gas != null) {
            // Compute the intrinsic gas cost for this transaction
            // @TODO: This is based on the yellow paper as of Petersburg; this is something
            // we may wish to parameterize in v6 as part of the Network object. Since this
            // is always a non-nil to address, we can ignore G_create, but may wish to add
            // similar logic to the ContractFactory.
            let intrinsic = 21000;
            const bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__["arrayify"])(data);
            for (let i = 0; i < bytes.length; i++) {
                intrinsic += 4;
                if (bytes[i]) {
                    intrinsic += 64;
                }
            }
            tx.gasLimit = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__["BigNumber"].from(fragment.gas).add(intrinsic);
        }
        // Populate "value" override
        if (ro.value) {
            const roValue = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__["BigNumber"].from(ro.value);
            if (!roValue.isZero() && !fragment.payable) {
                logger.throwError("non-payable method cannot override value", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: overrides.value
                });
            }
            tx.value = roValue;
        }
        if (ro.customData) {
            tx.customData = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["shallowCopy"])(ro.customData);
        }
        // Remove the overrides
        delete overrides.nonce;
        delete overrides.gasLimit;
        delete overrides.gasPrice;
        delete overrides.from;
        delete overrides.value;
        delete overrides.type;
        delete overrides.accessList;
        delete overrides.maxFeePerGas;
        delete overrides.maxPriorityFeePerGas;
        delete overrides.customData;
        // Make sure there are no stray overrides, which may indicate a
        // typo or using an unsupported key.
        const leftovers = Object.keys(overrides).filter((key) => (overrides[key] != null));
        if (leftovers.length) {
            logger.throwError(`cannot override ${leftovers.map((l) => JSON.stringify(l)).join(",")}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "overrides",
                overrides: leftovers
            });
        }
        return tx;
    });
}
function buildPopulate(contract, fragment) {
    return function (...args) {
        return populateTransaction(contract, fragment, args);
    };
}
function buildEstimate(contract, fragment) {
    const signerOrProvider = (contract.signer || contract.provider);
    return function (...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!signerOrProvider) {
                logger.throwError("estimate require a provider or signer", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
                    operation: "estimateGas"
                });
            }
            const tx = yield populateTransaction(contract, fragment, args);
            return yield signerOrProvider.estimateGas(tx);
        });
    };
}
function addContractWait(contract, tx) {
    const wait = tx.wait.bind(tx);
    tx.wait = (confirmations) => {
        return wait(confirmations).then((receipt) => {
            receipt.events = receipt.logs.map((log) => {
                let event = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["deepCopy"])(log);
                let parsed = null;
                try {
                    parsed = contract.interface.parseLog(log);
                }
                catch (e) { }
                // Successfully parsed the event log; include it
                if (parsed) {
                    event.args = parsed.args;
                    event.decode = (data, topics) => {
                        return contract.interface.decodeEventLog(parsed.eventFragment, data, topics);
                    };
                    event.event = parsed.name;
                    event.eventSignature = parsed.signature;
                }
                // Useful operations
                event.removeListener = () => { return contract.provider; };
                event.getBlock = () => {
                    return contract.provider.getBlock(receipt.blockHash);
                };
                event.getTransaction = () => {
                    return contract.provider.getTransaction(receipt.transactionHash);
                };
                event.getTransactionReceipt = () => {
                    return Promise.resolve(receipt);
                };
                return event;
            });
            return receipt;
        });
    };
}
function buildCall(contract, fragment, collapseSimple) {
    const signerOrProvider = (contract.signer || contract.provider);
    return function (...args) {
        return __awaiter(this, void 0, void 0, function* () {
            // Extract the "blockTag" override if present
            let blockTag = undefined;
            if (args.length === fragment.inputs.length + 1 && typeof (args[args.length - 1]) === "object") {
                const overrides = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["shallowCopy"])(args.pop());
                if (overrides.blockTag != null) {
                    blockTag = yield overrides.blockTag;
                }
                delete overrides.blockTag;
                args.push(overrides);
            }
            // If the contract was just deployed, wait until it is mined
            if (contract.deployTransaction != null) {
                yield contract._deployed(blockTag);
            }
            // Call a node and get the result
            const tx = yield populateTransaction(contract, fragment, args);
            const result = yield signerOrProvider.call(tx, blockTag);
            try {
                let value = contract.interface.decodeFunctionResult(fragment, result);
                if (collapseSimple && fragment.outputs.length === 1) {
                    value = value[0];
                }
                return value;
            }
            catch (error) {
                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.CALL_EXCEPTION) {
                    error.address = contract.address;
                    error.args = args;
                    error.transaction = tx;
                }
                throw error;
            }
        });
    };
}
function buildSend(contract, fragment) {
    return function (...args) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!contract.signer) {
                logger.throwError("sending a transaction requires a signer", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
                    operation: "sendTransaction"
                });
            }
            // If the contract was just deployed, wait until it is mined
            if (contract.deployTransaction != null) {
                yield contract._deployed();
            }
            const txRequest = yield populateTransaction(contract, fragment, args);
            const tx = yield contract.signer.sendTransaction(txRequest);
            // Tweak the tx.wait so the receipt has extra properties
            addContractWait(contract, tx);
            return tx;
        });
    };
}
function buildDefault(contract, fragment, collapseSimple) {
    if (fragment.constant) {
        return buildCall(contract, fragment, collapseSimple);
    }
    return buildSend(contract, fragment);
}
function getEventTag(filter) {
    if (filter.address && (filter.topics == null || filter.topics.length === 0)) {
        return "*";
    }
    return (filter.address || "*") + "@" + (filter.topics ? filter.topics.map((topic) => {
        if (Array.isArray(topic)) {
            return topic.join("|");
        }
        return topic;
    }).join(":") : "");
}
class RunningEvent {
    constructor(tag, filter) {
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "tag", tag);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "filter", filter);
        this._listeners = [];
    }
    addListener(listener, once) {
        this._listeners.push({ listener: listener, once: once });
    }
    removeListener(listener) {
        let done = false;
        this._listeners = this._listeners.filter((item) => {
            if (done || item.listener !== listener) {
                return true;
            }
            done = true;
            return false;
        });
    }
    removeAllListeners() {
        this._listeners = [];
    }
    listeners() {
        return this._listeners.map((i) => i.listener);
    }
    listenerCount() {
        return this._listeners.length;
    }
    run(args) {
        const listenerCount = this.listenerCount();
        this._listeners = this._listeners.filter((item) => {
            const argsCopy = args.slice();
            // Call the callback in the next event loop
            setTimeout(() => {
                item.listener.apply(this, argsCopy);
            }, 0);
            // Reschedule it if it not "once"
            return !(item.once);
        });
        return listenerCount;
    }
    prepareEvent(event) {
    }
    // Returns the array that will be applied to an emit
    getEmit(event) {
        return [event];
    }
}
class ErrorRunningEvent extends RunningEvent {
    constructor() {
        super("error", null);
    }
}
// @TODO Fragment should inherit Wildcard? and just override getEmit?
//       or have a common abstract super class, with enough constructor
//       options to configure both.
// A Fragment Event will populate all the properties that Wildcard
// will, and additionally dereference the arguments when emitting
class FragmentRunningEvent extends RunningEvent {
    constructor(address, contractInterface, fragment, topics) {
        const filter = {
            address: address
        };
        let topic = contractInterface.getEventTopic(fragment);
        if (topics) {
            if (topic !== topics[0]) {
                logger.throwArgumentError("topic mismatch", "topics", topics);
            }
            filter.topics = topics.slice();
        }
        else {
            filter.topics = [topic];
        }
        super(getEventTag(filter), filter);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "address", address);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "interface", contractInterface);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "fragment", fragment);
    }
    prepareEvent(event) {
        super.prepareEvent(event);
        event.event = this.fragment.name;
        event.eventSignature = this.fragment.format();
        event.decode = (data, topics) => {
            return this.interface.decodeEventLog(this.fragment, data, topics);
        };
        try {
            event.args = this.interface.decodeEventLog(this.fragment, event.data, event.topics);
        }
        catch (error) {
            event.args = null;
            event.decodeError = error;
        }
    }
    getEmit(event) {
        const errors = Object(_ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["checkResultErrors"])(event.args);
        if (errors.length) {
            throw errors[0].error;
        }
        const args = (event.args || []).slice();
        args.push(event);
        return args;
    }
}
// A Wildcard Event will attempt to populate:
//  - event            The name of the event name
//  - eventSignature   The full signature of the event
//  - decode           A function to decode data and topics
//  - args             The decoded data and topics
class WildcardRunningEvent extends RunningEvent {
    constructor(address, contractInterface) {
        super("*", { address: address });
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "address", address);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "interface", contractInterface);
    }
    prepareEvent(event) {
        super.prepareEvent(event);
        try {
            const parsed = this.interface.parseLog(event);
            event.event = parsed.name;
            event.eventSignature = parsed.signature;
            event.decode = (data, topics) => {
                return this.interface.decodeEventLog(parsed.eventFragment, data, topics);
            };
            event.args = parsed.args;
        }
        catch (error) {
            // No matching event
        }
    }
}
class BaseContract {
    constructor(addressOrName, contractInterface, signerOrProvider) {
        logger.checkNew(new.target, Contract);
        // @TODO: Maybe still check the addressOrName looks like a valid address or name?
        //address = getAddress(address);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "interface", Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["getStatic"])(new.target, "getInterface")(contractInterface));
        if (signerOrProvider == null) {
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "provider", null);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "signer", null);
        }
        else if (_ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_2__["Signer"].isSigner(signerOrProvider)) {
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "provider", signerOrProvider.provider || null);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "signer", signerOrProvider);
        }
        else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_1__["Provider"].isProvider(signerOrProvider)) {
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "provider", signerOrProvider);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "signer", null);
        }
        else {
            logger.throwArgumentError("invalid signer or provider", "signerOrProvider", signerOrProvider);
        }
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "callStatic", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "estimateGas", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "functions", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "populateTransaction", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "filters", {});
        {
            const uniqueFilters = {};
            Object.keys(this.interface.events).forEach((eventSignature) => {
                const event = this.interface.events[eventSignature];
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this.filters, eventSignature, (...args) => {
                    return {
                        address: this.address,
                        topics: this.interface.encodeFilterTopics(event, args)
                    };
                });
                if (!uniqueFilters[event.name]) {
                    uniqueFilters[event.name] = [];
                }
                uniqueFilters[event.name].push(eventSignature);
            });
            Object.keys(uniqueFilters).forEach((name) => {
                const filters = uniqueFilters[name];
                if (filters.length === 1) {
                    Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this.filters, name, this.filters[filters[0]]);
                }
                else {
                    logger.warn(`Duplicate definition of ${name} (${filters.join(", ")})`);
                }
            });
        }
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "_runningEvents", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "_wrappedEmits", {});
        if (addressOrName == null) {
            logger.throwArgumentError("invalid contract address or ENS name", "addressOrName", addressOrName);
        }
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "address", addressOrName);
        if (this.provider) {
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "resolvedAddress", resolveName(this.provider, addressOrName));
        }
        else {
            try {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "resolvedAddress", Promise.resolve(Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_3__["getAddress"])(addressOrName)));
            }
            catch (error) {
                // Without a provider, we cannot use ENS names
                logger.throwError("provider is required to use ENS name as contract address", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
                    operation: "new Contract"
                });
            }
        }
        const uniqueNames = {};
        const uniqueSignatures = {};
        Object.keys(this.interface.functions).forEach((signature) => {
            const fragment = this.interface.functions[signature];
            // Check that the signature is unique; if not the ABI generation has
            // not been cleaned or may be incorrectly generated
            if (uniqueSignatures[signature]) {
                logger.warn(`Duplicate ABI entry for ${JSON.stringify(signature)}`);
                return;
            }
            uniqueSignatures[signature] = true;
            // Track unique names; we only expose bare named functions if they
            // are ambiguous
            {
                const name = fragment.name;
                if (!uniqueNames[`%${name}`]) {
                    uniqueNames[`%${name}`] = [];
                }
                uniqueNames[`%${name}`].push(signature);
            }
            if (this[signature] == null) {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, signature, buildDefault(this, fragment, true));
            }
            // We do not collapse simple calls on this bucket, which allows
            // frameworks to safely use this without introspection as well as
            // allows decoding error recovery.
            if (this.functions[signature] == null) {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this.functions, signature, buildDefault(this, fragment, false));
            }
            if (this.callStatic[signature] == null) {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this.callStatic, signature, buildCall(this, fragment, true));
            }
            if (this.populateTransaction[signature] == null) {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this.populateTransaction, signature, buildPopulate(this, fragment));
            }
            if (this.estimateGas[signature] == null) {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this.estimateGas, signature, buildEstimate(this, fragment));
            }
        });
        Object.keys(uniqueNames).forEach((name) => {
            // Ambiguous names to not get attached as bare names
            const signatures = uniqueNames[name];
            if (signatures.length > 1) {
                return;
            }
            // Strip off the leading "%" used for prototype protection
            name = name.substring(1);
            const signature = signatures[0];
            // If overwriting a member property that is null, swallow the error
            try {
                if (this[name] == null) {
                    Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, name, this[signature]);
                }
            }
            catch (e) { }
            if (this.functions[name] == null) {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this.functions, name, this.functions[signature]);
            }
            if (this.callStatic[name] == null) {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this.callStatic, name, this.callStatic[signature]);
            }
            if (this.populateTransaction[name] == null) {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this.populateTransaction, name, this.populateTransaction[signature]);
            }
            if (this.estimateGas[name] == null) {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this.estimateGas, name, this.estimateGas[signature]);
            }
        });
    }
    static getContractAddress(transaction) {
        return Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_3__["getContractAddress"])(transaction);
    }
    static getInterface(contractInterface) {
        if (_ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["Interface"].isInterface(contractInterface)) {
            return contractInterface;
        }
        return new _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["Interface"](contractInterface);
    }
    // @TODO: Allow timeout?
    deployed() {
        return this._deployed();
    }
    _deployed(blockTag) {
        if (!this._deployedPromise) {
            // If we were just deployed, we know the transaction we should occur in
            if (this.deployTransaction) {
                this._deployedPromise = this.deployTransaction.wait().then(() => {
                    return this;
                });
            }
            else {
                // @TODO: Once we allow a timeout to be passed in, we will wait
                // up to that many blocks for getCode
                // Otherwise, poll for our code to be deployed
                this._deployedPromise = this.provider.getCode(this.address, blockTag).then((code) => {
                    if (code === "0x") {
                        logger.throwError("contract not deployed", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
                            contractAddress: this.address,
                            operation: "getDeployed"
                        });
                    }
                    return this;
                });
            }
        }
        return this._deployedPromise;
    }
    // @TODO:
    // estimateFallback(overrides?: TransactionRequest): Promise<BigNumber>
    // @TODO:
    // estimateDeploy(bytecode: string, ...args): Promise<BigNumber>
    fallback(overrides) {
        if (!this.signer) {
            logger.throwError("sending a transactions require a signer", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, { operation: "sendTransaction(fallback)" });
        }
        const tx = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["shallowCopy"])(overrides || {});
        ["from", "to"].forEach(function (key) {
            if (tx[key] == null) {
                return;
            }
            logger.throwError("cannot override " + key, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        tx.to = this.resolvedAddress;
        return this.deployed().then(() => {
            return this.signer.sendTransaction(tx);
        });
    }
    // Reconnect to a different signer or provider
    connect(signerOrProvider) {
        if (typeof (signerOrProvider) === "string") {
            signerOrProvider = new _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_2__["VoidSigner"](signerOrProvider, this.provider);
        }
        const contract = new (this.constructor)(this.address, this.interface, signerOrProvider);
        if (this.deployTransaction) {
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(contract, "deployTransaction", this.deployTransaction);
        }
        return contract;
    }
    // Re-attach to a different on-chain instance of this contract
    attach(addressOrName) {
        return new (this.constructor)(addressOrName, this.interface, this.signer || this.provider);
    }
    static isIndexed(value) {
        return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["Indexed"].isIndexed(value);
    }
    _normalizeRunningEvent(runningEvent) {
        // Already have an instance of this event running; we can re-use it
        if (this._runningEvents[runningEvent.tag]) {
            return this._runningEvents[runningEvent.tag];
        }
        return runningEvent;
    }
    _getRunningEvent(eventName) {
        if (typeof (eventName) === "string") {
            // Listen for "error" events (if your contract has an error event, include
            // the full signature to bypass this special event keyword)
            if (eventName === "error") {
                return this._normalizeRunningEvent(new ErrorRunningEvent());
            }
            // Listen for any event that is registered
            if (eventName === "event") {
                return this._normalizeRunningEvent(new RunningEvent("event", null));
            }
            // Listen for any event
            if (eventName === "*") {
                return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
            }
            // Get the event Fragment (throws if ambiguous/unknown event)
            const fragment = this.interface.getEvent(eventName);
            return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment));
        }
        // We have topics to filter by...
        if (eventName.topics && eventName.topics.length > 0) {
            // Is it a known topichash? (throws if no matching topichash)
            try {
                const topic = eventName.topics[0];
                if (typeof (topic) !== "string") {
                    throw new Error("invalid topic"); // @TODO: May happen for anonymous events
                }
                const fragment = this.interface.getEvent(topic);
                return this._normalizeRunningEvent(new FragmentRunningEvent(this.address, this.interface, fragment, eventName.topics));
            }
            catch (error) { }
            // Filter by the unknown topichash
            const filter = {
                address: this.address,
                topics: eventName.topics
            };
            return this._normalizeRunningEvent(new RunningEvent(getEventTag(filter), filter));
        }
        return this._normalizeRunningEvent(new WildcardRunningEvent(this.address, this.interface));
    }
    _checkRunningEvents(runningEvent) {
        if (runningEvent.listenerCount() === 0) {
            delete this._runningEvents[runningEvent.tag];
            // If we have a poller for this, remove it
            const emit = this._wrappedEmits[runningEvent.tag];
            if (emit && runningEvent.filter) {
                this.provider.off(runningEvent.filter, emit);
                delete this._wrappedEmits[runningEvent.tag];
            }
        }
    }
    // Subclasses can override this to gracefully recover
    // from parse errors if they wish
    _wrapEvent(runningEvent, log, listener) {
        const event = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["deepCopy"])(log);
        event.removeListener = () => {
            if (!listener) {
                return;
            }
            runningEvent.removeListener(listener);
            this._checkRunningEvents(runningEvent);
        };
        event.getBlock = () => { return this.provider.getBlock(log.blockHash); };
        event.getTransaction = () => { return this.provider.getTransaction(log.transactionHash); };
        event.getTransactionReceipt = () => { return this.provider.getTransactionReceipt(log.transactionHash); };
        // This may throw if the topics and data mismatch the signature
        runningEvent.prepareEvent(event);
        return event;
    }
    _addEventListener(runningEvent, listener, once) {
        if (!this.provider) {
            logger.throwError("events require a provider or a signer with a provider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, { operation: "once" });
        }
        runningEvent.addListener(listener, once);
        // Track this running event and its listeners (may already be there; but no hard in updating)
        this._runningEvents[runningEvent.tag] = runningEvent;
        // If we are not polling the provider, start polling
        if (!this._wrappedEmits[runningEvent.tag]) {
            const wrappedEmit = (log) => {
                let event = this._wrapEvent(runningEvent, log, listener);
                // Try to emit the result for the parameterized event...
                if (event.decodeError == null) {
                    try {
                        const args = runningEvent.getEmit(event);
                        this.emit(runningEvent.filter, ...args);
                    }
                    catch (error) {
                        event.decodeError = error.error;
                    }
                }
                // Always emit "event" for fragment-base events
                if (runningEvent.filter != null) {
                    this.emit("event", event);
                }
                // Emit "error" if there was an error
                if (event.decodeError != null) {
                    this.emit("error", event.decodeError, event);
                }
            };
            this._wrappedEmits[runningEvent.tag] = wrappedEmit;
            // Special events, like "error" do not have a filter
            if (runningEvent.filter != null) {
                this.provider.on(runningEvent.filter, wrappedEmit);
            }
        }
    }
    queryFilter(event, fromBlockOrBlockhash, toBlock) {
        const runningEvent = this._getRunningEvent(event);
        const filter = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["shallowCopy"])(runningEvent.filter);
        if (typeof (fromBlockOrBlockhash) === "string" && Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__["isHexString"])(fromBlockOrBlockhash, 32)) {
            if (toBlock != null) {
                logger.throwArgumentError("cannot specify toBlock with blockhash", "toBlock", toBlock);
            }
            filter.blockHash = fromBlockOrBlockhash;
        }
        else {
            filter.fromBlock = ((fromBlockOrBlockhash != null) ? fromBlockOrBlockhash : 0);
            filter.toBlock = ((toBlock != null) ? toBlock : "latest");
        }
        return this.provider.getLogs(filter).then((logs) => {
            return logs.map((log) => this._wrapEvent(runningEvent, log, null));
        });
    }
    on(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, false);
        return this;
    }
    once(event, listener) {
        this._addEventListener(this._getRunningEvent(event), listener, true);
        return this;
    }
    emit(eventName, ...args) {
        if (!this.provider) {
            return false;
        }
        const runningEvent = this._getRunningEvent(eventName);
        const result = (runningEvent.run(args) > 0);
        // May have drained all the "once" events; check for living events
        this._checkRunningEvents(runningEvent);
        return result;
    }
    listenerCount(eventName) {
        if (!this.provider) {
            return 0;
        }
        if (eventName == null) {
            return Object.keys(this._runningEvents).reduce((accum, key) => {
                return accum + this._runningEvents[key].listenerCount();
            }, 0);
        }
        return this._getRunningEvent(eventName).listenerCount();
    }
    listeners(eventName) {
        if (!this.provider) {
            return [];
        }
        if (eventName == null) {
            const result = [];
            for (let tag in this._runningEvents) {
                this._runningEvents[tag].listeners().forEach((listener) => {
                    result.push(listener);
                });
            }
            return result;
        }
        return this._getRunningEvent(eventName).listeners();
    }
    removeAllListeners(eventName) {
        if (!this.provider) {
            return this;
        }
        if (eventName == null) {
            for (const tag in this._runningEvents) {
                const runningEvent = this._runningEvents[tag];
                runningEvent.removeAllListeners();
                this._checkRunningEvents(runningEvent);
            }
            return this;
        }
        // Delete any listeners
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeAllListeners();
        this._checkRunningEvents(runningEvent);
        return this;
    }
    off(eventName, listener) {
        if (!this.provider) {
            return this;
        }
        const runningEvent = this._getRunningEvent(eventName);
        runningEvent.removeListener(listener);
        this._checkRunningEvents(runningEvent);
        return this;
    }
    removeListener(eventName, listener) {
        return this.off(eventName, listener);
    }
}
class Contract extends BaseContract {
}
class ContractFactory {
    constructor(contractInterface, bytecode, signer) {
        let bytecodeHex = null;
        if (typeof (bytecode) === "string") {
            bytecodeHex = bytecode;
        }
        else if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__["isBytes"])(bytecode)) {
            bytecodeHex = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__["hexlify"])(bytecode);
        }
        else if (bytecode && typeof (bytecode.object) === "string") {
            // Allow the bytecode object from the Solidity compiler
            bytecodeHex = bytecode.object;
        }
        else {
            // Crash in the next verification step
            bytecodeHex = "!";
        }
        // Make sure it is 0x prefixed
        if (bytecodeHex.substring(0, 2) !== "0x") {
            bytecodeHex = "0x" + bytecodeHex;
        }
        // Make sure the final result is valid bytecode
        if (!Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__["isHexString"])(bytecodeHex) || (bytecodeHex.length % 2)) {
            logger.throwArgumentError("invalid bytecode", "bytecode", bytecode);
        }
        // If we have a signer, make sure it is valid
        if (signer && !_ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_2__["Signer"].isSigner(signer)) {
            logger.throwArgumentError("invalid signer", "signer", signer);
        }
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "bytecode", bytecodeHex);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "interface", Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["getStatic"])(new.target, "getInterface")(contractInterface));
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(this, "signer", signer || null);
    }
    // @TODO: Future; rename to populateTransaction?
    getDeployTransaction(...args) {
        let tx = {};
        // If we have 1 additional argument, we allow transaction overrides
        if (args.length === this.interface.deploy.inputs.length + 1 && typeof (args[args.length - 1]) === "object") {
            tx = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["shallowCopy"])(args.pop());
            for (const key in tx) {
                if (!allowedTransactionKeys[key]) {
                    throw new Error("unknown transaction override " + key);
                }
            }
        }
        // Do not allow these to be overridden in a deployment transaction
        ["data", "from", "to"].forEach((key) => {
            if (tx[key] == null) {
                return;
            }
            logger.throwError("cannot override " + key, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, { operation: key });
        });
        if (tx.value) {
            const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_4__["BigNumber"].from(tx.value);
            if (!value.isZero() && !this.interface.deploy.payable) {
                logger.throwError("non-payable constructor cannot override value", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
                    operation: "overrides.value",
                    value: tx.value
                });
            }
        }
        // Make sure the call matches the constructor signature
        logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
        // Set the data to the bytecode + the encoded constructor arguments
        tx.data = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__["hexlify"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_5__["concat"])([
            this.bytecode,
            this.interface.encodeDeploy(args)
        ]));
        return tx;
    }
    deploy(...args) {
        return __awaiter(this, void 0, void 0, function* () {
            let overrides = {};
            // If 1 extra parameter was passed in, it contains overrides
            if (args.length === this.interface.deploy.inputs.length + 1) {
                overrides = args.pop();
            }
            // Make sure the call matches the constructor signature
            logger.checkArgumentCount(args.length, this.interface.deploy.inputs.length, " in Contract constructor");
            // Resolve ENS names and promises in the arguments
            const params = yield resolveAddresses(this.signer, args, this.interface.deploy.inputs);
            params.push(overrides);
            // Get the deployment transaction (with optional overrides)
            const unsignedTx = this.getDeployTransaction(...params);
            // Send the deployment transaction
            const tx = yield this.signer.sendTransaction(unsignedTx);
            const address = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["getStatic"])(this.constructor, "getContractAddress")(tx);
            const contract = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["getStatic"])(this.constructor, "getContract")(address, this.interface, this.signer);
            // Add the modified wait that wraps events
            addContractWait(contract, tx);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["defineReadOnly"])(contract, "deployTransaction", tx);
            return contract;
        });
    }
    attach(address) {
        return (this.constructor).getContract(address, this.interface, this.signer);
    }
    connect(signer) {
        return new (this.constructor)(this.interface, this.bytecode, signer);
    }
    static fromSolidity(compilerOutput, signer) {
        if (compilerOutput == null) {
            logger.throwError("missing compiler output", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.MISSING_ARGUMENT, { argument: "compilerOutput" });
        }
        if (typeof (compilerOutput) === "string") {
            compilerOutput = JSON.parse(compilerOutput);
        }
        const abi = compilerOutput.abi;
        let bytecode = null;
        if (compilerOutput.bytecode) {
            bytecode = compilerOutput.bytecode;
        }
        else if (compilerOutput.evm && compilerOutput.evm.bytecode) {
            bytecode = compilerOutput.evm.bytecode;
        }
        return new this(abi, bytecode, signer);
    }
    static getInterface(contractInterface) {
        return Contract.getInterface(contractInterface);
    }
    static getContractAddress(tx) {
        return Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_3__["getContractAddress"])(tx);
    }
    static getContract(address, contractInterface, signer) {
        return new Contract(address, contractInterface, signer);
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/hash/lib.esm/_version.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/_version.js ***!
  \**************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "hash/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/hash/lib.esm/id.js":
/*!********************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/id.js ***!
  \********************************************************/
/*! exports provided: id */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "id", function() { return id; });
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");


function id(text) {
    return Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_0__["keccak256"])(Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__["toUtf8Bytes"])(text));
}
//# sourceMappingURL=id.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/hash/lib.esm/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/index.js ***!
  \***********************************************************/
/*! exports provided: id, namehash, isValidName, messagePrefix, hashMessage, _TypedDataEncoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _id__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./id */ "./node_modules/@ethersproject/hash/lib.esm/id.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "id", function() { return _id__WEBPACK_IMPORTED_MODULE_0__["id"]; });

/* harmony import */ var _namehash__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./namehash */ "./node_modules/@ethersproject/hash/lib.esm/namehash.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namehash", function() { return _namehash__WEBPACK_IMPORTED_MODULE_1__["namehash"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isValidName", function() { return _namehash__WEBPACK_IMPORTED_MODULE_1__["isValidName"]; });

/* harmony import */ var _message__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./message */ "./node_modules/@ethersproject/hash/lib.esm/message.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "messagePrefix", function() { return _message__WEBPACK_IMPORTED_MODULE_2__["messagePrefix"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hashMessage", function() { return _message__WEBPACK_IMPORTED_MODULE_2__["hashMessage"]; });

/* harmony import */ var _typed_data__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./typed-data */ "./node_modules/@ethersproject/hash/lib.esm/typed-data.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_TypedDataEncoder", function() { return _typed_data__WEBPACK_IMPORTED_MODULE_3__["TypedDataEncoder"]; });







//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/hash/lib.esm/message.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/message.js ***!
  \*************************************************************/
/*! exports provided: messagePrefix, hashMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "messagePrefix", function() { return messagePrefix; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "hashMessage", function() { return hashMessage; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");



const messagePrefix = "\x19Ethereum Signed Message:\n";
function hashMessage(message) {
    if (typeof (message) === "string") {
        message = Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__["toUtf8Bytes"])(message);
    }
    return Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_1__["keccak256"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["concat"])([
        Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__["toUtf8Bytes"])(messagePrefix),
        Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_2__["toUtf8Bytes"])(String(message.length)),
        message
    ]));
}
//# sourceMappingURL=message.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/hash/lib.esm/namehash.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/namehash.js ***!
  \**************************************************************/
/*! exports provided: isValidName, namehash */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidName", function() { return isValidName; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "namehash", function() { return namehash; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/hash/lib.esm/_version.js");





const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__["Logger"](_version__WEBPACK_IMPORTED_MODULE_4__["version"]);
const Zeros = new Uint8Array(32);
Zeros.fill(0);
const Partition = new RegExp("^((.*)\\.)?([^.]+)$");
function isValidName(name) {
    try {
        const comps = name.split(".");
        for (let i = 0; i < comps.length; i++) {
            if (Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__["nameprep"])(comps[i]).length === 0) {
                throw new Error("empty");
            }
        }
        return true;
    }
    catch (error) { }
    return false;
}
function namehash(name) {
    /* istanbul ignore if */
    if (typeof (name) !== "string") {
        logger.throwArgumentError("invalid ENS name; not a string", "name", name);
    }
    let current = name;
    let result = Zeros;
    while (current.length) {
        const partition = current.match(Partition);
        if (partition == null || partition[2] === "") {
            logger.throwArgumentError("invalid ENS address; missing component", "name", name);
        }
        const label = Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__["toUtf8Bytes"])(Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__["nameprep"])(partition[3]));
        result = Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_2__["keccak256"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["concat"])([result, Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_2__["keccak256"])(label)]));
        current = partition[2] || "";
    }
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexlify"])(result);
}
//# sourceMappingURL=namehash.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/hash/lib.esm/typed-data.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/hash/lib.esm/typed-data.js ***!
  \****************************************************************/
/*! exports provided: TypedDataEncoder */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TypedDataEncoder", function() { return TypedDataEncoder; });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/hash/lib.esm/_version.js");
/* harmony import */ var _id__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./id */ "./node_modules/@ethersproject/hash/lib.esm/id.js");
var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__["Logger"](_version__WEBPACK_IMPORTED_MODULE_6__["version"]);

const padding = new Uint8Array(32);
padding.fill(0);
const NegativeOne = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(-1);
const Zero = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(0);
const One = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(1);
const MaxUint256 = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from("0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff");
function hexPadRight(value) {
    const bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(value);
    const padOffset = bytes.length % 32;
    if (padOffset) {
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexConcat"])([bytes, padding.slice(padOffset)]);
    }
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(bytes);
}
const hexTrue = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexZeroPad"])(One.toHexString(), 32);
const hexFalse = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexZeroPad"])(Zero.toHexString(), 32);
const domainFieldTypes = {
    name: "string",
    version: "string",
    chainId: "uint256",
    verifyingContract: "address",
    salt: "bytes32"
};
const domainFieldNames = [
    "name", "version", "chainId", "verifyingContract", "salt"
];
function checkString(key) {
    return function (value) {
        if (typeof (value) !== "string") {
            logger.throwArgumentError(`invalid domain value for ${JSON.stringify(key)}`, `domain.${key}`, value);
        }
        return value;
    };
}
const domainChecks = {
    name: checkString("name"),
    version: checkString("version"),
    chainId: function (value) {
        try {
            return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(value).toString();
        }
        catch (error) { }
        return logger.throwArgumentError(`invalid domain value for "chainId"`, "domain.chainId", value);
    },
    verifyingContract: function (value) {
        try {
            return Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(value).toLowerCase();
        }
        catch (error) { }
        return logger.throwArgumentError(`invalid domain value "verifyingContract"`, "domain.verifyingContract", value);
    },
    salt: function (value) {
        try {
            const bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(value);
            if (bytes.length !== 32) {
                throw new Error("bad length");
            }
            return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(bytes);
        }
        catch (error) { }
        return logger.throwArgumentError(`invalid domain value "salt"`, "domain.salt", value);
    }
};
function getBaseEncoder(type) {
    // intXX and uintXX
    {
        const match = type.match(/^(u?)int(\d*)$/);
        if (match) {
            const signed = (match[1] === "");
            const width = parseInt(match[2] || "256");
            if (width % 8 !== 0 || width > 256 || (match[2] && match[2] !== String(width))) {
                logger.throwArgumentError("invalid numeric width", "type", type);
            }
            const boundsUpper = MaxUint256.mask(signed ? (width - 1) : width);
            const boundsLower = signed ? boundsUpper.add(One).mul(NegativeOne) : Zero;
            return function (value) {
                const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(value);
                if (v.lt(boundsLower) || v.gt(boundsUpper)) {
                    logger.throwArgumentError(`value out-of-bounds for ${type}`, "value", value);
                }
                return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexZeroPad"])(v.toTwos(256).toHexString(), 32);
            };
        }
    }
    // bytesXX
    {
        const match = type.match(/^bytes(\d+)$/);
        if (match) {
            const width = parseInt(match[1]);
            if (width === 0 || width > 32 || match[1] !== String(width)) {
                logger.throwArgumentError("invalid bytes width", "type", type);
            }
            return function (value) {
                const bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(value);
                if (bytes.length !== width) {
                    logger.throwArgumentError(`invalid length for ${type}`, "value", value);
                }
                return hexPadRight(value);
            };
        }
    }
    switch (type) {
        case "address": return function (value) {
            return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexZeroPad"])(Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(value), 32);
        };
        case "bool": return function (value) {
            return ((!value) ? hexFalse : hexTrue);
        };
        case "bytes": return function (value) {
            return Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__["keccak256"])(value);
        };
        case "string": return function (value) {
            return Object(_id__WEBPACK_IMPORTED_MODULE_7__["id"])(value);
        };
    }
    return null;
}
function encodeType(name, fields) {
    return `${name}(${fields.map(({ name, type }) => (type + " " + name)).join(",")})`;
}
class TypedDataEncoder {
    constructor(types) {
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["defineReadOnly"])(this, "types", Object.freeze(Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["deepCopy"])(types)));
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["defineReadOnly"])(this, "_encoderCache", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["defineReadOnly"])(this, "_types", {});
        // Link struct types to their direct child structs
        const links = {};
        // Link structs to structs which contain them as a child
        const parents = {};
        // Link all subtypes within a given struct
        const subtypes = {};
        Object.keys(types).forEach((type) => {
            links[type] = {};
            parents[type] = [];
            subtypes[type] = {};
        });
        for (const name in types) {
            const uniqueNames = {};
            types[name].forEach((field) => {
                // Check each field has a unique name
                if (uniqueNames[field.name]) {
                    logger.throwArgumentError(`duplicate variable name ${JSON.stringify(field.name)} in ${JSON.stringify(name)}`, "types", types);
                }
                uniqueNames[field.name] = true;
                // Get the base type (drop any array specifiers)
                const baseType = field.type.match(/^([^\x5b]*)(\x5b|$)/)[1];
                if (baseType === name) {
                    logger.throwArgumentError(`circular type reference to ${JSON.stringify(baseType)}`, "types", types);
                }
                // Is this a base encoding type?
                const encoder = getBaseEncoder(baseType);
                if (encoder) {
                    return;
                }
                if (!parents[baseType]) {
                    logger.throwArgumentError(`unknown type ${JSON.stringify(baseType)}`, "types", types);
                }
                // Add linkage
                parents[baseType].push(name);
                links[name][baseType] = true;
            });
        }
        // Deduce the primary type
        const primaryTypes = Object.keys(parents).filter((n) => (parents[n].length === 0));
        if (primaryTypes.length === 0) {
            logger.throwArgumentError("missing primary type", "types", types);
        }
        else if (primaryTypes.length > 1) {
            logger.throwArgumentError(`ambiguous primary types or unused types: ${primaryTypes.map((t) => (JSON.stringify(t))).join(", ")}`, "types", types);
        }
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["defineReadOnly"])(this, "primaryType", primaryTypes[0]);
        // Check for circular type references
        function checkCircular(type, found) {
            if (found[type]) {
                logger.throwArgumentError(`circular type reference to ${JSON.stringify(type)}`, "types", types);
            }
            found[type] = true;
            Object.keys(links[type]).forEach((child) => {
                if (!parents[child]) {
                    return;
                }
                // Recursively check children
                checkCircular(child, found);
                // Mark all ancestors as having this decendant
                Object.keys(found).forEach((subtype) => {
                    subtypes[subtype][child] = true;
                });
            });
            delete found[type];
        }
        checkCircular(this.primaryType, {});
        // Compute each fully describe type
        for (const name in subtypes) {
            const st = Object.keys(subtypes[name]);
            st.sort();
            this._types[name] = encodeType(name, types[name]) + st.map((t) => encodeType(t, types[t])).join("");
        }
    }
    getEncoder(type) {
        let encoder = this._encoderCache[type];
        if (!encoder) {
            encoder = this._encoderCache[type] = this._getEncoder(type);
        }
        return encoder;
    }
    _getEncoder(type) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return encoder;
            }
        }
        // Array
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            const subtype = match[1];
            const subEncoder = this.getEncoder(subtype);
            const length = parseInt(match[3]);
            return (value) => {
                if (length >= 0 && value.length !== length) {
                    logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
                }
                let result = value.map(subEncoder);
                if (this._types[subtype]) {
                    result = result.map(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__["keccak256"]);
                }
                return Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__["keccak256"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexConcat"])(result));
            };
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            const encodedType = Object(_id__WEBPACK_IMPORTED_MODULE_7__["id"])(this._types[type]);
            return (value) => {
                const values = fields.map(({ name, type }) => {
                    const result = this.getEncoder(type)(value[name]);
                    if (this._types[type]) {
                        return Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__["keccak256"])(result);
                    }
                    return result;
                });
                values.unshift(encodedType);
                return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexConcat"])(values);
            };
        }
        return logger.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    encodeType(name) {
        const result = this._types[name];
        if (!result) {
            logger.throwArgumentError(`unknown type: ${JSON.stringify(name)}`, "name", name);
        }
        return result;
    }
    encodeData(type, value) {
        return this.getEncoder(type)(value);
    }
    hashStruct(name, value) {
        return Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__["keccak256"])(this.encodeData(name, value));
    }
    encode(value) {
        return this.encodeData(this.primaryType, value);
    }
    hash(value) {
        return this.hashStruct(this.primaryType, value);
    }
    _visit(type, value, callback) {
        // Basic encoder type (address, bool, uint256, etc)
        {
            const encoder = getBaseEncoder(type);
            if (encoder) {
                return callback(type, value);
            }
        }
        // Array
        const match = type.match(/^(.*)(\x5b(\d*)\x5d)$/);
        if (match) {
            const subtype = match[1];
            const length = parseInt(match[3]);
            if (length >= 0 && value.length !== length) {
                logger.throwArgumentError("array length mismatch; expected length ${ arrayLength }", "value", value);
            }
            return value.map((v) => this._visit(subtype, v, callback));
        }
        // Struct
        const fields = this.types[type];
        if (fields) {
            return fields.reduce((accum, { name, type }) => {
                accum[name] = this._visit(type, value[name], callback);
                return accum;
            }, {});
        }
        return logger.throwArgumentError(`unknown type: ${type}`, "type", type);
    }
    visit(value, callback) {
        return this._visit(this.primaryType, value, callback);
    }
    static from(types) {
        return new TypedDataEncoder(types);
    }
    static getPrimaryType(types) {
        return TypedDataEncoder.from(types).primaryType;
    }
    static hashStruct(name, types, value) {
        return TypedDataEncoder.from(types).hashStruct(name, value);
    }
    static hashDomain(domain) {
        const domainFields = [];
        for (const name in domain) {
            const type = domainFieldTypes[name];
            if (!type) {
                logger.throwArgumentError(`invalid typed-data domain key: ${JSON.stringify(name)}`, "domain", domain);
            }
            domainFields.push({ name, type });
        }
        domainFields.sort((a, b) => {
            return domainFieldNames.indexOf(a.name) - domainFieldNames.indexOf(b.name);
        });
        return TypedDataEncoder.hashStruct("EIP712Domain", { EIP712Domain: domainFields }, domain);
    }
    static encode(domain, types, value) {
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexConcat"])([
            "0x1901",
            TypedDataEncoder.hashDomain(domain),
            TypedDataEncoder.from(types).hash(value)
        ]);
    }
    static hash(domain, types, value) {
        return Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__["keccak256"])(TypedDataEncoder.encode(domain, types, value));
    }
    // Replaces all address types with ENS names with their looked up address
    static resolveNames(domain, types, value, resolveName) {
        return __awaiter(this, void 0, void 0, function* () {
            // Make a copy to isolate it from the object passed in
            domain = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["shallowCopy"])(domain);
            // Look up all ENS names
            const ensCache = {};
            // Do we need to look up the domain's verifyingContract?
            if (domain.verifyingContract && !Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(domain.verifyingContract, 20)) {
                ensCache[domain.verifyingContract] = "0x";
            }
            // We are going to use the encoder to visit all the base values
            const encoder = TypedDataEncoder.from(types);
            // Get a list of all the addresses
            encoder.visit(value, (type, value) => {
                if (type === "address" && !Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(value, 20)) {
                    ensCache[value] = "0x";
                }
                return value;
            });
            // Lookup each name
            for (const name in ensCache) {
                ensCache[name] = yield resolveName(name);
            }
            // Replace the domain verifyingContract if needed
            if (domain.verifyingContract && ensCache[domain.verifyingContract]) {
                domain.verifyingContract = ensCache[domain.verifyingContract];
            }
            // Replace all ENS names with their address
            value = encoder.visit(value, (type, value) => {
                if (type === "address" && ensCache[value]) {
                    return ensCache[value];
                }
                return value;
            });
            return { domain, value };
        });
    }
    static getPayload(domain, types, value) {
        // Validate the domain fields
        TypedDataEncoder.hashDomain(domain);
        // Derive the EIP712Domain Struct reference type
        const domainValues = {};
        const domainTypes = [];
        domainFieldNames.forEach((name) => {
            const value = domain[name];
            if (value == null) {
                return;
            }
            domainValues[name] = domainChecks[name](value);
            domainTypes.push({ name, type: domainFieldTypes[name] });
        });
        const encoder = TypedDataEncoder.from(types);
        const typesWithDomain = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["shallowCopy"])(types);
        if (typesWithDomain.EIP712Domain) {
            logger.throwArgumentError("types must not contain EIP712Domain type", "types.EIP712Domain", types);
        }
        else {
            typesWithDomain.EIP712Domain = domainTypes;
        }
        // Validate the data structures and types
        encoder.encode(value);
        return {
            types: typesWithDomain,
            domain: domainValues,
            primaryType: encoder.primaryType,
            message: encoder.visit(value, (type, value) => {
                // bytes
                if (type.match(/^bytes(\d*)/)) {
                    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(value));
                }
                // uint or int
                if (type.match(/^u?int/)) {
                    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(value).toString();
                }
                switch (type) {
                    case "address":
                        return value.toLowerCase();
                    case "bool":
                        return !!value;
                    case "string":
                        if (typeof (value) !== "string") {
                            logger.throwArgumentError(`invalid string`, "value", value);
                        }
                        return value;
                }
                return logger.throwArgumentError("unsupported type", "type", type);
            })
        };
    }
}
//# sourceMappingURL=typed-data.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/hdnode/lib.esm/_version.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/hdnode/lib.esm/_version.js ***!
  \****************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "hdnode/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/hdnode/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/hdnode/lib.esm/index.js ***!
  \*************************************************************/
/*! exports provided: defaultPath, HDNode, mnemonicToSeed, mnemonicToEntropy, entropyToMnemonic, isValidMnemonic, getAccountPath */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defaultPath", function() { return defaultPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HDNode", function() { return HDNode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mnemonicToSeed", function() { return mnemonicToSeed; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "mnemonicToEntropy", function() { return mnemonicToEntropy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entropyToMnemonic", function() { return entropyToMnemonic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isValidMnemonic", function() { return isValidMnemonic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAccountPath", function() { return getAccountPath; });
/* harmony import */ var _ethersproject_basex__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/basex */ "./node_modules/@ethersproject/basex/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");
/* harmony import */ var _ethersproject_pbkdf2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/pbkdf2 */ "./node_modules/@ethersproject/pbkdf2/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/signing-key */ "./node_modules/@ethersproject/signing-key/lib.esm/index.js");
/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/index.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/wordlists */ "./node_modules/@ethersproject/wordlists/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/hdnode/lib.esm/_version.js");













const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_10__["Logger"](_version__WEBPACK_IMPORTED_MODULE_11__["version"]);
const N = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from("0xfffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364141");
// "Bitcoin seed"
const MasterSecret = Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__["toUtf8Bytes"])("Bitcoin seed");
const HardenedBit = 0x80000000;
// Returns a byte with the MSB bits set
function getUpperMask(bits) {
    return ((1 << bits) - 1) << (8 - bits);
}
// Returns a byte with the LSB bits set
function getLowerMask(bits) {
    return (1 << bits) - 1;
}
function bytes32(value) {
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexZeroPad"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(value), 32);
}
function base58check(data) {
    return _ethersproject_basex__WEBPACK_IMPORTED_MODULE_0__["Base58"].encode(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["concat"])([data, Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexDataSlice"])(Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_7__["sha256"])(Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_7__["sha256"])(data)), 0, 4)]));
}
function getWordlist(wordlist) {
    if (wordlist == null) {
        return _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_9__["wordlists"]["en"];
    }
    if (typeof (wordlist) === "string") {
        const words = _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_9__["wordlists"][wordlist];
        if (words == null) {
            logger.throwArgumentError("unknown locale", "wordlist", wordlist);
        }
        return words;
    }
    return wordlist;
}
const _constructorGuard = {};
const defaultPath = "m/44'/60'/0'/0/0";
;
class HDNode {
    /**
     *  This constructor should not be called directly.
     *
     *  Please use:
     *   - fromMnemonic
     *   - fromSeed
     */
    constructor(constructorGuard, privateKey, publicKey, parentFingerprint, chainCode, index, depth, mnemonicOrPath) {
        logger.checkNew(new.target, HDNode);
        /* istanbul ignore if */
        if (constructorGuard !== _constructorGuard) {
            throw new Error("HDNode constructor cannot be called directly");
        }
        if (privateKey) {
            const signingKey = new _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_6__["SigningKey"](privateKey);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "privateKey", signingKey.privateKey);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "publicKey", signingKey.compressedPublicKey);
        }
        else {
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "privateKey", null);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "publicKey", Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(publicKey));
        }
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "parentFingerprint", parentFingerprint);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "fingerprint", Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexDataSlice"])(Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_7__["ripemd160"])(Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_7__["sha256"])(this.publicKey)), 0, 4));
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "address", Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_8__["computeAddress"])(this.publicKey));
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "chainCode", chainCode);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "index", index);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "depth", depth);
        if (mnemonicOrPath == null) {
            // From a source that does not preserve the path (e.g. extended keys)
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "mnemonic", null);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "path", null);
        }
        else if (typeof (mnemonicOrPath) === "string") {
            // From a source that does not preserve the mnemonic (e.g. neutered)
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "mnemonic", null);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "path", mnemonicOrPath);
        }
        else {
            // From a fully qualified source
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "mnemonic", mnemonicOrPath);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["defineReadOnly"])(this, "path", mnemonicOrPath.path);
        }
    }
    get extendedKey() {
        // We only support the mainnet values for now, but if anyone needs
        // testnet values, let me know. I believe current sentiment is that
        // we should always use mainnet, and use BIP-44 to derive the network
        //   - Mainnet: public=0x0488B21E, private=0x0488ADE4
        //   - Testnet: public=0x043587CF, private=0x04358394
        if (this.depth >= 256) {
            throw new Error("Depth too large!");
        }
        return base58check(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["concat"])([
            ((this.privateKey != null) ? "0x0488ADE4" : "0x0488B21E"),
            Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(this.depth),
            this.parentFingerprint,
            Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexZeroPad"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(this.index), 4),
            this.chainCode,
            ((this.privateKey != null) ? Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["concat"])(["0x00", this.privateKey]) : this.publicKey),
        ]));
    }
    neuter() {
        return new HDNode(_constructorGuard, null, this.publicKey, this.parentFingerprint, this.chainCode, this.index, this.depth, this.path);
    }
    _derive(index) {
        if (index > 0xffffffff) {
            throw new Error("invalid index - " + String(index));
        }
        // Base path
        let path = this.path;
        if (path) {
            path += "/" + (index & ~HardenedBit);
        }
        const data = new Uint8Array(37);
        if (index & HardenedBit) {
            if (!this.privateKey) {
                throw new Error("cannot derive child of neutered node");
            }
            // Data = 0x00 || ser_256(k_par)
            data.set(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(this.privateKey), 1);
            // Hardened path
            if (path) {
                path += "'";
            }
        }
        else {
            // Data = ser_p(point(k_par))
            data.set(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(this.publicKey));
        }
        // Data += ser_32(i)
        for (let i = 24; i >= 0; i -= 8) {
            data[33 + (i >> 3)] = ((index >> (24 - i)) & 0xff);
        }
        const I = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_7__["computeHmac"])(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_7__["SupportedAlgorithm"].sha512, this.chainCode, data));
        const IL = I.slice(0, 32);
        const IR = I.slice(32);
        // The private key
        let ki = null;
        // The public key
        let Ki = null;
        if (this.privateKey) {
            ki = bytes32(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(IL).add(this.privateKey).mod(N));
        }
        else {
            const ek = new _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_6__["SigningKey"](Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(IL));
            Ki = ek._addPoint(this.publicKey);
        }
        let mnemonicOrPath = path;
        const srcMnemonic = this.mnemonic;
        if (srcMnemonic) {
            mnemonicOrPath = Object.freeze({
                phrase: srcMnemonic.phrase,
                path: path,
                locale: (srcMnemonic.locale || "en")
            });
        }
        return new HDNode(_constructorGuard, ki, Ki, this.fingerprint, bytes32(IR), index, this.depth + 1, mnemonicOrPath);
    }
    derivePath(path) {
        const components = path.split("/");
        if (components.length === 0 || (components[0] === "m" && this.depth !== 0)) {
            throw new Error("invalid path - " + path);
        }
        if (components[0] === "m") {
            components.shift();
        }
        let result = this;
        for (let i = 0; i < components.length; i++) {
            const component = components[i];
            if (component.match(/^[0-9]+'$/)) {
                const index = parseInt(component.substring(0, component.length - 1));
                if (index >= HardenedBit) {
                    throw new Error("invalid path index - " + component);
                }
                result = result._derive(HardenedBit + index);
            }
            else if (component.match(/^[0-9]+$/)) {
                const index = parseInt(component);
                if (index >= HardenedBit) {
                    throw new Error("invalid path index - " + component);
                }
                result = result._derive(index);
            }
            else {
                throw new Error("invalid path component - " + component);
            }
        }
        return result;
    }
    static _fromSeed(seed, mnemonic) {
        const seedArray = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(seed);
        if (seedArray.length < 16 || seedArray.length > 64) {
            throw new Error("invalid seed");
        }
        const I = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_7__["computeHmac"])(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_7__["SupportedAlgorithm"].sha512, MasterSecret, seedArray));
        return new HDNode(_constructorGuard, bytes32(I.slice(0, 32)), null, "0x00000000", bytes32(I.slice(32)), 0, 0, mnemonic);
    }
    static fromMnemonic(mnemonic, password, wordlist) {
        // If a locale name was passed in, find the associated wordlist
        wordlist = getWordlist(wordlist);
        // Normalize the case and spacing in the mnemonic (throws if the mnemonic is invalid)
        mnemonic = entropyToMnemonic(mnemonicToEntropy(mnemonic, wordlist), wordlist);
        return HDNode._fromSeed(mnemonicToSeed(mnemonic, password), {
            phrase: mnemonic,
            path: "m",
            locale: wordlist.locale
        });
    }
    static fromSeed(seed) {
        return HDNode._fromSeed(seed, null);
    }
    static fromExtendedKey(extendedKey) {
        const bytes = _ethersproject_basex__WEBPACK_IMPORTED_MODULE_0__["Base58"].decode(extendedKey);
        if (bytes.length !== 82 || base58check(bytes.slice(0, 78)) !== extendedKey) {
            logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
        }
        const depth = bytes[4];
        const parentFingerprint = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(bytes.slice(5, 9));
        const index = parseInt(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(bytes.slice(9, 13)).substring(2), 16);
        const chainCode = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(bytes.slice(13, 45));
        const key = bytes.slice(45, 78);
        switch (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(bytes.slice(0, 4))) {
            // Public Key
            case "0x0488b21e":
            case "0x043587cf":
                return new HDNode(_constructorGuard, null, Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(key), parentFingerprint, chainCode, index, depth, null);
            // Private Key
            case "0x0488ade4":
            case "0x04358394 ":
                if (key[0] !== 0) {
                    break;
                }
                return new HDNode(_constructorGuard, Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(key.slice(1)), null, parentFingerprint, chainCode, index, depth, null);
        }
        return logger.throwArgumentError("invalid extended key", "extendedKey", "[REDACTED]");
    }
}
function mnemonicToSeed(mnemonic, password) {
    if (!password) {
        password = "";
    }
    const salt = Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__["toUtf8Bytes"])("mnemonic" + password, _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__["UnicodeNormalizationForm"].NFKD);
    return Object(_ethersproject_pbkdf2__WEBPACK_IMPORTED_MODULE_4__["pbkdf2"])(Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__["toUtf8Bytes"])(mnemonic, _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__["UnicodeNormalizationForm"].NFKD), salt, 2048, 64, "sha512");
}
function mnemonicToEntropy(mnemonic, wordlist) {
    wordlist = getWordlist(wordlist);
    logger.checkNormalize();
    const words = wordlist.split(mnemonic);
    if ((words.length % 3) !== 0) {
        throw new Error("invalid mnemonic");
    }
    const entropy = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(new Uint8Array(Math.ceil(11 * words.length / 8)));
    let offset = 0;
    for (let i = 0; i < words.length; i++) {
        let index = wordlist.getWordIndex(words[i].normalize("NFKD"));
        if (index === -1) {
            throw new Error("invalid mnemonic");
        }
        for (let bit = 0; bit < 11; bit++) {
            if (index & (1 << (10 - bit))) {
                entropy[offset >> 3] |= (1 << (7 - (offset % 8)));
            }
            offset++;
        }
    }
    const entropyBits = 32 * words.length / 3;
    const checksumBits = words.length / 3;
    const checksumMask = getUpperMask(checksumBits);
    const checksum = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_7__["sha256"])(entropy.slice(0, entropyBits / 8)))[0] & checksumMask;
    if (checksum !== (entropy[entropy.length - 1] & checksumMask)) {
        throw new Error("invalid checksum");
    }
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(entropy.slice(0, entropyBits / 8));
}
function entropyToMnemonic(entropy, wordlist) {
    wordlist = getWordlist(wordlist);
    entropy = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(entropy);
    if ((entropy.length % 4) !== 0 || entropy.length < 16 || entropy.length > 32) {
        throw new Error("invalid entropy");
    }
    const indices = [0];
    let remainingBits = 11;
    for (let i = 0; i < entropy.length; i++) {
        // Consume the whole byte (with still more to go)
        if (remainingBits > 8) {
            indices[indices.length - 1] <<= 8;
            indices[indices.length - 1] |= entropy[i];
            remainingBits -= 8;
            // This byte will complete an 11-bit index
        }
        else {
            indices[indices.length - 1] <<= remainingBits;
            indices[indices.length - 1] |= entropy[i] >> (8 - remainingBits);
            // Start the next word
            indices.push(entropy[i] & getLowerMask(8 - remainingBits));
            remainingBits += 3;
        }
    }
    // Compute the checksum bits
    const checksumBits = entropy.length / 4;
    const checksum = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_7__["sha256"])(entropy))[0] & getUpperMask(checksumBits);
    // Shift the checksum into the word indices
    indices[indices.length - 1] <<= checksumBits;
    indices[indices.length - 1] |= (checksum >> (8 - checksumBits));
    return wordlist.join(indices.map((index) => wordlist.getWord(index)));
}
function isValidMnemonic(mnemonic, wordlist) {
    try {
        mnemonicToEntropy(mnemonic, wordlist);
        return true;
    }
    catch (error) { }
    return false;
}
function getAccountPath(index) {
    if (typeof (index) !== "number" || index < 0 || index >= HardenedBit || index % 1) {
        logger.throwArgumentError("invalid account index", "index", index);
    }
    return `m/44'/60'/${index}'/0/0`;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/json-wallets/lib.esm/_version.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/json-wallets/lib.esm/_version.js ***!
  \**********************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "json-wallets/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js ***!
  \***********************************************************************/
/*! exports provided: CrowdsaleAccount, decrypt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CrowdsaleAccount", function() { return CrowdsaleAccount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decrypt", function() { return decrypt; });
/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aes-js */ "./node_modules/aes-js/index.js");
/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(aes_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_pbkdf2__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/pbkdf2 */ "./node_modules/@ethersproject/pbkdf2/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/json-wallets/lib.esm/_version.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./utils */ "./node_modules/@ethersproject/json-wallets/lib.esm/utils.js");










const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_7__["Logger"](_version__WEBPACK_IMPORTED_MODULE_8__["version"]);

class CrowdsaleAccount extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_6__["Description"] {
    isCrowdsaleAccount(value) {
        return !!(value && value._isCrowdsaleAccount);
    }
}
// See: https://github.com/ethereum/pyethsaletool
function decrypt(json, password) {
    const data = JSON.parse(json);
    password = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["getPassword"])(password);
    // Ethereum Address
    const ethaddr = Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_1__["getAddress"])(Object(_utils__WEBPACK_IMPORTED_MODULE_9__["searchPath"])(data, "ethaddr"));
    // Encrypted Seed
    const encseed = Object(_utils__WEBPACK_IMPORTED_MODULE_9__["looseArrayify"])(Object(_utils__WEBPACK_IMPORTED_MODULE_9__["searchPath"])(data, "encseed"));
    if (!encseed || (encseed.length % 16) !== 0) {
        logger.throwArgumentError("invalid encseed", "json", json);
    }
    const key = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(Object(_ethersproject_pbkdf2__WEBPACK_IMPORTED_MODULE_4__["pbkdf2"])(password, password, 2000, 32, "sha256")).slice(0, 16);
    const iv = encseed.slice(0, 16);
    const encryptedSeed = encseed.slice(16);
    // Decrypt the seed
    const aesCbc = new aes_js__WEBPACK_IMPORTED_MODULE_0___default.a.ModeOfOperation.cbc(key, iv);
    const seed = aes_js__WEBPACK_IMPORTED_MODULE_0___default.a.padding.pkcs7.strip(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(aesCbc.decrypt(encryptedSeed)));
    // This wallet format is weird... Convert the binary encoded hex to a string.
    let seedHex = "";
    for (let i = 0; i < seed.length; i++) {
        seedHex += String.fromCharCode(seed[i]);
    }
    const seedHexBytes = Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_5__["toUtf8Bytes"])(seedHex);
    const privateKey = Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_3__["keccak256"])(seedHexBytes);
    return new CrowdsaleAccount({
        _isCrowdsaleAccount: true,
        address: ethaddr,
        privateKey: privateKey
    });
}
//# sourceMappingURL=crowdsale.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/json-wallets/lib.esm/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/json-wallets/lib.esm/index.js ***!
  \*******************************************************************/
/*! exports provided: decryptCrowdsale, decryptKeystore, decryptKeystoreSync, encryptKeystore, isCrowdsaleWallet, isKeystoreWallet, getJsonWalletAddress, decryptJsonWallet, decryptJsonWalletSync */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decryptJsonWallet", function() { return decryptJsonWallet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decryptJsonWalletSync", function() { return decryptJsonWalletSync; });
/* harmony import */ var _crowdsale__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./crowdsale */ "./node_modules/@ethersproject/json-wallets/lib.esm/crowdsale.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decryptCrowdsale", function() { return _crowdsale__WEBPACK_IMPORTED_MODULE_0__["decrypt"]; });

/* harmony import */ var _inspect__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./inspect */ "./node_modules/@ethersproject/json-wallets/lib.esm/inspect.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isCrowdsaleWallet", function() { return _inspect__WEBPACK_IMPORTED_MODULE_1__["isCrowdsaleWallet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isKeystoreWallet", function() { return _inspect__WEBPACK_IMPORTED_MODULE_1__["isKeystoreWallet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getJsonWalletAddress", function() { return _inspect__WEBPACK_IMPORTED_MODULE_1__["getJsonWalletAddress"]; });

/* harmony import */ var _keystore__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./keystore */ "./node_modules/@ethersproject/json-wallets/lib.esm/keystore.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decryptKeystore", function() { return _keystore__WEBPACK_IMPORTED_MODULE_2__["decrypt"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "decryptKeystoreSync", function() { return _keystore__WEBPACK_IMPORTED_MODULE_2__["decryptSync"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "encryptKeystore", function() { return _keystore__WEBPACK_IMPORTED_MODULE_2__["encrypt"]; });





function decryptJsonWallet(json, password, progressCallback) {
    if (Object(_inspect__WEBPACK_IMPORTED_MODULE_1__["isCrowdsaleWallet"])(json)) {
        if (progressCallback) {
            progressCallback(0);
        }
        const account = Object(_crowdsale__WEBPACK_IMPORTED_MODULE_0__["decrypt"])(json, password);
        if (progressCallback) {
            progressCallback(1);
        }
        return Promise.resolve(account);
    }
    if (Object(_inspect__WEBPACK_IMPORTED_MODULE_1__["isKeystoreWallet"])(json)) {
        return Object(_keystore__WEBPACK_IMPORTED_MODULE_2__["decrypt"])(json, password, progressCallback);
    }
    return Promise.reject(new Error("invalid JSON wallet"));
}
function decryptJsonWalletSync(json, password) {
    if (Object(_inspect__WEBPACK_IMPORTED_MODULE_1__["isCrowdsaleWallet"])(json)) {
        return Object(_crowdsale__WEBPACK_IMPORTED_MODULE_0__["decrypt"])(json, password);
    }
    if (Object(_inspect__WEBPACK_IMPORTED_MODULE_1__["isKeystoreWallet"])(json)) {
        return Object(_keystore__WEBPACK_IMPORTED_MODULE_2__["decryptSync"])(json, password);
    }
    throw new Error("invalid JSON wallet");
}

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/json-wallets/lib.esm/inspect.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/json-wallets/lib.esm/inspect.js ***!
  \*********************************************************************/
/*! exports provided: isCrowdsaleWallet, isKeystoreWallet, getJsonWalletAddress */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCrowdsaleWallet", function() { return isCrowdsaleWallet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isKeystoreWallet", function() { return isKeystoreWallet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getJsonWalletAddress", function() { return getJsonWalletAddress; });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");


function isCrowdsaleWallet(json) {
    let data = null;
    try {
        data = JSON.parse(json);
    }
    catch (error) {
        return false;
    }
    return (data.encseed && data.ethaddr);
}
function isKeystoreWallet(json) {
    let data = null;
    try {
        data = JSON.parse(json);
    }
    catch (error) {
        return false;
    }
    if (!data.version || parseInt(data.version) !== data.version || parseInt(data.version) !== 3) {
        return false;
    }
    // @TODO: Put more checks to make sure it has kdf, iv and all that good stuff
    return true;
}
//export function isJsonWallet(json: string): boolean {
//    return (isSecretStorageWallet(json) || isCrowdsaleWallet(json));
//}
function getJsonWalletAddress(json) {
    if (isCrowdsaleWallet(json)) {
        try {
            return Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(JSON.parse(json).ethaddr);
        }
        catch (error) {
            return null;
        }
    }
    if (isKeystoreWallet(json)) {
        try {
            return Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(JSON.parse(json).address);
        }
        catch (error) {
            return null;
        }
    }
    return null;
}
//# sourceMappingURL=inspect.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/json-wallets/lib.esm/keystore.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/json-wallets/lib.esm/keystore.js ***!
  \**********************************************************************/
/*! exports provided: KeystoreAccount, decryptSync, decrypt, encrypt */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeystoreAccount", function() { return KeystoreAccount; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decryptSync", function() { return decryptSync; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decrypt", function() { return decrypt; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encrypt", function() { return encrypt; });
/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! aes-js */ "./node_modules/aes-js/index.js");
/* harmony import */ var aes_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(aes_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var scrypt_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! scrypt-js */ "./node_modules/scrypt-js/scrypt.js");
/* harmony import */ var scrypt_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(scrypt_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/hdnode */ "./node_modules/@ethersproject/hdnode/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_pbkdf2__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/pbkdf2 */ "./node_modules/@ethersproject/pbkdf2/lib.esm/index.js");
/* harmony import */ var _ethersproject_random__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/random */ "./node_modules/@ethersproject/random/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./utils */ "./node_modules/@ethersproject/json-wallets/lib.esm/utils.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/json-wallets/lib.esm/_version.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};













const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_11__["Logger"](_version__WEBPACK_IMPORTED_MODULE_12__["version"]);
// Exported Types
function hasMnemonic(value) {
    return (value != null && value.mnemonic && value.mnemonic.phrase);
}
class KeystoreAccount extends _ethersproject_properties__WEBPACK_IMPORTED_MODULE_8__["Description"] {
    isKeystoreAccount(value) {
        return !!(value && value._isKeystoreAccount);
    }
}
function _decrypt(data, key, ciphertext) {
    const cipher = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/cipher");
    if (cipher === "aes-128-ctr") {
        const iv = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["looseArrayify"])(Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/cipherparams/iv"));
        const counter = new aes_js__WEBPACK_IMPORTED_MODULE_0___default.a.Counter(iv);
        const aesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0___default.a.ModeOfOperation.ctr(key, counter);
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(aesCtr.decrypt(ciphertext));
    }
    return null;
}
function _getAccount(data, key) {
    const ciphertext = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["looseArrayify"])(Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/ciphertext"));
    const computedMAC = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__["keccak256"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["concat"])([key.slice(16, 32), ciphertext]))).substring(2);
    if (computedMAC !== Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/mac").toLowerCase()) {
        throw new Error("invalid password");
    }
    const privateKey = _decrypt(data, key.slice(0, 16), ciphertext);
    if (!privateKey) {
        logger.throwError("unsupported cipher", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_11__["Logger"].errors.UNSUPPORTED_OPERATION, {
            operation: "decrypt"
        });
    }
    const mnemonicKey = key.slice(32, 64);
    const address = Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_9__["computeAddress"])(privateKey);
    if (data.address) {
        let check = data.address.toLowerCase();
        if (check.substring(0, 2) !== "0x") {
            check = "0x" + check;
        }
        if (Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__["getAddress"])(check) !== address) {
            throw new Error("address mismatch");
        }
    }
    const account = {
        _isKeystoreAccount: true,
        address: address,
        privateKey: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(privateKey)
    };
    // Version 0.1 x-ethers metadata must contain an encrypted mnemonic phrase
    if (Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "x-ethers/version") === "0.1") {
        const mnemonicCiphertext = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["looseArrayify"])(Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "x-ethers/mnemonicCiphertext"));
        const mnemonicIv = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["looseArrayify"])(Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "x-ethers/mnemonicCounter"));
        const mnemonicCounter = new aes_js__WEBPACK_IMPORTED_MODULE_0___default.a.Counter(mnemonicIv);
        const mnemonicAesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0___default.a.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
        const path = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "x-ethers/path") || _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_4__["defaultPath"];
        const locale = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "x-ethers/locale") || "en";
        const entropy = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(mnemonicAesCtr.decrypt(mnemonicCiphertext));
        try {
            const mnemonic = Object(_ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_4__["entropyToMnemonic"])(entropy, locale);
            const node = _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_4__["HDNode"].fromMnemonic(mnemonic, null, locale).derivePath(path);
            if (node.privateKey != account.privateKey) {
                throw new Error("mnemonic mismatch");
            }
            account.mnemonic = node.mnemonic;
        }
        catch (error) {
            // If we don't have the locale wordlist installed to
            // read this mnemonic, just bail and don't set the
            // mnemonic
            if (error.code !== _ethersproject_logger__WEBPACK_IMPORTED_MODULE_11__["Logger"].errors.INVALID_ARGUMENT || error.argument !== "wordlist") {
                throw error;
            }
        }
    }
    return new KeystoreAccount(account);
}
function pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc) {
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(Object(_ethersproject_pbkdf2__WEBPACK_IMPORTED_MODULE_6__["pbkdf2"])(passwordBytes, salt, count, dkLen, prfFunc));
}
function pbkdf2(passwordBytes, salt, count, dkLen, prfFunc) {
    return Promise.resolve(pbkdf2Sync(passwordBytes, salt, count, dkLen, prfFunc));
}
function _computeKdfKey(data, password, pbkdf2Func, scryptFunc, progressCallback) {
    const passwordBytes = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["getPassword"])(password);
    const kdf = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/kdf");
    if (kdf && typeof (kdf) === "string") {
        const throwError = function (name, value) {
            return logger.throwArgumentError("invalid key-derivation function parameters", name, value);
        };
        if (kdf.toLowerCase() === "scrypt") {
            const salt = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["looseArrayify"])(Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/kdfparams/salt"));
            const N = parseInt(Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/kdfparams/n"));
            const r = parseInt(Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/kdfparams/r"));
            const p = parseInt(Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/kdfparams/p"));
            // Check for all required parameters
            if (!N || !r || !p) {
                throwError("kdf", kdf);
            }
            // Make sure N is a power of 2
            if ((N & (N - 1)) !== 0) {
                throwError("N", N);
            }
            const dkLen = parseInt(Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/kdfparams/dklen"));
            if (dkLen !== 32) {
                throwError("dklen", dkLen);
            }
            return scryptFunc(passwordBytes, salt, N, r, p, 64, progressCallback);
        }
        else if (kdf.toLowerCase() === "pbkdf2") {
            const salt = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["looseArrayify"])(Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/kdfparams/salt"));
            let prfFunc = null;
            const prf = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/kdfparams/prf");
            if (prf === "hmac-sha256") {
                prfFunc = "sha256";
            }
            else if (prf === "hmac-sha512") {
                prfFunc = "sha512";
            }
            else {
                throwError("prf", prf);
            }
            const count = parseInt(Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/kdfparams/c"));
            const dkLen = parseInt(Object(_utils__WEBPACK_IMPORTED_MODULE_10__["searchPath"])(data, "crypto/kdfparams/dklen"));
            if (dkLen !== 32) {
                throwError("dklen", dkLen);
            }
            return pbkdf2Func(passwordBytes, salt, count, dkLen, prfFunc);
        }
    }
    return logger.throwArgumentError("unsupported key-derivation function", "kdf", kdf);
}
function decryptSync(json, password) {
    const data = JSON.parse(json);
    const key = _computeKdfKey(data, password, pbkdf2Sync, scrypt_js__WEBPACK_IMPORTED_MODULE_1___default.a.syncScrypt);
    return _getAccount(data, key);
}
function decrypt(json, password, progressCallback) {
    return __awaiter(this, void 0, void 0, function* () {
        const data = JSON.parse(json);
        const key = yield _computeKdfKey(data, password, pbkdf2, scrypt_js__WEBPACK_IMPORTED_MODULE_1___default.a.scrypt, progressCallback);
        return _getAccount(data, key);
    });
}
function encrypt(account, password, options, progressCallback) {
    try {
        // Check the address matches the private key
        if (Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_2__["getAddress"])(account.address) !== Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_9__["computeAddress"])(account.privateKey)) {
            throw new Error("address/privateKey mismatch");
        }
        // Check the mnemonic (if any) matches the private key
        if (hasMnemonic(account)) {
            const mnemonic = account.mnemonic;
            const node = _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_4__["HDNode"].fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path || _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_4__["defaultPath"]);
            if (node.privateKey != account.privateKey) {
                throw new Error("mnemonic mismatch");
            }
        }
    }
    catch (e) {
        return Promise.reject(e);
    }
    // The options are optional, so adjust the call as needed
    if (typeof (options) === "function" && !progressCallback) {
        progressCallback = options;
        options = {};
    }
    if (!options) {
        options = {};
    }
    const privateKey = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(account.privateKey);
    const passwordBytes = Object(_utils__WEBPACK_IMPORTED_MODULE_10__["getPassword"])(password);
    let entropy = null;
    let path = null;
    let locale = null;
    if (hasMnemonic(account)) {
        const srcMnemonic = account.mnemonic;
        entropy = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(Object(_ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_4__["mnemonicToEntropy"])(srcMnemonic.phrase, srcMnemonic.locale || "en"));
        path = srcMnemonic.path || _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_4__["defaultPath"];
        locale = srcMnemonic.locale || "en";
    }
    let client = options.client;
    if (!client) {
        client = "ethers.js";
    }
    // Check/generate the salt
    let salt = null;
    if (options.salt) {
        salt = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(options.salt);
    }
    else {
        salt = Object(_ethersproject_random__WEBPACK_IMPORTED_MODULE_7__["randomBytes"])(32);
        ;
    }
    // Override initialization vector
    let iv = null;
    if (options.iv) {
        iv = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(options.iv);
        if (iv.length !== 16) {
            throw new Error("invalid iv");
        }
    }
    else {
        iv = Object(_ethersproject_random__WEBPACK_IMPORTED_MODULE_7__["randomBytes"])(16);
    }
    // Override the uuid
    let uuidRandom = null;
    if (options.uuid) {
        uuidRandom = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(options.uuid);
        if (uuidRandom.length !== 16) {
            throw new Error("invalid uuid");
        }
    }
    else {
        uuidRandom = Object(_ethersproject_random__WEBPACK_IMPORTED_MODULE_7__["randomBytes"])(16);
    }
    // Override the scrypt password-based key derivation function parameters
    let N = (1 << 17), r = 8, p = 1;
    if (options.scrypt) {
        if (options.scrypt.N) {
            N = options.scrypt.N;
        }
        if (options.scrypt.r) {
            r = options.scrypt.r;
        }
        if (options.scrypt.p) {
            p = options.scrypt.p;
        }
    }
    // We take 64 bytes:
    //   - 32 bytes   As normal for the Web3 secret storage (derivedKey, macPrefix)
    //   - 32 bytes   AES key to encrypt mnemonic with (required here to be Ethers Wallet)
    return scrypt_js__WEBPACK_IMPORTED_MODULE_1___default.a.scrypt(passwordBytes, salt, N, r, p, 64, progressCallback).then((key) => {
        key = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(key);
        // This will be used to encrypt the wallet (as per Web3 secret storage)
        const derivedKey = key.slice(0, 16);
        const macPrefix = key.slice(16, 32);
        // This will be used to encrypt the mnemonic phrase (if any)
        const mnemonicKey = key.slice(32, 64);
        // Encrypt the private key
        const counter = new aes_js__WEBPACK_IMPORTED_MODULE_0___default.a.Counter(iv);
        const aesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0___default.a.ModeOfOperation.ctr(derivedKey, counter);
        const ciphertext = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(aesCtr.encrypt(privateKey));
        // Compute the message authentication code, used to check the password
        const mac = Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_5__["keccak256"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["concat"])([macPrefix, ciphertext]));
        // See: https://github.com/ethereum/wiki/wiki/Web3-Secret-Storage-Definition
        const data = {
            address: account.address.substring(2).toLowerCase(),
            id: Object(_utils__WEBPACK_IMPORTED_MODULE_10__["uuidV4"])(uuidRandom),
            version: 3,
            Crypto: {
                cipher: "aes-128-ctr",
                cipherparams: {
                    iv: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(iv).substring(2),
                },
                ciphertext: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(ciphertext).substring(2),
                kdf: "scrypt",
                kdfparams: {
                    salt: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(salt).substring(2),
                    n: N,
                    dklen: 32,
                    p: p,
                    r: r
                },
                mac: mac.substring(2)
            }
        };
        // If we have a mnemonic, encrypt it into the JSON wallet
        if (entropy) {
            const mnemonicIv = Object(_ethersproject_random__WEBPACK_IMPORTED_MODULE_7__["randomBytes"])(16);
            const mnemonicCounter = new aes_js__WEBPACK_IMPORTED_MODULE_0___default.a.Counter(mnemonicIv);
            const mnemonicAesCtr = new aes_js__WEBPACK_IMPORTED_MODULE_0___default.a.ModeOfOperation.ctr(mnemonicKey, mnemonicCounter);
            const mnemonicCiphertext = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(mnemonicAesCtr.encrypt(entropy));
            const now = new Date();
            const timestamp = (now.getUTCFullYear() + "-" +
                Object(_utils__WEBPACK_IMPORTED_MODULE_10__["zpad"])(now.getUTCMonth() + 1, 2) + "-" +
                Object(_utils__WEBPACK_IMPORTED_MODULE_10__["zpad"])(now.getUTCDate(), 2) + "T" +
                Object(_utils__WEBPACK_IMPORTED_MODULE_10__["zpad"])(now.getUTCHours(), 2) + "-" +
                Object(_utils__WEBPACK_IMPORTED_MODULE_10__["zpad"])(now.getUTCMinutes(), 2) + "-" +
                Object(_utils__WEBPACK_IMPORTED_MODULE_10__["zpad"])(now.getUTCSeconds(), 2) + ".0Z");
            data["x-ethers"] = {
                client: client,
                gethFilename: ("UTC--" + timestamp + "--" + data.address),
                mnemonicCounter: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(mnemonicIv).substring(2),
                mnemonicCiphertext: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(mnemonicCiphertext).substring(2),
                path: path,
                locale: locale,
                version: "0.1"
            };
        }
        return JSON.stringify(data);
    });
}
//# sourceMappingURL=keystore.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/json-wallets/lib.esm/utils.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/json-wallets/lib.esm/utils.js ***!
  \*******************************************************************/
/*! exports provided: looseArrayify, zpad, getPassword, searchPath, uuidV4 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "looseArrayify", function() { return looseArrayify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "zpad", function() { return zpad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getPassword", function() { return getPassword; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "searchPath", function() { return searchPath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "uuidV4", function() { return uuidV4; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");



function looseArrayify(hexString) {
    if (typeof (hexString) === 'string' && hexString.substring(0, 2) !== '0x') {
        hexString = '0x' + hexString;
    }
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(hexString);
}
function zpad(value, length) {
    value = String(value);
    while (value.length < length) {
        value = '0' + value;
    }
    return value;
}
function getPassword(password) {
    if (typeof (password) === 'string') {
        return Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__["toUtf8Bytes"])(password, _ethersproject_strings__WEBPACK_IMPORTED_MODULE_1__["UnicodeNormalizationForm"].NFKC);
    }
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(password);
}
function searchPath(object, path) {
    let currentChild = object;
    const comps = path.toLowerCase().split('/');
    for (let i = 0; i < comps.length; i++) {
        // Search for a child object with a case-insensitive matching key
        let matchingChild = null;
        for (const key in currentChild) {
            if (key.toLowerCase() === comps[i]) {
                matchingChild = currentChild[key];
                break;
            }
        }
        // Didn't find one. :'(
        if (matchingChild === null) {
            return null;
        }
        // Now check this child...
        currentChild = matchingChild;
    }
    return currentChild;
}
// See: https://www.ietf.org/rfc/rfc4122.txt (Section 4.4)
function uuidV4(randomBytes) {
    const bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(randomBytes);
    // Section: 4.1.3:
    // - time_hi_and_version[12:16] = 0b0100
    bytes[6] = (bytes[6] & 0x0f) | 0x40;
    // Section 4.4
    // - clock_seq_hi_and_reserved[6] = 0b0
    // - clock_seq_hi_and_reserved[7] = 0b1
    bytes[8] = (bytes[8] & 0x3f) | 0x80;
    const value = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexlify"])(bytes);
    return [
        value.substring(2, 10),
        value.substring(10, 14),
        value.substring(14, 18),
        value.substring(18, 22),
        value.substring(22, 34),
    ].join("-");
}
//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/keccak256/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/keccak256/lib.esm/index.js ***!
  \****************************************************************/
/*! exports provided: keccak256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keccak256", function() { return keccak256; });
/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! js-sha3 */ "./node_modules/js-sha3/src/sha3.js");
/* harmony import */ var js_sha3__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(js_sha3__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");



function keccak256(data) {
    return '0x' + js_sha3__WEBPACK_IMPORTED_MODULE_0___default.a.keccak_256(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(data));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/logger/lib.esm/_version.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/logger/lib.esm/_version.js ***!
  \****************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "logger/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/logger/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/logger/lib.esm/index.js ***!
  \*************************************************************/
/*! exports provided: LogLevel, ErrorCode, Logger */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLevel", function() { return LogLevel; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ErrorCode", function() { return ErrorCode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return Logger; });
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/logger/lib.esm/_version.js");

let _permanentCensorErrors = false;
let _censorErrors = false;
const LogLevels = { debug: 1, "default": 2, info: 2, warning: 3, error: 4, off: 5 };
let _logLevel = LogLevels["default"];

let _globalLogger = null;
function _checkNormalize() {
    try {
        const missing = [];
        // Make sure all forms of normalization are supported
        ["NFD", "NFC", "NFKD", "NFKC"].forEach((form) => {
            try {
                if ("test".normalize(form) !== "test") {
                    throw new Error("bad normalize");
                }
                ;
            }
            catch (error) {
                missing.push(form);
            }
        });
        if (missing.length) {
            throw new Error("missing " + missing.join(", "));
        }
        if (String.fromCharCode(0xe9).normalize("NFD") !== String.fromCharCode(0x65, 0x0301)) {
            throw new Error("broken implementation");
        }
    }
    catch (error) {
        return error.message;
    }
    return null;
}
const _normalizeError = _checkNormalize();
var LogLevel;
(function (LogLevel) {
    LogLevel["DEBUG"] = "DEBUG";
    LogLevel["INFO"] = "INFO";
    LogLevel["WARNING"] = "WARNING";
    LogLevel["ERROR"] = "ERROR";
    LogLevel["OFF"] = "OFF";
})(LogLevel || (LogLevel = {}));
var ErrorCode;
(function (ErrorCode) {
    ///////////////////
    // Generic Errors
    // Unknown Error
    ErrorCode["UNKNOWN_ERROR"] = "UNKNOWN_ERROR";
    // Not Implemented
    ErrorCode["NOT_IMPLEMENTED"] = "NOT_IMPLEMENTED";
    // Unsupported Operation
    //   - operation
    ErrorCode["UNSUPPORTED_OPERATION"] = "UNSUPPORTED_OPERATION";
    // Network Error (i.e. Ethereum Network, such as an invalid chain ID)
    //   - event ("noNetwork" is not re-thrown in provider.ready; otherwise thrown)
    ErrorCode["NETWORK_ERROR"] = "NETWORK_ERROR";
    // Some sort of bad response from the server
    ErrorCode["SERVER_ERROR"] = "SERVER_ERROR";
    // Timeout
    ErrorCode["TIMEOUT"] = "TIMEOUT";
    ///////////////////
    // Operational  Errors
    // Buffer Overrun
    ErrorCode["BUFFER_OVERRUN"] = "BUFFER_OVERRUN";
    // Numeric Fault
    //   - operation: the operation being executed
    //   - fault: the reason this faulted
    ErrorCode["NUMERIC_FAULT"] = "NUMERIC_FAULT";
    ///////////////////
    // Argument Errors
    // Missing new operator to an object
    //  - name: The name of the class
    ErrorCode["MISSING_NEW"] = "MISSING_NEW";
    // Invalid argument (e.g. value is incompatible with type) to a function:
    //   - argument: The argument name that was invalid
    //   - value: The value of the argument
    ErrorCode["INVALID_ARGUMENT"] = "INVALID_ARGUMENT";
    // Missing argument to a function:
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["MISSING_ARGUMENT"] = "MISSING_ARGUMENT";
    // Too many arguments
    //   - count: The number of arguments received
    //   - expectedCount: The number of arguments expected
    ErrorCode["UNEXPECTED_ARGUMENT"] = "UNEXPECTED_ARGUMENT";
    ///////////////////
    // Blockchain Errors
    // Call exception
    //  - transaction: the transaction
    //  - address?: the contract address
    //  - args?: The arguments passed into the function
    //  - method?: The Solidity method signature
    //  - errorSignature?: The EIP848 error signature
    //  - errorArgs?: The EIP848 error parameters
    //  - reason: The reason (only for EIP848 "Error(string)")
    ErrorCode["CALL_EXCEPTION"] = "CALL_EXCEPTION";
    // Insufficient funds (< value + gasLimit * gasPrice)
    //   - transaction: the transaction attempted
    ErrorCode["INSUFFICIENT_FUNDS"] = "INSUFFICIENT_FUNDS";
    // Nonce has already been used
    //   - transaction: the transaction attempted
    ErrorCode["NONCE_EXPIRED"] = "NONCE_EXPIRED";
    // The replacement fee for the transaction is too low
    //   - transaction: the transaction attempted
    ErrorCode["REPLACEMENT_UNDERPRICED"] = "REPLACEMENT_UNDERPRICED";
    // The gas limit could not be estimated
    //   - transaction: the transaction passed to estimateGas
    ErrorCode["UNPREDICTABLE_GAS_LIMIT"] = "UNPREDICTABLE_GAS_LIMIT";
    // The transaction was replaced by one with a higher gas price
    //   - reason: "cancelled", "replaced" or "repriced"
    //   - cancelled: true if reason == "cancelled" or reason == "replaced")
    //   - hash: original transaction hash
    //   - replacement: the full TransactionsResponse for the replacement
    //   - receipt: the receipt of the replacement
    ErrorCode["TRANSACTION_REPLACED"] = "TRANSACTION_REPLACED";
})(ErrorCode || (ErrorCode = {}));
;
const HEX = "0123456789abcdef";
class Logger {
    constructor(version) {
        Object.defineProperty(this, "version", {
            enumerable: true,
            value: version,
            writable: false
        });
    }
    _log(logLevel, args) {
        const level = logLevel.toLowerCase();
        if (LogLevels[level] == null) {
            this.throwArgumentError("invalid log level name", "logLevel", logLevel);
        }
        if (_logLevel > LogLevels[level]) {
            return;
        }
        console.log.apply(console, args);
    }
    debug(...args) {
        this._log(Logger.levels.DEBUG, args);
    }
    info(...args) {
        this._log(Logger.levels.INFO, args);
    }
    warn(...args) {
        this._log(Logger.levels.WARNING, args);
    }
    makeError(message, code, params) {
        // Errors are being censored
        if (_censorErrors) {
            return this.makeError("censored error", code, {});
        }
        if (!code) {
            code = Logger.errors.UNKNOWN_ERROR;
        }
        if (!params) {
            params = {};
        }
        const messageDetails = [];
        Object.keys(params).forEach((key) => {
            const value = params[key];
            try {
                if (value instanceof Uint8Array) {
                    let hex = "";
                    for (let i = 0; i < value.length; i++) {
                        hex += HEX[value[i] >> 4];
                        hex += HEX[value[i] & 0x0f];
                    }
                    messageDetails.push(key + "=Uint8Array(0x" + hex + ")");
                }
                else {
                    messageDetails.push(key + "=" + JSON.stringify(value));
                }
            }
            catch (error) {
                messageDetails.push(key + "=" + JSON.stringify(params[key].toString()));
            }
        });
        messageDetails.push(`code=${code}`);
        messageDetails.push(`version=${this.version}`);
        const reason = message;
        if (messageDetails.length) {
            message += " (" + messageDetails.join(", ") + ")";
        }
        // @TODO: Any??
        const error = new Error(message);
        error.reason = reason;
        error.code = code;
        Object.keys(params).forEach(function (key) {
            error[key] = params[key];
        });
        return error;
    }
    throwError(message, code, params) {
        throw this.makeError(message, code, params);
    }
    throwArgumentError(message, name, value) {
        return this.throwError(message, Logger.errors.INVALID_ARGUMENT, {
            argument: name,
            value: value
        });
    }
    assert(condition, message, code, params) {
        if (!!condition) {
            return;
        }
        this.throwError(message, code, params);
    }
    assertArgument(condition, message, name, value) {
        if (!!condition) {
            return;
        }
        this.throwArgumentError(message, name, value);
    }
    checkNormalize(message) {
        if (message == null) {
            message = "platform missing String.prototype.normalize";
        }
        if (_normalizeError) {
            this.throwError("platform missing String.prototype.normalize", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "String.prototype.normalize", form: _normalizeError
            });
        }
    }
    checkSafeUint53(value, message) {
        if (typeof (value) !== "number") {
            return;
        }
        if (message == null) {
            message = "value not safe";
        }
        if (value < 0 || value >= 0x1fffffffffffff) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "out-of-safe-range",
                value: value
            });
        }
        if (value % 1) {
            this.throwError(message, Logger.errors.NUMERIC_FAULT, {
                operation: "checkSafeInteger",
                fault: "non-integer",
                value: value
            });
        }
    }
    checkArgumentCount(count, expectedCount, message) {
        if (message) {
            message = ": " + message;
        }
        else {
            message = "";
        }
        if (count < expectedCount) {
            this.throwError("missing argument" + message, Logger.errors.MISSING_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
        if (count > expectedCount) {
            this.throwError("too many arguments" + message, Logger.errors.UNEXPECTED_ARGUMENT, {
                count: count,
                expectedCount: expectedCount
            });
        }
    }
    checkNew(target, kind) {
        if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    checkAbstract(target, kind) {
        if (target === kind) {
            this.throwError("cannot instantiate abstract class " + JSON.stringify(kind.name) + " directly; use a sub-class", Logger.errors.UNSUPPORTED_OPERATION, { name: target.name, operation: "new" });
        }
        else if (target === Object || target == null) {
            this.throwError("missing new", Logger.errors.MISSING_NEW, { name: kind.name });
        }
    }
    static globalLogger() {
        if (!_globalLogger) {
            _globalLogger = new Logger(_version__WEBPACK_IMPORTED_MODULE_0__["version"]);
        }
        return _globalLogger;
    }
    static setCensorship(censorship, permanent) {
        if (!censorship && permanent) {
            this.globalLogger().throwError("cannot permanently disable censorship", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        if (_permanentCensorErrors) {
            if (!censorship) {
                return;
            }
            this.globalLogger().throwError("error censorship permanent", Logger.errors.UNSUPPORTED_OPERATION, {
                operation: "setCensorship"
            });
        }
        _censorErrors = !!censorship;
        _permanentCensorErrors = !!permanent;
    }
    static setLogLevel(logLevel) {
        const level = LogLevels[logLevel.toLowerCase()];
        if (level == null) {
            Logger.globalLogger().warn("invalid log level - " + logLevel);
            return;
        }
        _logLevel = level;
    }
    static from(version) {
        return new Logger(version);
    }
}
Logger.errors = ErrorCode;
Logger.levels = LogLevel;
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/networks/lib.esm/_version.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/networks/lib.esm/_version.js ***!
  \******************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "networks/5.5.1";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/networks/lib.esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/networks/lib.esm/index.js ***!
  \***************************************************************/
/*! exports provided: getNetwork */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getNetwork", function() { return getNetwork; });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/networks/lib.esm/_version.js");



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__["Logger"](_version__WEBPACK_IMPORTED_MODULE_1__["version"]);
;
function isRenetworkable(value) {
    return (value && typeof (value.renetwork) === "function");
}
function ethDefaultProvider(network) {
    const func = function (providers, options) {
        if (options == null) {
            options = {};
        }
        const providerList = [];
        if (providers.InfuraProvider) {
            try {
                providerList.push(new providers.InfuraProvider(network, options.infura));
            }
            catch (error) { }
        }
        if (providers.EtherscanProvider) {
            try {
                providerList.push(new providers.EtherscanProvider(network, options.etherscan));
            }
            catch (error) { }
        }
        if (providers.AlchemyProvider) {
            try {
                providerList.push(new providers.AlchemyProvider(network, options.alchemy));
            }
            catch (error) { }
        }
        if (providers.PocketProvider) {
            // These networks are currently faulty on Pocket as their
            // network does not handle the Berlin hardfork, which is
            // live on these ones.
            // @TODO: This goes away once Pocket has upgraded their nodes
            const skip = ["goerli", "ropsten", "rinkeby"];
            try {
                const provider = new providers.PocketProvider(network);
                if (provider.network && skip.indexOf(provider.network.name) === -1) {
                    providerList.push(provider);
                }
            }
            catch (error) { }
        }
        if (providers.CloudflareProvider) {
            try {
                providerList.push(new providers.CloudflareProvider(network));
            }
            catch (error) { }
        }
        if (providerList.length === 0) {
            return null;
        }
        if (providers.FallbackProvider) {
            let quorum = 1;
            if (options.quorum != null) {
                quorum = options.quorum;
            }
            else if (network === "homestead") {
                quorum = 2;
            }
            return new providers.FallbackProvider(providerList, quorum);
        }
        return providerList[0];
    };
    func.renetwork = function (network) {
        return ethDefaultProvider(network);
    };
    return func;
}
function etcDefaultProvider(url, network) {
    const func = function (providers, options) {
        if (providers.JsonRpcProvider) {
            return new providers.JsonRpcProvider(url, network);
        }
        return null;
    };
    func.renetwork = function (network) {
        return etcDefaultProvider(url, network);
    };
    return func;
}
const homestead = {
    chainId: 1,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "homestead",
    _defaultProvider: ethDefaultProvider("homestead")
};
const ropsten = {
    chainId: 3,
    ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
    name: "ropsten",
    _defaultProvider: ethDefaultProvider("ropsten")
};
const classicMordor = {
    chainId: 63,
    name: "classicMordor",
    _defaultProvider: etcDefaultProvider("https://www.ethercluster.com/mordor", "classicMordor")
};
// See: https://chainlist.org
const networks = {
    unspecified: { chainId: 0, name: "unspecified" },
    homestead: homestead,
    mainnet: homestead,
    morden: { chainId: 2, name: "morden" },
    ropsten: ropsten,
    testnet: ropsten,
    rinkeby: {
        chainId: 4,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "rinkeby",
        _defaultProvider: ethDefaultProvider("rinkeby")
    },
    kovan: {
        chainId: 42,
        name: "kovan",
        _defaultProvider: ethDefaultProvider("kovan")
    },
    goerli: {
        chainId: 5,
        ensAddress: "0x00000000000C2E074eC69A0dFb2997BA6C7d2e1e",
        name: "goerli",
        _defaultProvider: ethDefaultProvider("goerli")
    },
    // ETC (See: #351)
    classic: {
        chainId: 61,
        name: "classic",
        _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/etc", "classic")
    },
    classicMorden: { chainId: 62, name: "classicMorden" },
    classicMordor: classicMordor,
    classicTestnet: classicMordor,
    classicKotti: {
        chainId: 6,
        name: "classicKotti",
        _defaultProvider: etcDefaultProvider("https:/\/www.ethercluster.com/kotti", "classicKotti")
    },
    xdai: { chainId: 100, name: "xdai" },
    matic: { chainId: 137, name: "matic" },
    maticmum: { chainId: 80001, name: "maticmum" },
    optimism: { chainId: 10, name: "optimism" },
    "optimism-kovan": { chainId: 69, name: "optimism-kovan" },
    "optimism-goerli": { chainId: 420, name: "optimism-goerli" },
    arbitrum: { chainId: 42161, name: "arbitrum" },
    "arbitrum-rinkeby": { chainId: 421611, name: "arbitrum-rinkeby" },
    bnb: { chainId: 56, name: "bnb" },
    bnbt: { chainId: 97, name: "bnbt" },
};
/**
 *  getNetwork
 *
 *  Converts a named common networks or chain ID (network ID) to a Network
 *  and verifies a network is a valid Network..
 */
function getNetwork(network) {
    // No network (null)
    if (network == null) {
        return null;
    }
    if (typeof (network) === "number") {
        for (const name in networks) {
            const standard = networks[name];
            if (standard.chainId === network) {
                return {
                    name: standard.name,
                    chainId: standard.chainId,
                    ensAddress: (standard.ensAddress || null),
                    _defaultProvider: (standard._defaultProvider || null)
                };
            }
        }
        return {
            chainId: network,
            name: "unknown"
        };
    }
    if (typeof (network) === "string") {
        const standard = networks[network];
        if (standard == null) {
            return null;
        }
        return {
            name: standard.name,
            chainId: standard.chainId,
            ensAddress: standard.ensAddress,
            _defaultProvider: (standard._defaultProvider || null)
        };
    }
    const standard = networks[network.name];
    // Not a standard network; check that it is a valid network in general
    if (!standard) {
        if (typeof (network.chainId) !== "number") {
            logger.throwArgumentError("invalid network chainId", "network", network);
        }
        return network;
    }
    // Make sure the chainId matches the expected network chainId (or is 0; disable EIP-155)
    if (network.chainId !== 0 && network.chainId !== standard.chainId) {
        logger.throwArgumentError("network chainId mismatch", "network", network);
    }
    // @TODO: In the next major version add an attach function to a defaultProvider
    // class and move the _defaultProvider internal to this file (extend Network)
    let defaultProvider = network._defaultProvider || null;
    if (defaultProvider == null && standard._defaultProvider) {
        if (isRenetworkable(standard._defaultProvider)) {
            defaultProvider = standard._defaultProvider.renetwork(network);
        }
        else {
            defaultProvider = standard._defaultProvider;
        }
    }
    // Standard Network (allow overriding the ENS address)
    return {
        name: network.name,
        chainId: standard.chainId,
        ensAddress: (network.ensAddress || standard.ensAddress || null),
        _defaultProvider: defaultProvider
    };
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/pbkdf2/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/pbkdf2/lib.esm/index.js ***!
  \*************************************************************/
/*! exports provided: pbkdf2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _pbkdf2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./pbkdf2 */ "./node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "pbkdf2", function() { return _pbkdf2__WEBPACK_IMPORTED_MODULE_0__["pbkdf2"]; });


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/pbkdf2/lib.esm/pbkdf2.js ***!
  \**************************************************************/
/*! exports provided: pbkdf2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pbkdf2", function() { return pbkdf2; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/index.js");



function pbkdf2(password, salt, iterations, keylen, hashAlgorithm) {
    password = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(password);
    salt = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(salt);
    let hLen;
    let l = 1;
    const DK = new Uint8Array(keylen);
    const block1 = new Uint8Array(salt.length + 4);
    block1.set(salt);
    //salt.copy(block1, 0, 0, salt.length)
    let r;
    let T;
    for (let i = 1; i <= l; i++) {
        //block1.writeUInt32BE(i, salt.length)
        block1[salt.length] = (i >> 24) & 0xff;
        block1[salt.length + 1] = (i >> 16) & 0xff;
        block1[salt.length + 2] = (i >> 8) & 0xff;
        block1[salt.length + 3] = i & 0xff;
        //let U = createHmac(password).update(block1).digest();
        let U = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_1__["computeHmac"])(hashAlgorithm, password, block1));
        if (!hLen) {
            hLen = U.length;
            T = new Uint8Array(hLen);
            l = Math.ceil(keylen / hLen);
            r = keylen - (l - 1) * hLen;
        }
        //U.copy(T, 0, 0, hLen)
        T.set(U);
        for (let j = 1; j < iterations; j++) {
            //U = createHmac(password).update(U).digest();
            U = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_1__["computeHmac"])(hashAlgorithm, password, U));
            for (let k = 0; k < hLen; k++)
                T[k] ^= U[k];
        }
        const destPos = (i - 1) * hLen;
        const len = (i === l ? r : hLen);
        //T.copy(DK, destPos, 0, len)
        DK.set(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(T).slice(0, len), destPos);
    }
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexlify"])(DK);
}
//# sourceMappingURL=pbkdf2.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/properties/lib.esm/_version.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/properties/lib.esm/_version.js ***!
  \********************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "properties/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/properties/lib.esm/index.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/properties/lib.esm/index.js ***!
  \*****************************************************************/
/*! exports provided: defineReadOnly, getStatic, resolveProperties, checkProperties, shallowCopy, deepCopy, Description */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "defineReadOnly", function() { return defineReadOnly; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getStatic", function() { return getStatic; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "resolveProperties", function() { return resolveProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "checkProperties", function() { return checkProperties; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shallowCopy", function() { return shallowCopy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "deepCopy", function() { return deepCopy; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Description", function() { return Description; });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/properties/lib.esm/_version.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};


const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__["Logger"](_version__WEBPACK_IMPORTED_MODULE_1__["version"]);
function defineReadOnly(object, name, value) {
    Object.defineProperty(object, name, {
        enumerable: true,
        value: value,
        writable: false,
    });
}
// Crawl up the constructor chain to find a static method
function getStatic(ctor, key) {
    for (let i = 0; i < 32; i++) {
        if (ctor[key]) {
            return ctor[key];
        }
        if (!ctor.prototype || typeof (ctor.prototype) !== "object") {
            break;
        }
        ctor = Object.getPrototypeOf(ctor.prototype).constructor;
    }
    return null;
}
function resolveProperties(object) {
    return __awaiter(this, void 0, void 0, function* () {
        const promises = Object.keys(object).map((key) => {
            const value = object[key];
            return Promise.resolve(value).then((v) => ({ key: key, value: v }));
        });
        const results = yield Promise.all(promises);
        return results.reduce((accum, result) => {
            accum[(result.key)] = result.value;
            return accum;
        }, {});
    });
}
function checkProperties(object, properties) {
    if (!object || typeof (object) !== "object") {
        logger.throwArgumentError("invalid object", "object", object);
    }
    Object.keys(object).forEach((key) => {
        if (!properties[key]) {
            logger.throwArgumentError("invalid object key - " + key, "transaction:" + key, object);
        }
    });
}
function shallowCopy(object) {
    const result = {};
    for (const key in object) {
        result[key] = object[key];
    }
    return result;
}
const opaque = { bigint: true, boolean: true, "function": true, number: true, string: true };
function _isFrozen(object) {
    // Opaque objects are not mutable, so safe to copy by assignment
    if (object === undefined || object === null || opaque[typeof (object)]) {
        return true;
    }
    if (Array.isArray(object) || typeof (object) === "object") {
        if (!Object.isFrozen(object)) {
            return false;
        }
        const keys = Object.keys(object);
        for (let i = 0; i < keys.length; i++) {
            let value = null;
            try {
                value = object[keys[i]];
            }
            catch (error) {
                // If accessing a value triggers an error, it is a getter
                // designed to do so (e.g. Result) and is therefore "frozen"
                continue;
            }
            if (!_isFrozen(value)) {
                return false;
            }
        }
        return true;
    }
    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
// Returns a new copy of object, such that no properties may be replaced.
// New properties may be added only to objects.
function _deepCopy(object) {
    if (_isFrozen(object)) {
        return object;
    }
    // Arrays are mutable, so we need to create a copy
    if (Array.isArray(object)) {
        return Object.freeze(object.map((item) => deepCopy(item)));
    }
    if (typeof (object) === "object") {
        const result = {};
        for (const key in object) {
            const value = object[key];
            if (value === undefined) {
                continue;
            }
            defineReadOnly(result, key, deepCopy(value));
        }
        return result;
    }
    return logger.throwArgumentError(`Cannot deepCopy ${typeof (object)}`, "object", object);
}
function deepCopy(object) {
    return _deepCopy(object);
}
class Description {
    constructor(info) {
        for (const key in info) {
            this[key] = deepCopy(info[key]);
        }
    }
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/_version.js ***!
  \*******************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "providers/5.5.1";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js ***!
  \***************************************************************************/
/*! exports provided: AlchemyWebSocketProvider, AlchemyProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlchemyWebSocketProvider", function() { return AlchemyWebSocketProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlchemyProvider", function() { return AlchemyProvider; });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");
/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./websocket-provider */ "./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");






const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__["Logger"](_version__WEBPACK_IMPORTED_MODULE_4__["version"]);

// This key was provided to ethers.js by Alchemy to be used by the
// default provider, but it is recommended that for your own
// production environments, that you acquire your own API key at:
//   https://dashboard.alchemyapi.io
const defaultApiKey = "_gg7wSSi0KMBsdKnGVfHDueq6xMB9EkC";
class AlchemyWebSocketProvider extends _websocket_provider__WEBPACK_IMPORTED_MODULE_2__["WebSocketProvider"] {
    constructor(network, apiKey) {
        const provider = new AlchemyProvider(network, apiKey);
        const url = provider.connection.url.replace(/^http/i, "ws")
            .replace(".alchemyapi.", ".ws.alchemyapi.");
        super(url, provider.network);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["defineReadOnly"])(this, "apiKey", provider.apiKey);
    }
    isCommunityResource() {
        return (this.apiKey === defaultApiKey);
    }
}
class AlchemyProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_5__["UrlJsonRpcProvider"] {
    static getWebSocketProvider(network, apiKey) {
        return new AlchemyWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
        if (apiKey == null) {
            return defaultApiKey;
        }
        if (apiKey && typeof (apiKey) !== "string") {
            logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch (network.name) {
            case "homestead":
                host = "eth-mainnet.alchemyapi.io/v2/";
                break;
            case "ropsten":
                host = "eth-ropsten.alchemyapi.io/v2/";
                break;
            case "rinkeby":
                host = "eth-rinkeby.alchemyapi.io/v2/";
                break;
            case "goerli":
                host = "eth-goerli.alchemyapi.io/v2/";
                break;
            case "kovan":
                host = "eth-kovan.alchemyapi.io/v2/";
                break;
            case "matic":
                host = "polygon-mainnet.g.alchemy.com/v2/";
                break;
            case "maticmum":
                host = "polygon-mumbai.g.alchemy.com/v2/";
                break;
            case "arbitrum":
                host = "arb-mainnet.g.alchemy.com/v2/";
                break;
            case "arbitrum-rinkeby":
                host = "arb-rinkeby.g.alchemy.com/v2/";
                break;
            case "optimism":
                host = "opt-mainnet.g.alchemy.com/v2/";
                break;
            case "optimism-kovan":
                host = "opt-kovan.g.alchemy.com/v2/";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return {
            allowGzip: true,
            url: ("https:/" + "/" + host + apiKey),
            throttleCallback: (attempt, url) => {
                if (apiKey === defaultApiKey) {
                    Object(_formatter__WEBPACK_IMPORTED_MODULE_1__["showThrottleMessage"])();
                }
                return Promise.resolve(true);
            }
        };
    }
    isCommunityResource() {
        return (this.apiKey === defaultApiKey);
    }
}
//# sourceMappingURL=alchemy-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/base-provider.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/base-provider.js ***!
  \************************************************************************/
/*! exports provided: Event, Resolver, BaseProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Event", function() { return Event; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Resolver", function() { return Resolver; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BaseProvider", function() { return BaseProvider; });
/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/abstract-provider */ "./node_modules/@ethersproject/abstract-provider/lib.esm/index.js");
/* harmony import */ var _ethersproject_basex__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/basex */ "./node_modules/@ethersproject/basex/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/constants */ "./node_modules/@ethersproject/constants/lib.esm/index.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/index.js");
/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/networks */ "./node_modules/@ethersproject/networks/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");
/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");
/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! bech32 */ "./node_modules/bech32/index.js");
/* harmony import */ var bech32__WEBPACK_IMPORTED_MODULE_11___default = /*#__PURE__*/__webpack_require__.n(bech32__WEBPACK_IMPORTED_MODULE_11__);
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};














const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"](_version__WEBPACK_IMPORTED_MODULE_13__["version"]);

//////////////////////////////
// Event Serializeing
function checkTopic(topic) {
    if (topic == null) {
        return "null";
    }
    if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexDataLength"])(topic) !== 32) {
        logger.throwArgumentError("invalid topic", "topic", topic);
    }
    return topic.toLowerCase();
}
function serializeTopics(topics) {
    // Remove trailing null AND-topics; they are redundant
    topics = topics.slice();
    while (topics.length > 0 && topics[topics.length - 1] == null) {
        topics.pop();
    }
    return topics.map((topic) => {
        if (Array.isArray(topic)) {
            // Only track unique OR-topics
            const unique = {};
            topic.forEach((topic) => {
                unique[checkTopic(topic)] = true;
            });
            // The order of OR-topics does not matter
            const sorted = Object.keys(unique);
            sorted.sort();
            return sorted.join("|");
        }
        else {
            return checkTopic(topic);
        }
    }).join("&");
}
function deserializeTopics(data) {
    if (data === "") {
        return [];
    }
    return data.split(/&/g).map((topic) => {
        if (topic === "") {
            return [];
        }
        const comps = topic.split("|").map((topic) => {
            return ((topic === "null") ? null : topic);
        });
        return ((comps.length === 1) ? comps[0] : comps);
    });
}
function getEventTag(eventName) {
    if (typeof (eventName) === "string") {
        eventName = eventName.toLowerCase();
        if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexDataLength"])(eventName) === 32) {
            return "tx:" + eventName;
        }
        if (eventName.indexOf(":") === -1) {
            return eventName;
        }
    }
    else if (Array.isArray(eventName)) {
        return "filter:*:" + serializeTopics(eventName);
    }
    else if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_0__["ForkEvent"].isForkEvent(eventName)) {
        logger.warn("not implemented");
        throw new Error("not implemented");
    }
    else if (eventName && typeof (eventName) === "object") {
        return "filter:" + (eventName.address || "*") + ":" + serializeTopics(eventName.topics || []);
    }
    throw new Error("invalid event - " + eventName);
}
//////////////////////////////
// Helper Object
function getTime() {
    return (new Date()).getTime();
}
function stall(duration) {
    return new Promise((resolve) => {
        setTimeout(resolve, duration);
    });
}
//////////////////////////////
// Provider Object
/**
 *  EventType
 *   - "block"
 *   - "poll"
 *   - "didPoll"
 *   - "pending"
 *   - "error"
 *   - "network"
 *   - filter
 *   - topics array
 *   - transaction hash
 */
const PollableEvents = ["block", "network", "pending", "poll"];
class Event {
    constructor(tag, listener, once) {
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "tag", tag);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "listener", listener);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "once", once);
    }
    get event() {
        switch (this.type) {
            case "tx":
                return this.hash;
            case "filter":
                return this.filter;
        }
        return this.tag;
    }
    get type() {
        return this.tag.split(":")[0];
    }
    get hash() {
        const comps = this.tag.split(":");
        if (comps[0] !== "tx") {
            return null;
        }
        return comps[1];
    }
    get filter() {
        const comps = this.tag.split(":");
        if (comps[0] !== "filter") {
            return null;
        }
        const address = comps[1];
        const topics = deserializeTopics(comps[2]);
        const filter = {};
        if (topics.length > 0) {
            filter.topics = topics;
        }
        if (address && address !== "*") {
            filter.address = address;
        }
        return filter;
    }
    pollable() {
        return (this.tag.indexOf(":") >= 0 || PollableEvents.indexOf(this.tag) >= 0);
    }
}
;
// https://github.com/satoshilabs/slips/blob/master/slip-0044.md
const coinInfos = {
    "0": { symbol: "btc", p2pkh: 0x00, p2sh: 0x05, prefix: "bc" },
    "2": { symbol: "ltc", p2pkh: 0x30, p2sh: 0x32, prefix: "ltc" },
    "3": { symbol: "doge", p2pkh: 0x1e, p2sh: 0x16 },
    "60": { symbol: "eth", ilk: "eth" },
    "61": { symbol: "etc", ilk: "eth" },
    "700": { symbol: "xdai", ilk: "eth" },
};
function bytes32ify(value) {
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexZeroPad"])(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(value).toHexString(), 32);
}
// Compute the Base58Check encoded data (checksum is first 4 bytes of sha256d)
function base58Encode(data) {
    return _ethersproject_basex__WEBPACK_IMPORTED_MODULE_1__["Base58"].encode(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["concat"])([data, Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexDataSlice"])(Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__["sha256"])(Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_8__["sha256"])(data)), 0, 4)]));
}
const matchers = [
    new RegExp("^(https):/\/(.*)$", "i"),
    new RegExp("^(data):(.*)$", "i"),
    new RegExp("^(ipfs):/\/(.*)$", "i"),
    new RegExp("^eip155:[0-9]+/(erc[0-9]+):(.*)$", "i"),
];
function _parseString(result) {
    try {
        return Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__["toUtf8String"])(_parseBytes(result));
    }
    catch (error) { }
    return null;
}
function _parseBytes(result) {
    if (result === "0x") {
        return null;
    }
    const offset = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexDataSlice"])(result, 0, 32)).toNumber();
    const length = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexDataSlice"])(result, offset, offset + 32)).toNumber();
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexDataSlice"])(result, offset + 32, offset + 32 + length);
}
class Resolver {
    // The resolvedAddress is only for creating a ReverseLookup resolver
    constructor(provider, address, name, resolvedAddress) {
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "provider", provider);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "name", name);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "address", provider.formatter.address(address));
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "_resolvedAddress", resolvedAddress);
    }
    _fetchBytes(selector, parameters) {
        return __awaiter(this, void 0, void 0, function* () {
            // e.g. keccak256("addr(bytes32,uint256)")
            const tx = {
                to: this.address,
                data: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexConcat"])([selector, Object(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_5__["namehash"])(this.name), (parameters || "0x")])
            };
            try {
                return _parseBytes(yield this.provider.call(tx));
            }
            catch (error) {
                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.CALL_EXCEPTION) {
                    return null;
                }
                return null;
            }
        });
    }
    _getAddress(coinType, hexBytes) {
        const coinInfo = coinInfos[String(coinType)];
        if (coinInfo == null) {
            logger.throwError(`unsupported coin type: ${coinType}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: `getAddress(${coinType})`
            });
        }
        if (coinInfo.ilk === "eth") {
            return this.provider.formatter.address(hexBytes);
        }
        const bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(hexBytes);
        // P2PKH: OP_DUP OP_HASH160 <pubKeyHash> OP_EQUALVERIFY OP_CHECKSIG
        if (coinInfo.p2pkh != null) {
            const p2pkh = hexBytes.match(/^0x76a9([0-9a-f][0-9a-f])([0-9a-f]*)88ac$/);
            if (p2pkh) {
                const length = parseInt(p2pkh[1], 16);
                if (p2pkh[2].length === length * 2 && length >= 1 && length <= 75) {
                    return base58Encode(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["concat"])([[coinInfo.p2pkh], ("0x" + p2pkh[2])]));
                }
            }
        }
        // P2SH: OP_HASH160 <scriptHash> OP_EQUAL
        if (coinInfo.p2sh != null) {
            const p2sh = hexBytes.match(/^0xa9([0-9a-f][0-9a-f])([0-9a-f]*)87$/);
            if (p2sh) {
                const length = parseInt(p2sh[1], 16);
                if (p2sh[2].length === length * 2 && length >= 1 && length <= 75) {
                    return base58Encode(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["concat"])([[coinInfo.p2sh], ("0x" + p2sh[2])]));
                }
            }
        }
        // Bech32
        if (coinInfo.prefix != null) {
            const length = bytes[1];
            // https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki#witness-program
            let version = bytes[0];
            if (version === 0x00) {
                if (length !== 20 && length !== 32) {
                    version = -1;
                }
            }
            else {
                version = -1;
            }
            if (version >= 0 && bytes.length === 2 + length && length >= 1 && length <= 75) {
                const words = bech32__WEBPACK_IMPORTED_MODULE_11___default.a.toWords(bytes.slice(2));
                words.unshift(version);
                return bech32__WEBPACK_IMPORTED_MODULE_11___default.a.encode(coinInfo.prefix, words);
            }
        }
        return null;
    }
    getAddress(coinType) {
        return __awaiter(this, void 0, void 0, function* () {
            if (coinType == null) {
                coinType = 60;
            }
            // If Ethereum, use the standard `addr(bytes32)`
            if (coinType === 60) {
                try {
                    // keccak256("addr(bytes32)")
                    const transaction = {
                        to: this.address,
                        data: ("0x3b3b57de" + Object(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_5__["namehash"])(this.name).substring(2))
                    };
                    const hexBytes = yield this.provider.call(transaction);
                    // No address
                    if (hexBytes === "0x" || hexBytes === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_4__["HashZero"]) {
                        return null;
                    }
                    return this.provider.formatter.callAddress(hexBytes);
                }
                catch (error) {
                    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.CALL_EXCEPTION) {
                        return null;
                    }
                    throw error;
                }
            }
            // keccak256("addr(bytes32,uint256")
            const hexBytes = yield this._fetchBytes("0xf1cb7e06", bytes32ify(coinType));
            // No address
            if (hexBytes == null || hexBytes === "0x") {
                return null;
            }
            // Compute the address
            const address = this._getAddress(coinType, hexBytes);
            if (address == null) {
                logger.throwError(`invalid or unsupported coin data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.UNSUPPORTED_OPERATION, {
                    operation: `getAddress(${coinType})`,
                    coinType: coinType,
                    data: hexBytes
                });
            }
            return address;
        });
    }
    getAvatar() {
        return __awaiter(this, void 0, void 0, function* () {
            const linkage = [];
            try {
                // test data for ricmoo.eth
                //const avatar = "eip155:1/erc721:0x265385c7f4132228A0d54EB1A9e7460b91c0cC68/29233";
                const avatar = yield this.getText("avatar");
                if (avatar == null) {
                    return null;
                }
                for (let i = 0; i < matchers.length; i++) {
                    const match = avatar.match(matchers[i]);
                    if (match == null) {
                        continue;
                    }
                    switch (match[1]) {
                        case "https":
                            linkage.push({ type: "url", content: avatar });
                            return { linkage, url: avatar };
                        case "data":
                            linkage.push({ type: "data", content: avatar });
                            return { linkage, url: avatar };
                        case "ipfs":
                            linkage.push({ type: "ipfs", content: avatar });
                            return { linkage, url: `https:/\/gateway.ipfs.io/ipfs/${avatar.substring(7)}` };
                        case "erc721":
                        case "erc1155": {
                            // Depending on the ERC type, use tokenURI(uint256) or url(uint256)
                            const selector = (match[1] === "erc721") ? "0xc87b56dd" : "0x0e89341c";
                            linkage.push({ type: match[1], content: avatar });
                            // The owner of this name
                            const owner = (this._resolvedAddress || (yield this.getAddress()));
                            const comps = (match[2] || "").split("/");
                            if (comps.length !== 2) {
                                return null;
                            }
                            const addr = yield this.provider.formatter.address(comps[0]);
                            const tokenId = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexZeroPad"])(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(comps[1]).toHexString(), 32);
                            // Check that this account owns the token
                            if (match[1] === "erc721") {
                                // ownerOf(uint256 tokenId)
                                const tokenOwner = this.provider.formatter.callAddress(yield this.provider.call({
                                    to: addr, data: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexConcat"])(["0x6352211e", tokenId])
                                }));
                                if (owner !== tokenOwner) {
                                    return null;
                                }
                                linkage.push({ type: "owner", content: tokenOwner });
                            }
                            else if (match[1] === "erc1155") {
                                // balanceOf(address owner, uint256 tokenId)
                                const balance = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(yield this.provider.call({
                                    to: addr, data: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexConcat"])(["0x00fdd58e", Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexZeroPad"])(owner, 32), tokenId])
                                }));
                                if (balance.isZero()) {
                                    return null;
                                }
                                linkage.push({ type: "balance", content: balance.toString() });
                            }
                            // Call the token contract for the metadata URL
                            const tx = {
                                to: this.provider.formatter.address(comps[0]),
                                data: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexConcat"])([selector, tokenId])
                            };
                            let metadataUrl = _parseString(yield this.provider.call(tx));
                            if (metadataUrl == null) {
                                return null;
                            }
                            linkage.push({ type: "metadata-url", content: metadataUrl });
                            // ERC-1155 allows a generic {id} in the URL
                            if (match[1] === "erc1155") {
                                metadataUrl = metadataUrl.replace("{id}", tokenId.substring(2));
                            }
                            // Get the token metadata
                            const metadata = yield Object(_ethersproject_web__WEBPACK_IMPORTED_MODULE_10__["fetchJson"])(metadataUrl);
                            // Pull the image URL out
                            if (!metadata || typeof (metadata.image) !== "string" || !metadata.image.match(/^(https:\/\/|data:)/i)) {
                                return null;
                            }
                            linkage.push({ type: "metadata", content: JSON.stringify(metadata) });
                            linkage.push({ type: "url", content: metadata.image });
                            return { linkage, url: metadata.image };
                        }
                    }
                }
            }
            catch (error) { }
            return null;
        });
    }
    getContentHash() {
        return __awaiter(this, void 0, void 0, function* () {
            // keccak256("contenthash()")
            const hexBytes = yield this._fetchBytes("0xbc1c58d1");
            // No contenthash
            if (hexBytes == null || hexBytes === "0x") {
                return null;
            }
            // IPFS (CID: 1, Type: DAG-PB)
            const ipfs = hexBytes.match(/^0xe3010170(([0-9a-f][0-9a-f])([0-9a-f][0-9a-f])([0-9a-f]*))$/);
            if (ipfs) {
                const length = parseInt(ipfs[3], 16);
                if (ipfs[4].length === length * 2) {
                    return "ipfs:/\/" + _ethersproject_basex__WEBPACK_IMPORTED_MODULE_1__["Base58"].encode("0x" + ipfs[1]);
                }
            }
            // Swarm (CID: 1, Type: swarm-manifest; hash/length hard-coded to keccak256/32)
            const swarm = hexBytes.match(/^0xe40101fa011b20([0-9a-f]*)$/);
            if (swarm) {
                if (swarm[1].length === (32 * 2)) {
                    return "bzz:/\/" + swarm[1];
                }
            }
            return logger.throwError(`invalid or unsupported content hash data`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "getContentHash()",
                data: hexBytes
            });
        });
    }
    getText(key) {
        return __awaiter(this, void 0, void 0, function* () {
            // The key encoded as parameter to fetchBytes
            let keyBytes = Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__["toUtf8Bytes"])(key);
            // The nodehash consumes the first slot, so the string pointer targets
            // offset 64, with the length at offset 64 and data starting at offset 96
            keyBytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["concat"])([bytes32ify(64), bytes32ify(keyBytes.length), keyBytes]);
            // Pad to word-size (32 bytes)
            if ((keyBytes.length % 32) !== 0) {
                keyBytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["concat"])([keyBytes, Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexZeroPad"])("0x", 32 - (key.length % 32))]);
            }
            const hexBytes = yield this._fetchBytes("0x59d1d43c", Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(keyBytes));
            if (hexBytes == null || hexBytes === "0x") {
                return null;
            }
            return Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__["toUtf8String"])(hexBytes);
        });
    }
}
let defaultFormatter = null;
let nextPollId = 1;
class BaseProvider extends _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_0__["Provider"] {
    /**
     *  ready
     *
     *  A Promise<Network> that resolves only once the provider is ready.
     *
     *  Sub-classes that call the super with a network without a chainId
     *  MUST set this. Standard named networks have a known chainId.
     *
     */
    constructor(network) {
        logger.checkNew(new.target, _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_0__["Provider"]);
        super();
        // Events being listened to
        this._events = [];
        this._emitted = { block: -2 };
        this.formatter = new.target.getFormatter();
        // If network is any, this Provider allows the underlying
        // network to change dynamically, and we auto-detect the
        // current network
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "anyNetwork", (network === "any"));
        if (this.anyNetwork) {
            network = this.detectNetwork();
        }
        if (network instanceof Promise) {
            this._networkPromise = network;
            // Squash any "unhandled promise" errors; that do not need to be handled
            network.catch((error) => { });
            // Trigger initial network setting (async)
            this._ready().catch((error) => { });
        }
        else {
            const knownNetwork = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["getStatic"])(new.target, "getNetwork")(network);
            if (knownNetwork) {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "_network", knownNetwork);
                this.emit("network", knownNetwork, null);
            }
            else {
                logger.throwArgumentError("invalid network", "network", network);
            }
        }
        this._maxInternalBlockNumber = -1024;
        this._lastBlockNumber = -2;
        this._pollingInterval = 4000;
        this._fastQueryDate = 0;
    }
    _ready() {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._network == null) {
                let network = null;
                if (this._networkPromise) {
                    try {
                        network = yield this._networkPromise;
                    }
                    catch (error) { }
                }
                // Try the Provider's network detection (this MUST throw if it cannot)
                if (network == null) {
                    network = yield this.detectNetwork();
                }
                // This should never happen; every Provider sub-class should have
                // suggested a network by here (or have thrown).
                if (!network) {
                    logger.throwError("no network detected", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.UNKNOWN_ERROR, {});
                }
                // Possible this call stacked so do not call defineReadOnly again
                if (this._network == null) {
                    if (this.anyNetwork) {
                        this._network = network;
                    }
                    else {
                        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "_network", network);
                    }
                    this.emit("network", network, null);
                }
            }
            return this._network;
        });
    }
    // This will always return the most recently established network.
    // For "any", this can change (a "network" event is emitted before
    // any change is reflected); otherwise this cannot change
    get ready() {
        return Object(_ethersproject_web__WEBPACK_IMPORTED_MODULE_10__["poll"])(() => {
            return this._ready().then((network) => {
                return network;
            }, (error) => {
                // If the network isn't running yet, we will wait
                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.NETWORK_ERROR && error.event === "noNetwork") {
                    return undefined;
                }
                throw error;
            });
        });
    }
    // @TODO: Remove this and just create a singleton formatter
    static getFormatter() {
        if (defaultFormatter == null) {
            defaultFormatter = new _formatter__WEBPACK_IMPORTED_MODULE_14__["Formatter"]();
        }
        return defaultFormatter;
    }
    // @TODO: Remove this and just use getNetwork
    static getNetwork(network) {
        return Object(_ethersproject_networks__WEBPACK_IMPORTED_MODULE_6__["getNetwork"])((network == null) ? "homestead" : network);
    }
    // Fetches the blockNumber, but will reuse any result that is less
    // than maxAge old or has been requested since the last request
    _getInternalBlockNumber(maxAge) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this._ready();
            // Allowing stale data up to maxAge old
            if (maxAge > 0) {
                // While there are pending internal block requests...
                while (this._internalBlockNumber) {
                    // ..."remember" which fetch we started with
                    const internalBlockNumber = this._internalBlockNumber;
                    try {
                        // Check the result is not too stale
                        const result = yield internalBlockNumber;
                        if ((getTime() - result.respTime) <= maxAge) {
                            return result.blockNumber;
                        }
                        // Too old; fetch a new value
                        break;
                    }
                    catch (error) {
                        // The fetch rejected; if we are the first to get the
                        // rejection, drop through so we replace it with a new
                        // fetch; all others blocked will then get that fetch
                        // which won't match the one they "remembered" and loop
                        if (this._internalBlockNumber === internalBlockNumber) {
                            break;
                        }
                    }
                }
            }
            const reqTime = getTime();
            const checkInternalBlockNumber = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["resolveProperties"])({
                blockNumber: this.perform("getBlockNumber", {}),
                networkError: this.getNetwork().then((network) => (null), (error) => (error))
            }).then(({ blockNumber, networkError }) => {
                if (networkError) {
                    // Unremember this bad internal block number
                    if (this._internalBlockNumber === checkInternalBlockNumber) {
                        this._internalBlockNumber = null;
                    }
                    throw networkError;
                }
                const respTime = getTime();
                blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(blockNumber).toNumber();
                if (blockNumber < this._maxInternalBlockNumber) {
                    blockNumber = this._maxInternalBlockNumber;
                }
                this._maxInternalBlockNumber = blockNumber;
                this._setFastBlockNumber(blockNumber); // @TODO: Still need this?
                return { blockNumber, reqTime, respTime };
            });
            this._internalBlockNumber = checkInternalBlockNumber;
            // Swallow unhandled exceptions; if needed they are handled else where
            checkInternalBlockNumber.catch((error) => {
                // Don't null the dead (rejected) fetch, if it has already been updated
                if (this._internalBlockNumber === checkInternalBlockNumber) {
                    this._internalBlockNumber = null;
                }
            });
            return (yield checkInternalBlockNumber).blockNumber;
        });
    }
    poll() {
        return __awaiter(this, void 0, void 0, function* () {
            const pollId = nextPollId++;
            // Track all running promises, so we can trigger a post-poll once they are complete
            const runners = [];
            let blockNumber = null;
            try {
                blockNumber = yield this._getInternalBlockNumber(100 + this.pollingInterval / 2);
            }
            catch (error) {
                this.emit("error", error);
                return;
            }
            this._setFastBlockNumber(blockNumber);
            // Emit a poll event after we have the latest (fast) block number
            this.emit("poll", pollId, blockNumber);
            // If the block has not changed, meh.
            if (blockNumber === this._lastBlockNumber) {
                this.emit("didPoll", pollId);
                return;
            }
            // First polling cycle, trigger a "block" events
            if (this._emitted.block === -2) {
                this._emitted.block = blockNumber - 1;
            }
            if (Math.abs((this._emitted.block) - blockNumber) > 1000) {
                logger.warn(`network block skew detected; skipping block events (emitted=${this._emitted.block} blockNumber${blockNumber})`);
                this.emit("error", logger.makeError("network block skew detected", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.NETWORK_ERROR, {
                    blockNumber: blockNumber,
                    event: "blockSkew",
                    previousBlockNumber: this._emitted.block
                }));
                this.emit("block", blockNumber);
            }
            else {
                // Notify all listener for each block that has passed
                for (let i = this._emitted.block + 1; i <= blockNumber; i++) {
                    this.emit("block", i);
                }
            }
            // The emitted block was updated, check for obsolete events
            if (this._emitted.block !== blockNumber) {
                this._emitted.block = blockNumber;
                Object.keys(this._emitted).forEach((key) => {
                    // The block event does not expire
                    if (key === "block") {
                        return;
                    }
                    // The block we were at when we emitted this event
                    const eventBlockNumber = this._emitted[key];
                    // We cannot garbage collect pending transactions or blocks here
                    // They should be garbage collected by the Provider when setting
                    // "pending" events
                    if (eventBlockNumber === "pending") {
                        return;
                    }
                    // Evict any transaction hashes or block hashes over 12 blocks
                    // old, since they should not return null anyways
                    if (blockNumber - eventBlockNumber > 12) {
                        delete this._emitted[key];
                    }
                });
            }
            // First polling cycle
            if (this._lastBlockNumber === -2) {
                this._lastBlockNumber = blockNumber - 1;
            }
            // Find all transaction hashes we are waiting on
            this._events.forEach((event) => {
                switch (event.type) {
                    case "tx": {
                        const hash = event.hash;
                        let runner = this.getTransactionReceipt(hash).then((receipt) => {
                            if (!receipt || receipt.blockNumber == null) {
                                return null;
                            }
                            this._emitted["t:" + hash] = receipt.blockNumber;
                            this.emit(hash, receipt);
                            return null;
                        }).catch((error) => { this.emit("error", error); });
                        runners.push(runner);
                        break;
                    }
                    case "filter": {
                        const filter = event.filter;
                        filter.fromBlock = this._lastBlockNumber + 1;
                        filter.toBlock = blockNumber;
                        const runner = this.getLogs(filter).then((logs) => {
                            if (logs.length === 0) {
                                return;
                            }
                            logs.forEach((log) => {
                                this._emitted["b:" + log.blockHash] = log.blockNumber;
                                this._emitted["t:" + log.transactionHash] = log.blockNumber;
                                this.emit(filter, log);
                            });
                        }).catch((error) => { this.emit("error", error); });
                        runners.push(runner);
                        break;
                    }
                }
            });
            this._lastBlockNumber = blockNumber;
            // Once all events for this loop have been processed, emit "didPoll"
            Promise.all(runners).then(() => {
                this.emit("didPoll", pollId);
            }).catch((error) => { this.emit("error", error); });
            return;
        });
    }
    // Deprecated; do not use this
    resetEventsBlock(blockNumber) {
        this._lastBlockNumber = blockNumber - 1;
        if (this.polling) {
            this.poll();
        }
    }
    get network() {
        return this._network;
    }
    // This method should query the network if the underlying network
    // can change, such as when connected to a JSON-RPC backend
    detectNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return logger.throwError("provider does not support network detection", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "provider.detectNetwork"
            });
        });
    }
    getNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            const network = yield this._ready();
            // Make sure we are still connected to the same network; this is
            // only an external call for backends which can have the underlying
            // network change spontaneously
            const currentNetwork = yield this.detectNetwork();
            if (network.chainId !== currentNetwork.chainId) {
                // We are allowing network changes, things can get complex fast;
                // make sure you know what you are doing if you use "any"
                if (this.anyNetwork) {
                    this._network = currentNetwork;
                    // Reset all internal block number guards and caches
                    this._lastBlockNumber = -2;
                    this._fastBlockNumber = null;
                    this._fastBlockNumberPromise = null;
                    this._fastQueryDate = 0;
                    this._emitted.block = -2;
                    this._maxInternalBlockNumber = -1024;
                    this._internalBlockNumber = null;
                    // The "network" event MUST happen before this method resolves
                    // so any events have a chance to unregister, so we stall an
                    // additional event loop before returning from /this/ call
                    this.emit("network", currentNetwork, network);
                    yield stall(0);
                    return this._network;
                }
                const error = logger.makeError("underlying network changed", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.NETWORK_ERROR, {
                    event: "changed",
                    network: network,
                    detectedNetwork: currentNetwork
                });
                this.emit("error", error);
                throw error;
            }
            return network;
        });
    }
    get blockNumber() {
        this._getInternalBlockNumber(100 + this.pollingInterval / 2).then((blockNumber) => {
            this._setFastBlockNumber(blockNumber);
        }, (error) => { });
        return (this._fastBlockNumber != null) ? this._fastBlockNumber : -1;
    }
    get polling() {
        return (this._poller != null);
    }
    set polling(value) {
        if (value && !this._poller) {
            this._poller = setInterval(() => { this.poll(); }, this.pollingInterval);
            if (!this._bootstrapPoll) {
                this._bootstrapPoll = setTimeout(() => {
                    this.poll();
                    // We block additional polls until the polling interval
                    // is done, to prevent overwhelming the poll function
                    this._bootstrapPoll = setTimeout(() => {
                        // If polling was disabled, something may require a poke
                        // since starting the bootstrap poll and it was disabled
                        if (!this._poller) {
                            this.poll();
                        }
                        // Clear out the bootstrap so we can do another
                        this._bootstrapPoll = null;
                    }, this.pollingInterval);
                }, 0);
            }
        }
        else if (!value && this._poller) {
            clearInterval(this._poller);
            this._poller = null;
        }
    }
    get pollingInterval() {
        return this._pollingInterval;
    }
    set pollingInterval(value) {
        if (typeof (value) !== "number" || value <= 0 || parseInt(String(value)) != value) {
            throw new Error("invalid polling interval");
        }
        this._pollingInterval = value;
        if (this._poller) {
            clearInterval(this._poller);
            this._poller = setInterval(() => { this.poll(); }, this._pollingInterval);
        }
    }
    _getFastBlockNumber() {
        const now = getTime();
        // Stale block number, request a newer value
        if ((now - this._fastQueryDate) > 2 * this._pollingInterval) {
            this._fastQueryDate = now;
            this._fastBlockNumberPromise = this.getBlockNumber().then((blockNumber) => {
                if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
                    this._fastBlockNumber = blockNumber;
                }
                return this._fastBlockNumber;
            });
        }
        return this._fastBlockNumberPromise;
    }
    _setFastBlockNumber(blockNumber) {
        // Older block, maybe a stale request
        if (this._fastBlockNumber != null && blockNumber < this._fastBlockNumber) {
            return;
        }
        // Update the time we updated the blocknumber
        this._fastQueryDate = getTime();
        // Newer block number, use  it
        if (this._fastBlockNumber == null || blockNumber > this._fastBlockNumber) {
            this._fastBlockNumber = blockNumber;
            this._fastBlockNumberPromise = Promise.resolve(blockNumber);
        }
    }
    waitForTransaction(transactionHash, confirmations, timeout) {
        return __awaiter(this, void 0, void 0, function* () {
            return this._waitForTransaction(transactionHash, (confirmations == null) ? 1 : confirmations, timeout || 0, null);
        });
    }
    _waitForTransaction(transactionHash, confirmations, timeout, replaceable) {
        return __awaiter(this, void 0, void 0, function* () {
            const receipt = yield this.getTransactionReceipt(transactionHash);
            // Receipt is already good
            if ((receipt ? receipt.confirmations : 0) >= confirmations) {
                return receipt;
            }
            // Poll until the receipt is good...
            return new Promise((resolve, reject) => {
                const cancelFuncs = [];
                let done = false;
                const alreadyDone = function () {
                    if (done) {
                        return true;
                    }
                    done = true;
                    cancelFuncs.forEach((func) => { func(); });
                    return false;
                };
                const minedHandler = (receipt) => {
                    if (receipt.confirmations < confirmations) {
                        return;
                    }
                    if (alreadyDone()) {
                        return;
                    }
                    resolve(receipt);
                };
                this.on(transactionHash, minedHandler);
                cancelFuncs.push(() => { this.removeListener(transactionHash, minedHandler); });
                if (replaceable) {
                    let lastBlockNumber = replaceable.startBlock;
                    let scannedBlock = null;
                    const replaceHandler = (blockNumber) => __awaiter(this, void 0, void 0, function* () {
                        if (done) {
                            return;
                        }
                        // Wait 1 second; this is only used in the case of a fault, so
                        // we will trade off a little bit of latency for more consistent
                        // results and fewer JSON-RPC calls
                        yield stall(1000);
                        this.getTransactionCount(replaceable.from).then((nonce) => __awaiter(this, void 0, void 0, function* () {
                            if (done) {
                                return;
                            }
                            if (nonce <= replaceable.nonce) {
                                lastBlockNumber = blockNumber;
                            }
                            else {
                                // First check if the transaction was mined
                                {
                                    const mined = yield this.getTransaction(transactionHash);
                                    if (mined && mined.blockNumber != null) {
                                        return;
                                    }
                                }
                                // First time scanning. We start a little earlier for some
                                // wiggle room here to handle the eventually consistent nature
                                // of blockchain (e.g. the getTransactionCount was for a
                                // different block)
                                if (scannedBlock == null) {
                                    scannedBlock = lastBlockNumber - 3;
                                    if (scannedBlock < replaceable.startBlock) {
                                        scannedBlock = replaceable.startBlock;
                                    }
                                }
                                while (scannedBlock <= blockNumber) {
                                    if (done) {
                                        return;
                                    }
                                    const block = yield this.getBlockWithTransactions(scannedBlock);
                                    for (let ti = 0; ti < block.transactions.length; ti++) {
                                        const tx = block.transactions[ti];
                                        // Successfully mined!
                                        if (tx.hash === transactionHash) {
                                            return;
                                        }
                                        // Matches our transaction from and nonce; its a replacement
                                        if (tx.from === replaceable.from && tx.nonce === replaceable.nonce) {
                                            if (done) {
                                                return;
                                            }
                                            // Get the receipt of the replacement
                                            const receipt = yield this.waitForTransaction(tx.hash, confirmations);
                                            // Already resolved or rejected (prolly a timeout)
                                            if (alreadyDone()) {
                                                return;
                                            }
                                            // The reason we were replaced
                                            let reason = "replaced";
                                            if (tx.data === replaceable.data && tx.to === replaceable.to && tx.value.eq(replaceable.value)) {
                                                reason = "repriced";
                                            }
                                            else if (tx.data === "0x" && tx.from === tx.to && tx.value.isZero()) {
                                                reason = "cancelled";
                                            }
                                            // Explain why we were replaced
                                            reject(logger.makeError("transaction was replaced", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.TRANSACTION_REPLACED, {
                                                cancelled: (reason === "replaced" || reason === "cancelled"),
                                                reason,
                                                replacement: this._wrapTransaction(tx),
                                                hash: transactionHash,
                                                receipt
                                            }));
                                            return;
                                        }
                                    }
                                    scannedBlock++;
                                }
                            }
                            if (done) {
                                return;
                            }
                            this.once("block", replaceHandler);
                        }), (error) => {
                            if (done) {
                                return;
                            }
                            this.once("block", replaceHandler);
                        });
                    });
                    if (done) {
                        return;
                    }
                    this.once("block", replaceHandler);
                    cancelFuncs.push(() => {
                        this.removeListener("block", replaceHandler);
                    });
                }
                if (typeof (timeout) === "number" && timeout > 0) {
                    const timer = setTimeout(() => {
                        if (alreadyDone()) {
                            return;
                        }
                        reject(logger.makeError("timeout exceeded", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.TIMEOUT, { timeout: timeout }));
                    }, timeout);
                    if (timer.unref) {
                        timer.unref();
                    }
                    cancelFuncs.push(() => { clearTimeout(timer); });
                }
            });
        });
    }
    getBlockNumber() {
        return __awaiter(this, void 0, void 0, function* () {
            return this._getInternalBlockNumber(0);
        });
    }
    getGasPrice() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const result = yield this.perform("getGasPrice", {});
            try {
                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(result);
            }
            catch (error) {
                return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.SERVER_ERROR, {
                    method: "getGasPrice",
                    result, error
                });
            }
        });
    }
    getBalance(addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["resolveProperties"])({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("getBalance", params);
            try {
                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(result);
            }
            catch (error) {
                return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.SERVER_ERROR, {
                    method: "getBalance",
                    params, result, error
                });
            }
        });
    }
    getTransactionCount(addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["resolveProperties"])({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("getTransactionCount", params);
            try {
                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(result).toNumber();
            }
            catch (error) {
                return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.SERVER_ERROR, {
                    method: "getTransactionCount",
                    params, result, error
                });
            }
        });
    }
    getCode(addressOrName, blockTag) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["resolveProperties"])({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("getCode", params);
            try {
                return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(result);
            }
            catch (error) {
                return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.SERVER_ERROR, {
                    method: "getCode",
                    params, result, error
                });
            }
        });
    }
    getStorageAt(addressOrName, position, blockTag) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["resolveProperties"])({
                address: this._getAddress(addressOrName),
                blockTag: this._getBlockTag(blockTag),
                position: Promise.resolve(position).then((p) => Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexValue"])(p))
            });
            const result = yield this.perform("getStorageAt", params);
            try {
                return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(result);
            }
            catch (error) {
                return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.SERVER_ERROR, {
                    method: "getStorageAt",
                    params, result, error
                });
            }
        });
    }
    // This should be called by any subclass wrapping a TransactionResponse
    _wrapTransaction(tx, hash, startBlock) {
        if (hash != null && Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexDataLength"])(hash) !== 32) {
            throw new Error("invalid response - sendTransaction");
        }
        const result = tx;
        // Check the hash we expect is the same as the hash the server reported
        if (hash != null && tx.hash !== hash) {
            logger.throwError("Transaction hash mismatch from Provider.sendTransaction.", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.UNKNOWN_ERROR, { expectedHash: tx.hash, returnedHash: hash });
        }
        result.wait = (confirms, timeout) => __awaiter(this, void 0, void 0, function* () {
            if (confirms == null) {
                confirms = 1;
            }
            if (timeout == null) {
                timeout = 0;
            }
            // Get the details to detect replacement
            let replacement = undefined;
            if (confirms !== 0 && startBlock != null) {
                replacement = {
                    data: tx.data,
                    from: tx.from,
                    nonce: tx.nonce,
                    to: tx.to,
                    value: tx.value,
                    startBlock
                };
            }
            const receipt = yield this._waitForTransaction(tx.hash, confirms, timeout, replacement);
            if (receipt == null && confirms === 0) {
                return null;
            }
            // No longer pending, allow the polling loop to garbage collect this
            this._emitted["t:" + tx.hash] = receipt.blockNumber;
            if (receipt.status === 0) {
                logger.throwError("transaction failed", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.CALL_EXCEPTION, {
                    transactionHash: tx.hash,
                    transaction: tx,
                    receipt: receipt
                });
            }
            return receipt;
        });
        return result;
    }
    sendTransaction(signedTransaction) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const hexTx = yield Promise.resolve(signedTransaction).then(t => Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(t));
            const tx = this.formatter.transaction(signedTransaction);
            if (tx.confirmations == null) {
                tx.confirmations = 0;
            }
            const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
            try {
                const hash = yield this.perform("sendTransaction", { signedTransaction: hexTx });
                return this._wrapTransaction(tx, hash, blockNumber);
            }
            catch (error) {
                error.transaction = tx;
                error.transactionHash = tx.hash;
                throw error;
            }
        });
    }
    _getTransactionRequest(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            const values = yield transaction;
            const tx = {};
            ["from", "to"].forEach((key) => {
                if (values[key] == null) {
                    return;
                }
                tx[key] = Promise.resolve(values[key]).then((v) => (v ? this._getAddress(v) : null));
            });
            ["gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "value"].forEach((key) => {
                if (values[key] == null) {
                    return;
                }
                tx[key] = Promise.resolve(values[key]).then((v) => (v ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(v) : null));
            });
            ["type"].forEach((key) => {
                if (values[key] == null) {
                    return;
                }
                tx[key] = Promise.resolve(values[key]).then((v) => ((v != null) ? v : null));
            });
            if (values.accessList) {
                tx.accessList = this.formatter.accessList(values.accessList);
            }
            ["data"].forEach((key) => {
                if (values[key] == null) {
                    return;
                }
                tx[key] = Promise.resolve(values[key]).then((v) => (v ? Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(v) : null));
            });
            return this.formatter.transactionRequest(yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["resolveProperties"])(tx));
        });
    }
    _getFilter(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            filter = yield filter;
            const result = {};
            if (filter.address != null) {
                result.address = this._getAddress(filter.address);
            }
            ["blockHash", "topics"].forEach((key) => {
                if (filter[key] == null) {
                    return;
                }
                result[key] = filter[key];
            });
            ["fromBlock", "toBlock"].forEach((key) => {
                if (filter[key] == null) {
                    return;
                }
                result[key] = this._getBlockTag(filter[key]);
            });
            return this.formatter.filter(yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["resolveProperties"])(result));
        });
    }
    call(transaction, blockTag) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["resolveProperties"])({
                transaction: this._getTransactionRequest(transaction),
                blockTag: this._getBlockTag(blockTag)
            });
            const result = yield this.perform("call", params);
            try {
                return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexlify"])(result);
            }
            catch (error) {
                return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.SERVER_ERROR, {
                    method: "call",
                    params, result, error
                });
            }
        });
    }
    estimateGas(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["resolveProperties"])({
                transaction: this._getTransactionRequest(transaction)
            });
            const result = yield this.perform("estimateGas", params);
            try {
                return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(result);
            }
            catch (error) {
                return logger.throwError("bad result from backend", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.SERVER_ERROR, {
                    method: "estimateGas",
                    params, result, error
                });
            }
        });
    }
    _getAddress(addressOrName) {
        return __awaiter(this, void 0, void 0, function* () {
            addressOrName = yield addressOrName;
            if (typeof (addressOrName) !== "string") {
                logger.throwArgumentError("invalid address or ENS name", "name", addressOrName);
            }
            const address = yield this.resolveName(addressOrName);
            if (address == null) {
                logger.throwError("ENS name not configured", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.UNSUPPORTED_OPERATION, {
                    operation: `resolveName(${JSON.stringify(addressOrName)})`
                });
            }
            return address;
        });
    }
    _getBlock(blockHashOrBlockTag, includeTransactions) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            blockHashOrBlockTag = yield blockHashOrBlockTag;
            // If blockTag is a number (not "latest", etc), this is the block number
            let blockNumber = -128;
            const params = {
                includeTransactions: !!includeTransactions
            };
            if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["isHexString"])(blockHashOrBlockTag, 32)) {
                params.blockHash = blockHashOrBlockTag;
            }
            else {
                try {
                    params.blockTag = yield this._getBlockTag(blockHashOrBlockTag);
                    if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["isHexString"])(params.blockTag)) {
                        blockNumber = parseInt(params.blockTag.substring(2), 16);
                    }
                }
                catch (error) {
                    logger.throwArgumentError("invalid block hash or block tag", "blockHashOrBlockTag", blockHashOrBlockTag);
                }
            }
            return Object(_ethersproject_web__WEBPACK_IMPORTED_MODULE_10__["poll"])(() => __awaiter(this, void 0, void 0, function* () {
                const block = yield this.perform("getBlock", params);
                // Block was not found
                if (block == null) {
                    // For blockhashes, if we didn't say it existed, that blockhash may
                    // not exist. If we did see it though, perhaps from a log, we know
                    // it exists, and this node is just not caught up yet.
                    if (params.blockHash != null) {
                        if (this._emitted["b:" + params.blockHash] == null) {
                            return null;
                        }
                    }
                    // For block tags, if we are asking for a future block, we return null
                    if (params.blockTag != null) {
                        if (blockNumber > this._emitted.block) {
                            return null;
                        }
                    }
                    // Retry on the next block
                    return undefined;
                }
                // Add transactions
                if (includeTransactions) {
                    let blockNumber = null;
                    for (let i = 0; i < block.transactions.length; i++) {
                        const tx = block.transactions[i];
                        if (tx.blockNumber == null) {
                            tx.confirmations = 0;
                        }
                        else if (tx.confirmations == null) {
                            if (blockNumber == null) {
                                blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                            }
                            // Add the confirmations using the fast block number (pessimistic)
                            let confirmations = (blockNumber - tx.blockNumber) + 1;
                            if (confirmations <= 0) {
                                confirmations = 1;
                            }
                            tx.confirmations = confirmations;
                        }
                    }
                    const blockWithTxs = this.formatter.blockWithTransactions(block);
                    blockWithTxs.transactions = blockWithTxs.transactions.map((tx) => this._wrapTransaction(tx));
                    return blockWithTxs;
                }
                return this.formatter.block(block);
            }), { oncePoll: this });
        });
    }
    getBlock(blockHashOrBlockTag) {
        return (this._getBlock(blockHashOrBlockTag, false));
    }
    getBlockWithTransactions(blockHashOrBlockTag) {
        return (this._getBlock(blockHashOrBlockTag, true));
    }
    getTransaction(transactionHash) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            transactionHash = yield transactionHash;
            const params = { transactionHash: this.formatter.hash(transactionHash, true) };
            return Object(_ethersproject_web__WEBPACK_IMPORTED_MODULE_10__["poll"])(() => __awaiter(this, void 0, void 0, function* () {
                const result = yield this.perform("getTransaction", params);
                if (result == null) {
                    if (this._emitted["t:" + transactionHash] == null) {
                        return null;
                    }
                    return undefined;
                }
                const tx = this.formatter.transactionResponse(result);
                if (tx.blockNumber == null) {
                    tx.confirmations = 0;
                }
                else if (tx.confirmations == null) {
                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                    // Add the confirmations using the fast block number (pessimistic)
                    let confirmations = (blockNumber - tx.blockNumber) + 1;
                    if (confirmations <= 0) {
                        confirmations = 1;
                    }
                    tx.confirmations = confirmations;
                }
                return this._wrapTransaction(tx);
            }), { oncePoll: this });
        });
    }
    getTransactionReceipt(transactionHash) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            transactionHash = yield transactionHash;
            const params = { transactionHash: this.formatter.hash(transactionHash, true) };
            return Object(_ethersproject_web__WEBPACK_IMPORTED_MODULE_10__["poll"])(() => __awaiter(this, void 0, void 0, function* () {
                const result = yield this.perform("getTransactionReceipt", params);
                if (result == null) {
                    if (this._emitted["t:" + transactionHash] == null) {
                        return null;
                    }
                    return undefined;
                }
                // "geth-etc" returns receipts before they are ready
                if (result.blockHash == null) {
                    return undefined;
                }
                const receipt = this.formatter.receipt(result);
                if (receipt.blockNumber == null) {
                    receipt.confirmations = 0;
                }
                else if (receipt.confirmations == null) {
                    const blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                    // Add the confirmations using the fast block number (pessimistic)
                    let confirmations = (blockNumber - receipt.blockNumber) + 1;
                    if (confirmations <= 0) {
                        confirmations = 1;
                    }
                    receipt.confirmations = confirmations;
                }
                return receipt;
            }), { oncePoll: this });
        });
    }
    getLogs(filter) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            const params = yield Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["resolveProperties"])({ filter: this._getFilter(filter) });
            const logs = yield this.perform("getLogs", params);
            logs.forEach((log) => {
                if (log.removed == null) {
                    log.removed = false;
                }
            });
            return _formatter__WEBPACK_IMPORTED_MODULE_14__["Formatter"].arrayOf(this.formatter.filterLog.bind(this.formatter))(logs);
        });
    }
    getEtherPrice() {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.getNetwork();
            return this.perform("getEtherPrice", {});
        });
    }
    _getBlockTag(blockTag) {
        return __awaiter(this, void 0, void 0, function* () {
            blockTag = yield blockTag;
            if (typeof (blockTag) === "number" && blockTag < 0) {
                if (blockTag % 1) {
                    logger.throwArgumentError("invalid BlockTag", "blockTag", blockTag);
                }
                let blockNumber = yield this._getInternalBlockNumber(100 + 2 * this.pollingInterval);
                blockNumber += blockTag;
                if (blockNumber < 0) {
                    blockNumber = 0;
                }
                return this.formatter.blockTag(blockNumber);
            }
            return this.formatter.blockTag(blockTag);
        });
    }
    getResolver(name) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const address = yield this._getResolver(name);
                if (address == null) {
                    return null;
                }
                return new Resolver(this, address, name);
            }
            catch (error) {
                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.CALL_EXCEPTION) {
                    return null;
                }
                return null;
            }
        });
    }
    _getResolver(name) {
        return __awaiter(this, void 0, void 0, function* () {
            // Get the resolver from the blockchain
            const network = yield this.getNetwork();
            // No ENS...
            if (!network.ensAddress) {
                logger.throwError("network does not support ENS", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.UNSUPPORTED_OPERATION, { operation: "ENS", network: network.name });
            }
            // keccak256("resolver(bytes32)")
            const transaction = {
                to: network.ensAddress,
                data: ("0x0178b8bf" + Object(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_5__["namehash"])(name).substring(2))
            };
            try {
                return this.formatter.callAddress(yield this.call(transaction));
            }
            catch (error) {
                if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.CALL_EXCEPTION) {
                    return null;
                }
                throw error;
            }
        });
    }
    resolveName(name) {
        return __awaiter(this, void 0, void 0, function* () {
            name = yield name;
            // If it is already an address, nothing to resolve
            try {
                return Promise.resolve(this.formatter.address(name));
            }
            catch (error) {
                // If is is a hexstring, the address is bad (See #694)
                if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["isHexString"])(name)) {
                    throw error;
                }
            }
            if (typeof (name) !== "string") {
                logger.throwArgumentError("invalid ENS name", "name", name);
            }
            // Get the addr from the resovler
            const resolver = yield this.getResolver(name);
            if (!resolver) {
                return null;
            }
            return yield resolver.getAddress();
        });
    }
    lookupAddress(address) {
        return __awaiter(this, void 0, void 0, function* () {
            address = yield address;
            address = this.formatter.address(address);
            const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
            const resolverAddress = yield this._getResolver(reverseName);
            if (!resolverAddress) {
                return null;
            }
            // keccak("name(bytes32)")
            let bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(yield this.call({
                to: resolverAddress,
                data: ("0x691f3431" + Object(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_5__["namehash"])(reverseName).substring(2))
            }));
            // Strip off the dynamic string pointer (0x20)
            if (bytes.length < 32 || !_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(bytes.slice(0, 32)).eq(32)) {
                return null;
            }
            bytes = bytes.slice(32);
            // Not a length-prefixed string
            if (bytes.length < 32) {
                return null;
            }
            // Get the length of the string (from the length-prefix)
            const length = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_2__["BigNumber"].from(bytes.slice(0, 32)).toNumber();
            bytes = bytes.slice(32);
            // Length longer than available data
            if (length > bytes.length) {
                return null;
            }
            const name = Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_9__["toUtf8String"])(bytes.slice(0, length));
            // Make sure the reverse record matches the foward record
            const addr = yield this.resolveName(name);
            if (addr != address) {
                return null;
            }
            return name;
        });
    }
    getAvatar(nameOrAddress) {
        return __awaiter(this, void 0, void 0, function* () {
            let resolver = null;
            if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["isHexString"])(nameOrAddress)) {
                // Address; reverse lookup
                const address = this.formatter.address(nameOrAddress);
                const reverseName = address.substring(2).toLowerCase() + ".addr.reverse";
                const resolverAddress = yield this._getResolver(reverseName);
                if (!resolverAddress) {
                    return null;
                }
                resolver = new Resolver(this, resolverAddress, "_", address);
            }
            else {
                // ENS name; forward lookup
                resolver = yield this.getResolver(nameOrAddress);
                if (!resolver) {
                    return null;
                }
            }
            const avatar = yield resolver.getAvatar();
            if (avatar == null) {
                return null;
            }
            return avatar.url;
        });
    }
    perform(method, params) {
        return logger.throwError(method + " not implemented", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.NOT_IMPLEMENTED, { operation: method });
    }
    _startEvent(event) {
        this.polling = (this._events.filter((e) => e.pollable()).length > 0);
    }
    _stopEvent(event) {
        this.polling = (this._events.filter((e) => e.pollable()).length > 0);
    }
    _addEventListener(eventName, listener, once) {
        const event = new Event(getEventTag(eventName), listener, once);
        this._events.push(event);
        this._startEvent(event);
        return this;
    }
    on(eventName, listener) {
        return this._addEventListener(eventName, listener, false);
    }
    once(eventName, listener) {
        return this._addEventListener(eventName, listener, true);
    }
    emit(eventName, ...args) {
        let result = false;
        let stopped = [];
        let eventTag = getEventTag(eventName);
        this._events = this._events.filter((event) => {
            if (event.tag !== eventTag) {
                return true;
            }
            setTimeout(() => {
                event.listener.apply(this, args);
            }, 0);
            result = true;
            if (event.once) {
                stopped.push(event);
                return false;
            }
            return true;
        });
        stopped.forEach((event) => { this._stopEvent(event); });
        return result;
    }
    listenerCount(eventName) {
        if (!eventName) {
            return this._events.length;
        }
        let eventTag = getEventTag(eventName);
        return this._events.filter((event) => {
            return (event.tag === eventTag);
        }).length;
    }
    listeners(eventName) {
        if (eventName == null) {
            return this._events.map((event) => event.listener);
        }
        let eventTag = getEventTag(eventName);
        return this._events
            .filter((event) => (event.tag === eventTag))
            .map((event) => event.listener);
    }
    off(eventName, listener) {
        if (listener == null) {
            return this.removeAllListeners(eventName);
        }
        const stopped = [];
        let found = false;
        let eventTag = getEventTag(eventName);
        this._events = this._events.filter((event) => {
            if (event.tag !== eventTag || event.listener != listener) {
                return true;
            }
            if (found) {
                return true;
            }
            found = true;
            stopped.push(event);
            return false;
        });
        stopped.forEach((event) => { this._stopEvent(event); });
        return this;
    }
    removeAllListeners(eventName) {
        let stopped = [];
        if (eventName == null) {
            stopped = this._events;
            this._events = [];
        }
        else {
            const eventTag = getEventTag(eventName);
            this._events = this._events.filter((event) => {
                if (event.tag !== eventTag) {
                    return true;
                }
                stopped.push(event);
                return false;
            });
        }
        stopped.forEach((event) => { this._stopEvent(event); });
        return this;
    }
}
//# sourceMappingURL=base-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js":
/*!******************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js ***!
  \******************************************************************************/
/*! exports provided: CloudflareProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CloudflareProvider", function() { return CloudflareProvider; });
/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"](_version__WEBPACK_IMPORTED_MODULE_2__["version"]);
class CloudflareProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_0__["UrlJsonRpcProvider"] {
    static getApiKey(apiKey) {
        if (apiKey != null) {
            logger.throwArgumentError("apiKey not supported for cloudflare", "apiKey", apiKey);
        }
        return null;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch (network.name) {
            case "homestead":
                host = "https://cloudflare-eth.com/";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return host;
    }
    perform(method, params) {
        const _super = Object.create(null, {
            perform: { get: () => super.perform }
        });
        return __awaiter(this, void 0, void 0, function* () {
            // The Cloudflare provider does not support eth_blockNumber,
            // so we get the latest block and pull it from that
            if (method === "getBlockNumber") {
                const block = yield _super.perform.call(this, "getBlock", { blockTag: "latest" });
                return block.number;
            }
            return _super.perform.call(this, method, params);
        });
    }
}
//# sourceMappingURL=cloudflare-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js ***!
  \*****************************************************************************/
/*! exports provided: EtherscanProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EtherscanProvider", function() { return EtherscanProvider; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./base-provider */ "./node_modules/@ethersproject/providers/lib.esm/base-provider.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};







const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__["Logger"](_version__WEBPACK_IMPORTED_MODULE_6__["version"]);

// The transaction has already been sanitized by the calls in Provider
function getTransactionPostData(transaction) {
    const result = {};
    for (let key in transaction) {
        if (transaction[key] == null) {
            continue;
        }
        let value = transaction[key];
        if (key === "type" && value === 0) {
            continue;
        }
        // Quantity-types require no leading zero, unless 0
        if ({ type: true, gasLimit: true, gasPrice: true, maxFeePerGs: true, maxPriorityFeePerGas: true, nonce: true, value: true }[key]) {
            value = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexValue"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexlify"])(value));
        }
        else if (key === "accessList") {
            value = "[" + Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_2__["accessListify"])(value).map((set) => {
                return `{address:"${set.address}",storageKeys:["${set.storageKeys.join('","')}"]}`;
            }).join(",") + "]";
        }
        else {
            value = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexlify"])(value);
        }
        result[key] = value;
    }
    return result;
}
function getResult(result) {
    // getLogs, getHistory have weird success responses
    if (result.status == 0 && (result.message === "No records found" || result.message === "No transactions found")) {
        return result.result;
    }
    if (result.status != 1 || result.message != "OK") {
        const error = new Error("invalid response");
        error.result = JSON.stringify(result);
        if ((result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
            error.throttleRetry = true;
        }
        throw error;
    }
    return result.result;
}
function getJsonResult(result) {
    // This response indicates we are being throttled
    if (result && result.status == 0 && result.message == "NOTOK" && (result.result || "").toLowerCase().indexOf("rate limit") >= 0) {
        const error = new Error("throttled response");
        error.result = JSON.stringify(result);
        error.throttleRetry = true;
        throw error;
    }
    if (result.jsonrpc != "2.0") {
        // @TODO: not any
        const error = new Error("invalid response");
        error.result = JSON.stringify(result);
        throw error;
    }
    if (result.error) {
        // @TODO: not any
        const error = new Error(result.error.message || "unknown error");
        if (result.error.code) {
            error.code = result.error.code;
        }
        if (result.error.data) {
            error.data = result.error.data;
        }
        throw error;
    }
    return result.result;
}
// The blockTag was normalized as a string by the Provider pre-perform operations
function checkLogTag(blockTag) {
    if (blockTag === "pending") {
        throw new Error("pending not supported");
    }
    if (blockTag === "latest") {
        return blockTag;
    }
    return parseInt(blockTag.substring(2), 16);
}
const defaultApiKey = "9D13ZE7XSBTJ94N9BNJ2MA33VMAY2YPIRB";
function checkError(method, error, transaction) {
    // Undo the "convenience" some nodes are attempting to prevent backwards
    // incompatibility; maybe for v6 consider forwarding reverts as errors
    if (method === "call" && error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].errors.SERVER_ERROR) {
        const e = error.error;
        // Etherscan keeps changing their string
        if (e && (e.message.match(/reverted/i) || e.message.match(/VM execution error/i))) {
            // Etherscan prefixes the data like "Reverted 0x1234"
            let data = e.data;
            if (data) {
                data = "0x" + data.replace(/^.*0x/i, "");
            }
            if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["isHexString"])(data)) {
                return data;
            }
            logger.throwError("missing revert data in call exception", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].errors.CALL_EXCEPTION, {
                error, data: "0x"
            });
        }
    }
    // Get the message from any nested error structure
    let message = error.message;
    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].errors.SERVER_ERROR) {
        if (error.error && typeof (error.error.message) === "string") {
            message = error.error.message;
        }
        else if (typeof (error.body) === "string") {
            message = error.body;
        }
        else if (typeof (error.responseText) === "string") {
            message = error.responseText;
        }
    }
    message = (message || "").toLowerCase();
    // "Insufficient funds. The account you tried to send transaction from does not have enough funds. Required 21464000000000 and got: 0"
    if (message.match(/insufficient funds/)) {
        logger.throwError("insufficient funds for intrinsic transaction cost", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].errors.INSUFFICIENT_FUNDS, {
            error, method, transaction
        });
    }
    // "Transaction with the same hash was already imported."
    if (message.match(/same hash was already imported|transaction nonce is too low|nonce too low/)) {
        logger.throwError("nonce has already been used", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].errors.NONCE_EXPIRED, {
            error, method, transaction
        });
    }
    // "Transaction gas price is too low. There is another transaction with same nonce in the queue. Try increasing the gas price or incrementing the nonce."
    if (message.match(/another transaction with same nonce/)) {
        logger.throwError("replacement fee too low", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].errors.REPLACEMENT_UNDERPRICED, {
            error, method, transaction
        });
    }
    if (message.match(/execution failed due to an exception|execution reverted/)) {
        logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].errors.UNPREDICTABLE_GAS_LIMIT, {
            error, method, transaction
        });
    }
    throw error;
}
class EtherscanProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_7__["BaseProvider"] {
    constructor(network, apiKey) {
        logger.checkNew(new.target, EtherscanProvider);
        super(network);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "baseUrl", this.getBaseUrl());
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "apiKey", apiKey || defaultApiKey);
    }
    getBaseUrl() {
        switch (this.network ? this.network.name : "invalid") {
            case "homestead":
                return "https:/\/api.etherscan.io";
            case "ropsten":
                return "https:/\/api-ropsten.etherscan.io";
            case "rinkeby":
                return "https:/\/api-rinkeby.etherscan.io";
            case "kovan":
                return "https:/\/api-kovan.etherscan.io";
            case "goerli":
                return "https:/\/api-goerli.etherscan.io";
            default:
        }
        return logger.throwArgumentError("unsupported network", "network", name);
    }
    getUrl(module, params) {
        const query = Object.keys(params).reduce((accum, key) => {
            const value = params[key];
            if (value != null) {
                accum += `&${key}=${value}`;
            }
            return accum;
        }, "");
        const apiKey = ((this.apiKey) ? `&apikey=${this.apiKey}` : "");
        return `${this.baseUrl}/api?module=${module}${query}${apiKey}`;
    }
    getPostUrl() {
        return `${this.baseUrl}/api`;
    }
    getPostData(module, params) {
        params.module = module;
        params.apikey = this.apiKey;
        return params;
    }
    fetch(module, params, post) {
        return __awaiter(this, void 0, void 0, function* () {
            const url = (post ? this.getPostUrl() : this.getUrl(module, params));
            const payload = (post ? this.getPostData(module, params) : null);
            const procFunc = (module === "proxy") ? getJsonResult : getResult;
            this.emit("debug", {
                action: "request",
                request: url,
                provider: this
            });
            const connection = {
                url: url,
                throttleSlotInterval: 1000,
                throttleCallback: (attempt, url) => {
                    if (this.isCommunityResource()) {
                        Object(_formatter__WEBPACK_IMPORTED_MODULE_4__["showThrottleMessage"])();
                    }
                    return Promise.resolve(true);
                }
            };
            let payloadStr = null;
            if (payload) {
                connection.headers = { "content-type": "application/x-www-form-urlencoded; charset=UTF-8" };
                payloadStr = Object.keys(payload).map((key) => {
                    return `${key}=${payload[key]}`;
                }).join("&");
            }
            const result = yield Object(_ethersproject_web__WEBPACK_IMPORTED_MODULE_3__["fetchJson"])(connection, payloadStr, procFunc || getJsonResult);
            this.emit("debug", {
                action: "response",
                request: url,
                response: Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["deepCopy"])(result),
                provider: this
            });
            return result;
        });
    }
    detectNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            return this.network;
        });
    }
    perform(method, params) {
        const _super = Object.create(null, {
            perform: { get: () => super.perform }
        });
        return __awaiter(this, void 0, void 0, function* () {
            switch (method) {
                case "getBlockNumber":
                    return this.fetch("proxy", { action: "eth_blockNumber" });
                case "getGasPrice":
                    return this.fetch("proxy", { action: "eth_gasPrice" });
                case "getBalance":
                    // Returns base-10 result
                    return this.fetch("account", {
                        action: "balance",
                        address: params.address,
                        tag: params.blockTag
                    });
                case "getTransactionCount":
                    return this.fetch("proxy", {
                        action: "eth_getTransactionCount",
                        address: params.address,
                        tag: params.blockTag
                    });
                case "getCode":
                    return this.fetch("proxy", {
                        action: "eth_getCode",
                        address: params.address,
                        tag: params.blockTag
                    });
                case "getStorageAt":
                    return this.fetch("proxy", {
                        action: "eth_getStorageAt",
                        address: params.address,
                        position: params.position,
                        tag: params.blockTag
                    });
                case "sendTransaction":
                    return this.fetch("proxy", {
                        action: "eth_sendRawTransaction",
                        hex: params.signedTransaction
                    }, true).catch((error) => {
                        return checkError("sendTransaction", error, params.signedTransaction);
                    });
                case "getBlock":
                    if (params.blockTag) {
                        return this.fetch("proxy", {
                            action: "eth_getBlockByNumber",
                            tag: params.blockTag,
                            boolean: (params.includeTransactions ? "true" : "false")
                        });
                    }
                    throw new Error("getBlock by blockHash not implemented");
                case "getTransaction":
                    return this.fetch("proxy", {
                        action: "eth_getTransactionByHash",
                        txhash: params.transactionHash
                    });
                case "getTransactionReceipt":
                    return this.fetch("proxy", {
                        action: "eth_getTransactionReceipt",
                        txhash: params.transactionHash
                    });
                case "call": {
                    if (params.blockTag !== "latest") {
                        throw new Error("EtherscanProvider does not support blockTag for call");
                    }
                    const postData = getTransactionPostData(params.transaction);
                    postData.module = "proxy";
                    postData.action = "eth_call";
                    try {
                        return yield this.fetch("proxy", postData, true);
                    }
                    catch (error) {
                        return checkError("call", error, params.transaction);
                    }
                }
                case "estimateGas": {
                    const postData = getTransactionPostData(params.transaction);
                    postData.module = "proxy";
                    postData.action = "eth_estimateGas";
                    try {
                        return yield this.fetch("proxy", postData, true);
                    }
                    catch (error) {
                        return checkError("estimateGas", error, params.transaction);
                    }
                }
                case "getLogs": {
                    const args = { action: "getLogs" };
                    if (params.filter.fromBlock) {
                        args.fromBlock = checkLogTag(params.filter.fromBlock);
                    }
                    if (params.filter.toBlock) {
                        args.toBlock = checkLogTag(params.filter.toBlock);
                    }
                    if (params.filter.address) {
                        args.address = params.filter.address;
                    }
                    // @TODO: We can handle slightly more complicated logs using the logs API
                    if (params.filter.topics && params.filter.topics.length > 0) {
                        if (params.filter.topics.length > 1) {
                            logger.throwError("unsupported topic count", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].errors.UNSUPPORTED_OPERATION, { topics: params.filter.topics });
                        }
                        if (params.filter.topics.length === 1) {
                            const topic0 = params.filter.topics[0];
                            if (typeof (topic0) !== "string" || topic0.length !== 66) {
                                logger.throwError("unsupported topic format", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__["Logger"].errors.UNSUPPORTED_OPERATION, { topic0: topic0 });
                            }
                            args.topic0 = topic0;
                        }
                    }
                    const logs = yield this.fetch("logs", args);
                    // Cache txHash => blockHash
                    let blocks = {};
                    // Add any missing blockHash to the logs
                    for (let i = 0; i < logs.length; i++) {
                        const log = logs[i];
                        if (log.blockHash != null) {
                            continue;
                        }
                        if (blocks[log.blockNumber] == null) {
                            const block = yield this.getBlock(log.blockNumber);
                            if (block) {
                                blocks[log.blockNumber] = block.hash;
                            }
                        }
                        log.blockHash = blocks[log.blockNumber];
                    }
                    return logs;
                }
                case "getEtherPrice":
                    if (this.network.name !== "homestead") {
                        return 0.0;
                    }
                    return parseFloat((yield this.fetch("stats", { action: "ethprice" })).ethusd);
                default:
                    break;
            }
            return _super.perform.call(this, method, params);
        });
    }
    // Note: The `page` page parameter only allows pagination within the
    //       10,000 window available without a page and offset parameter
    //       Error: Result window is too large, PageNo x Offset size must
    //              be less than or equal to 10000
    getHistory(addressOrName, startBlock, endBlock) {
        return __awaiter(this, void 0, void 0, function* () {
            const params = {
                action: "txlist",
                address: (yield this.resolveName(addressOrName)),
                startblock: ((startBlock == null) ? 0 : startBlock),
                endblock: ((endBlock == null) ? 99999999 : endBlock),
                sort: "asc"
            };
            const result = yield this.fetch("account", params);
            return result.map((tx) => {
                ["contractAddress", "to"].forEach(function (key) {
                    if (tx[key] == "") {
                        delete tx[key];
                    }
                });
                if (tx.creates == null && tx.contractAddress != null) {
                    tx.creates = tx.contractAddress;
                }
                const item = this.formatter.transactionResponse(tx);
                if (tx.timeStamp) {
                    item.timestamp = parseInt(tx.timeStamp);
                }
                return item;
            });
        });
    }
    isCommunityResource() {
        return (this.apiKey === defaultApiKey);
    }
}
//# sourceMappingURL=etherscan-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/fallback-provider.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/fallback-provider.js ***!
  \****************************************************************************/
/*! exports provided: FallbackProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FallbackProvider", function() { return FallbackProvider; });
/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/abstract-provider */ "./node_modules/@ethersproject/abstract-provider/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_random__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/random */ "./node_modules/@ethersproject/random/lib.esm/index.js");
/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");
/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./base-provider */ "./node_modules/@ethersproject/providers/lib.esm/base-provider.js");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};










const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"](_version__WEBPACK_IMPORTED_MODULE_9__["version"]);
function now() { return (new Date()).getTime(); }
// Returns to network as long as all agree, or null if any is null.
// Throws an error if any two networks do not match.
function checkNetworks(networks) {
    let result = null;
    for (let i = 0; i < networks.length; i++) {
        const network = networks[i];
        // Null! We do not know our network; bail.
        if (network == null) {
            return null;
        }
        if (result) {
            // Make sure the network matches the previous networks
            if (!(result.name === network.name && result.chainId === network.chainId &&
                ((result.ensAddress === network.ensAddress) || (result.ensAddress == null && network.ensAddress == null)))) {
                logger.throwArgumentError("provider mismatch", "networks", networks);
            }
        }
        else {
            result = network;
        }
    }
    return result;
}
function median(values, maxDelta) {
    values = values.slice().sort();
    const middle = Math.floor(values.length / 2);
    // Odd length; take the middle
    if (values.length % 2) {
        return values[middle];
    }
    // Even length; take the average of the two middle
    const a = values[middle - 1], b = values[middle];
    if (maxDelta != null && Math.abs(a - b) > maxDelta) {
        return null;
    }
    return (a + b) / 2;
}
function serialize(value) {
    if (value === null) {
        return "null";
    }
    else if (typeof (value) === "number" || typeof (value) === "boolean") {
        return JSON.stringify(value);
    }
    else if (typeof (value) === "string") {
        return value;
    }
    else if (_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].isBigNumber(value)) {
        return value.toString();
    }
    else if (Array.isArray(value)) {
        return JSON.stringify(value.map((i) => serialize(i)));
    }
    else if (typeof (value) === "object") {
        const keys = Object.keys(value);
        keys.sort();
        return "{" + keys.map((key) => {
            let v = value[key];
            if (typeof (v) === "function") {
                v = "[function]";
            }
            else {
                v = serialize(v);
            }
            return JSON.stringify(key) + ":" + v;
        }).join(",") + "}";
    }
    throw new Error("unknown value type: " + typeof (value));
}
// Next request ID to use for emitting debug info
let nextRid = 1;
;
function stall(duration) {
    let cancel = null;
    let timer = null;
    let promise = (new Promise((resolve) => {
        cancel = function () {
            if (timer) {
                clearTimeout(timer);
                timer = null;
            }
            resolve();
        };
        timer = setTimeout(cancel, duration);
    }));
    const wait = (func) => {
        promise = promise.then(func);
        return promise;
    };
    function getPromise() {
        return promise;
    }
    return { cancel, getPromise, wait };
}
const ForwardErrors = [
    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.CALL_EXCEPTION,
    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.INSUFFICIENT_FUNDS,
    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.NONCE_EXPIRED,
    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.REPLACEMENT_UNDERPRICED,
    _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNPREDICTABLE_GAS_LIMIT
];
const ForwardProperties = [
    "address",
    "args",
    "errorArgs",
    "errorSignature",
    "method",
    "transaction",
];
;
function exposeDebugConfig(config, now) {
    const result = {
        weight: config.weight
    };
    Object.defineProperty(result, "provider", { get: () => config.provider });
    if (config.start) {
        result.start = config.start;
    }
    if (now) {
        result.duration = (now - config.start);
    }
    if (config.done) {
        if (config.error) {
            result.error = config.error;
        }
        else {
            result.result = config.result || null;
        }
    }
    return result;
}
function normalizedTally(normalize, quorum) {
    return function (configs) {
        // Count the votes for each result
        const tally = {};
        configs.forEach((c) => {
            const value = normalize(c.result);
            if (!tally[value]) {
                tally[value] = { count: 0, result: c.result };
            }
            tally[value].count++;
        });
        // Check for a quorum on any given result
        const keys = Object.keys(tally);
        for (let i = 0; i < keys.length; i++) {
            const check = tally[keys[i]];
            if (check.count >= quorum) {
                return check.result;
            }
        }
        // No quroum
        return undefined;
    };
}
function getProcessFunc(provider, method, params) {
    let normalize = serialize;
    switch (method) {
        case "getBlockNumber":
            // Return the median value, unless there is (median + 1) is also
            // present, in which case that is probably true and the median
            // is going to be stale soon. In the event of a malicious node,
            // the lie will be true soon enough.
            return function (configs) {
                const values = configs.map((c) => c.result);
                // Get the median block number
                let blockNumber = median(configs.map((c) => c.result), 2);
                if (blockNumber == null) {
                    return undefined;
                }
                blockNumber = Math.ceil(blockNumber);
                // If the next block height is present, its prolly safe to use
                if (values.indexOf(blockNumber + 1) >= 0) {
                    blockNumber++;
                }
                // Don't ever roll back the blockNumber
                if (blockNumber >= provider._highestBlockNumber) {
                    provider._highestBlockNumber = blockNumber;
                }
                return provider._highestBlockNumber;
            };
        case "getGasPrice":
            // Return the middle (round index up) value, similar to median
            // but do not average even entries and choose the higher.
            // Malicious actors must compromise 50% of the nodes to lie.
            return function (configs) {
                const values = configs.map((c) => c.result);
                values.sort();
                return values[Math.floor(values.length / 2)];
            };
        case "getEtherPrice":
            // Returns the median price. Malicious actors must compromise at
            // least 50% of the nodes to lie (in a meaningful way).
            return function (configs) {
                return median(configs.map((c) => c.result));
            };
        // No additional normalizing required; serialize is enough
        case "getBalance":
        case "getTransactionCount":
        case "getCode":
        case "getStorageAt":
        case "call":
        case "estimateGas":
        case "getLogs":
            break;
        // We drop the confirmations from transactions as it is approximate
        case "getTransaction":
        case "getTransactionReceipt":
            normalize = function (tx) {
                if (tx == null) {
                    return null;
                }
                tx = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__["shallowCopy"])(tx);
                tx.confirmations = -1;
                return serialize(tx);
            };
            break;
        // We drop the confirmations from transactions as it is approximate
        case "getBlock":
            // We drop the confirmations from transactions as it is approximate
            if (params.includeTransactions) {
                normalize = function (block) {
                    if (block == null) {
                        return null;
                    }
                    block = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__["shallowCopy"])(block);
                    block.transactions = block.transactions.map((tx) => {
                        tx = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__["shallowCopy"])(tx);
                        tx.confirmations = -1;
                        return tx;
                    });
                    return serialize(block);
                };
            }
            else {
                normalize = function (block) {
                    if (block == null) {
                        return null;
                    }
                    return serialize(block);
                };
            }
            break;
        default:
            throw new Error("unknown method: " + method);
    }
    // Return the result if and only if the expected quorum is
    // satisfied and agreed upon for the final result.
    return normalizedTally(normalize, provider.quorum);
}
// If we are doing a blockTag query, we need to make sure the backend is
// caught up to the FallbackProvider, before sending a request to it.
function waitForSync(config, blockNumber) {
    return __awaiter(this, void 0, void 0, function* () {
        const provider = (config.provider);
        if ((provider.blockNumber != null && provider.blockNumber >= blockNumber) || blockNumber === -1) {
            return provider;
        }
        return Object(_ethersproject_web__WEBPACK_IMPORTED_MODULE_5__["poll"])(() => {
            return new Promise((resolve, reject) => {
                setTimeout(function () {
                    // We are synced
                    if (provider.blockNumber >= blockNumber) {
                        return resolve(provider);
                    }
                    // We're done; just quit
                    if (config.cancelled) {
                        return resolve(null);
                    }
                    // Try again, next block
                    return resolve(undefined);
                }, 0);
            });
        }, { oncePoll: provider });
    });
}
function getRunner(config, currentBlockNumber, method, params) {
    return __awaiter(this, void 0, void 0, function* () {
        let provider = config.provider;
        switch (method) {
            case "getBlockNumber":
            case "getGasPrice":
                return provider[method]();
            case "getEtherPrice":
                if (provider.getEtherPrice) {
                    return provider.getEtherPrice();
                }
                break;
            case "getBalance":
            case "getTransactionCount":
            case "getCode":
                if (params.blockTag && Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(params.blockTag)) {
                    provider = yield waitForSync(config, currentBlockNumber);
                }
                return provider[method](params.address, params.blockTag || "latest");
            case "getStorageAt":
                if (params.blockTag && Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(params.blockTag)) {
                    provider = yield waitForSync(config, currentBlockNumber);
                }
                return provider.getStorageAt(params.address, params.position, params.blockTag || "latest");
            case "getBlock":
                if (params.blockTag && Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(params.blockTag)) {
                    provider = yield waitForSync(config, currentBlockNumber);
                }
                return provider[(params.includeTransactions ? "getBlockWithTransactions" : "getBlock")](params.blockTag || params.blockHash);
            case "call":
            case "estimateGas":
                if (params.blockTag && Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(params.blockTag)) {
                    provider = yield waitForSync(config, currentBlockNumber);
                }
                return provider[method](params.transaction);
            case "getTransaction":
            case "getTransactionReceipt":
                return provider[method](params.transactionHash);
            case "getLogs": {
                let filter = params.filter;
                if ((filter.fromBlock && Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(filter.fromBlock)) || (filter.toBlock && Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(filter.toBlock))) {
                    provider = yield waitForSync(config, currentBlockNumber);
                }
                return provider.getLogs(filter);
            }
        }
        return logger.throwError("unknown method error", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNKNOWN_ERROR, {
            method: method,
            params: params
        });
    });
}
class FallbackProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_6__["BaseProvider"] {
    constructor(providers, quorum) {
        logger.checkNew(new.target, FallbackProvider);
        if (providers.length === 0) {
            logger.throwArgumentError("missing providers", "providers", providers);
        }
        const providerConfigs = providers.map((configOrProvider, index) => {
            if (_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_0__["Provider"].isProvider(configOrProvider)) {
                const stallTimeout = Object(_formatter__WEBPACK_IMPORTED_MODULE_7__["isCommunityResource"])(configOrProvider) ? 2000 : 750;
                const priority = 1;
                return Object.freeze({ provider: configOrProvider, weight: 1, stallTimeout, priority });
            }
            const config = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__["shallowCopy"])(configOrProvider);
            if (config.priority == null) {
                config.priority = 1;
            }
            if (config.stallTimeout == null) {
                config.stallTimeout = Object(_formatter__WEBPACK_IMPORTED_MODULE_7__["isCommunityResource"])(configOrProvider) ? 2000 : 750;
            }
            if (config.weight == null) {
                config.weight = 1;
            }
            const weight = config.weight;
            if (weight % 1 || weight > 512 || weight < 1) {
                logger.throwArgumentError("invalid weight; must be integer in [1, 512]", `providers[${index}].weight`, weight);
            }
            return Object.freeze(config);
        });
        const total = providerConfigs.reduce((accum, c) => (accum + c.weight), 0);
        if (quorum == null) {
            quorum = total / 2;
        }
        else if (quorum > total) {
            logger.throwArgumentError("quorum will always fail; larger than total weight", "quorum", quorum);
        }
        // Are all providers' networks are known
        let networkOrReady = checkNetworks(providerConfigs.map((c) => (c.provider).network));
        // Not all networks are known; we must stall
        if (networkOrReady == null) {
            networkOrReady = new Promise((resolve, reject) => {
                setTimeout(() => {
                    this.detectNetwork().then(resolve, reject);
                }, 0);
            });
        }
        super(networkOrReady);
        // Preserve a copy, so we do not get mutated
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__["defineReadOnly"])(this, "providerConfigs", Object.freeze(providerConfigs));
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__["defineReadOnly"])(this, "quorum", quorum);
        this._highestBlockNumber = -1;
    }
    detectNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            const networks = yield Promise.all(this.providerConfigs.map((c) => c.provider.getNetwork()));
            return checkNetworks(networks);
        });
    }
    perform(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            // Sending transactions is special; always broadcast it to all backends
            if (method === "sendTransaction") {
                const results = yield Promise.all(this.providerConfigs.map((c) => {
                    return c.provider.sendTransaction(params.signedTransaction).then((result) => {
                        return result.hash;
                    }, (error) => {
                        return error;
                    });
                }));
                // Any success is good enough (other errors are likely "already seen" errors
                for (let i = 0; i < results.length; i++) {
                    const result = results[i];
                    if (typeof (result) === "string") {
                        return result;
                    }
                }
                // They were all an error; pick the first error
                throw results[0];
            }
            // We need to make sure we are in sync with our backends, so we need
            // to know this before we can make a lot of calls
            if (this._highestBlockNumber === -1 && method !== "getBlockNumber") {
                yield this.getBlockNumber();
            }
            const processFunc = getProcessFunc(this, method, params);
            // Shuffle the providers and then sort them by their priority; we
            // shallowCopy them since we will store the result in them too
            const configs = Object(_ethersproject_random__WEBPACK_IMPORTED_MODULE_4__["shuffled"])(this.providerConfigs.map(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__["shallowCopy"]));
            configs.sort((a, b) => (a.priority - b.priority));
            const currentBlockNumber = this._highestBlockNumber;
            let i = 0;
            let first = true;
            while (true) {
                const t0 = now();
                // Compute the inflight weight (exclude anything past)
                let inflightWeight = configs.filter((c) => (c.runner && ((t0 - c.start) < c.stallTimeout)))
                    .reduce((accum, c) => (accum + c.weight), 0);
                // Start running enough to meet quorum
                while (inflightWeight < this.quorum && i < configs.length) {
                    const config = configs[i++];
                    const rid = nextRid++;
                    config.start = now();
                    config.staller = stall(config.stallTimeout);
                    config.staller.wait(() => { config.staller = null; });
                    config.runner = getRunner(config, currentBlockNumber, method, params).then((result) => {
                        config.done = true;
                        config.result = result;
                        if (this.listenerCount("debug")) {
                            this.emit("debug", {
                                action: "request",
                                rid: rid,
                                backend: exposeDebugConfig(config, now()),
                                request: { method: method, params: Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__["deepCopy"])(params) },
                                provider: this
                            });
                        }
                    }, (error) => {
                        config.done = true;
                        config.error = error;
                        if (this.listenerCount("debug")) {
                            this.emit("debug", {
                                action: "request",
                                rid: rid,
                                backend: exposeDebugConfig(config, now()),
                                request: { method: method, params: Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__["deepCopy"])(params) },
                                provider: this
                            });
                        }
                    });
                    if (this.listenerCount("debug")) {
                        this.emit("debug", {
                            action: "request",
                            rid: rid,
                            backend: exposeDebugConfig(config, null),
                            request: { method: method, params: Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_3__["deepCopy"])(params) },
                            provider: this
                        });
                    }
                    inflightWeight += config.weight;
                }
                // Wait for anything meaningful to finish or stall out
                const waiting = [];
                configs.forEach((c) => {
                    if (c.done || !c.runner) {
                        return;
                    }
                    waiting.push(c.runner);
                    if (c.staller) {
                        waiting.push(c.staller.getPromise());
                    }
                });
                if (waiting.length) {
                    yield Promise.race(waiting);
                }
                // Check the quorum and process the results; the process function
                // may additionally decide the quorum is not met
                const results = configs.filter((c) => (c.done && c.error == null));
                if (results.length >= this.quorum) {
                    const result = processFunc(results);
                    if (result !== undefined) {
                        // Shut down any stallers
                        configs.forEach(c => {
                            if (c.staller) {
                                c.staller.cancel();
                            }
                            c.cancelled = true;
                        });
                        return result;
                    }
                    if (!first) {
                        yield stall(100).getPromise();
                    }
                    first = false;
                }
                // No result, check for errors that should be forwarded
                const errors = configs.reduce((accum, c) => {
                    if (!c.done || c.error == null) {
                        return accum;
                    }
                    const code = (c.error).code;
                    if (ForwardErrors.indexOf(code) >= 0) {
                        if (!accum[code]) {
                            accum[code] = { error: c.error, weight: 0 };
                        }
                        accum[code].weight += c.weight;
                    }
                    return accum;
                }, ({}));
                Object.keys(errors).forEach((errorCode) => {
                    const tally = errors[errorCode];
                    if (tally.weight < this.quorum) {
                        return;
                    }
                    // Shut down any stallers
                    configs.forEach(c => {
                        if (c.staller) {
                            c.staller.cancel();
                        }
                        c.cancelled = true;
                    });
                    const e = (tally.error);
                    const props = {};
                    ForwardProperties.forEach((name) => {
                        if (e[name] == null) {
                            return;
                        }
                        props[name] = e[name];
                    });
                    logger.throwError(e.reason || e.message, errorCode, props);
                });
                // All configs have run to completion; we will never get more data
                if (configs.filter((c) => !c.done).length === 0) {
                    break;
                }
            }
            // Shut down any stallers; shouldn't be any
            configs.forEach(c => {
                if (c.staller) {
                    c.staller.cancel();
                }
                c.cancelled = true;
            });
            return logger.throwError("failed to meet quorum", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.SERVER_ERROR, {
                method: method,
                params: params,
                //results: configs.map((c) => c.result),
                //errors: configs.map((c) => c.error),
                results: configs.map((c) => exposeDebugConfig(c)),
                provider: this
            });
        });
    }
}
//# sourceMappingURL=fallback-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/formatter.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/formatter.js ***!
  \********************************************************************/
/*! exports provided: Formatter, isCommunityResourcable, isCommunityResource, showThrottleMessage */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Formatter", function() { return Formatter; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCommunityResourcable", function() { return isCommunityResourcable; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "isCommunityResource", function() { return isCommunityResource; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "showThrottleMessage", function() { return showThrottleMessage; });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/constants */ "./node_modules/@ethersproject/constants/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");









const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_6__["Logger"](_version__WEBPACK_IMPORTED_MODULE_7__["version"]);
class Formatter {
    constructor() {
        logger.checkNew(new.target, Formatter);
        this.formats = this.getDefaultFormats();
    }
    getDefaultFormats() {
        const formats = ({});
        const address = this.address.bind(this);
        const bigNumber = this.bigNumber.bind(this);
        const blockTag = this.blockTag.bind(this);
        const data = this.data.bind(this);
        const hash = this.hash.bind(this);
        const hex = this.hex.bind(this);
        const number = this.number.bind(this);
        const type = this.type.bind(this);
        const strictData = (v) => { return this.data(v, true); };
        formats.transaction = {
            hash: hash,
            type: type,
            accessList: Formatter.allowNull(this.accessList.bind(this), null),
            blockHash: Formatter.allowNull(hash, null),
            blockNumber: Formatter.allowNull(number, null),
            transactionIndex: Formatter.allowNull(number, null),
            confirmations: Formatter.allowNull(number, null),
            from: address,
            // either (gasPrice) or (maxPriorityFeePerGas + maxFeePerGas)
            // must be set
            gasPrice: Formatter.allowNull(bigNumber),
            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
            maxFeePerGas: Formatter.allowNull(bigNumber),
            gasLimit: bigNumber,
            to: Formatter.allowNull(address, null),
            value: bigNumber,
            nonce: number,
            data: data,
            r: Formatter.allowNull(this.uint256),
            s: Formatter.allowNull(this.uint256),
            v: Formatter.allowNull(number),
            creates: Formatter.allowNull(address, null),
            raw: Formatter.allowNull(data),
        };
        formats.transactionRequest = {
            from: Formatter.allowNull(address),
            nonce: Formatter.allowNull(number),
            gasLimit: Formatter.allowNull(bigNumber),
            gasPrice: Formatter.allowNull(bigNumber),
            maxPriorityFeePerGas: Formatter.allowNull(bigNumber),
            maxFeePerGas: Formatter.allowNull(bigNumber),
            to: Formatter.allowNull(address),
            value: Formatter.allowNull(bigNumber),
            data: Formatter.allowNull(strictData),
            type: Formatter.allowNull(number),
            accessList: Formatter.allowNull(this.accessList.bind(this), null),
        };
        formats.receiptLog = {
            transactionIndex: number,
            blockNumber: number,
            transactionHash: hash,
            address: address,
            topics: Formatter.arrayOf(hash),
            data: data,
            logIndex: number,
            blockHash: hash,
        };
        formats.receipt = {
            to: Formatter.allowNull(this.address, null),
            from: Formatter.allowNull(this.address, null),
            contractAddress: Formatter.allowNull(address, null),
            transactionIndex: number,
            // should be allowNull(hash), but broken-EIP-658 support is handled in receipt
            root: Formatter.allowNull(hex),
            gasUsed: bigNumber,
            logsBloom: Formatter.allowNull(data),
            blockHash: hash,
            transactionHash: hash,
            logs: Formatter.arrayOf(this.receiptLog.bind(this)),
            blockNumber: number,
            confirmations: Formatter.allowNull(number, null),
            cumulativeGasUsed: bigNumber,
            effectiveGasPrice: Formatter.allowNull(bigNumber),
            status: Formatter.allowNull(number),
            type: type
        };
        formats.block = {
            hash: hash,
            parentHash: hash,
            number: number,
            timestamp: number,
            nonce: Formatter.allowNull(hex),
            difficulty: this.difficulty.bind(this),
            gasLimit: bigNumber,
            gasUsed: bigNumber,
            miner: address,
            extraData: data,
            transactions: Formatter.allowNull(Formatter.arrayOf(hash)),
            baseFeePerGas: Formatter.allowNull(bigNumber)
        };
        formats.blockWithTransactions = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["shallowCopy"])(formats.block);
        formats.blockWithTransactions.transactions = Formatter.allowNull(Formatter.arrayOf(this.transactionResponse.bind(this)));
        formats.filter = {
            fromBlock: Formatter.allowNull(blockTag, undefined),
            toBlock: Formatter.allowNull(blockTag, undefined),
            blockHash: Formatter.allowNull(hash, undefined),
            address: Formatter.allowNull(address, undefined),
            topics: Formatter.allowNull(this.topics.bind(this), undefined),
        };
        formats.filterLog = {
            blockNumber: Formatter.allowNull(number),
            blockHash: Formatter.allowNull(hash),
            transactionIndex: number,
            removed: Formatter.allowNull(this.boolean.bind(this)),
            address: address,
            data: Formatter.allowFalsish(data, "0x"),
            topics: Formatter.arrayOf(hash),
            transactionHash: hash,
            logIndex: number,
        };
        return formats;
    }
    accessList(accessList) {
        return Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__["accessListify"])(accessList || []);
    }
    // Requires a BigNumberish that is within the IEEE754 safe integer range; returns a number
    // Strict! Used on input.
    number(number) {
        if (number === "0x") {
            return 0;
        }
        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(number).toNumber();
    }
    type(number) {
        if (number === "0x" || number == null) {
            return 0;
        }
        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(number).toNumber();
    }
    // Strict! Used on input.
    bigNumber(value) {
        return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(value);
    }
    // Requires a boolean, "true" or  "false"; returns a boolean
    boolean(value) {
        if (typeof (value) === "boolean") {
            return value;
        }
        if (typeof (value) === "string") {
            value = value.toLowerCase();
            if (value === "true") {
                return true;
            }
            if (value === "false") {
                return false;
            }
        }
        throw new Error("invalid boolean - " + value);
    }
    hex(value, strict) {
        if (typeof (value) === "string") {
            if (!strict && value.substring(0, 2) !== "0x") {
                value = "0x" + value;
            }
            if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(value)) {
                return value.toLowerCase();
            }
        }
        return logger.throwArgumentError("invalid hash", "value", value);
    }
    data(value, strict) {
        const result = this.hex(value, strict);
        if ((result.length % 2) !== 0) {
            throw new Error("invalid data; odd-length - " + value);
        }
        return result;
    }
    // Requires an address
    // Strict! Used on input.
    address(value) {
        return Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(value);
    }
    callAddress(value) {
        if (!Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(value, 32)) {
            return null;
        }
        const address = Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexDataSlice"])(value, 12));
        return (address === _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__["AddressZero"]) ? null : address;
    }
    contractAddress(value) {
        return Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getContractAddress"])(value);
    }
    // Strict! Used on input.
    blockTag(blockTag) {
        if (blockTag == null) {
            return "latest";
        }
        if (blockTag === "earliest") {
            return "0x0";
        }
        if (blockTag === "latest" || blockTag === "pending") {
            return blockTag;
        }
        if (typeof (blockTag) === "number" || Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(blockTag)) {
            return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexValue"])(blockTag);
        }
        throw new Error("invalid blockTag");
    }
    // Requires a hash, optionally requires 0x prefix; returns prefixed lowercase hash.
    hash(value, strict) {
        const result = this.hex(value, strict);
        if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexDataLength"])(result) !== 32) {
            return logger.throwArgumentError("invalid hash", "value", value);
        }
        return result;
    }
    // Returns the difficulty as a number, or if too large (i.e. PoA network) null
    difficulty(value) {
        if (value == null) {
            return null;
        }
        const v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(value);
        try {
            return v.toNumber();
        }
        catch (error) { }
        return null;
    }
    uint256(value) {
        if (!Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(value)) {
            throw new Error("invalid uint256");
        }
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexZeroPad"])(value, 32);
    }
    _block(value, format) {
        if (value.author != null && value.miner == null) {
            value.miner = value.author;
        }
        // The difficulty may need to come from _difficulty in recursed blocks
        const difficulty = (value._difficulty != null) ? value._difficulty : value.difficulty;
        const result = Formatter.check(format, value);
        result._difficulty = ((difficulty == null) ? null : _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(difficulty));
        return result;
    }
    block(value) {
        return this._block(value, this.formats.block);
    }
    blockWithTransactions(value) {
        return this._block(value, this.formats.blockWithTransactions);
    }
    // Strict! Used on input.
    transactionRequest(value) {
        return Formatter.check(this.formats.transactionRequest, value);
    }
    transactionResponse(transaction) {
        // Rename gas to gasLimit
        if (transaction.gas != null && transaction.gasLimit == null) {
            transaction.gasLimit = transaction.gas;
        }
        // Some clients (TestRPC) do strange things like return 0x0 for the
        // 0 address; correct this to be a real address
        if (transaction.to && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(transaction.to).isZero()) {
            transaction.to = "0x0000000000000000000000000000000000000000";
        }
        // Rename input to data
        if (transaction.input != null && transaction.data == null) {
            transaction.data = transaction.input;
        }
        // If to and creates are empty, populate the creates from the transaction
        if (transaction.to == null && transaction.creates == null) {
            transaction.creates = this.contractAddress(transaction);
        }
        if ((transaction.type === 1 || transaction.type === 2) && transaction.accessList == null) {
            transaction.accessList = [];
        }
        const result = Formatter.check(this.formats.transaction, transaction);
        if (transaction.chainId != null) {
            let chainId = transaction.chainId;
            if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(chainId)) {
                chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(chainId).toNumber();
            }
            result.chainId = chainId;
        }
        else {
            let chainId = transaction.networkId;
            // geth-etc returns chainId
            if (chainId == null && result.v == null) {
                chainId = transaction.chainId;
            }
            if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(chainId)) {
                chainId = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(chainId).toNumber();
            }
            if (typeof (chainId) !== "number" && result.v != null) {
                chainId = (result.v - 35) / 2;
                if (chainId < 0) {
                    chainId = 0;
                }
                chainId = parseInt(chainId);
            }
            if (typeof (chainId) !== "number") {
                chainId = 0;
            }
            result.chainId = chainId;
        }
        // 0x0000... should actually be null
        if (result.blockHash && result.blockHash.replace(/0/g, "") === "x") {
            result.blockHash = null;
        }
        return result;
    }
    transaction(value) {
        return Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_5__["parse"])(value);
    }
    receiptLog(value) {
        return Formatter.check(this.formats.receiptLog, value);
    }
    receipt(value) {
        const result = Formatter.check(this.formats.receipt, value);
        // RSK incorrectly implemented EIP-658, so we munge things a bit here for it
        if (result.root != null) {
            if (result.root.length <= 4) {
                // Could be 0x00, 0x0, 0x01 or 0x1
                const value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(result.root).toNumber();
                if (value === 0 || value === 1) {
                    // Make sure if both are specified, they match
                    if (result.status != null && (result.status !== value)) {
                        logger.throwArgumentError("alt-root-status/status mismatch", "value", { root: result.root, status: result.status });
                    }
                    result.status = value;
                    delete result.root;
                }
                else {
                    logger.throwArgumentError("invalid alt-root-status", "value.root", result.root);
                }
            }
            else if (result.root.length !== 66) {
                // Must be a valid bytes32
                logger.throwArgumentError("invalid root hash", "value.root", result.root);
            }
        }
        if (result.status != null) {
            result.byzantium = true;
        }
        return result;
    }
    topics(value) {
        if (Array.isArray(value)) {
            return value.map((v) => this.topics(v));
        }
        else if (value != null) {
            return this.hash(value, true);
        }
        return null;
    }
    filter(value) {
        return Formatter.check(this.formats.filter, value);
    }
    filterLog(value) {
        return Formatter.check(this.formats.filterLog, value);
    }
    static check(format, object) {
        const result = {};
        for (const key in format) {
            try {
                const value = format[key](object[key]);
                if (value !== undefined) {
                    result[key] = value;
                }
            }
            catch (error) {
                error.checkKey = key;
                error.checkValue = object[key];
                throw error;
            }
        }
        return result;
    }
    // if value is null-ish, nullValue is returned
    static allowNull(format, nullValue) {
        return (function (value) {
            if (value == null) {
                return nullValue;
            }
            return format(value);
        });
    }
    // If value is false-ish, replaceValue is returned
    static allowFalsish(format, replaceValue) {
        return (function (value) {
            if (!value) {
                return replaceValue;
            }
            return format(value);
        });
    }
    // Requires an Array satisfying check
    static arrayOf(format) {
        return (function (array) {
            if (!Array.isArray(array)) {
                throw new Error("not an array");
            }
            const result = [];
            array.forEach(function (value) {
                result.push(format(value));
            });
            return result;
        });
    }
}
function isCommunityResourcable(value) {
    return (value && typeof (value.isCommunityResource) === "function");
}
function isCommunityResource(value) {
    return (isCommunityResourcable(value) && value.isCommunityResource());
}
// Show the throttle message only once
let throttleMessage = false;
function showThrottleMessage() {
    if (throttleMessage) {
        return;
    }
    throttleMessage = true;
    console.log("========= NOTICE =========");
    console.log("Request-Rate Exceeded  (this message will not be repeated)");
    console.log("");
    console.log("The default API keys for each service are provided as a highly-throttled,");
    console.log("community resource for low-traffic projects and early prototyping.");
    console.log("");
    console.log("While your application will continue to function, we highly recommended");
    console.log("signing up for your own API keys to improve performance, increase your");
    console.log("request rate/limit and enable other perks, such as metrics and advanced APIs.");
    console.log("");
    console.log("For more details: https:/\/docs.ethers.io/api-keys/");
    console.log("==========================");
}
//# sourceMappingURL=formatter.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/index.js ***!
  \****************************************************************/
/*! exports provided: Provider, BaseProvider, Resolver, UrlJsonRpcProvider, FallbackProvider, AlchemyProvider, AlchemyWebSocketProvider, CloudflareProvider, EtherscanProvider, InfuraProvider, InfuraWebSocketProvider, JsonRpcProvider, JsonRpcBatchProvider, NodesmithProvider, PocketProvider, StaticJsonRpcProvider, Web3Provider, WebSocketProvider, IpcProvider, JsonRpcSigner, getDefaultProvider, getNetwork, isCommunityResource, isCommunityResourcable, showThrottleMessage, Formatter */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getDefaultProvider", function() { return getDefaultProvider; });
/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/abstract-provider */ "./node_modules/@ethersproject/abstract-provider/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Provider", function() { return _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_0__["Provider"]; });

/* harmony import */ var _ethersproject_networks__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/networks */ "./node_modules/@ethersproject/networks/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getNetwork", function() { return _ethersproject_networks__WEBPACK_IMPORTED_MODULE_1__["getNetwork"]; });

/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./base-provider */ "./node_modules/@ethersproject/providers/lib.esm/base-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseProvider", function() { return _base_provider__WEBPACK_IMPORTED_MODULE_2__["BaseProvider"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Resolver", function() { return _base_provider__WEBPACK_IMPORTED_MODULE_2__["Resolver"]; });

/* harmony import */ var _alchemy_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./alchemy-provider */ "./node_modules/@ethersproject/providers/lib.esm/alchemy-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AlchemyProvider", function() { return _alchemy_provider__WEBPACK_IMPORTED_MODULE_3__["AlchemyProvider"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AlchemyWebSocketProvider", function() { return _alchemy_provider__WEBPACK_IMPORTED_MODULE_3__["AlchemyWebSocketProvider"]; });

/* harmony import */ var _cloudflare_provider__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./cloudflare-provider */ "./node_modules/@ethersproject/providers/lib.esm/cloudflare-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "CloudflareProvider", function() { return _cloudflare_provider__WEBPACK_IMPORTED_MODULE_4__["CloudflareProvider"]; });

/* harmony import */ var _etherscan_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./etherscan-provider */ "./node_modules/@ethersproject/providers/lib.esm/etherscan-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EtherscanProvider", function() { return _etherscan_provider__WEBPACK_IMPORTED_MODULE_5__["EtherscanProvider"]; });

/* harmony import */ var _fallback_provider__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./fallback-provider */ "./node_modules/@ethersproject/providers/lib.esm/fallback-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FallbackProvider", function() { return _fallback_provider__WEBPACK_IMPORTED_MODULE_6__["FallbackProvider"]; });

/* harmony import */ var _ipc_provider__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./ipc-provider */ "./node_modules/@ethersproject/providers/lib.esm/ipc-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "IpcProvider", function() { return _ipc_provider__WEBPACK_IMPORTED_MODULE_7__["IpcProvider"]; });

/* harmony import */ var _infura_provider__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./infura-provider */ "./node_modules/@ethersproject/providers/lib.esm/infura-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InfuraProvider", function() { return _infura_provider__WEBPACK_IMPORTED_MODULE_8__["InfuraProvider"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "InfuraWebSocketProvider", function() { return _infura_provider__WEBPACK_IMPORTED_MODULE_8__["InfuraWebSocketProvider"]; });

/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JsonRpcProvider", function() { return _json_rpc_provider__WEBPACK_IMPORTED_MODULE_9__["JsonRpcProvider"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JsonRpcSigner", function() { return _json_rpc_provider__WEBPACK_IMPORTED_MODULE_9__["JsonRpcSigner"]; });

/* harmony import */ var _json_rpc_batch_provider__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./json-rpc-batch-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "JsonRpcBatchProvider", function() { return _json_rpc_batch_provider__WEBPACK_IMPORTED_MODULE_10__["JsonRpcBatchProvider"]; });

/* harmony import */ var _nodesmith_provider__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./nodesmith-provider */ "./node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "NodesmithProvider", function() { return _nodesmith_provider__WEBPACK_IMPORTED_MODULE_11__["NodesmithProvider"]; });

/* harmony import */ var _pocket_provider__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./pocket-provider */ "./node_modules/@ethersproject/providers/lib.esm/pocket-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "PocketProvider", function() { return _pocket_provider__WEBPACK_IMPORTED_MODULE_12__["PocketProvider"]; });

/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UrlJsonRpcProvider", function() { return _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_13__["UrlJsonRpcProvider"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "StaticJsonRpcProvider", function() { return _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_13__["StaticJsonRpcProvider"]; });

/* harmony import */ var _web3_provider__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./web3-provider */ "./node_modules/@ethersproject/providers/lib.esm/web3-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Web3Provider", function() { return _web3_provider__WEBPACK_IMPORTED_MODULE_14__["Web3Provider"]; });

/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./websocket-provider */ "./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "WebSocketProvider", function() { return _websocket_provider__WEBPACK_IMPORTED_MODULE_15__["WebSocketProvider"]; });

/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isCommunityResource", function() { return _formatter__WEBPACK_IMPORTED_MODULE_16__["isCommunityResource"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isCommunityResourcable", function() { return _formatter__WEBPACK_IMPORTED_MODULE_16__["isCommunityResourcable"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "showThrottleMessage", function() { return _formatter__WEBPACK_IMPORTED_MODULE_16__["showThrottleMessage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Formatter", function() { return _formatter__WEBPACK_IMPORTED_MODULE_16__["Formatter"]; });

/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");




















const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_17__["Logger"](_version__WEBPACK_IMPORTED_MODULE_18__["version"]);
////////////////////////
// Helper Functions
function getDefaultProvider(network, options) {
    if (network == null) {
        network = "homestead";
    }
    // If passed a URL, figure out the right type of provider based on the scheme
    if (typeof (network) === "string") {
        // @TODO: Add support for IpcProvider; maybe if it ends in ".ipc"?
        // Handle http and ws (and their secure variants)
        const match = network.match(/^(ws|http)s?:/i);
        if (match) {
            switch (match[1]) {
                case "http":
                    return new _json_rpc_provider__WEBPACK_IMPORTED_MODULE_9__["JsonRpcProvider"](network);
                case "ws":
                    return new _websocket_provider__WEBPACK_IMPORTED_MODULE_15__["WebSocketProvider"](network);
                default:
                    logger.throwArgumentError("unsupported URL scheme", "network", network);
            }
        }
    }
    const n = Object(_ethersproject_networks__WEBPACK_IMPORTED_MODULE_1__["getNetwork"])(network);
    if (!n || !n._defaultProvider) {
        logger.throwError("unsupported getDefaultProvider network", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_17__["Logger"].errors.NETWORK_ERROR, {
            operation: "getDefaultProvider",
            network: network
        });
    }
    return n._defaultProvider({
        FallbackProvider: _fallback_provider__WEBPACK_IMPORTED_MODULE_6__["FallbackProvider"],
        AlchemyProvider: _alchemy_provider__WEBPACK_IMPORTED_MODULE_3__["AlchemyProvider"],
        CloudflareProvider: _cloudflare_provider__WEBPACK_IMPORTED_MODULE_4__["CloudflareProvider"],
        EtherscanProvider: _etherscan_provider__WEBPACK_IMPORTED_MODULE_5__["EtherscanProvider"],
        InfuraProvider: _infura_provider__WEBPACK_IMPORTED_MODULE_8__["InfuraProvider"],
        JsonRpcProvider: _json_rpc_provider__WEBPACK_IMPORTED_MODULE_9__["JsonRpcProvider"],
        NodesmithProvider: _nodesmith_provider__WEBPACK_IMPORTED_MODULE_11__["NodesmithProvider"],
        PocketProvider: _pocket_provider__WEBPACK_IMPORTED_MODULE_12__["PocketProvider"],
        Web3Provider: _web3_provider__WEBPACK_IMPORTED_MODULE_14__["Web3Provider"],
        IpcProvider: _ipc_provider__WEBPACK_IMPORTED_MODULE_7__["IpcProvider"],
    }, options);
}
////////////////////////
// Exports

//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/infura-provider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/infura-provider.js ***!
  \**************************************************************************/
/*! exports provided: InfuraWebSocketProvider, InfuraProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InfuraWebSocketProvider", function() { return InfuraWebSocketProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InfuraProvider", function() { return InfuraProvider; });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _websocket_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./websocket-provider */ "./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js");
/* harmony import */ var _formatter__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./formatter */ "./node_modules/@ethersproject/providers/lib.esm/formatter.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");






const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__["Logger"](_version__WEBPACK_IMPORTED_MODULE_4__["version"]);

const defaultProjectId = "84842078b09946638c03157f83405213";
class InfuraWebSocketProvider extends _websocket_provider__WEBPACK_IMPORTED_MODULE_1__["WebSocketProvider"] {
    constructor(network, apiKey) {
        const provider = new InfuraProvider(network, apiKey);
        const connection = provider.connection;
        if (connection.password) {
            logger.throwError("INFURA WebSocket project secrets unsupported", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "InfuraProvider.getWebSocketProvider()"
            });
        }
        const url = connection.url.replace(/^http/i, "ws").replace("/v3/", "/ws/v3/");
        super(url, network);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["defineReadOnly"])(this, "apiKey", provider.projectId);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["defineReadOnly"])(this, "projectId", provider.projectId);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["defineReadOnly"])(this, "projectSecret", provider.projectSecret);
    }
    isCommunityResource() {
        return (this.projectId === defaultProjectId);
    }
}
class InfuraProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_5__["UrlJsonRpcProvider"] {
    static getWebSocketProvider(network, apiKey) {
        return new InfuraWebSocketProvider(network, apiKey);
    }
    static getApiKey(apiKey) {
        const apiKeyObj = {
            apiKey: defaultProjectId,
            projectId: defaultProjectId,
            projectSecret: null
        };
        if (apiKey == null) {
            return apiKeyObj;
        }
        if (typeof (apiKey) === "string") {
            apiKeyObj.projectId = apiKey;
        }
        else if (apiKey.projectSecret != null) {
            logger.assertArgument((typeof (apiKey.projectId) === "string"), "projectSecret requires a projectId", "projectId", apiKey.projectId);
            logger.assertArgument((typeof (apiKey.projectSecret) === "string"), "invalid projectSecret", "projectSecret", "[REDACTED]");
            apiKeyObj.projectId = apiKey.projectId;
            apiKeyObj.projectSecret = apiKey.projectSecret;
        }
        else if (apiKey.projectId) {
            apiKeyObj.projectId = apiKey.projectId;
        }
        apiKeyObj.apiKey = apiKeyObj.projectId;
        return apiKeyObj;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch (network ? network.name : "unknown") {
            case "homestead":
                host = "mainnet.infura.io";
                break;
            case "ropsten":
                host = "ropsten.infura.io";
                break;
            case "rinkeby":
                host = "rinkeby.infura.io";
                break;
            case "kovan":
                host = "kovan.infura.io";
                break;
            case "goerli":
                host = "goerli.infura.io";
                break;
            case "matic":
                host = "polygon-mainnet.infura.io";
                break;
            case "maticmum":
                host = "polygon-mumbai.infura.io";
                break;
            case "optimism":
                host = "optimism-mainnet.infura.io";
                break;
            case "optimism-kovan":
                host = "optimism-kovan.infura.io";
                break;
            case "arbitrum":
                host = "arbitrum-mainnet.infura.io";
                break;
            case "arbitrum-rinkeby":
                host = "arbitrum-rinkeby.infura.io";
                break;
            default:
                logger.throwError("unsupported network", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].errors.INVALID_ARGUMENT, {
                    argument: "network",
                    value: network
                });
        }
        const connection = {
            allowGzip: true,
            url: ("https:/" + "/" + host + "/v3/" + apiKey.projectId),
            throttleCallback: (attempt, url) => {
                if (apiKey.projectId === defaultProjectId) {
                    Object(_formatter__WEBPACK_IMPORTED_MODULE_2__["showThrottleMessage"])();
                }
                return Promise.resolve(true);
            }
        };
        if (apiKey.projectSecret != null) {
            connection.user = "";
            connection.password = apiKey.projectSecret;
        }
        return connection;
    }
    isCommunityResource() {
        return (this.projectId === defaultProjectId);
    }
}
//# sourceMappingURL=infura-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/ipc-provider.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/ipc-provider.js ***!
  \***********************************************************************/
/*! exports provided: IpcProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IpcProvider", function() { return IpcProvider; });

const IpcProvider = null;

//# sourceMappingURL=ipc-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/json-rpc-batch-provider.js ***!
  \**********************************************************************************/
/*! exports provided: JsonRpcBatchProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonRpcBatchProvider", function() { return JsonRpcBatchProvider; });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");
/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js");



// Experimental
class JsonRpcBatchProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__["JsonRpcProvider"] {
    send(method, params) {
        const request = {
            method: method,
            params: params,
            id: (this._nextId++),
            jsonrpc: "2.0"
        };
        if (this._pendingBatch == null) {
            this._pendingBatch = [];
        }
        const inflightRequest = { request, resolve: null, reject: null };
        const promise = new Promise((resolve, reject) => {
            inflightRequest.resolve = resolve;
            inflightRequest.reject = reject;
        });
        this._pendingBatch.push(inflightRequest);
        if (!this._pendingBatchAggregator) {
            // Schedule batch for next event loop + short duration
            this._pendingBatchAggregator = setTimeout(() => {
                // Get teh current batch and clear it, so new requests
                // go into the next batch
                const batch = this._pendingBatch;
                this._pendingBatch = null;
                this._pendingBatchAggregator = null;
                // Get the request as an array of requests
                const request = batch.map((inflight) => inflight.request);
                this.emit("debug", {
                    action: "requestBatch",
                    request: Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["deepCopy"])(request),
                    provider: this
                });
                return Object(_ethersproject_web__WEBPACK_IMPORTED_MODULE_1__["fetchJson"])(this.connection, JSON.stringify(request)).then((result) => {
                    this.emit("debug", {
                        action: "response",
                        request: request,
                        response: result,
                        provider: this
                    });
                    // For each result, feed it to the correct Promise, depending
                    // on whether it was a success or error
                    batch.forEach((inflightRequest, index) => {
                        const payload = result[index];
                        if (payload.error) {
                            const error = new Error(payload.error.message);
                            error.code = payload.error.code;
                            error.data = payload.error.data;
                            inflightRequest.reject(error);
                        }
                        else {
                            inflightRequest.resolve(payload.result);
                        }
                    });
                }, (error) => {
                    this.emit("debug", {
                        action: "response",
                        error: error,
                        request: request,
                        provider: this
                    });
                    batch.forEach((inflightRequest) => {
                        inflightRequest.reject(error);
                    });
                });
            }, 10);
        }
        return promise;
    }
}
//# sourceMappingURL=json-rpc-batch-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js":
/*!****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js ***!
  \****************************************************************************/
/*! exports provided: JsonRpcSigner, JsonRpcProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonRpcSigner", function() { return JsonRpcSigner; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JsonRpcProvider", function() { return JsonRpcProvider; });
/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/abstract-signer */ "./node_modules/@ethersproject/abstract-signer/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _base_provider__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./base-provider */ "./node_modules/@ethersproject/providers/lib.esm/base-provider.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};










const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"](_version__WEBPACK_IMPORTED_MODULE_9__["version"]);

const errorGas = ["call", "estimateGas"];
function checkError(method, error, params) {
    // Undo the "convenience" some nodes are attempting to prevent backwards
    // incompatibility; maybe for v6 consider forwarding reverts as errors
    if (method === "call" && error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.SERVER_ERROR) {
        const e = error.error;
        if (e && e.message.match("reverted") && Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isHexString"])(e.data)) {
            return e.data;
        }
        logger.throwError("missing revert data in call exception", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.CALL_EXCEPTION, {
            error, data: "0x"
        });
    }
    let message = error.message;
    if (error.code === _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.SERVER_ERROR && error.error && typeof (error.error.message) === "string") {
        message = error.error.message;
    }
    else if (typeof (error.body) === "string") {
        message = error.body;
    }
    else if (typeof (error.responseText) === "string") {
        message = error.responseText;
    }
    message = (message || "").toLowerCase();
    const transaction = params.transaction || params.signedTransaction;
    // "insufficient funds for gas * price + value + cost(data)"
    if (message.match(/insufficient funds|base fee exceeds gas limit/)) {
        logger.throwError("insufficient funds for intrinsic transaction cost", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.INSUFFICIENT_FUNDS, {
            error, method, transaction
        });
    }
    // "nonce too low"
    if (message.match(/nonce too low/)) {
        logger.throwError("nonce has already been used", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.NONCE_EXPIRED, {
            error, method, transaction
        });
    }
    // "replacement transaction underpriced"
    if (message.match(/replacement transaction underpriced/)) {
        logger.throwError("replacement fee too low", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.REPLACEMENT_UNDERPRICED, {
            error, method, transaction
        });
    }
    // "replacement transaction underpriced"
    if (message.match(/only replay-protected/)) {
        logger.throwError("legacy pre-eip-155 transactions not supported", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
            error, method, transaction
        });
    }
    if (errorGas.indexOf(method) >= 0 && message.match(/gas required exceeds allowance|always failing transaction|execution reverted/)) {
        logger.throwError("cannot estimate gas; transaction may fail or may require manual gas limit", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNPREDICTABLE_GAS_LIMIT, {
            error, method, transaction
        });
    }
    throw error;
}
function timer(timeout) {
    return new Promise(function (resolve) {
        setTimeout(resolve, timeout);
    });
}
function getResult(payload) {
    if (payload.error) {
        // @TODO: not any
        const error = new Error(payload.error.message);
        error.code = payload.error.code;
        error.data = payload.error.data;
        throw error;
    }
    return payload.result;
}
function getLowerCase(value) {
    if (value) {
        return value.toLowerCase();
    }
    return value;
}
const _constructorGuard = {};
class JsonRpcSigner extends _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_0__["Signer"] {
    constructor(constructorGuard, provider, addressOrIndex) {
        logger.checkNew(new.target, JsonRpcSigner);
        super();
        if (constructorGuard !== _constructorGuard) {
            throw new Error("do not call the JsonRpcSigner constructor directly; use provider.getSigner");
        }
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["defineReadOnly"])(this, "provider", provider);
        if (addressOrIndex == null) {
            addressOrIndex = 0;
        }
        if (typeof (addressOrIndex) === "string") {
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["defineReadOnly"])(this, "_address", this.provider.formatter.address(addressOrIndex));
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["defineReadOnly"])(this, "_index", null);
        }
        else if (typeof (addressOrIndex) === "number") {
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["defineReadOnly"])(this, "_index", addressOrIndex);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["defineReadOnly"])(this, "_address", null);
        }
        else {
            logger.throwArgumentError("invalid address or index", "addressOrIndex", addressOrIndex);
        }
    }
    connect(provider) {
        return logger.throwError("cannot alter JSON-RPC Signer connection", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
            operation: "connect"
        });
    }
    connectUnchecked() {
        return new UncheckedJsonRpcSigner(_constructorGuard, this.provider, this._address || this._index);
    }
    getAddress() {
        if (this._address) {
            return Promise.resolve(this._address);
        }
        return this.provider.send("eth_accounts", []).then((accounts) => {
            if (accounts.length <= this._index) {
                logger.throwError("unknown account #" + this._index, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
                    operation: "getAddress"
                });
            }
            return this.provider.formatter.address(accounts[this._index]);
        });
    }
    sendUncheckedTransaction(transaction) {
        transaction = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["shallowCopy"])(transaction);
        const fromAddress = this.getAddress().then((address) => {
            if (address) {
                address = address.toLowerCase();
            }
            return address;
        });
        // The JSON-RPC for eth_sendTransaction uses 90000 gas; if the user
        // wishes to use this, it is easy to specify explicitly, otherwise
        // we look it up for them.
        if (transaction.gasLimit == null) {
            const estimate = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["shallowCopy"])(transaction);
            estimate.from = fromAddress;
            transaction.gasLimit = this.provider.estimateGas(estimate);
        }
        if (transaction.to != null) {
            transaction.to = Promise.resolve(transaction.to).then((to) => __awaiter(this, void 0, void 0, function* () {
                if (to == null) {
                    return null;
                }
                const address = yield this.provider.resolveName(to);
                if (address == null) {
                    logger.throwArgumentError("provided ENS name resolves to null", "tx.to", to);
                }
                return address;
            }));
        }
        return Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["resolveProperties"])({
            tx: Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["resolveProperties"])(transaction),
            sender: fromAddress
        }).then(({ tx, sender }) => {
            if (tx.from != null) {
                if (tx.from.toLowerCase() !== sender) {
                    logger.throwArgumentError("from address mismatch", "transaction", transaction);
                }
            }
            else {
                tx.from = sender;
            }
            const hexTx = this.provider.constructor.hexlifyTransaction(tx, { from: true });
            return this.provider.send("eth_sendTransaction", [hexTx]).then((hash) => {
                return hash;
            }, (error) => {
                return checkError("sendTransaction", error, hexTx);
            });
        });
    }
    signTransaction(transaction) {
        return logger.throwError("signing transactions is unsupported", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
            operation: "signTransaction"
        });
    }
    sendTransaction(transaction) {
        return __awaiter(this, void 0, void 0, function* () {
            // This cannot be mined any earlier than any recent block
            const blockNumber = yield this.provider._getInternalBlockNumber(100 + 2 * this.provider.pollingInterval);
            // Send the transaction
            const hash = yield this.sendUncheckedTransaction(transaction);
            try {
                // Unfortunately, JSON-RPC only provides and opaque transaction hash
                // for a response, and we need the actual transaction, so we poll
                // for it; it should show up very quickly
                return yield Object(_ethersproject_web__WEBPACK_IMPORTED_MODULE_7__["poll"])(() => __awaiter(this, void 0, void 0, function* () {
                    const tx = yield this.provider.getTransaction(hash);
                    if (tx === null) {
                        return undefined;
                    }
                    return this.provider._wrapTransaction(tx, hash, blockNumber);
                }), { oncePoll: this.provider });
            }
            catch (error) {
                error.transactionHash = hash;
                throw error;
            }
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = ((typeof (message) === "string") ? Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_5__["toUtf8Bytes"])(message) : message);
            const address = yield this.getAddress();
            return yield this.provider.send("personal_sign", [Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(data), address.toLowerCase()]);
        });
    }
    _legacySignMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            const data = ((typeof (message) === "string") ? Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_5__["toUtf8Bytes"])(message) : message);
            const address = yield this.getAddress();
            // https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign
            return yield this.provider.send("eth_sign", [address.toLowerCase(), Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(data)]);
        });
    }
    _signTypedData(domain, types, value) {
        return __awaiter(this, void 0, void 0, function* () {
            // Populate any ENS names (in-place)
            const populated = yield _ethersproject_hash__WEBPACK_IMPORTED_MODULE_3__["_TypedDataEncoder"].resolveNames(domain, types, value, (name) => {
                return this.provider.resolveName(name);
            });
            const address = yield this.getAddress();
            return yield this.provider.send("eth_signTypedData_v4", [
                address.toLowerCase(),
                JSON.stringify(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_3__["_TypedDataEncoder"].getPayload(populated.domain, types, populated.value))
            ]);
        });
    }
    unlock(password) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = this.provider;
            const address = yield this.getAddress();
            return provider.send("personal_unlockAccount", [address.toLowerCase(), password, null]);
        });
    }
}
class UncheckedJsonRpcSigner extends JsonRpcSigner {
    sendTransaction(transaction) {
        return this.sendUncheckedTransaction(transaction).then((hash) => {
            return {
                hash: hash,
                nonce: null,
                gasLimit: null,
                gasPrice: null,
                data: null,
                value: null,
                chainId: null,
                confirmations: 0,
                from: null,
                wait: (confirmations) => { return this.provider.waitForTransaction(hash, confirmations); }
            };
        });
    }
}
const allowedTransactionKeys = {
    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, value: true,
    type: true, accessList: true,
    maxFeePerGas: true, maxPriorityFeePerGas: true
};
class JsonRpcProvider extends _base_provider__WEBPACK_IMPORTED_MODULE_10__["BaseProvider"] {
    constructor(url, network) {
        logger.checkNew(new.target, JsonRpcProvider);
        let networkOrReady = network;
        // The network is unknown, query the JSON-RPC for it
        if (networkOrReady == null) {
            networkOrReady = new Promise((resolve, reject) => {
                setTimeout(() => {
                    this.detectNetwork().then((network) => {
                        resolve(network);
                    }, (error) => {
                        reject(error);
                    });
                }, 0);
            });
        }
        super(networkOrReady);
        // Default URL
        if (!url) {
            url = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["getStatic"])(this.constructor, "defaultUrl")();
        }
        if (typeof (url) === "string") {
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["defineReadOnly"])(this, "connection", Object.freeze({
                url: url
            }));
        }
        else {
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["defineReadOnly"])(this, "connection", Object.freeze(Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["shallowCopy"])(url)));
        }
        this._nextId = 42;
    }
    get _cache() {
        if (this._eventLoopCache == null) {
            this._eventLoopCache = {};
        }
        return this._eventLoopCache;
    }
    static defaultUrl() {
        return "http:/\/localhost:8545";
    }
    detectNetwork() {
        if (!this._cache["detectNetwork"]) {
            this._cache["detectNetwork"] = this._uncachedDetectNetwork();
            // Clear this cache at the beginning of the next event loop
            setTimeout(() => {
                this._cache["detectNetwork"] = null;
            }, 0);
        }
        return this._cache["detectNetwork"];
    }
    _uncachedDetectNetwork() {
        return __awaiter(this, void 0, void 0, function* () {
            yield timer(0);
            let chainId = null;
            try {
                chainId = yield this.send("eth_chainId", []);
            }
            catch (error) {
                try {
                    chainId = yield this.send("net_version", []);
                }
                catch (error) { }
            }
            if (chainId != null) {
                const getNetwork = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["getStatic"])(this.constructor, "getNetwork");
                try {
                    return getNetwork(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(chainId).toNumber());
                }
                catch (error) {
                    return logger.throwError("could not detect network", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.NETWORK_ERROR, {
                        chainId: chainId,
                        event: "invalidNetwork",
                        serverError: error
                    });
                }
            }
            return logger.throwError("could not detect network", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.NETWORK_ERROR, {
                event: "noNetwork"
            });
        });
    }
    getSigner(addressOrIndex) {
        return new JsonRpcSigner(_constructorGuard, this, addressOrIndex);
    }
    getUncheckedSigner(addressOrIndex) {
        return this.getSigner(addressOrIndex).connectUnchecked();
    }
    listAccounts() {
        return this.send("eth_accounts", []).then((accounts) => {
            return accounts.map((a) => this.formatter.address(a));
        });
    }
    send(method, params) {
        const request = {
            method: method,
            params: params,
            id: (this._nextId++),
            jsonrpc: "2.0"
        };
        this.emit("debug", {
            action: "request",
            request: Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["deepCopy"])(request),
            provider: this
        });
        // We can expand this in the future to any call, but for now these
        // are the biggest wins and do not require any serializing parameters.
        const cache = (["eth_chainId", "eth_blockNumber"].indexOf(method) >= 0);
        if (cache && this._cache[method]) {
            return this._cache[method];
        }
        const result = Object(_ethersproject_web__WEBPACK_IMPORTED_MODULE_7__["fetchJson"])(this.connection, JSON.stringify(request), getResult).then((result) => {
            this.emit("debug", {
                action: "response",
                request: request,
                response: result,
                provider: this
            });
            return result;
        }, (error) => {
            this.emit("debug", {
                action: "response",
                error: error,
                request: request,
                provider: this
            });
            throw error;
        });
        // Cache the fetch, but clear it on the next event loop
        if (cache) {
            this._cache[method] = result;
            setTimeout(() => {
                this._cache[method] = null;
            }, 0);
        }
        return result;
    }
    prepareRequest(method, params) {
        switch (method) {
            case "getBlockNumber":
                return ["eth_blockNumber", []];
            case "getGasPrice":
                return ["eth_gasPrice", []];
            case "getBalance":
                return ["eth_getBalance", [getLowerCase(params.address), params.blockTag]];
            case "getTransactionCount":
                return ["eth_getTransactionCount", [getLowerCase(params.address), params.blockTag]];
            case "getCode":
                return ["eth_getCode", [getLowerCase(params.address), params.blockTag]];
            case "getStorageAt":
                return ["eth_getStorageAt", [getLowerCase(params.address), params.position, params.blockTag]];
            case "sendTransaction":
                return ["eth_sendRawTransaction", [params.signedTransaction]];
            case "getBlock":
                if (params.blockTag) {
                    return ["eth_getBlockByNumber", [params.blockTag, !!params.includeTransactions]];
                }
                else if (params.blockHash) {
                    return ["eth_getBlockByHash", [params.blockHash, !!params.includeTransactions]];
                }
                return null;
            case "getTransaction":
                return ["eth_getTransactionByHash", [params.transactionHash]];
            case "getTransactionReceipt":
                return ["eth_getTransactionReceipt", [params.transactionHash]];
            case "call": {
                const hexlifyTransaction = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["getStatic"])(this.constructor, "hexlifyTransaction");
                return ["eth_call", [hexlifyTransaction(params.transaction, { from: true }), params.blockTag]];
            }
            case "estimateGas": {
                const hexlifyTransaction = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["getStatic"])(this.constructor, "hexlifyTransaction");
                return ["eth_estimateGas", [hexlifyTransaction(params.transaction, { from: true })]];
            }
            case "getLogs":
                if (params.filter && params.filter.address != null) {
                    params.filter.address = getLowerCase(params.filter.address);
                }
                return ["eth_getLogs", [params.filter]];
            default:
                break;
        }
        return null;
    }
    perform(method, params) {
        return __awaiter(this, void 0, void 0, function* () {
            // Legacy networks do not like the type field being passed along (which
            // is fair), so we delete type if it is 0 and a non-EIP-1559 network
            if (method === "call" || method === "estimateGas") {
                const tx = params.transaction;
                if (tx && tx.type != null && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(tx.type).isZero()) {
                    // If there are no EIP-1559 properties, it might be non-EIP-a559
                    if (tx.maxFeePerGas == null && tx.maxPriorityFeePerGas == null) {
                        const feeData = yield this.getFeeData();
                        if (feeData.maxFeePerGas == null && feeData.maxPriorityFeePerGas == null) {
                            // Network doesn't know about EIP-1559 (and hence type)
                            params = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["shallowCopy"])(params);
                            params.transaction = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["shallowCopy"])(tx);
                            delete params.transaction.type;
                        }
                    }
                }
            }
            const args = this.prepareRequest(method, params);
            if (args == null) {
                logger.throwError(method + " not implemented", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.NOT_IMPLEMENTED, { operation: method });
            }
            try {
                return yield this.send(args[0], args[1]);
            }
            catch (error) {
                return checkError(method, error, params);
            }
        });
    }
    _startEvent(event) {
        if (event.tag === "pending") {
            this._startPending();
        }
        super._startEvent(event);
    }
    _startPending() {
        if (this._pendingFilter != null) {
            return;
        }
        const self = this;
        const pendingFilter = this.send("eth_newPendingTransactionFilter", []);
        this._pendingFilter = pendingFilter;
        pendingFilter.then(function (filterId) {
            function poll() {
                self.send("eth_getFilterChanges", [filterId]).then(function (hashes) {
                    if (self._pendingFilter != pendingFilter) {
                        return null;
                    }
                    let seq = Promise.resolve();
                    hashes.forEach(function (hash) {
                        // @TODO: This should be garbage collected at some point... How? When?
                        self._emitted["t:" + hash.toLowerCase()] = "pending";
                        seq = seq.then(function () {
                            return self.getTransaction(hash).then(function (tx) {
                                self.emit("pending", tx);
                                return null;
                            });
                        });
                    });
                    return seq.then(function () {
                        return timer(1000);
                    });
                }).then(function () {
                    if (self._pendingFilter != pendingFilter) {
                        self.send("eth_uninstallFilter", [filterId]);
                        return;
                    }
                    setTimeout(function () { poll(); }, 0);
                    return null;
                }).catch((error) => { });
            }
            poll();
            return filterId;
        }).catch((error) => { });
    }
    _stopEvent(event) {
        if (event.tag === "pending" && this.listenerCount("pending") === 0) {
            this._pendingFilter = null;
        }
        super._stopEvent(event);
    }
    // Convert an ethers.js transaction into a JSON-RPC transaction
    //  - gasLimit => gas
    //  - All values hexlified
    //  - All numeric values zero-striped
    //  - All addresses are lowercased
    // NOTE: This allows a TransactionRequest, but all values should be resolved
    //       before this is called
    // @TODO: This will likely be removed in future versions and prepareRequest
    //        will be the preferred method for this.
    static hexlifyTransaction(transaction, allowExtra) {
        // Check only allowed properties are given
        const allowed = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["shallowCopy"])(allowedTransactionKeys);
        if (allowExtra) {
            for (const key in allowExtra) {
                if (allowExtra[key]) {
                    allowed[key] = true;
                }
            }
        }
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_4__["checkProperties"])(transaction, allowed);
        const result = {};
        // Some nodes (INFURA ropsten; INFURA mainnet is fine) do not like leading zeros.
        ["gasLimit", "gasPrice", "type", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "value"].forEach(function (key) {
            if (transaction[key] == null) {
                return;
            }
            const value = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexValue"])(transaction[key]);
            if (key === "gasLimit") {
                key = "gas";
            }
            result[key] = value;
        });
        ["from", "to", "data"].forEach(function (key) {
            if (transaction[key] == null) {
                return;
            }
            result[key] = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(transaction[key]);
        });
        if (transaction.accessList) {
            result["accessList"] = Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_6__["accessListify"])(transaction.accessList);
        }
        return result;
    }
}
//# sourceMappingURL=json-rpc-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/nodesmith-provider.js ***!
  \*****************************************************************************/
/*! exports provided: NodesmithProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NodesmithProvider", function() { return NodesmithProvider; });
/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* istanbul ignore file */




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"](_version__WEBPACK_IMPORTED_MODULE_2__["version"]);
// Special API key provided by Nodesmith for ethers.js
const defaultApiKey = "ETHERS_JS_SHARED";
class NodesmithProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_0__["UrlJsonRpcProvider"] {
    static getApiKey(apiKey) {
        if (apiKey && typeof (apiKey) !== "string") {
            logger.throwArgumentError("invalid apiKey", "apiKey", apiKey);
        }
        return apiKey || defaultApiKey;
    }
    static getUrl(network, apiKey) {
        logger.warn("NodeSmith will be discontinued on 2019-12-20; please migrate to another platform.");
        let host = null;
        switch (network.name) {
            case "homestead":
                host = "https://ethereum.api.nodesmith.io/v1/mainnet/jsonrpc";
                break;
            case "ropsten":
                host = "https://ethereum.api.nodesmith.io/v1/ropsten/jsonrpc";
                break;
            case "rinkeby":
                host = "https://ethereum.api.nodesmith.io/v1/rinkeby/jsonrpc";
                break;
            case "goerli":
                host = "https://ethereum.api.nodesmith.io/v1/goerli/jsonrpc";
                break;
            case "kovan":
                host = "https://ethereum.api.nodesmith.io/v1/kovan/jsonrpc";
                break;
            default:
                logger.throwArgumentError("unsupported network", "network", arguments[0]);
        }
        return (host + "?apiKey=" + apiKey);
    }
}
//# sourceMappingURL=nodesmith-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/pocket-provider.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/pocket-provider.js ***!
  \**************************************************************************/
/*! exports provided: PocketProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PocketProvider", function() { return PocketProvider; });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./url-json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js");




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"](_version__WEBPACK_IMPORTED_MODULE_2__["version"]);

// These are load-balancer-based application IDs
const defaultApplicationIds = {
    homestead: "6004bcd10040261633ade990",
    ropsten: "6004bd4d0040261633ade991",
    rinkeby: "6004bda20040261633ade994",
    goerli: "6004bd860040261633ade992",
};
class PocketProvider extends _url_json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__["UrlJsonRpcProvider"] {
    constructor(network, apiKey) {
        // We need a bit of creativity in the constructor because
        // Pocket uses different default API keys based on the network
        if (apiKey == null) {
            const n = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["getStatic"])(new.target, "getNetwork")(network);
            if (n) {
                const applicationId = defaultApplicationIds[n.name];
                if (applicationId) {
                    apiKey = {
                        applicationId: applicationId,
                        loadBalancer: true
                    };
                }
            }
            // If there was any issue above, we don't know this network
            if (apiKey == null) {
                logger.throwError("unsupported network", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.INVALID_ARGUMENT, {
                    argument: "network",
                    value: network
                });
            }
        }
        super(network, apiKey);
    }
    static getApiKey(apiKey) {
        // Most API Providers allow null to get the default configuration, but
        // Pocket requires the network to decide the default provider, so we
        // rely on hijacking the constructor to add a sensible default for us
        if (apiKey == null) {
            logger.throwArgumentError("PocketProvider.getApiKey does not support null apiKey", "apiKey", apiKey);
        }
        const apiKeyObj = {
            applicationId: null,
            loadBalancer: false,
            applicationSecretKey: null
        };
        // Parse applicationId and applicationSecretKey
        if (typeof (apiKey) === "string") {
            apiKeyObj.applicationId = apiKey;
        }
        else if (apiKey.applicationSecretKey != null) {
            logger.assertArgument((typeof (apiKey.applicationId) === "string"), "applicationSecretKey requires an applicationId", "applicationId", apiKey.applicationId);
            logger.assertArgument((typeof (apiKey.applicationSecretKey) === "string"), "invalid applicationSecretKey", "applicationSecretKey", "[REDACTED]");
            apiKeyObj.applicationId = apiKey.applicationId;
            apiKeyObj.applicationSecretKey = apiKey.applicationSecretKey;
            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
        }
        else if (apiKey.applicationId) {
            logger.assertArgument((typeof (apiKey.applicationId) === "string"), "apiKey.applicationId must be a string", "apiKey.applicationId", apiKey.applicationId);
            apiKeyObj.applicationId = apiKey.applicationId;
            apiKeyObj.loadBalancer = !!apiKey.loadBalancer;
        }
        else {
            logger.throwArgumentError("unsupported PocketProvider apiKey", "apiKey", apiKey);
        }
        return apiKeyObj;
    }
    static getUrl(network, apiKey) {
        let host = null;
        switch (network ? network.name : "unknown") {
            case "homestead":
                host = "eth-mainnet.gateway.pokt.network";
                break;
            case "ropsten":
                host = "eth-ropsten.gateway.pokt.network";
                break;
            case "rinkeby":
                host = "eth-rinkeby.gateway.pokt.network";
                break;
            case "goerli":
                host = "eth-goerli.gateway.pokt.network";
                break;
            default:
                logger.throwError("unsupported network", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.INVALID_ARGUMENT, {
                    argument: "network",
                    value: network
                });
        }
        let url = null;
        if (apiKey.loadBalancer) {
            url = `https:/\/${host}/v1/lb/${apiKey.applicationId}`;
        }
        else {
            url = `https:/\/${host}/v1/${apiKey.applicationId}`;
        }
        const connection = { url };
        // Initialize empty headers
        connection.headers = {};
        // Apply application secret key
        if (apiKey.applicationSecretKey != null) {
            connection.user = "";
            connection.password = apiKey.applicationSecretKey;
        }
        return connection;
    }
    isCommunityResource() {
        return (this.applicationId === defaultApplicationIds[this.network.name]);
    }
}
//# sourceMappingURL=pocket-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js":
/*!********************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/url-json-rpc-provider.js ***!
  \********************************************************************************/
/*! exports provided: StaticJsonRpcProvider, UrlJsonRpcProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StaticJsonRpcProvider", function() { return StaticJsonRpcProvider; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UrlJsonRpcProvider", function() { return UrlJsonRpcProvider; });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"](_version__WEBPACK_IMPORTED_MODULE_2__["version"]);

// A StaticJsonRpcProvider is useful when you *know* for certain that
// the backend will never change, as it never calls eth_chainId to
// verify its backend. However, if the backend does change, the effects
// are undefined and may include:
// - inconsistent results
// - locking up the UI
// - block skew warnings
// - wrong results
// If the network is not explicit (i.e. auto-detection is expected), the
// node MUST be running and available to respond to requests BEFORE this
// is instantiated.
class StaticJsonRpcProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__["JsonRpcProvider"] {
    detectNetwork() {
        const _super = Object.create(null, {
            detectNetwork: { get: () => super.detectNetwork }
        });
        return __awaiter(this, void 0, void 0, function* () {
            let network = this.network;
            if (network == null) {
                network = yield _super.detectNetwork.call(this);
                if (!network) {
                    logger.throwError("no network detected", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.UNKNOWN_ERROR, {});
                }
                // If still not set, set it
                if (this._network == null) {
                    // A static network does not support "any"
                    Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["defineReadOnly"])(this, "_network", network);
                    this.emit("network", network, null);
                }
            }
            return network;
        });
    }
}
class UrlJsonRpcProvider extends StaticJsonRpcProvider {
    constructor(network, apiKey) {
        logger.checkAbstract(new.target, UrlJsonRpcProvider);
        // Normalize the Network and API Key
        network = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["getStatic"])(new.target, "getNetwork")(network);
        apiKey = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["getStatic"])(new.target, "getApiKey")(apiKey);
        const connection = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["getStatic"])(new.target, "getUrl")(network, apiKey);
        super(connection, network);
        if (typeof (apiKey) === "string") {
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["defineReadOnly"])(this, "apiKey", apiKey);
        }
        else if (apiKey != null) {
            Object.keys(apiKey).forEach((key) => {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["defineReadOnly"])(this, key, apiKey[key]);
            });
        }
    }
    _startPending() {
        logger.warn("WARNING: API provider does not support pending filters");
    }
    isCommunityResource() {
        return false;
    }
    getSigner(address) {
        return logger.throwError("API provider does not support signing", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.UNSUPPORTED_OPERATION, { operation: "getSigner" });
    }
    listAccounts() {
        return Promise.resolve([]);
    }
    // Return a defaultApiKey if null, otherwise validate the API key
    static getApiKey(apiKey) {
        return apiKey;
    }
    // Returns the url or connection for the given network and API key. The
    // API key will have been sanitized by the getApiKey first, so any validation
    // or transformations can be done there.
    static getUrl(network, apiKey) {
        return logger.throwError("not implemented; sub-classes must override getUrl", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.NOT_IMPLEMENTED, {
            operation: "getUrl"
        });
    }
}
//# sourceMappingURL=url-json-rpc-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/web3-provider.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/web3-provider.js ***!
  \************************************************************************/
/*! exports provided: Web3Provider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Web3Provider", function() { return Web3Provider; });
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");
/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js");




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"](_version__WEBPACK_IMPORTED_MODULE_2__["version"]);

let _nextId = 1;
function buildWeb3LegacyFetcher(provider, sendFunc) {
    const fetcher = "Web3LegacyFetcher";
    return function (method, params) {
        const request = {
            method: method,
            params: params,
            id: (_nextId++),
            jsonrpc: "2.0"
        };
        return new Promise((resolve, reject) => {
            this.emit("debug", {
                action: "request",
                fetcher,
                request: Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["deepCopy"])(request),
                provider: this
            });
            sendFunc(request, (error, response) => {
                if (error) {
                    this.emit("debug", {
                        action: "response",
                        fetcher,
                        error,
                        request,
                        provider: this
                    });
                    return reject(error);
                }
                this.emit("debug", {
                    action: "response",
                    fetcher,
                    request,
                    response,
                    provider: this
                });
                if (response.error) {
                    const error = new Error(response.error.message);
                    error.code = response.error.code;
                    error.data = response.error.data;
                    return reject(error);
                }
                resolve(response.result);
            });
        });
    };
}
function buildEip1193Fetcher(provider) {
    return function (method, params) {
        if (params == null) {
            params = [];
        }
        const request = { method, params };
        this.emit("debug", {
            action: "request",
            fetcher: "Eip1193Fetcher",
            request: Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["deepCopy"])(request),
            provider: this
        });
        return provider.request(request).then((response) => {
            this.emit("debug", {
                action: "response",
                fetcher: "Eip1193Fetcher",
                request,
                response,
                provider: this
            });
            return response;
        }, (error) => {
            this.emit("debug", {
                action: "response",
                fetcher: "Eip1193Fetcher",
                request,
                error,
                provider: this
            });
            throw error;
        });
    };
}
class Web3Provider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_3__["JsonRpcProvider"] {
    constructor(provider, network) {
        logger.checkNew(new.target, Web3Provider);
        if (provider == null) {
            logger.throwArgumentError("missing provider", "provider", provider);
        }
        let path = null;
        let jsonRpcFetchFunc = null;
        let subprovider = null;
        if (typeof (provider) === "function") {
            path = "unknown:";
            jsonRpcFetchFunc = provider;
        }
        else {
            path = provider.host || provider.path || "";
            if (!path && provider.isMetaMask) {
                path = "metamask";
            }
            subprovider = provider;
            if (provider.request) {
                if (path === "") {
                    path = "eip-1193:";
                }
                jsonRpcFetchFunc = buildEip1193Fetcher(provider);
            }
            else if (provider.sendAsync) {
                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.sendAsync.bind(provider));
            }
            else if (provider.send) {
                jsonRpcFetchFunc = buildWeb3LegacyFetcher(provider, provider.send.bind(provider));
            }
            else {
                logger.throwArgumentError("unsupported provider", "provider", provider);
            }
            if (!path) {
                path = "unknown:";
            }
        }
        super(path, network);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["defineReadOnly"])(this, "jsonRpcFetchFunc", jsonRpcFetchFunc);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_0__["defineReadOnly"])(this, "provider", subprovider);
    }
    send(method, params) {
        return this.jsonRpcFetchFunc(method, params);
    }
}
//# sourceMappingURL=web3-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js":
/*!*****************************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/websocket-provider.js ***!
  \*****************************************************************************/
/*! exports provided: WebSocketProvider */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebSocketProvider", function() { return WebSocketProvider; });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./json-rpc-provider */ "./node_modules/@ethersproject/providers/lib.esm/json-rpc-provider.js");
/* harmony import */ var _ws__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./ws */ "./node_modules/@ethersproject/providers/lib.esm/ws.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"](_version__WEBPACK_IMPORTED_MODULE_5__["version"]);
/**
 *  Notes:
 *
 *  This provider differs a bit from the polling providers. One main
 *  difference is how it handles consistency. The polling providers
 *  will stall responses to ensure a consistent state, while this
 *  WebSocket provider assumes the connected backend will manage this.
 *
 *  For example, if a polling provider emits an event which indicates
 *  the event occurred in blockhash XXX, a call to fetch that block by
 *  its hash XXX, if not present will retry until it is present. This
 *  can occur when querying a pool of nodes that are mildly out of sync
 *  with each other.
 */
let NextId = 1;
// For more info about the Real-time Event API see:
//   https://geth.ethereum.org/docs/rpc/pubsub
class WebSocketProvider extends _json_rpc_provider__WEBPACK_IMPORTED_MODULE_2__["JsonRpcProvider"] {
    constructor(url, network) {
        // This will be added in the future; please open an issue to expedite
        if (network === "any") {
            logger.throwError("WebSocketProvider does not support 'any' network yet", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "network:any"
            });
        }
        super(url, network);
        this._pollingInterval = -1;
        this._wsReady = false;
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "_websocket", new _ws__WEBPACK_IMPORTED_MODULE_3__["WebSocket"](this.connection.url));
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "_requests", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "_subs", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "_subIds", {});
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "_detectNetwork", super.detectNetwork());
        // Stall sending requests until the socket is open...
        this._websocket.onopen = () => {
            this._wsReady = true;
            Object.keys(this._requests).forEach((id) => {
                this._websocket.send(this._requests[id].payload);
            });
        };
        this._websocket.onmessage = (messageEvent) => {
            const data = messageEvent.data;
            const result = JSON.parse(data);
            if (result.id != null) {
                const id = String(result.id);
                const request = this._requests[id];
                delete this._requests[id];
                if (result.result !== undefined) {
                    request.callback(null, result.result);
                    this.emit("debug", {
                        action: "response",
                        request: JSON.parse(request.payload),
                        response: result.result,
                        provider: this
                    });
                }
                else {
                    let error = null;
                    if (result.error) {
                        error = new Error(result.error.message || "unknown error");
                        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(error, "code", result.error.code || null);
                        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(error, "response", data);
                    }
                    else {
                        error = new Error("unknown error");
                    }
                    request.callback(error, undefined);
                    this.emit("debug", {
                        action: "response",
                        error: error,
                        request: JSON.parse(request.payload),
                        provider: this
                    });
                }
            }
            else if (result.method === "eth_subscription") {
                // Subscription...
                const sub = this._subs[result.params.subscription];
                if (sub) {
                    //this.emit.apply(this,                  );
                    sub.processFunc(result.params.result);
                }
            }
            else {
                console.warn("this should not happen");
            }
        };
        // This Provider does not actually poll, but we want to trigger
        // poll events for things that depend on them (like stalling for
        // block and transaction lookups)
        const fauxPoll = setInterval(() => {
            this.emit("poll");
        }, 1000);
        if (fauxPoll.unref) {
            fauxPoll.unref();
        }
    }
    detectNetwork() {
        return this._detectNetwork;
    }
    get pollingInterval() {
        return 0;
    }
    resetEventsBlock(blockNumber) {
        logger.throwError("cannot reset events block on WebSocketProvider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].errors.UNSUPPORTED_OPERATION, {
            operation: "resetEventBlock"
        });
    }
    set pollingInterval(value) {
        logger.throwError("cannot set polling interval on WebSocketProvider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].errors.UNSUPPORTED_OPERATION, {
            operation: "setPollingInterval"
        });
    }
    poll() {
        return __awaiter(this, void 0, void 0, function* () {
            return null;
        });
    }
    set polling(value) {
        if (!value) {
            return;
        }
        logger.throwError("cannot set polling on WebSocketProvider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].errors.UNSUPPORTED_OPERATION, {
            operation: "setPolling"
        });
    }
    send(method, params) {
        const rid = NextId++;
        return new Promise((resolve, reject) => {
            function callback(error, result) {
                if (error) {
                    return reject(error);
                }
                return resolve(result);
            }
            const payload = JSON.stringify({
                method: method,
                params: params,
                id: rid,
                jsonrpc: "2.0"
            });
            this.emit("debug", {
                action: "request",
                request: JSON.parse(payload),
                provider: this
            });
            this._requests[String(rid)] = { callback, payload };
            if (this._wsReady) {
                this._websocket.send(payload);
            }
        });
    }
    static defaultUrl() {
        return "ws:/\/localhost:8546";
    }
    _subscribe(tag, param, processFunc) {
        return __awaiter(this, void 0, void 0, function* () {
            let subIdPromise = this._subIds[tag];
            if (subIdPromise == null) {
                subIdPromise = Promise.all(param).then((param) => {
                    return this.send("eth_subscribe", param);
                });
                this._subIds[tag] = subIdPromise;
            }
            const subId = yield subIdPromise;
            this._subs[subId] = { tag, processFunc };
        });
    }
    _startEvent(event) {
        switch (event.type) {
            case "block":
                this._subscribe("block", ["newHeads"], (result) => {
                    const blockNumber = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(result.number).toNumber();
                    this._emitted.block = blockNumber;
                    this.emit("block", blockNumber);
                });
                break;
            case "pending":
                this._subscribe("pending", ["newPendingTransactions"], (result) => {
                    this.emit("pending", result);
                });
                break;
            case "filter":
                this._subscribe(event.tag, ["logs", this._getFilter(event.filter)], (result) => {
                    if (result.removed == null) {
                        result.removed = false;
                    }
                    this.emit(event.filter, this.formatter.filterLog(result));
                });
                break;
            case "tx": {
                const emitReceipt = (event) => {
                    const hash = event.hash;
                    this.getTransactionReceipt(hash).then((receipt) => {
                        if (!receipt) {
                            return;
                        }
                        this.emit(hash, receipt);
                    });
                };
                // In case it is already mined
                emitReceipt(event);
                // To keep things simple, we start up a single newHeads subscription
                // to keep an eye out for transactions we are watching for.
                // Starting a subscription for an event (i.e. "tx") that is already
                // running is (basically) a nop.
                this._subscribe("tx", ["newHeads"], (result) => {
                    this._events.filter((e) => (e.type === "tx")).forEach(emitReceipt);
                });
                break;
            }
            // Nothing is needed
            case "debug":
            case "poll":
            case "willPoll":
            case "didPoll":
            case "error":
                break;
            default:
                console.log("unhandled:", event);
                break;
        }
    }
    _stopEvent(event) {
        let tag = event.tag;
        if (event.type === "tx") {
            // There are remaining transaction event listeners
            if (this._events.filter((e) => (e.type === "tx")).length) {
                return;
            }
            tag = "tx";
        }
        else if (this.listenerCount(event.event)) {
            // There are remaining event listeners
            return;
        }
        const subId = this._subIds[tag];
        if (!subId) {
            return;
        }
        delete this._subIds[tag];
        subId.then((subId) => {
            if (!this._subs[subId]) {
                return;
            }
            delete this._subs[subId];
            this.send("eth_unsubscribe", [subId]);
        });
    }
    destroy() {
        return __awaiter(this, void 0, void 0, function* () {
            // Wait until we have connected before trying to disconnect
            if (this._websocket.readyState === _ws__WEBPACK_IMPORTED_MODULE_3__["WebSocket"].CONNECTING) {
                yield (new Promise((resolve) => {
                    this._websocket.onopen = function () {
                        resolve(true);
                    };
                    this._websocket.onerror = function () {
                        resolve(false);
                    };
                }));
            }
            // Hangup
            // See: https://developer.mozilla.org/en-US/docs/Web/API/CloseEvent#Status_codes
            this._websocket.close(1000);
        });
    }
}
//# sourceMappingURL=websocket-provider.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/providers/lib.esm/ws.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/providers/lib.esm/ws.js ***!
  \*************************************************************/
/*! exports provided: WebSocket */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebSocket", function() { return WS; });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/providers/lib.esm/_version.js");



let WS = null;
try {
    WS = WebSocket;
    if (WS == null) {
        throw new Error("inject please");
    }
}
catch (error) {
    const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__["Logger"](_version__WEBPACK_IMPORTED_MODULE_1__["version"]);
    WS = function () {
        logger.throwError("WebSockets not supported in this environment", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_0__["Logger"].errors.UNSUPPORTED_OPERATION, {
            operation: "new WebSocket()"
        });
    };
}
//export default WS;
//module.exports = WS;

//# sourceMappingURL=ws.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/random/lib.esm/_version.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/random/lib.esm/_version.js ***!
  \****************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "random/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/random/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/random/lib.esm/index.js ***!
  \*************************************************************/
/*! exports provided: randomBytes, shuffled */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _random__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./random */ "./node_modules/@ethersproject/random/lib.esm/random.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomBytes", function() { return _random__WEBPACK_IMPORTED_MODULE_0__["randomBytes"]; });

/* harmony import */ var _shuffle__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./shuffle */ "./node_modules/@ethersproject/random/lib.esm/shuffle.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffled", function() { return _shuffle__WEBPACK_IMPORTED_MODULE_1__["shuffled"]; });




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/random/lib.esm/random.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/random/lib.esm/random.js ***!
  \**************************************************************/
/*! exports provided: randomBytes */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "randomBytes", function() { return randomBytes; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/random/lib.esm/_version.js");




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"](_version__WEBPACK_IMPORTED_MODULE_2__["version"]);
// Debugging line for testing browser lib in node
//const window = { crypto: { getRandomValues: () => { } } };
let anyGlobal = null;
try {
    anyGlobal = window;
    if (anyGlobal == null) {
        throw new Error("try next");
    }
}
catch (error) {
    try {
        anyGlobal = global;
        if (anyGlobal == null) {
            throw new Error("try next");
        }
    }
    catch (error) {
        anyGlobal = {};
    }
}
let crypto = anyGlobal.crypto || anyGlobal.msCrypto;
if (!crypto || !crypto.getRandomValues) {
    logger.warn("WARNING: Missing strong random number source");
    crypto = {
        getRandomValues: function (buffer) {
            return logger.throwError("no secure random source avaialble", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.UNSUPPORTED_OPERATION, {
                operation: "crypto.getRandomValues"
            });
        }
    };
}
function randomBytes(length) {
    if (length <= 0 || length > 1024 || (length % 1) || length != length) {
        logger.throwArgumentError("invalid length", "length", length);
    }
    const result = new Uint8Array(length);
    crypto.getRandomValues(result);
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(result);
}
;
//# sourceMappingURL=random.js.map
/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/global.js */ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@ethersproject/random/lib.esm/shuffle.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/random/lib.esm/shuffle.js ***!
  \***************************************************************/
/*! exports provided: shuffled */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "shuffled", function() { return shuffled; });

function shuffled(array) {
    array = array.slice();
    for (let i = array.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const tmp = array[i];
        array[i] = array[j];
        array[j] = tmp;
    }
    return array;
}
//# sourceMappingURL=shuffle.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/rlp/lib.esm/_version.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/rlp/lib.esm/_version.js ***!
  \*************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "rlp/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/rlp/lib.esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethersproject/rlp/lib.esm/index.js ***!
  \**********************************************************/
/*! exports provided: encode, decode */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "encode", function() { return encode; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "decode", function() { return decode; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/rlp/lib.esm/_version.js");

//See: https://github.com/ethereum/wiki/wiki/RLP



const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"](_version__WEBPACK_IMPORTED_MODULE_2__["version"]);
function arrayifyInteger(value) {
    const result = [];
    while (value) {
        result.unshift(value & 0xff);
        value >>= 8;
    }
    return result;
}
function unarrayifyInteger(data, offset, length) {
    let result = 0;
    for (let i = 0; i < length; i++) {
        result = (result * 256) + data[offset + i];
    }
    return result;
}
function _encode(object) {
    if (Array.isArray(object)) {
        let payload = [];
        object.forEach(function (child) {
            payload = payload.concat(_encode(child));
        });
        if (payload.length <= 55) {
            payload.unshift(0xc0 + payload.length);
            return payload;
        }
        const length = arrayifyInteger(payload.length);
        length.unshift(0xf7 + length.length);
        return length.concat(payload);
    }
    if (!Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["isBytesLike"])(object)) {
        logger.throwArgumentError("RLP object must be BytesLike", "object", object);
    }
    const data = Array.prototype.slice.call(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(object));
    if (data.length === 1 && data[0] <= 0x7f) {
        return data;
    }
    else if (data.length <= 55) {
        data.unshift(0x80 + data.length);
        return data;
    }
    const length = arrayifyInteger(data.length);
    length.unshift(0xb7 + length.length);
    return length.concat(data);
}
function encode(object) {
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexlify"])(_encode(object));
}
function _decodeChildren(data, offset, childOffset, length) {
    const result = [];
    while (childOffset < offset + 1 + length) {
        const decoded = _decode(data, childOffset);
        result.push(decoded.result);
        childOffset += decoded.consumed;
        if (childOffset > offset + 1 + length) {
            logger.throwError("child data too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.BUFFER_OVERRUN, {});
        }
    }
    return { consumed: (1 + length), result: result };
}
// returns { consumed: number, result: Object }
function _decode(data, offset) {
    if (data.length === 0) {
        logger.throwError("data too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.BUFFER_OVERRUN, {});
    }
    // Array with extra length prefix
    if (data[offset] >= 0xf8) {
        const lengthLength = data[offset] - 0xf7;
        if (offset + 1 + lengthLength > data.length) {
            logger.throwError("data short segment too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger.throwError("data long segment too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1 + lengthLength, lengthLength + length);
    }
    else if (data[offset] >= 0xc0) {
        const length = data[offset] - 0xc0;
        if (offset + 1 + length > data.length) {
            logger.throwError("data array too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.BUFFER_OVERRUN, {});
        }
        return _decodeChildren(data, offset, offset + 1, length);
    }
    else if (data[offset] >= 0xb8) {
        const lengthLength = data[offset] - 0xb7;
        if (offset + 1 + lengthLength > data.length) {
            logger.throwError("data array too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.BUFFER_OVERRUN, {});
        }
        const length = unarrayifyInteger(data, offset + 1, lengthLength);
        if (offset + 1 + lengthLength + length > data.length) {
            logger.throwError("data array too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.BUFFER_OVERRUN, {});
        }
        const result = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexlify"])(data.slice(offset + 1 + lengthLength, offset + 1 + lengthLength + length));
        return { consumed: (1 + lengthLength + length), result: result };
    }
    else if (data[offset] >= 0x80) {
        const length = data[offset] - 0x80;
        if (offset + 1 + length > data.length) {
            logger.throwError("data too short", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"].errors.BUFFER_OVERRUN, {});
        }
        const result = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexlify"])(data.slice(offset + 1, offset + 1 + length));
        return { consumed: (1 + length), result: result };
    }
    return { consumed: 1, result: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["hexlify"])(data[offset]) };
}
function decode(data) {
    const bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(data);
    const decoded = _decode(bytes, 0);
    if (decoded.consumed !== bytes.length) {
        logger.throwArgumentError("invalid rlp data", "data", data);
    }
    return decoded.result;
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/sha2/lib.esm/_version.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/sha2/lib.esm/_version.js ***!
  \**************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "sha2/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/sha2/lib.esm/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ethersproject/sha2/lib.esm/index.js ***!
  \***********************************************************/
/*! exports provided: computeHmac, ripemd160, sha256, sha512, SupportedAlgorithm */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _sha2__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/sha2.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeHmac", function() { return _sha2__WEBPACK_IMPORTED_MODULE_0__["computeHmac"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ripemd160", function() { return _sha2__WEBPACK_IMPORTED_MODULE_0__["ripemd160"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sha256", function() { return _sha2__WEBPACK_IMPORTED_MODULE_0__["sha256"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sha512", function() { return _sha2__WEBPACK_IMPORTED_MODULE_0__["sha512"]; });

/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ "./node_modules/@ethersproject/sha2/lib.esm/types.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SupportedAlgorithm", function() { return _types__WEBPACK_IMPORTED_MODULE_1__["SupportedAlgorithm"]; });




//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/sha2/lib.esm/sha2.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethersproject/sha2/lib.esm/sha2.js ***!
  \**********************************************************/
/*! exports provided: ripemd160, sha256, sha512, computeHmac */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ripemd160", function() { return ripemd160; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sha256", function() { return sha256; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sha512", function() { return sha512; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeHmac", function() { return computeHmac; });
/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(hash_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./types */ "./node_modules/@ethersproject/sha2/lib.esm/types.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/sha2/lib.esm/_version.js");


//const _ripemd160 = _hash.ripemd160;




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__["Logger"](_version__WEBPACK_IMPORTED_MODULE_4__["version"]);
function ripemd160(data) {
    return "0x" + (hash_js__WEBPACK_IMPORTED_MODULE_0___default.a.ripemd160().update(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(data)).digest("hex"));
}
function sha256(data) {
    return "0x" + (hash_js__WEBPACK_IMPORTED_MODULE_0___default.a.sha256().update(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(data)).digest("hex"));
}
function sha512(data) {
    return "0x" + (hash_js__WEBPACK_IMPORTED_MODULE_0___default.a.sha512().update(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(data)).digest("hex"));
}
function computeHmac(algorithm, key, data) {
    if (!_types__WEBPACK_IMPORTED_MODULE_2__["SupportedAlgorithm"][algorithm]) {
        logger.throwError("unsupported algorithm " + algorithm, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__["Logger"].errors.UNSUPPORTED_OPERATION, {
            operation: "hmac",
            algorithm: algorithm
        });
    }
    return "0x" + hash_js__WEBPACK_IMPORTED_MODULE_0___default.a.hmac(hash_js__WEBPACK_IMPORTED_MODULE_0___default.a[algorithm], Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(key)).update(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(data)).digest("hex");
}
//# sourceMappingURL=sha2.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/sha2/lib.esm/types.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ethersproject/sha2/lib.esm/types.js ***!
  \***********************************************************/
/*! exports provided: SupportedAlgorithm */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SupportedAlgorithm", function() { return SupportedAlgorithm; });
var SupportedAlgorithm;
(function (SupportedAlgorithm) {
    SupportedAlgorithm["sha256"] = "sha256";
    SupportedAlgorithm["sha512"] = "sha512";
})(SupportedAlgorithm || (SupportedAlgorithm = {}));
;
//# sourceMappingURL=types.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/signing-key/lib.esm/_version.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/signing-key/lib.esm/_version.js ***!
  \*********************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "signing-key/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/signing-key/lib.esm/elliptic.js":
/*!*********************************************************************!*\
  !*** ./node_modules/@ethersproject/signing-key/lib.esm/elliptic.js ***!
  \*********************************************************************/
/*! exports provided: EC */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* WEBPACK VAR INJECTION */(function(global) {/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EC", function() { return EC$1; });
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! bn.js */ "./node_modules/bn.js/lib/bn.js");
/* harmony import */ var bn_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(bn_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! hash.js */ "./node_modules/hash.js/lib/hash.js");
/* harmony import */ var hash_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(hash_js__WEBPACK_IMPORTED_MODULE_1__);



var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

function getDefaultExportFromCjs (x) {
	return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
}

function createCommonjsModule(fn, basedir, module) {
	return module = {
		path: basedir,
		exports: {},
		require: function (path, base) {
			return commonjsRequire(path, (base === undefined || base === null) ? module.path : base);
		}
	}, fn(module, module.exports), module.exports;
}

function getDefaultExportFromNamespaceIfPresent (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') ? n['default'] : n;
}

function getDefaultExportFromNamespaceIfNotNamed (n) {
	return n && Object.prototype.hasOwnProperty.call(n, 'default') && Object.keys(n).length === 1 ? n['default'] : n;
}

function getAugmentedNamespace(n) {
	if (n.__esModule) return n;
	var a = Object.defineProperty({}, '__esModule', {value: true});
	Object.keys(n).forEach(function (k) {
		var d = Object.getOwnPropertyDescriptor(n, k);
		Object.defineProperty(a, k, d.get ? d : {
			enumerable: true,
			get: function () {
				return n[k];
			}
		});
	});
	return a;
}

function commonjsRequire () {
	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
}

var minimalisticAssert = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};

var utils_1 = createCommonjsModule(function (module, exports) {
'use strict';

var utils = exports;

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg !== 'string') {
    for (var i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
    return res;
  }
  if (enc === 'hex') {
    msg = msg.replace(/[^a-z0-9]+/ig, '');
    if (msg.length % 2 !== 0)
      msg = '0' + msg;
    for (var i = 0; i < msg.length; i += 2)
      res.push(parseInt(msg[i] + msg[i + 1], 16));
  } else {
    for (var i = 0; i < msg.length; i++) {
      var c = msg.charCodeAt(i);
      var hi = c >> 8;
      var lo = c & 0xff;
      if (hi)
        res.push(hi, lo);
      else
        res.push(lo);
    }
  }
  return res;
}
utils.toArray = toArray;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
utils.zero2 = zero2;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
utils.toHex = toHex;

utils.encode = function encode(arr, enc) {
  if (enc === 'hex')
    return toHex(arr);
  else
    return arr;
};
});

var utils_1$1 = createCommonjsModule(function (module, exports) {
'use strict';

var utils = exports;




utils.assert = minimalisticAssert;
utils.toArray = utils_1.toArray;
utils.zero2 = utils_1.zero2;
utils.toHex = utils_1.toHex;
utils.encode = utils_1.encode;

// Represent num in a w-NAF form
function getNAF(num, w, bits) {
  var naf = new Array(Math.max(num.bitLength(), bits) + 1);
  naf.fill(0);

  var ws = 1 << (w + 1);
  var k = num.clone();

  for (var i = 0; i < naf.length; i++) {
    var z;
    var mod = k.andln(ws - 1);
    if (k.isOdd()) {
      if (mod > (ws >> 1) - 1)
        z = (ws >> 1) - mod;
      else
        z = mod;
      k.isubn(z);
    } else {
      z = 0;
    }

    naf[i] = z;
    k.iushrn(1);
  }

  return naf;
}
utils.getNAF = getNAF;

// Represent k1, k2 in a Joint Sparse Form
function getJSF(k1, k2) {
  var jsf = [
    [],
    [],
  ];

  k1 = k1.clone();
  k2 = k2.clone();
  var d1 = 0;
  var d2 = 0;
  var m8;
  while (k1.cmpn(-d1) > 0 || k2.cmpn(-d2) > 0) {
    // First phase
    var m14 = (k1.andln(3) + d1) & 3;
    var m24 = (k2.andln(3) + d2) & 3;
    if (m14 === 3)
      m14 = -1;
    if (m24 === 3)
      m24 = -1;
    var u1;
    if ((m14 & 1) === 0) {
      u1 = 0;
    } else {
      m8 = (k1.andln(7) + d1) & 7;
      if ((m8 === 3 || m8 === 5) && m24 === 2)
        u1 = -m14;
      else
        u1 = m14;
    }
    jsf[0].push(u1);

    var u2;
    if ((m24 & 1) === 0) {
      u2 = 0;
    } else {
      m8 = (k2.andln(7) + d2) & 7;
      if ((m8 === 3 || m8 === 5) && m14 === 2)
        u2 = -m24;
      else
        u2 = m24;
    }
    jsf[1].push(u2);

    // Second phase
    if (2 * d1 === u1 + 1)
      d1 = 1 - d1;
    if (2 * d2 === u2 + 1)
      d2 = 1 - d2;
    k1.iushrn(1);
    k2.iushrn(1);
  }

  return jsf;
}
utils.getJSF = getJSF;

function cachedProperty(obj, name, computer) {
  var key = '_' + name;
  obj.prototype[name] = function cachedProperty() {
    return this[key] !== undefined ? this[key] :
      this[key] = computer.call(this);
  };
}
utils.cachedProperty = cachedProperty;

function parseBytes(bytes) {
  return typeof bytes === 'string' ? utils.toArray(bytes, 'hex') :
    bytes;
}
utils.parseBytes = parseBytes;

function intFromLE(bytes) {
  return new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(bytes, 'hex', 'le');
}
utils.intFromLE = intFromLE;
});

'use strict';



var getNAF = utils_1$1.getNAF;
var getJSF = utils_1$1.getJSF;
var assert$1 = utils_1$1.assert;

function BaseCurve(type, conf) {
  this.type = type;
  this.p = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(conf.p, 16);

  // Use Montgomery, when there is no fast reduction for the prime
  this.red = conf.prime ? bn_js__WEBPACK_IMPORTED_MODULE_0___default.a.red(conf.prime) : bn_js__WEBPACK_IMPORTED_MODULE_0___default.a.mont(this.p);

  // Useful for many curves
  this.zero = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(0).toRed(this.red);
  this.one = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(1).toRed(this.red);
  this.two = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(2).toRed(this.red);

  // Curve configuration, optional
  this.n = conf.n && new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(conf.n, 16);
  this.g = conf.g && this.pointFromJSON(conf.g, conf.gRed);

  // Temporary arrays
  this._wnafT1 = new Array(4);
  this._wnafT2 = new Array(4);
  this._wnafT3 = new Array(4);
  this._wnafT4 = new Array(4);

  this._bitLength = this.n ? this.n.bitLength() : 0;

  // Generalized Greg Maxwell's trick
  var adjustCount = this.n && this.p.div(this.n);
  if (!adjustCount || adjustCount.cmpn(100) > 0) {
    this.redN = null;
  } else {
    this._maxwellTrick = true;
    this.redN = this.n.toRed(this.red);
  }
}
var base = BaseCurve;

BaseCurve.prototype.point = function point() {
  throw new Error('Not implemented');
};

BaseCurve.prototype.validate = function validate() {
  throw new Error('Not implemented');
};

BaseCurve.prototype._fixedNafMul = function _fixedNafMul(p, k) {
  assert$1(p.precomputed);
  var doubles = p._getDoubles();

  var naf = getNAF(k, 1, this._bitLength);
  var I = (1 << (doubles.step + 1)) - (doubles.step % 2 === 0 ? 2 : 1);
  I /= 3;

  // Translate into more windowed form
  var repr = [];
  var j;
  var nafW;
  for (j = 0; j < naf.length; j += doubles.step) {
    nafW = 0;
    for (var l = j + doubles.step - 1; l >= j; l--)
      nafW = (nafW << 1) + naf[l];
    repr.push(nafW);
  }

  var a = this.jpoint(null, null, null);
  var b = this.jpoint(null, null, null);
  for (var i = I; i > 0; i--) {
    for (j = 0; j < repr.length; j++) {
      nafW = repr[j];
      if (nafW === i)
        b = b.mixedAdd(doubles.points[j]);
      else if (nafW === -i)
        b = b.mixedAdd(doubles.points[j].neg());
    }
    a = a.add(b);
  }
  return a.toP();
};

BaseCurve.prototype._wnafMul = function _wnafMul(p, k) {
  var w = 4;

  // Precompute window
  var nafPoints = p._getNAFPoints(w);
  w = nafPoints.wnd;
  var wnd = nafPoints.points;

  // Get NAF form
  var naf = getNAF(k, w, this._bitLength);

  // Add `this`*(N+1) for every w-NAF index
  var acc = this.jpoint(null, null, null);
  for (var i = naf.length - 1; i >= 0; i--) {
    // Count zeroes
    for (var l = 0; i >= 0 && naf[i] === 0; i--)
      l++;
    if (i >= 0)
      l++;
    acc = acc.dblp(l);

    if (i < 0)
      break;
    var z = naf[i];
    assert$1(z !== 0);
    if (p.type === 'affine') {
      // J +- P
      if (z > 0)
        acc = acc.mixedAdd(wnd[(z - 1) >> 1]);
      else
        acc = acc.mixedAdd(wnd[(-z - 1) >> 1].neg());
    } else {
      // J +- J
      if (z > 0)
        acc = acc.add(wnd[(z - 1) >> 1]);
      else
        acc = acc.add(wnd[(-z - 1) >> 1].neg());
    }
  }
  return p.type === 'affine' ? acc.toP() : acc;
};

BaseCurve.prototype._wnafMulAdd = function _wnafMulAdd(defW,
  points,
  coeffs,
  len,
  jacobianResult) {
  var wndWidth = this._wnafT1;
  var wnd = this._wnafT2;
  var naf = this._wnafT3;

  // Fill all arrays
  var max = 0;
  var i;
  var j;
  var p;
  for (i = 0; i < len; i++) {
    p = points[i];
    var nafPoints = p._getNAFPoints(defW);
    wndWidth[i] = nafPoints.wnd;
    wnd[i] = nafPoints.points;
  }

  // Comb small window NAFs
  for (i = len - 1; i >= 1; i -= 2) {
    var a = i - 1;
    var b = i;
    if (wndWidth[a] !== 1 || wndWidth[b] !== 1) {
      naf[a] = getNAF(coeffs[a], wndWidth[a], this._bitLength);
      naf[b] = getNAF(coeffs[b], wndWidth[b], this._bitLength);
      max = Math.max(naf[a].length, max);
      max = Math.max(naf[b].length, max);
      continue;
    }

    var comb = [
      points[a], /* 1 */
      null, /* 3 */
      null, /* 5 */
      points[b], /* 7 */
    ];

    // Try to avoid Projective points, if possible
    if (points[a].y.cmp(points[b].y) === 0) {
      comb[1] = points[a].add(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    } else if (points[a].y.cmp(points[b].y.redNeg()) === 0) {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].add(points[b].neg());
    } else {
      comb[1] = points[a].toJ().mixedAdd(points[b]);
      comb[2] = points[a].toJ().mixedAdd(points[b].neg());
    }

    var index = [
      -3, /* -1 -1 */
      -1, /* -1 0 */
      -5, /* -1 1 */
      -7, /* 0 -1 */
      0, /* 0 0 */
      7, /* 0 1 */
      5, /* 1 -1 */
      1, /* 1 0 */
      3,  /* 1 1 */
    ];

    var jsf = getJSF(coeffs[a], coeffs[b]);
    max = Math.max(jsf[0].length, max);
    naf[a] = new Array(max);
    naf[b] = new Array(max);
    for (j = 0; j < max; j++) {
      var ja = jsf[0][j] | 0;
      var jb = jsf[1][j] | 0;

      naf[a][j] = index[(ja + 1) * 3 + (jb + 1)];
      naf[b][j] = 0;
      wnd[a] = comb;
    }
  }

  var acc = this.jpoint(null, null, null);
  var tmp = this._wnafT4;
  for (i = max; i >= 0; i--) {
    var k = 0;

    while (i >= 0) {
      var zero = true;
      for (j = 0; j < len; j++) {
        tmp[j] = naf[j][i] | 0;
        if (tmp[j] !== 0)
          zero = false;
      }
      if (!zero)
        break;
      k++;
      i--;
    }
    if (i >= 0)
      k++;
    acc = acc.dblp(k);
    if (i < 0)
      break;

    for (j = 0; j < len; j++) {
      var z = tmp[j];
      p;
      if (z === 0)
        continue;
      else if (z > 0)
        p = wnd[j][(z - 1) >> 1];
      else if (z < 0)
        p = wnd[j][(-z - 1) >> 1].neg();

      if (p.type === 'affine')
        acc = acc.mixedAdd(p);
      else
        acc = acc.add(p);
    }
  }
  // Zeroify references
  for (i = 0; i < len; i++)
    wnd[i] = null;

  if (jacobianResult)
    return acc;
  else
    return acc.toP();
};

function BasePoint(curve, type) {
  this.curve = curve;
  this.type = type;
  this.precomputed = null;
}
BaseCurve.BasePoint = BasePoint;

BasePoint.prototype.eq = function eq(/*other*/) {
  throw new Error('Not implemented');
};

BasePoint.prototype.validate = function validate() {
  return this.curve.validate(this);
};

BaseCurve.prototype.decodePoint = function decodePoint(bytes, enc) {
  bytes = utils_1$1.toArray(bytes, enc);

  var len = this.p.byteLength();

  // uncompressed, hybrid-odd, hybrid-even
  if ((bytes[0] === 0x04 || bytes[0] === 0x06 || bytes[0] === 0x07) &&
      bytes.length - 1 === 2 * len) {
    if (bytes[0] === 0x06)
      assert$1(bytes[bytes.length - 1] % 2 === 0);
    else if (bytes[0] === 0x07)
      assert$1(bytes[bytes.length - 1] % 2 === 1);

    var res =  this.point(bytes.slice(1, 1 + len),
      bytes.slice(1 + len, 1 + 2 * len));

    return res;
  } else if ((bytes[0] === 0x02 || bytes[0] === 0x03) &&
              bytes.length - 1 === len) {
    return this.pointFromX(bytes.slice(1, 1 + len), bytes[0] === 0x03);
  }
  throw new Error('Unknown point format');
};

BasePoint.prototype.encodeCompressed = function encodeCompressed(enc) {
  return this.encode(enc, true);
};

BasePoint.prototype._encode = function _encode(compact) {
  var len = this.curve.p.byteLength();
  var x = this.getX().toArray('be', len);

  if (compact)
    return [ this.getY().isEven() ? 0x02 : 0x03 ].concat(x);

  return [ 0x04 ].concat(x, this.getY().toArray('be', len));
};

BasePoint.prototype.encode = function encode(enc, compact) {
  return utils_1$1.encode(this._encode(compact), enc);
};

BasePoint.prototype.precompute = function precompute(power) {
  if (this.precomputed)
    return this;

  var precomputed = {
    doubles: null,
    naf: null,
    beta: null,
  };
  precomputed.naf = this._getNAFPoints(8);
  precomputed.doubles = this._getDoubles(4, power);
  precomputed.beta = this._getBeta();
  this.precomputed = precomputed;

  return this;
};

BasePoint.prototype._hasDoubles = function _hasDoubles(k) {
  if (!this.precomputed)
    return false;

  var doubles = this.precomputed.doubles;
  if (!doubles)
    return false;

  return doubles.points.length >= Math.ceil((k.bitLength() + 1) / doubles.step);
};

BasePoint.prototype._getDoubles = function _getDoubles(step, power) {
  if (this.precomputed && this.precomputed.doubles)
    return this.precomputed.doubles;

  var doubles = [ this ];
  var acc = this;
  for (var i = 0; i < power; i += step) {
    for (var j = 0; j < step; j++)
      acc = acc.dbl();
    doubles.push(acc);
  }
  return {
    step: step,
    points: doubles,
  };
};

BasePoint.prototype._getNAFPoints = function _getNAFPoints(wnd) {
  if (this.precomputed && this.precomputed.naf)
    return this.precomputed.naf;

  var res = [ this ];
  var max = (1 << wnd) - 1;
  var dbl = max === 1 ? null : this.dbl();
  for (var i = 1; i < max; i++)
    res[i] = res[i - 1].add(dbl);
  return {
    wnd: wnd,
    points: res,
  };
};

BasePoint.prototype._getBeta = function _getBeta() {
  return null;
};

BasePoint.prototype.dblp = function dblp(k) {
  var r = this;
  for (var i = 0; i < k; i++)
    r = r.dbl();
  return r;
};

var inherits_browser = createCommonjsModule(function (module) {
if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      });
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor;
      var TempCtor = function () {};
      TempCtor.prototype = superCtor.prototype;
      ctor.prototype = new TempCtor();
      ctor.prototype.constructor = ctor;
    }
  };
}
});

'use strict';






var assert$2 = utils_1$1.assert;

function ShortCurve(conf) {
  base.call(this, 'short', conf);

  this.a = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(conf.a, 16).toRed(this.red);
  this.b = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(conf.b, 16).toRed(this.red);
  this.tinv = this.two.redInvm();

  this.zeroA = this.a.fromRed().cmpn(0) === 0;
  this.threeA = this.a.fromRed().sub(this.p).cmpn(-3) === 0;

  // If the curve is endomorphic, precalculate beta and lambda
  this.endo = this._getEndomorphism(conf);
  this._endoWnafT1 = new Array(4);
  this._endoWnafT2 = new Array(4);
}
inherits_browser(ShortCurve, base);
var short_1 = ShortCurve;

ShortCurve.prototype._getEndomorphism = function _getEndomorphism(conf) {
  // No efficient endomorphism
  if (!this.zeroA || !this.g || !this.n || this.p.modn(3) !== 1)
    return;

  // Compute beta and lambda, that lambda * P = (beta * Px; Py)
  var beta;
  var lambda;
  if (conf.beta) {
    beta = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(conf.beta, 16).toRed(this.red);
  } else {
    var betas = this._getEndoRoots(this.p);
    // Choose the smallest beta
    beta = betas[0].cmp(betas[1]) < 0 ? betas[0] : betas[1];
    beta = beta.toRed(this.red);
  }
  if (conf.lambda) {
    lambda = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(conf.lambda, 16);
  } else {
    // Choose the lambda that is matching selected beta
    var lambdas = this._getEndoRoots(this.n);
    if (this.g.mul(lambdas[0]).x.cmp(this.g.x.redMul(beta)) === 0) {
      lambda = lambdas[0];
    } else {
      lambda = lambdas[1];
      assert$2(this.g.mul(lambda).x.cmp(this.g.x.redMul(beta)) === 0);
    }
  }

  // Get basis vectors, used for balanced length-two representation
  var basis;
  if (conf.basis) {
    basis = conf.basis.map(function(vec) {
      return {
        a: new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(vec.a, 16),
        b: new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(vec.b, 16),
      };
    });
  } else {
    basis = this._getEndoBasis(lambda);
  }

  return {
    beta: beta,
    lambda: lambda,
    basis: basis,
  };
};

ShortCurve.prototype._getEndoRoots = function _getEndoRoots(num) {
  // Find roots of for x^2 + x + 1 in F
  // Root = (-1 +- Sqrt(-3)) / 2
  //
  var red = num === this.p ? this.red : bn_js__WEBPACK_IMPORTED_MODULE_0___default.a.mont(num);
  var tinv = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(2).toRed(red).redInvm();
  var ntinv = tinv.redNeg();

  var s = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(3).toRed(red).redNeg().redSqrt().redMul(tinv);

  var l1 = ntinv.redAdd(s).fromRed();
  var l2 = ntinv.redSub(s).fromRed();
  return [ l1, l2 ];
};

ShortCurve.prototype._getEndoBasis = function _getEndoBasis(lambda) {
  // aprxSqrt >= sqrt(this.n)
  var aprxSqrt = this.n.ushrn(Math.floor(this.n.bitLength() / 2));

  // 3.74
  // Run EGCD, until r(L + 1) < aprxSqrt
  var u = lambda;
  var v = this.n.clone();
  var x1 = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(1);
  var y1 = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(0);
  var x2 = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(0);
  var y2 = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(1);

  // NOTE: all vectors are roots of: a + b * lambda = 0 (mod n)
  var a0;
  var b0;
  // First vector
  var a1;
  var b1;
  // Second vector
  var a2;
  var b2;

  var prevR;
  var i = 0;
  var r;
  var x;
  while (u.cmpn(0) !== 0) {
    var q = v.div(u);
    r = v.sub(q.mul(u));
    x = x2.sub(q.mul(x1));
    var y = y2.sub(q.mul(y1));

    if (!a1 && r.cmp(aprxSqrt) < 0) {
      a0 = prevR.neg();
      b0 = x1;
      a1 = r.neg();
      b1 = x;
    } else if (a1 && ++i === 2) {
      break;
    }
    prevR = r;

    v = u;
    u = r;
    x2 = x1;
    x1 = x;
    y2 = y1;
    y1 = y;
  }
  a2 = r.neg();
  b2 = x;

  var len1 = a1.sqr().add(b1.sqr());
  var len2 = a2.sqr().add(b2.sqr());
  if (len2.cmp(len1) >= 0) {
    a2 = a0;
    b2 = b0;
  }

  // Normalize signs
  if (a1.negative) {
    a1 = a1.neg();
    b1 = b1.neg();
  }
  if (a2.negative) {
    a2 = a2.neg();
    b2 = b2.neg();
  }

  return [
    { a: a1, b: b1 },
    { a: a2, b: b2 },
  ];
};

ShortCurve.prototype._endoSplit = function _endoSplit(k) {
  var basis = this.endo.basis;
  var v1 = basis[0];
  var v2 = basis[1];

  var c1 = v2.b.mul(k).divRound(this.n);
  var c2 = v1.b.neg().mul(k).divRound(this.n);

  var p1 = c1.mul(v1.a);
  var p2 = c2.mul(v2.a);
  var q1 = c1.mul(v1.b);
  var q2 = c2.mul(v2.b);

  // Calculate answer
  var k1 = k.sub(p1).sub(p2);
  var k2 = q1.add(q2).neg();
  return { k1: k1, k2: k2 };
};

ShortCurve.prototype.pointFromX = function pointFromX(x, odd) {
  x = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(x, 16);
  if (!x.red)
    x = x.toRed(this.red);

  var y2 = x.redSqr().redMul(x).redIAdd(x.redMul(this.a)).redIAdd(this.b);
  var y = y2.redSqrt();
  if (y.redSqr().redSub(y2).cmp(this.zero) !== 0)
    throw new Error('invalid point');

  // XXX Is there any way to tell if the number is odd without converting it
  // to non-red form?
  var isOdd = y.fromRed().isOdd();
  if (odd && !isOdd || !odd && isOdd)
    y = y.redNeg();

  return this.point(x, y);
};

ShortCurve.prototype.validate = function validate(point) {
  if (point.inf)
    return true;

  var x = point.x;
  var y = point.y;

  var ax = this.a.redMul(x);
  var rhs = x.redSqr().redMul(x).redIAdd(ax).redIAdd(this.b);
  return y.redSqr().redISub(rhs).cmpn(0) === 0;
};

ShortCurve.prototype._endoWnafMulAdd =
    function _endoWnafMulAdd(points, coeffs, jacobianResult) {
      var npoints = this._endoWnafT1;
      var ncoeffs = this._endoWnafT2;
      for (var i = 0; i < points.length; i++) {
        var split = this._endoSplit(coeffs[i]);
        var p = points[i];
        var beta = p._getBeta();

        if (split.k1.negative) {
          split.k1.ineg();
          p = p.neg(true);
        }
        if (split.k2.negative) {
          split.k2.ineg();
          beta = beta.neg(true);
        }

        npoints[i * 2] = p;
        npoints[i * 2 + 1] = beta;
        ncoeffs[i * 2] = split.k1;
        ncoeffs[i * 2 + 1] = split.k2;
      }
      var res = this._wnafMulAdd(1, npoints, ncoeffs, i * 2, jacobianResult);

      // Clean-up references to points and coefficients
      for (var j = 0; j < i * 2; j++) {
        npoints[j] = null;
        ncoeffs[j] = null;
      }
      return res;
    };

function Point(curve, x, y, isRed) {
  base.BasePoint.call(this, curve, 'affine');
  if (x === null && y === null) {
    this.x = null;
    this.y = null;
    this.inf = true;
  } else {
    this.x = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(x, 16);
    this.y = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(y, 16);
    // Force redgomery representation when loading from JSON
    if (isRed) {
      this.x.forceRed(this.curve.red);
      this.y.forceRed(this.curve.red);
    }
    if (!this.x.red)
      this.x = this.x.toRed(this.curve.red);
    if (!this.y.red)
      this.y = this.y.toRed(this.curve.red);
    this.inf = false;
  }
}
inherits_browser(Point, base.BasePoint);

ShortCurve.prototype.point = function point(x, y, isRed) {
  return new Point(this, x, y, isRed);
};

ShortCurve.prototype.pointFromJSON = function pointFromJSON(obj, red) {
  return Point.fromJSON(this, obj, red);
};

Point.prototype._getBeta = function _getBeta() {
  if (!this.curve.endo)
    return;

  var pre = this.precomputed;
  if (pre && pre.beta)
    return pre.beta;

  var beta = this.curve.point(this.x.redMul(this.curve.endo.beta), this.y);
  if (pre) {
    var curve = this.curve;
    var endoMul = function(p) {
      return curve.point(p.x.redMul(curve.endo.beta), p.y);
    };
    pre.beta = beta;
    beta.precomputed = {
      beta: null,
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(endoMul),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(endoMul),
      },
    };
  }
  return beta;
};

Point.prototype.toJSON = function toJSON() {
  if (!this.precomputed)
    return [ this.x, this.y ];

  return [ this.x, this.y, this.precomputed && {
    doubles: this.precomputed.doubles && {
      step: this.precomputed.doubles.step,
      points: this.precomputed.doubles.points.slice(1),
    },
    naf: this.precomputed.naf && {
      wnd: this.precomputed.naf.wnd,
      points: this.precomputed.naf.points.slice(1),
    },
  } ];
};

Point.fromJSON = function fromJSON(curve, obj, red) {
  if (typeof obj === 'string')
    obj = JSON.parse(obj);
  var res = curve.point(obj[0], obj[1], red);
  if (!obj[2])
    return res;

  function obj2point(obj) {
    return curve.point(obj[0], obj[1], red);
  }

  var pre = obj[2];
  res.precomputed = {
    beta: null,
    doubles: pre.doubles && {
      step: pre.doubles.step,
      points: [ res ].concat(pre.doubles.points.map(obj2point)),
    },
    naf: pre.naf && {
      wnd: pre.naf.wnd,
      points: [ res ].concat(pre.naf.points.map(obj2point)),
    },
  };
  return res;
};

Point.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC Point Infinity>';
  return '<EC Point x: ' + this.x.fromRed().toString(16, 2) +
      ' y: ' + this.y.fromRed().toString(16, 2) + '>';
};

Point.prototype.isInfinity = function isInfinity() {
  return this.inf;
};

Point.prototype.add = function add(p) {
  // O + P = P
  if (this.inf)
    return p;

  // P + O = P
  if (p.inf)
    return this;

  // P + P = 2P
  if (this.eq(p))
    return this.dbl();

  // P + (-P) = O
  if (this.neg().eq(p))
    return this.curve.point(null, null);

  // P + Q = O
  if (this.x.cmp(p.x) === 0)
    return this.curve.point(null, null);

  var c = this.y.redSub(p.y);
  if (c.cmpn(0) !== 0)
    c = c.redMul(this.x.redSub(p.x).redInvm());
  var nx = c.redSqr().redISub(this.x).redISub(p.x);
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.dbl = function dbl() {
  if (this.inf)
    return this;

  // 2P = O
  var ys1 = this.y.redAdd(this.y);
  if (ys1.cmpn(0) === 0)
    return this.curve.point(null, null);

  var a = this.curve.a;

  var x2 = this.x.redSqr();
  var dyinv = ys1.redInvm();
  var c = x2.redAdd(x2).redIAdd(x2).redIAdd(a).redMul(dyinv);

  var nx = c.redSqr().redISub(this.x.redAdd(this.x));
  var ny = c.redMul(this.x.redSub(nx)).redISub(this.y);
  return this.curve.point(nx, ny);
};

Point.prototype.getX = function getX() {
  return this.x.fromRed();
};

Point.prototype.getY = function getY() {
  return this.y.fromRed();
};

Point.prototype.mul = function mul(k) {
  k = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(k, 16);
  if (this.isInfinity())
    return this;
  else if (this._hasDoubles(k))
    return this.curve._fixedNafMul(this, k);
  else if (this.curve.endo)
    return this.curve._endoWnafMulAdd([ this ], [ k ]);
  else
    return this.curve._wnafMul(this, k);
};

Point.prototype.mulAdd = function mulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2);
};

Point.prototype.jmulAdd = function jmulAdd(k1, p2, k2) {
  var points = [ this, p2 ];
  var coeffs = [ k1, k2 ];
  if (this.curve.endo)
    return this.curve._endoWnafMulAdd(points, coeffs, true);
  else
    return this.curve._wnafMulAdd(1, points, coeffs, 2, true);
};

Point.prototype.eq = function eq(p) {
  return this === p ||
         this.inf === p.inf &&
             (this.inf || this.x.cmp(p.x) === 0 && this.y.cmp(p.y) === 0);
};

Point.prototype.neg = function neg(_precompute) {
  if (this.inf)
    return this;

  var res = this.curve.point(this.x, this.y.redNeg());
  if (_precompute && this.precomputed) {
    var pre = this.precomputed;
    var negate = function(p) {
      return p.neg();
    };
    res.precomputed = {
      naf: pre.naf && {
        wnd: pre.naf.wnd,
        points: pre.naf.points.map(negate),
      },
      doubles: pre.doubles && {
        step: pre.doubles.step,
        points: pre.doubles.points.map(negate),
      },
    };
  }
  return res;
};

Point.prototype.toJ = function toJ() {
  if (this.inf)
    return this.curve.jpoint(null, null, null);

  var res = this.curve.jpoint(this.x, this.y, this.curve.one);
  return res;
};

function JPoint(curve, x, y, z) {
  base.BasePoint.call(this, curve, 'jacobian');
  if (x === null && y === null && z === null) {
    this.x = this.curve.one;
    this.y = this.curve.one;
    this.z = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(0);
  } else {
    this.x = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(x, 16);
    this.y = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(y, 16);
    this.z = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(z, 16);
  }
  if (!this.x.red)
    this.x = this.x.toRed(this.curve.red);
  if (!this.y.red)
    this.y = this.y.toRed(this.curve.red);
  if (!this.z.red)
    this.z = this.z.toRed(this.curve.red);

  this.zOne = this.z === this.curve.one;
}
inherits_browser(JPoint, base.BasePoint);

ShortCurve.prototype.jpoint = function jpoint(x, y, z) {
  return new JPoint(this, x, y, z);
};

JPoint.prototype.toP = function toP() {
  if (this.isInfinity())
    return this.curve.point(null, null);

  var zinv = this.z.redInvm();
  var zinv2 = zinv.redSqr();
  var ax = this.x.redMul(zinv2);
  var ay = this.y.redMul(zinv2).redMul(zinv);

  return this.curve.point(ax, ay);
};

JPoint.prototype.neg = function neg() {
  return this.curve.jpoint(this.x, this.y.redNeg(), this.z);
};

JPoint.prototype.add = function add(p) {
  // O + P = P
  if (this.isInfinity())
    return p;

  // P + O = P
  if (p.isInfinity())
    return this;

  // 12M + 4S + 7A
  var pz2 = p.z.redSqr();
  var z2 = this.z.redSqr();
  var u1 = this.x.redMul(pz2);
  var u2 = p.x.redMul(z2);
  var s1 = this.y.redMul(pz2.redMul(p.z));
  var s2 = p.y.redMul(z2.redMul(this.z));

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(p.z).redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mixedAdd = function mixedAdd(p) {
  // O + P = P
  if (this.isInfinity())
    return p.toJ();

  // P + O = P
  if (p.isInfinity())
    return this;

  // 8M + 3S + 7A
  var z2 = this.z.redSqr();
  var u1 = this.x;
  var u2 = p.x.redMul(z2);
  var s1 = this.y;
  var s2 = p.y.redMul(z2).redMul(this.z);

  var h = u1.redSub(u2);
  var r = s1.redSub(s2);
  if (h.cmpn(0) === 0) {
    if (r.cmpn(0) !== 0)
      return this.curve.jpoint(null, null, null);
    else
      return this.dbl();
  }

  var h2 = h.redSqr();
  var h3 = h2.redMul(h);
  var v = u1.redMul(h2);

  var nx = r.redSqr().redIAdd(h3).redISub(v).redISub(v);
  var ny = r.redMul(v.redISub(nx)).redISub(s1.redMul(h3));
  var nz = this.z.redMul(h);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.dblp = function dblp(pow) {
  if (pow === 0)
    return this;
  if (this.isInfinity())
    return this;
  if (!pow)
    return this.dbl();

  var i;
  if (this.curve.zeroA || this.curve.threeA) {
    var r = this;
    for (i = 0; i < pow; i++)
      r = r.dbl();
    return r;
  }

  // 1M + 2S + 1A + N * (4S + 5M + 8A)
  // N = 1 => 6M + 6S + 9A
  var a = this.curve.a;
  var tinv = this.curve.tinv;

  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  // Reuse results
  var jyd = jy.redAdd(jy);
  for (i = 0; i < pow; i++) {
    var jx2 = jx.redSqr();
    var jyd2 = jyd.redSqr();
    var jyd4 = jyd2.redSqr();
    var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

    var t1 = jx.redMul(jyd2);
    var nx = c.redSqr().redISub(t1.redAdd(t1));
    var t2 = t1.redISub(nx);
    var dny = c.redMul(t2);
    dny = dny.redIAdd(dny).redISub(jyd4);
    var nz = jyd.redMul(jz);
    if (i + 1 < pow)
      jz4 = jz4.redMul(jyd4);

    jx = nx;
    jz = nz;
    jyd = dny;
  }

  return this.curve.jpoint(jx, jyd.redMul(tinv), jz);
};

JPoint.prototype.dbl = function dbl() {
  if (this.isInfinity())
    return this;

  if (this.curve.zeroA)
    return this._zeroDbl();
  else if (this.curve.threeA)
    return this._threeDbl();
  else
    return this._dbl();
};

JPoint.prototype._zeroDbl = function _zeroDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 14A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a; a = 0
    var m = xx.redAdd(xx).redIAdd(xx);
    // T = M ^ 2 - 2*S
    var t = m.redSqr().redISub(s).redISub(s);

    // 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);

    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2*Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html
    //     #doubling-dbl-2009-l
    // 2M + 5S + 13A

    // A = X1^2
    var a = this.x.redSqr();
    // B = Y1^2
    var b = this.y.redSqr();
    // C = B^2
    var c = b.redSqr();
    // D = 2 * ((X1 + B)^2 - A - C)
    var d = this.x.redAdd(b).redSqr().redISub(a).redISub(c);
    d = d.redIAdd(d);
    // E = 3 * A
    var e = a.redAdd(a).redIAdd(a);
    // F = E^2
    var f = e.redSqr();

    // 8 * C
    var c8 = c.redIAdd(c);
    c8 = c8.redIAdd(c8);
    c8 = c8.redIAdd(c8);

    // X3 = F - 2 * D
    nx = f.redISub(d).redISub(d);
    // Y3 = E * (D - X3) - 8 * C
    ny = e.redMul(d.redISub(nx)).redISub(c8);
    // Z3 = 2 * Y1 * Z1
    nz = this.y.redMul(this.z);
    nz = nz.redIAdd(nz);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._threeDbl = function _threeDbl() {
  var nx;
  var ny;
  var nz;
  // Z = 1
  if (this.zOne) {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html
    //     #doubling-mdbl-2007-bl
    // 1M + 5S + 15A

    // XX = X1^2
    var xx = this.x.redSqr();
    // YY = Y1^2
    var yy = this.y.redSqr();
    // YYYY = YY^2
    var yyyy = yy.redSqr();
    // S = 2 * ((X1 + YY)^2 - XX - YYYY)
    var s = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
    s = s.redIAdd(s);
    // M = 3 * XX + a
    var m = xx.redAdd(xx).redIAdd(xx).redIAdd(this.curve.a);
    // T = M^2 - 2 * S
    var t = m.redSqr().redISub(s).redISub(s);
    // X3 = T
    nx = t;
    // Y3 = M * (S - T) - 8 * YYYY
    var yyyy8 = yyyy.redIAdd(yyyy);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    yyyy8 = yyyy8.redIAdd(yyyy8);
    ny = m.redMul(s.redISub(t)).redISub(yyyy8);
    // Z3 = 2 * Y1
    nz = this.y.redAdd(this.y);
  } else {
    // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-3.html#doubling-dbl-2001-b
    // 3M + 5S

    // delta = Z1^2
    var delta = this.z.redSqr();
    // gamma = Y1^2
    var gamma = this.y.redSqr();
    // beta = X1 * gamma
    var beta = this.x.redMul(gamma);
    // alpha = 3 * (X1 - delta) * (X1 + delta)
    var alpha = this.x.redSub(delta).redMul(this.x.redAdd(delta));
    alpha = alpha.redAdd(alpha).redIAdd(alpha);
    // X3 = alpha^2 - 8 * beta
    var beta4 = beta.redIAdd(beta);
    beta4 = beta4.redIAdd(beta4);
    var beta8 = beta4.redAdd(beta4);
    nx = alpha.redSqr().redISub(beta8);
    // Z3 = (Y1 + Z1)^2 - gamma - delta
    nz = this.y.redAdd(this.z).redSqr().redISub(gamma).redISub(delta);
    // Y3 = alpha * (4 * beta - X3) - 8 * gamma^2
    var ggamma8 = gamma.redSqr();
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ggamma8 = ggamma8.redIAdd(ggamma8);
    ny = alpha.redMul(beta4.redISub(nx)).redISub(ggamma8);
  }

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype._dbl = function _dbl() {
  var a = this.curve.a;

  // 4M + 6S + 10A
  var jx = this.x;
  var jy = this.y;
  var jz = this.z;
  var jz4 = jz.redSqr().redSqr();

  var jx2 = jx.redSqr();
  var jy2 = jy.redSqr();

  var c = jx2.redAdd(jx2).redIAdd(jx2).redIAdd(a.redMul(jz4));

  var jxd4 = jx.redAdd(jx);
  jxd4 = jxd4.redIAdd(jxd4);
  var t1 = jxd4.redMul(jy2);
  var nx = c.redSqr().redISub(t1.redAdd(t1));
  var t2 = t1.redISub(nx);

  var jyd8 = jy2.redSqr();
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  jyd8 = jyd8.redIAdd(jyd8);
  var ny = c.redMul(t2).redISub(jyd8);
  var nz = jy.redAdd(jy).redMul(jz);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.trpl = function trpl() {
  if (!this.curve.zeroA)
    return this.dbl().add(this);

  // hyperelliptic.org/EFD/g1p/auto-shortw-jacobian-0.html#tripling-tpl-2007-bl
  // 5M + 10S + ...

  // XX = X1^2
  var xx = this.x.redSqr();
  // YY = Y1^2
  var yy = this.y.redSqr();
  // ZZ = Z1^2
  var zz = this.z.redSqr();
  // YYYY = YY^2
  var yyyy = yy.redSqr();
  // M = 3 * XX + a * ZZ2; a = 0
  var m = xx.redAdd(xx).redIAdd(xx);
  // MM = M^2
  var mm = m.redSqr();
  // E = 6 * ((X1 + YY)^2 - XX - YYYY) - MM
  var e = this.x.redAdd(yy).redSqr().redISub(xx).redISub(yyyy);
  e = e.redIAdd(e);
  e = e.redAdd(e).redIAdd(e);
  e = e.redISub(mm);
  // EE = E^2
  var ee = e.redSqr();
  // T = 16*YYYY
  var t = yyyy.redIAdd(yyyy);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  t = t.redIAdd(t);
  // U = (M + E)^2 - MM - EE - T
  var u = m.redIAdd(e).redSqr().redISub(mm).redISub(ee).redISub(t);
  // X3 = 4 * (X1 * EE - 4 * YY * U)
  var yyu4 = yy.redMul(u);
  yyu4 = yyu4.redIAdd(yyu4);
  yyu4 = yyu4.redIAdd(yyu4);
  var nx = this.x.redMul(ee).redISub(yyu4);
  nx = nx.redIAdd(nx);
  nx = nx.redIAdd(nx);
  // Y3 = 8 * Y1 * (U * (T - U) - E * EE)
  var ny = this.y.redMul(u.redMul(t.redISub(u)).redISub(e.redMul(ee)));
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  ny = ny.redIAdd(ny);
  // Z3 = (Z1 + E)^2 - ZZ - EE
  var nz = this.z.redAdd(e).redSqr().redISub(zz).redISub(ee);

  return this.curve.jpoint(nx, ny, nz);
};

JPoint.prototype.mul = function mul(k, kbase) {
  k = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(k, kbase);

  return this.curve._wnafMul(this, k);
};

JPoint.prototype.eq = function eq(p) {
  if (p.type === 'affine')
    return this.eq(p.toJ());

  if (this === p)
    return true;

  // x1 * z2^2 == x2 * z1^2
  var z2 = this.z.redSqr();
  var pz2 = p.z.redSqr();
  if (this.x.redMul(pz2).redISub(p.x.redMul(z2)).cmpn(0) !== 0)
    return false;

  // y1 * z2^3 == y2 * z1^3
  var z3 = z2.redMul(this.z);
  var pz3 = pz2.redMul(p.z);
  return this.y.redMul(pz3).redISub(p.y.redMul(z3)).cmpn(0) === 0;
};

JPoint.prototype.eqXToP = function eqXToP(x) {
  var zs = this.z.redSqr();
  var rx = x.toRed(this.curve.red).redMul(zs);
  if (this.x.cmp(rx) === 0)
    return true;

  var xc = x.clone();
  var t = this.curve.redN.redMul(zs);
  for (;;) {
    xc.iadd(this.curve.n);
    if (xc.cmp(this.curve.p) >= 0)
      return false;

    rx.redIAdd(t);
    if (this.x.cmp(rx) === 0)
      return true;
  }
};

JPoint.prototype.inspect = function inspect() {
  if (this.isInfinity())
    return '<EC JPoint Infinity>';
  return '<EC JPoint x: ' + this.x.toString(16, 2) +
      ' y: ' + this.y.toString(16, 2) +
      ' z: ' + this.z.toString(16, 2) + '>';
};

JPoint.prototype.isInfinity = function isInfinity() {
  // XXX This code assumes that zero is always zero in red
  return this.z.cmpn(0) === 0;
};

var curve_1 = createCommonjsModule(function (module, exports) {
'use strict';

var curve = exports;

curve.base = base;
curve.short = short_1;
curve.mont = /*RicMoo:ethers:require(./mont)*/(null);
curve.edwards = /*RicMoo:ethers:require(./edwards)*/(null);
});

var curves_1 = createCommonjsModule(function (module, exports) {
'use strict';

var curves = exports;





var assert = utils_1$1.assert;

function PresetCurve(options) {
  if (options.type === 'short')
    this.curve = new curve_1.short(options);
  else if (options.type === 'edwards')
    this.curve = new curve_1.edwards(options);
  else
    this.curve = new curve_1.mont(options);
  this.g = this.curve.g;
  this.n = this.curve.n;
  this.hash = options.hash;

  assert(this.g.validate(), 'Invalid curve');
  assert(this.g.mul(this.n).isInfinity(), 'Invalid curve, G*N != O');
}
curves.PresetCurve = PresetCurve;

function defineCurve(name, options) {
  Object.defineProperty(curves, name, {
    configurable: true,
    enumerable: true,
    get: function() {
      var curve = new PresetCurve(options);
      Object.defineProperty(curves, name, {
        configurable: true,
        enumerable: true,
        value: curve,
      });
      return curve;
    },
  });
}

defineCurve('p192', {
  type: 'short',
  prime: 'p192',
  p: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff fffffffc',
  b: '64210519 e59c80e7 0fa7e9ab 72243049 feb8deec c146b9b1',
  n: 'ffffffff ffffffff ffffffff 99def836 146bc9b1 b4d22831',
  hash: hash_js__WEBPACK_IMPORTED_MODULE_1___default.a.sha256,
  gRed: false,
  g: [
    '188da80e b03090f6 7cbf20eb 43a18800 f4ff0afd 82ff1012',
    '07192b95 ffc8da78 631011ed 6b24cdd5 73f977a1 1e794811',
  ],
});

defineCurve('p224', {
  type: 'short',
  prime: 'p224',
  p: 'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001',
  a: 'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff fffffffe',
  b: 'b4050a85 0c04b3ab f5413256 5044b0b7 d7bfd8ba 270b3943 2355ffb4',
  n: 'ffffffff ffffffff ffffffff ffff16a2 e0b8f03e 13dd2945 5c5c2a3d',
  hash: hash_js__WEBPACK_IMPORTED_MODULE_1___default.a.sha256,
  gRed: false,
  g: [
    'b70e0cbd 6bb4bf7f 321390b9 4a03c1d3 56c21122 343280d6 115c1d21',
    'bd376388 b5f723fb 4c22dfe6 cd4375a0 5a074764 44d58199 85007e34',
  ],
});

defineCurve('p256', {
  type: 'short',
  prime: null,
  p: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff ffffffff',
  a: 'ffffffff 00000001 00000000 00000000 00000000 ffffffff ffffffff fffffffc',
  b: '5ac635d8 aa3a93e7 b3ebbd55 769886bc 651d06b0 cc53b0f6 3bce3c3e 27d2604b',
  n: 'ffffffff 00000000 ffffffff ffffffff bce6faad a7179e84 f3b9cac2 fc632551',
  hash: hash_js__WEBPACK_IMPORTED_MODULE_1___default.a.sha256,
  gRed: false,
  g: [
    '6b17d1f2 e12c4247 f8bce6e5 63a440f2 77037d81 2deb33a0 f4a13945 d898c296',
    '4fe342e2 fe1a7f9b 8ee7eb4a 7c0f9e16 2bce3357 6b315ece cbb64068 37bf51f5',
  ],
});

defineCurve('p384', {
  type: 'short',
  prime: null,
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 ffffffff',
  a: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'fffffffe ffffffff 00000000 00000000 fffffffc',
  b: 'b3312fa7 e23ee7e4 988e056b e3f82d19 181d9c6e fe814112 0314088f ' +
     '5013875a c656398d 8a2ed19d 2a85c8ed d3ec2aef',
  n: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff c7634d81 ' +
     'f4372ddf 581a0db2 48b0a77a ecec196a ccc52973',
  hash: hash_js__WEBPACK_IMPORTED_MODULE_1___default.a.sha384,
  gRed: false,
  g: [
    'aa87ca22 be8b0537 8eb1c71e f320ad74 6e1d3b62 8ba79b98 59f741e0 82542a38 ' +
    '5502f25d bf55296c 3a545e38 72760ab7',
    '3617de4a 96262c6f 5d9e98bf 9292dc29 f8f41dbd 289a147c e9da3113 b5f0b8c0 ' +
    '0a60b1ce 1d7e819d 7a431d7c 90ea0e5f',
  ],
});

defineCurve('p521', {
  type: 'short',
  prime: null,
  p: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff',
  a: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff ffffffff ffffffff fffffffc',
  b: '00000051 953eb961 8e1c9a1f 929a21a0 b68540ee a2da725b ' +
     '99b315f3 b8b48991 8ef109e1 56193951 ec7e937b 1652c0bd ' +
     '3bb1bf07 3573df88 3d2c34f1 ef451fd4 6b503f00',
  n: '000001ff ffffffff ffffffff ffffffff ffffffff ffffffff ' +
     'ffffffff ffffffff fffffffa 51868783 bf2f966b 7fcc0148 ' +
     'f709a5d0 3bb5c9b8 899c47ae bb6fb71e 91386409',
  hash: hash_js__WEBPACK_IMPORTED_MODULE_1___default.a.sha512,
  gRed: false,
  g: [
    '000000c6 858e06b7 0404e9cd 9e3ecb66 2395b442 9c648139 ' +
    '053fb521 f828af60 6b4d3dba a14b5e77 efe75928 fe1dc127 ' +
    'a2ffa8de 3348b3c1 856a429b f97e7e31 c2e5bd66',
    '00000118 39296a78 9a3bc004 5c8a5fb4 2c7d1bd9 98f54449 ' +
    '579b4468 17afbd17 273e662c 97ee7299 5ef42640 c550b901 ' +
    '3fad0761 353c7086 a272c240 88be9476 9fd16650',
  ],
});

defineCurve('curve25519', {
  type: 'mont',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '76d06',
  b: '1',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash_js__WEBPACK_IMPORTED_MODULE_1___default.a.sha256,
  gRed: false,
  g: [
    '9',
  ],
});

defineCurve('ed25519', {
  type: 'edwards',
  prime: 'p25519',
  p: '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed',
  a: '-1',
  c: '1',
  // -121665 * (121666^(-1)) (mod P)
  d: '52036cee2b6ffe73 8cc740797779e898 00700a4d4141d8ab 75eb4dca135978a3',
  n: '1000000000000000 0000000000000000 14def9dea2f79cd6 5812631a5cf5d3ed',
  hash: hash_js__WEBPACK_IMPORTED_MODULE_1___default.a.sha256,
  gRed: false,
  g: [
    '216936d3cd6e53fec0a4e231fdd6dc5c692cc7609525a7b2c9562d608f25d51a',

    // 4/5
    '6666666666666666666666666666666666666666666666666666666666666658',
  ],
});

var pre;
try {
  pre = /*RicMoo:ethers:require(./precomputed/secp256k1)*/(null).crash();
} catch (e) {
  pre = undefined;
}

defineCurve('secp256k1', {
  type: 'short',
  prime: 'k256',
  p: 'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f',
  a: '0',
  b: '7',
  n: 'ffffffff ffffffff ffffffff fffffffe baaedce6 af48a03b bfd25e8c d0364141',
  h: '1',
  hash: hash_js__WEBPACK_IMPORTED_MODULE_1___default.a.sha256,

  // Precomputed endomorphism
  beta: '7ae96a2b657c07106e64479eac3434e99cf0497512f58995c1396c28719501ee',
  lambda: '5363ad4cc05c30e0a5261c028812645a122e22ea20816678df02967c1b23bd72',
  basis: [
    {
      a: '3086d221a7d46bcde86c90e49284eb15',
      b: '-e4437ed6010e88286f547fa90abfe4c3',
    },
    {
      a: '114ca50f7a8e2f3f657c1108d9d44cfd8',
      b: '3086d221a7d46bcde86c90e49284eb15',
    },
  ],

  gRed: false,
  g: [
    '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',
    '483ada7726a3c4655da4fbfc0e1108a8fd17b448a68554199c47d08ffb10d4b8',
    pre,
  ],
});
});

'use strict';





function HmacDRBG(options) {
  if (!(this instanceof HmacDRBG))
    return new HmacDRBG(options);
  this.hash = options.hash;
  this.predResist = !!options.predResist;

  this.outLen = this.hash.outSize;
  this.minEntropy = options.minEntropy || this.hash.hmacStrength;

  this._reseed = null;
  this.reseedInterval = null;
  this.K = null;
  this.V = null;

  var entropy = utils_1.toArray(options.entropy, options.entropyEnc || 'hex');
  var nonce = utils_1.toArray(options.nonce, options.nonceEnc || 'hex');
  var pers = utils_1.toArray(options.pers, options.persEnc || 'hex');
  minimalisticAssert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');
  this._init(entropy, nonce, pers);
}
var hmacDrbg = HmacDRBG;

HmacDRBG.prototype._init = function init(entropy, nonce, pers) {
  var seed = entropy.concat(nonce).concat(pers);

  this.K = new Array(this.outLen / 8);
  this.V = new Array(this.outLen / 8);
  for (var i = 0; i < this.V.length; i++) {
    this.K[i] = 0x00;
    this.V[i] = 0x01;
  }

  this._update(seed);
  this._reseed = 1;
  this.reseedInterval = 0x1000000000000;  // 2^48
};

HmacDRBG.prototype._hmac = function hmac() {
  return new hash_js__WEBPACK_IMPORTED_MODULE_1___default.a.hmac(this.hash, this.K);
};

HmacDRBG.prototype._update = function update(seed) {
  var kmac = this._hmac()
                 .update(this.V)
                 .update([ 0x00 ]);
  if (seed)
    kmac = kmac.update(seed);
  this.K = kmac.digest();
  this.V = this._hmac().update(this.V).digest();
  if (!seed)
    return;

  this.K = this._hmac()
               .update(this.V)
               .update([ 0x01 ])
               .update(seed)
               .digest();
  this.V = this._hmac().update(this.V).digest();
};

HmacDRBG.prototype.reseed = function reseed(entropy, entropyEnc, add, addEnc) {
  // Optional entropy enc
  if (typeof entropyEnc !== 'string') {
    addEnc = add;
    add = entropyEnc;
    entropyEnc = null;
  }

  entropy = utils_1.toArray(entropy, entropyEnc);
  add = utils_1.toArray(add, addEnc);

  minimalisticAssert(entropy.length >= (this.minEntropy / 8),
         'Not enough entropy. Minimum is: ' + this.minEntropy + ' bits');

  this._update(entropy.concat(add || []));
  this._reseed = 1;
};

HmacDRBG.prototype.generate = function generate(len, enc, add, addEnc) {
  if (this._reseed > this.reseedInterval)
    throw new Error('Reseed is required');

  // Optional encoding
  if (typeof enc !== 'string') {
    addEnc = add;
    add = enc;
    enc = null;
  }

  // Optional additional data
  if (add) {
    add = utils_1.toArray(add, addEnc || 'hex');
    this._update(add);
  }

  var temp = [];
  while (temp.length < len) {
    this.V = this._hmac().update(this.V).digest();
    temp = temp.concat(this.V);
  }

  var res = temp.slice(0, len);
  this._update(add);
  this._reseed++;
  return utils_1.encode(res, enc);
};

'use strict';



var assert$3 = utils_1$1.assert;

function KeyPair(ec, options) {
  this.ec = ec;
  this.priv = null;
  this.pub = null;

  // KeyPair(ec, { priv: ..., pub: ... })
  if (options.priv)
    this._importPrivate(options.priv, options.privEnc);
  if (options.pub)
    this._importPublic(options.pub, options.pubEnc);
}
var key = KeyPair;

KeyPair.fromPublic = function fromPublic(ec, pub, enc) {
  if (pub instanceof KeyPair)
    return pub;

  return new KeyPair(ec, {
    pub: pub,
    pubEnc: enc,
  });
};

KeyPair.fromPrivate = function fromPrivate(ec, priv, enc) {
  if (priv instanceof KeyPair)
    return priv;

  return new KeyPair(ec, {
    priv: priv,
    privEnc: enc,
  });
};

KeyPair.prototype.validate = function validate() {
  var pub = this.getPublic();

  if (pub.isInfinity())
    return { result: false, reason: 'Invalid public key' };
  if (!pub.validate())
    return { result: false, reason: 'Public key is not a point' };
  if (!pub.mul(this.ec.curve.n).isInfinity())
    return { result: false, reason: 'Public key * N != O' };

  return { result: true, reason: null };
};

KeyPair.prototype.getPublic = function getPublic(compact, enc) {
  // compact is optional argument
  if (typeof compact === 'string') {
    enc = compact;
    compact = null;
  }

  if (!this.pub)
    this.pub = this.ec.g.mul(this.priv);

  if (!enc)
    return this.pub;

  return this.pub.encode(enc, compact);
};

KeyPair.prototype.getPrivate = function getPrivate(enc) {
  if (enc === 'hex')
    return this.priv.toString(16, 2);
  else
    return this.priv;
};

KeyPair.prototype._importPrivate = function _importPrivate(key, enc) {
  this.priv = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(key, enc || 16);

  // Ensure that the priv won't be bigger than n, otherwise we may fail
  // in fixed multiplication method
  this.priv = this.priv.umod(this.ec.curve.n);
};

KeyPair.prototype._importPublic = function _importPublic(key, enc) {
  if (key.x || key.y) {
    // Montgomery points only have an `x` coordinate.
    // Weierstrass/Edwards points on the other hand have both `x` and
    // `y` coordinates.
    if (this.ec.curve.type === 'mont') {
      assert$3(key.x, 'Need x coordinate');
    } else if (this.ec.curve.type === 'short' ||
               this.ec.curve.type === 'edwards') {
      assert$3(key.x && key.y, 'Need both x and y coordinate');
    }
    this.pub = this.ec.curve.point(key.x, key.y);
    return;
  }
  this.pub = this.ec.curve.decodePoint(key, enc);
};

// ECDH
KeyPair.prototype.derive = function derive(pub) {
  if(!pub.validate()) {
    assert$3(pub.validate(), 'public point not validated');
  }
  return pub.mul(this.priv).getX();
};

// ECDSA
KeyPair.prototype.sign = function sign(msg, enc, options) {
  return this.ec.sign(msg, this, enc, options);
};

KeyPair.prototype.verify = function verify(msg, signature) {
  return this.ec.verify(msg, signature, this);
};

KeyPair.prototype.inspect = function inspect() {
  return '<Key priv: ' + (this.priv && this.priv.toString(16, 2)) +
         ' pub: ' + (this.pub && this.pub.inspect()) + ' >';
};

'use strict';




var assert$4 = utils_1$1.assert;

function Signature(options, enc) {
  if (options instanceof Signature)
    return options;

  if (this._importDER(options, enc))
    return;

  assert$4(options.r && options.s, 'Signature without r or s');
  this.r = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(options.r, 16);
  this.s = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(options.s, 16);
  if (options.recoveryParam === undefined)
    this.recoveryParam = null;
  else
    this.recoveryParam = options.recoveryParam;
}
var signature = Signature;

function Position() {
  this.place = 0;
}

function getLength(buf, p) {
  var initial = buf[p.place++];
  if (!(initial & 0x80)) {
    return initial;
  }
  var octetLen = initial & 0xf;

  // Indefinite length or overflow
  if (octetLen === 0 || octetLen > 4) {
    return false;
  }

  var val = 0;
  for (var i = 0, off = p.place; i < octetLen; i++, off++) {
    val <<= 8;
    val |= buf[off];
    val >>>= 0;
  }

  // Leading zeroes
  if (val <= 0x7f) {
    return false;
  }

  p.place = off;
  return val;
}

function rmPadding(buf) {
  var i = 0;
  var len = buf.length - 1;
  while (!buf[i] && !(buf[i + 1] & 0x80) && i < len) {
    i++;
  }
  if (i === 0) {
    return buf;
  }
  return buf.slice(i);
}

Signature.prototype._importDER = function _importDER(data, enc) {
  data = utils_1$1.toArray(data, enc);
  var p = new Position();
  if (data[p.place++] !== 0x30) {
    return false;
  }
  var len = getLength(data, p);
  if (len === false) {
    return false;
  }
  if ((len + p.place) !== data.length) {
    return false;
  }
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var rlen = getLength(data, p);
  if (rlen === false) {
    return false;
  }
  var r = data.slice(p.place, rlen + p.place);
  p.place += rlen;
  if (data[p.place++] !== 0x02) {
    return false;
  }
  var slen = getLength(data, p);
  if (slen === false) {
    return false;
  }
  if (data.length !== slen + p.place) {
    return false;
  }
  var s = data.slice(p.place, slen + p.place);
  if (r[0] === 0) {
    if (r[1] & 0x80) {
      r = r.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }
  if (s[0] === 0) {
    if (s[1] & 0x80) {
      s = s.slice(1);
    } else {
      // Leading zeroes
      return false;
    }
  }

  this.r = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(r);
  this.s = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(s);
  this.recoveryParam = null;

  return true;
};

function constructLength(arr, len) {
  if (len < 0x80) {
    arr.push(len);
    return;
  }
  var octets = 1 + (Math.log(len) / Math.LN2 >>> 3);
  arr.push(octets | 0x80);
  while (--octets) {
    arr.push((len >>> (octets << 3)) & 0xff);
  }
  arr.push(len);
}

Signature.prototype.toDER = function toDER(enc) {
  var r = this.r.toArray();
  var s = this.s.toArray();

  // Pad values
  if (r[0] & 0x80)
    r = [ 0 ].concat(r);
  // Pad values
  if (s[0] & 0x80)
    s = [ 0 ].concat(s);

  r = rmPadding(r);
  s = rmPadding(s);

  while (!s[0] && !(s[1] & 0x80)) {
    s = s.slice(1);
  }
  var arr = [ 0x02 ];
  constructLength(arr, r.length);
  arr = arr.concat(r);
  arr.push(0x02);
  constructLength(arr, s.length);
  var backHalf = arr.concat(s);
  var res = [ 0x30 ];
  constructLength(res, backHalf.length);
  res = res.concat(backHalf);
  return utils_1$1.encode(res, enc);
};

'use strict';





var rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });
var assert$5 = utils_1$1.assert;




function EC(options) {
  if (!(this instanceof EC))
    return new EC(options);

  // Shortcut `elliptic.ec(curve-name)`
  if (typeof options === 'string') {
    assert$5(Object.prototype.hasOwnProperty.call(curves_1, options),
      'Unknown curve ' + options);

    options = curves_1[options];
  }

  // Shortcut for `elliptic.ec(elliptic.curves.curveName)`
  if (options instanceof curves_1.PresetCurve)
    options = { curve: options };

  this.curve = options.curve.curve;
  this.n = this.curve.n;
  this.nh = this.n.ushrn(1);
  this.g = this.curve.g;

  // Point on curve
  this.g = options.curve.g;
  this.g.precompute(options.curve.n.bitLength() + 1);

  // Hash for function for DRBG
  this.hash = options.hash || options.curve.hash;
}
var ec = EC;

EC.prototype.keyPair = function keyPair(options) {
  return new key(this, options);
};

EC.prototype.keyFromPrivate = function keyFromPrivate(priv, enc) {
  return key.fromPrivate(this, priv, enc);
};

EC.prototype.keyFromPublic = function keyFromPublic(pub, enc) {
  return key.fromPublic(this, pub, enc);
};

EC.prototype.genKeyPair = function genKeyPair(options) {
  if (!options)
    options = {};

  // Instantiate Hmac_DRBG
  var drbg = new hmacDrbg({
    hash: this.hash,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
    entropy: options.entropy || rand(this.hash.hmacStrength),
    entropyEnc: options.entropy && options.entropyEnc || 'utf8',
    nonce: this.n.toArray(),
  });

  var bytes = this.n.byteLength();
  var ns2 = this.n.sub(new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(2));
  for (;;) {
    var priv = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(drbg.generate(bytes));
    if (priv.cmp(ns2) > 0)
      continue;

    priv.iaddn(1);
    return this.keyFromPrivate(priv);
  }
};

EC.prototype._truncateToN = function _truncateToN(msg, truncOnly) {
  var delta = msg.byteLength() * 8 - this.n.bitLength();
  if (delta > 0)
    msg = msg.ushrn(delta);
  if (!truncOnly && msg.cmp(this.n) >= 0)
    return msg.sub(this.n);
  else
    return msg;
};

EC.prototype.sign = function sign(msg, key, enc, options) {
  if (typeof enc === 'object') {
    options = enc;
    enc = null;
  }
  if (!options)
    options = {};

  key = this.keyFromPrivate(key, enc);
  msg = this._truncateToN(new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(msg, 16));

  // Zero-extend key to provide enough entropy
  var bytes = this.n.byteLength();
  var bkey = key.getPrivate().toArray('be', bytes);

  // Zero-extend nonce to have the same byte size as N
  var nonce = msg.toArray('be', bytes);

  // Instantiate Hmac_DRBG
  var drbg = new hmacDrbg({
    hash: this.hash,
    entropy: bkey,
    nonce: nonce,
    pers: options.pers,
    persEnc: options.persEnc || 'utf8',
  });

  // Number of bytes to generate
  var ns1 = this.n.sub(new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(1));

  for (var iter = 0; ; iter++) {
    var k = options.k ?
      options.k(iter) :
      new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(drbg.generate(this.n.byteLength()));
    k = this._truncateToN(k, true);
    if (k.cmpn(1) <= 0 || k.cmp(ns1) >= 0)
      continue;

    var kp = this.g.mul(k);
    if (kp.isInfinity())
      continue;

    var kpX = kp.getX();
    var r = kpX.umod(this.n);
    if (r.cmpn(0) === 0)
      continue;

    var s = k.invm(this.n).mul(r.mul(key.getPrivate()).iadd(msg));
    s = s.umod(this.n);
    if (s.cmpn(0) === 0)
      continue;

    var recoveryParam = (kp.getY().isOdd() ? 1 : 0) |
                        (kpX.cmp(r) !== 0 ? 2 : 0);

    // Use complement of `s`, if it is > `n / 2`
    if (options.canonical && s.cmp(this.nh) > 0) {
      s = this.n.sub(s);
      recoveryParam ^= 1;
    }

    return new signature({ r: r, s: s, recoveryParam: recoveryParam });
  }
};

EC.prototype.verify = function verify(msg, signature$1, key, enc) {
  msg = this._truncateToN(new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(msg, 16));
  key = this.keyFromPublic(key, enc);
  signature$1 = new signature(signature$1, 'hex');

  // Perform primitive values validation
  var r = signature$1.r;
  var s = signature$1.s;
  if (r.cmpn(1) < 0 || r.cmp(this.n) >= 0)
    return false;
  if (s.cmpn(1) < 0 || s.cmp(this.n) >= 0)
    return false;

  // Validate signature
  var sinv = s.invm(this.n);
  var u1 = sinv.mul(msg).umod(this.n);
  var u2 = sinv.mul(r).umod(this.n);
  var p;

  if (!this.curve._maxwellTrick) {
    p = this.g.mulAdd(u1, key.getPublic(), u2);
    if (p.isInfinity())
      return false;

    return p.getX().umod(this.n).cmp(r) === 0;
  }

  // NOTE: Greg Maxwell's trick, inspired by:
  // https://git.io/vad3K

  p = this.g.jmulAdd(u1, key.getPublic(), u2);
  if (p.isInfinity())
    return false;

  // Compare `p.x` of Jacobian point with `r`,
  // this will do `p.x == r * p.z^2` instead of multiplying `p.x` by the
  // inverse of `p.z^2`
  return p.eqXToP(r);
};

EC.prototype.recoverPubKey = function(msg, signature$1, j, enc) {
  assert$5((3 & j) === j, 'The recovery param is more than two bits');
  signature$1 = new signature(signature$1, enc);

  var n = this.n;
  var e = new bn_js__WEBPACK_IMPORTED_MODULE_0___default.a(msg);
  var r = signature$1.r;
  var s = signature$1.s;

  // A set LSB signifies that the y-coordinate is odd
  var isYOdd = j & 1;
  var isSecondKey = j >> 1;
  if (r.cmp(this.curve.p.umod(this.curve.n)) >= 0 && isSecondKey)
    throw new Error('Unable to find sencond key candinate');

  // 1.1. Let x = r + jn.
  if (isSecondKey)
    r = this.curve.pointFromX(r.add(this.curve.n), isYOdd);
  else
    r = this.curve.pointFromX(r, isYOdd);

  var rInv = signature$1.r.invm(n);
  var s1 = n.sub(e).mul(rInv).umod(n);
  var s2 = s.mul(rInv).umod(n);

  // 1.6.1 Compute Q = r^-1 (sR -  eG)
  //               Q = r^-1 (sR + -eG)
  return this.g.mulAdd(s1, r, s2);
};

EC.prototype.getKeyRecoveryParam = function(e, signature$1, Q, enc) {
  signature$1 = new signature(signature$1, enc);
  if (signature$1.recoveryParam !== null)
    return signature$1.recoveryParam;

  for (var i = 0; i < 4; i++) {
    var Qprime;
    try {
      Qprime = this.recoverPubKey(e, signature$1, i);
    } catch (e) {
      continue;
    }

    if (Qprime.eq(Q))
      return i;
  }
  throw new Error('Unable to find valid recovery factor');
};

var elliptic_1 = createCommonjsModule(function (module, exports) {
'use strict';

var elliptic = exports;

elliptic.version = /*RicMoo:ethers*/{ version: "6.5.4" }.version;
elliptic.utils = utils_1$1;
elliptic.rand = /*RicMoo:ethers:require(brorand)*/(function() { throw new Error('unsupported'); });
elliptic.curve = curve_1;
elliptic.curves = curves_1;

// Protocols
elliptic.ec = ec;
elliptic.eddsa = /*RicMoo:ethers:require(./elliptic/eddsa)*/(null);
});

var EC$1 = elliptic_1.ec;


//# sourceMappingURL=elliptic.js.map

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/global.js */ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/@ethersproject/signing-key/lib.esm/index.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/signing-key/lib.esm/index.js ***!
  \******************************************************************/
/*! exports provided: SigningKey, recoverPublicKey, computePublicKey */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SigningKey", function() { return SigningKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recoverPublicKey", function() { return recoverPublicKey; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computePublicKey", function() { return computePublicKey; });
/* harmony import */ var _elliptic__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./elliptic */ "./node_modules/@ethersproject/signing-key/lib.esm/elliptic.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/signing-key/lib.esm/_version.js");






const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_3__["Logger"](_version__WEBPACK_IMPORTED_MODULE_4__["version"]);
let _curve = null;
function getCurve() {
    if (!_curve) {
        _curve = new _elliptic__WEBPACK_IMPORTED_MODULE_0__["EC"]("secp256k1");
    }
    return _curve;
}
class SigningKey {
    constructor(privateKey) {
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["defineReadOnly"])(this, "curve", "secp256k1");
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["defineReadOnly"])(this, "privateKey", Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(privateKey));
        const keyPair = getCurve().keyFromPrivate(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(this.privateKey));
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["defineReadOnly"])(this, "publicKey", "0x" + keyPair.getPublic(false, "hex"));
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["defineReadOnly"])(this, "compressedPublicKey", "0x" + keyPair.getPublic(true, "hex"));
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["defineReadOnly"])(this, "_isSigningKey", true);
    }
    _addPoint(other) {
        const p0 = getCurve().keyFromPublic(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(this.publicKey));
        const p1 = getCurve().keyFromPublic(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(other));
        return "0x" + p0.pub.add(p1.pub).encodeCompressed("hex");
    }
    signDigest(digest) {
        const keyPair = getCurve().keyFromPrivate(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(this.privateKey));
        const digestBytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(digest);
        if (digestBytes.length !== 32) {
            logger.throwArgumentError("bad digest length", "digest", digest);
        }
        const signature = keyPair.sign(digestBytes, { canonical: true });
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["splitSignature"])({
            recoveryParam: signature.recoveryParam,
            r: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexZeroPad"])("0x" + signature.r.toString(16), 32),
            s: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexZeroPad"])("0x" + signature.s.toString(16), 32),
        });
    }
    computeSharedSecret(otherKey) {
        const keyPair = getCurve().keyFromPrivate(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(this.privateKey));
        const otherKeyPair = getCurve().keyFromPublic(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(computePublicKey(otherKey)));
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexZeroPad"])("0x" + keyPair.derive(otherKeyPair.getPublic()).toString(16), 32);
    }
    static isSigningKey(value) {
        return !!(value && value._isSigningKey);
    }
}
function recoverPublicKey(digest, signature) {
    const sig = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["splitSignature"])(signature);
    const rs = { r: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(sig.r), s: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(sig.s) };
    return "0x" + getCurve().recoverPubKey(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(digest), rs, sig.recoveryParam).encode("hex", false);
}
function computePublicKey(key, compressed) {
    const bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(key);
    if (bytes.length === 32) {
        const signingKey = new SigningKey(bytes);
        if (compressed) {
            return "0x" + getCurve().keyFromPrivate(bytes).getPublic(true, "hex");
        }
        return signingKey.publicKey;
    }
    else if (bytes.length === 33) {
        if (compressed) {
            return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(false, "hex");
    }
    else if (bytes.length === 65) {
        if (!compressed) {
            return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(bytes);
        }
        return "0x" + getCurve().keyFromPublic(bytes).getPublic(true, "hex");
    }
    return logger.throwArgumentError("invalid public or private key", "key", "[REDACTED]");
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/solidity/lib.esm/_version.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/solidity/lib.esm/_version.js ***!
  \******************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "solidity/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/solidity/lib.esm/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/solidity/lib.esm/index.js ***!
  \***************************************************************/
/*! exports provided: pack, keccak256, sha256 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pack", function() { return pack; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "keccak256", function() { return keccak256; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sha256", function() { return sha256; });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/solidity/lib.esm/_version.js");






const regexBytes = new RegExp("^bytes([0-9]+)$");
const regexNumber = new RegExp("^(u?int)([0-9]*)$");
const regexArray = new RegExp("^(.*)\\[([0-9]*)\\]$");
const Zeros = "0000000000000000000000000000000000000000000000000000000000000000";


const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_5__["Logger"](_version__WEBPACK_IMPORTED_MODULE_6__["version"]);
function _pack(type, value, isArray) {
    switch (type) {
        case "address":
            if (isArray) {
                return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["zeroPad"])(value, 32);
            }
            return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(value);
        case "string":
            return Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_4__["toUtf8Bytes"])(value);
        case "bytes":
            return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(value);
        case "bool":
            value = (value ? "0x01" : "0x00");
            if (isArray) {
                return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["zeroPad"])(value, 32);
            }
            return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(value);
    }
    let match = type.match(regexNumber);
    if (match) {
        //let signed = (match[1] === "int")
        let size = parseInt(match[2] || "256");
        if ((match[2] && String(size) !== match[2]) || (size % 8 !== 0) || size === 0 || size > 256) {
            logger.throwArgumentError("invalid number type", "type", type);
        }
        if (isArray) {
            size = 256;
        }
        value = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(value).toTwos(size);
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["zeroPad"])(value, size / 8);
    }
    match = type.match(regexBytes);
    if (match) {
        const size = parseInt(match[1]);
        if (String(size) !== match[1] || size === 0 || size > 32) {
            logger.throwArgumentError("invalid bytes type", "type", type);
        }
        if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(value).byteLength !== size) {
            logger.throwArgumentError(`invalid value for ${type}`, "value", value);
        }
        if (isArray) {
            return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])((value + Zeros).substring(0, 66));
        }
        return value;
    }
    match = type.match(regexArray);
    if (match && Array.isArray(value)) {
        const baseType = match[1];
        const count = parseInt(match[2] || String(value.length));
        if (count != value.length) {
            logger.throwArgumentError(`invalid array length for ${type}`, "value", value);
        }
        const result = [];
        value.forEach(function (value) {
            result.push(_pack(baseType, value, true));
        });
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["concat"])(result);
    }
    return logger.throwArgumentError("invalid type", "type", type);
}
// @TODO: Array Enum
function pack(types, values) {
    if (types.length != values.length) {
        logger.throwArgumentError("wrong number of values; expected ${ types.length }", "values", values);
    }
    const tight = [];
    types.forEach(function (type, index) {
        tight.push(_pack(type, values[index]));
    });
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["concat"])(tight));
}
function keccak256(types, values) {
    return Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_2__["keccak256"])(pack(types, values));
}
function sha256(types, values) {
    return Object(_ethersproject_sha2__WEBPACK_IMPORTED_MODULE_3__["sha256"])(pack(types, values));
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/strings/lib.esm/_version.js":
/*!*****************************************************************!*\
  !*** ./node_modules/@ethersproject/strings/lib.esm/_version.js ***!
  \*****************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "strings/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/strings/lib.esm/bytes32.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/strings/lib.esm/bytes32.js ***!
  \****************************************************************/
/*! exports provided: formatBytes32String, parseBytes32String */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatBytes32String", function() { return formatBytes32String; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseBytes32String", function() { return parseBytes32String; });
/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/constants */ "./node_modules/@ethersproject/constants/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utf8 */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");




function formatBytes32String(text) {
    // Get the bytes
    const bytes = Object(_utf8__WEBPACK_IMPORTED_MODULE_2__["toUtf8Bytes"])(text);
    // Check we have room for null-termination
    if (bytes.length > 31) {
        throw new Error("bytes32 string must be less than 32 bytes");
    }
    // Zero-pad (implicitly null-terminates)
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["concat"])([bytes, _ethersproject_constants__WEBPACK_IMPORTED_MODULE_0__["HashZero"]]).slice(0, 32));
}
function parseBytes32String(bytes) {
    const data = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["arrayify"])(bytes);
    // Must be 32 bytes with a null-termination
    if (data.length !== 32) {
        throw new Error("invalid bytes32 - not 32 bytes long");
    }
    if (data[31] !== 0) {
        throw new Error("invalid bytes32 string - no null terminator");
    }
    // Find the null termination
    let length = 31;
    while (data[length - 1] === 0) {
        length--;
    }
    // Determine the string value
    return Object(_utf8__WEBPACK_IMPORTED_MODULE_2__["toUtf8String"])(data.slice(0, length));
}
//# sourceMappingURL=bytes32.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/strings/lib.esm/idna.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/strings/lib.esm/idna.js ***!
  \*************************************************************/
/*! exports provided: _nameprepTableA1, _nameprepTableB2, _nameprepTableC, nameprep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_nameprepTableA1", function() { return _nameprepTableA1; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_nameprepTableB2", function() { return _nameprepTableB2; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_nameprepTableC", function() { return _nameprepTableC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "nameprep", function() { return nameprep; });
/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./utf8 */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");


function bytes2(data) {
    if ((data.length % 4) !== 0) {
        throw new Error("bad data");
    }
    let result = [];
    for (let i = 0; i < data.length; i += 4) {
        result.push(parseInt(data.substring(i, i + 4), 16));
    }
    return result;
}
function createTable(data, func) {
    if (!func) {
        func = function (value) { return [parseInt(value, 16)]; };
    }
    let lo = 0;
    let result = {};
    data.split(",").forEach((pair) => {
        let comps = pair.split(":");
        lo += parseInt(comps[0], 16);
        result[lo] = func(comps[1]);
    });
    return result;
}
function createRangeTable(data) {
    let hi = 0;
    return data.split(",").map((v) => {
        let comps = v.split("-");
        if (comps.length === 1) {
            comps[1] = "0";
        }
        else if (comps[1] === "") {
            comps[1] = "1";
        }
        let lo = hi + parseInt(comps[0], 16);
        hi = parseInt(comps[1], 16);
        return { l: lo, h: hi };
    });
}
function matchMap(value, ranges) {
    let lo = 0;
    for (let i = 0; i < ranges.length; i++) {
        let range = ranges[i];
        lo += range.l;
        if (value >= lo && value <= lo + range.h && ((value - lo) % (range.d || 1)) === 0) {
            if (range.e && range.e.indexOf(value - lo) !== -1) {
                continue;
            }
            return range;
        }
    }
    return null;
}
const Table_A_1_ranges = createRangeTable("221,13-1b,5f-,40-10,51-f,11-3,3-3,2-2,2-4,8,2,15,2d,28-8,88,48,27-,3-5,11-20,27-,8,28,3-5,12,18,b-a,1c-4,6-16,2-d,2-2,2,1b-4,17-9,8f-,10,f,1f-2,1c-34,33-14e,4,36-,13-,6-2,1a-f,4,9-,3-,17,8,2-2,5-,2,8-,3-,4-8,2-3,3,6-,16-6,2-,7-3,3-,17,8,3,3,3-,2,6-3,3-,4-a,5,2-6,10-b,4,8,2,4,17,8,3,6-,b,4,4-,2-e,2-4,b-10,4,9-,3-,17,8,3-,5-,9-2,3-,4-7,3-3,3,4-3,c-10,3,7-2,4,5-2,3,2,3-2,3-2,4-2,9,4-3,6-2,4,5-8,2-e,d-d,4,9,4,18,b,6-3,8,4,5-6,3-8,3-3,b-11,3,9,4,18,b,6-3,8,4,5-6,3-6,2,3-3,b-11,3,9,4,18,11-3,7-,4,5-8,2-7,3-3,b-11,3,13-2,19,a,2-,8-2,2-3,7,2,9-11,4-b,3b-3,1e-24,3,2-,3,2-,2-5,5,8,4,2,2-,3,e,4-,6,2,7-,b-,3-21,49,23-5,1c-3,9,25,10-,2-2f,23,6,3,8-2,5-5,1b-45,27-9,2a-,2-3,5b-4,45-4,53-5,8,40,2,5-,8,2,5-,28,2,5-,20,2,5-,8,2,5-,8,8,18,20,2,5-,8,28,14-5,1d-22,56-b,277-8,1e-2,52-e,e,8-a,18-8,15-b,e,4,3-b,5e-2,b-15,10,b-5,59-7,2b-555,9d-3,5b-5,17-,7-,27-,7-,9,2,2,2,20-,36,10,f-,7,14-,4,a,54-3,2-6,6-5,9-,1c-10,13-1d,1c-14,3c-,10-6,32-b,240-30,28-18,c-14,a0,115-,3,66-,b-76,5,5-,1d,24,2,5-2,2,8-,35-2,19,f-10,1d-3,311-37f,1b,5a-b,d7-19,d-3,41,57-,68-4,29-3,5f,29-37,2e-2,25-c,2c-2,4e-3,30,78-3,64-,20,19b7-49,51a7-59,48e-2,38-738,2ba5-5b,222f-,3c-94,8-b,6-4,1b,6,2,3,3,6d-20,16e-f,41-,37-7,2e-2,11-f,5-b,18-,b,14,5-3,6,88-,2,bf-2,7-,7-,7-,4-2,8,8-9,8-2ff,20,5-b,1c-b4,27-,27-cbb1,f7-9,28-2,b5-221,56,48,3-,2-,3-,5,d,2,5,3,42,5-,9,8,1d,5,6,2-2,8,153-3,123-3,33-27fd,a6da-5128,21f-5df,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3-fffd,3,2-1d,61-ff7d");
// @TODO: Make this relative...
const Table_B_1_flags = "ad,34f,1806,180b,180c,180d,200b,200c,200d,2060,feff".split(",").map((v) => parseInt(v, 16));
const Table_B_2_ranges = [
    { h: 25, s: 32, l: 65 },
    { h: 30, s: 32, e: [23], l: 127 },
    { h: 54, s: 1, e: [48], l: 64, d: 2 },
    { h: 14, s: 1, l: 57, d: 2 },
    { h: 44, s: 1, l: 17, d: 2 },
    { h: 10, s: 1, e: [2, 6, 8], l: 61, d: 2 },
    { h: 16, s: 1, l: 68, d: 2 },
    { h: 84, s: 1, e: [18, 24, 66], l: 19, d: 2 },
    { h: 26, s: 32, e: [17], l: 435 },
    { h: 22, s: 1, l: 71, d: 2 },
    { h: 15, s: 80, l: 40 },
    { h: 31, s: 32, l: 16 },
    { h: 32, s: 1, l: 80, d: 2 },
    { h: 52, s: 1, l: 42, d: 2 },
    { h: 12, s: 1, l: 55, d: 2 },
    { h: 40, s: 1, e: [38], l: 15, d: 2 },
    { h: 14, s: 1, l: 48, d: 2 },
    { h: 37, s: 48, l: 49 },
    { h: 148, s: 1, l: 6351, d: 2 },
    { h: 88, s: 1, l: 160, d: 2 },
    { h: 15, s: 16, l: 704 },
    { h: 25, s: 26, l: 854 },
    { h: 25, s: 32, l: 55915 },
    { h: 37, s: 40, l: 1247 },
    { h: 25, s: -119711, l: 53248 },
    { h: 25, s: -119763, l: 52 },
    { h: 25, s: -119815, l: 52 },
    { h: 25, s: -119867, e: [1, 4, 5, 7, 8, 11, 12, 17], l: 52 },
    { h: 25, s: -119919, l: 52 },
    { h: 24, s: -119971, e: [2, 7, 8, 17], l: 52 },
    { h: 24, s: -120023, e: [2, 7, 13, 15, 16, 17], l: 52 },
    { h: 25, s: -120075, l: 52 },
    { h: 25, s: -120127, l: 52 },
    { h: 25, s: -120179, l: 52 },
    { h: 25, s: -120231, l: 52 },
    { h: 25, s: -120283, l: 52 },
    { h: 25, s: -120335, l: 52 },
    { h: 24, s: -119543, e: [17], l: 56 },
    { h: 24, s: -119601, e: [17], l: 58 },
    { h: 24, s: -119659, e: [17], l: 58 },
    { h: 24, s: -119717, e: [17], l: 58 },
    { h: 24, s: -119775, e: [17], l: 58 }
];
const Table_B_2_lut_abs = createTable("b5:3bc,c3:ff,7:73,2:253,5:254,3:256,1:257,5:259,1:25b,3:260,1:263,2:269,1:268,5:26f,1:272,2:275,7:280,3:283,5:288,3:28a,1:28b,5:292,3f:195,1:1bf,29:19e,125:3b9,8b:3b2,1:3b8,1:3c5,3:3c6,1:3c0,1a:3ba,1:3c1,1:3c3,2:3b8,1:3b5,1bc9:3b9,1c:1f76,1:1f77,f:1f7a,1:1f7b,d:1f78,1:1f79,1:1f7c,1:1f7d,107:63,5:25b,4:68,1:68,1:68,3:69,1:69,1:6c,3:6e,4:70,1:71,1:72,1:72,1:72,7:7a,2:3c9,2:7a,2:6b,1:e5,1:62,1:63,3:65,1:66,2:6d,b:3b3,1:3c0,6:64,1b574:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3,20:3b8,1a:3c3");
const Table_B_2_lut_rel = createTable("179:1,2:1,2:1,5:1,2:1,a:4f,a:1,8:1,2:1,2:1,3:1,5:1,3:1,4:1,2:1,3:1,4:1,8:2,1:1,2:2,1:1,2:2,27:2,195:26,2:25,1:25,1:25,2:40,2:3f,1:3f,33:1,11:-6,1:-9,1ac7:-3a,6d:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,b:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,c:-8,2:-8,2:-8,2:-8,9:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,1:-8,49:-8,1:-8,1:-4a,1:-4a,d:-56,1:-56,1:-56,1:-56,d:-8,1:-8,f:-8,1:-8,3:-7");
const Table_B_2_complex = createTable("df:00730073,51:00690307,19:02BC006E,a7:006A030C,18a:002003B9,16:03B903080301,20:03C503080301,1d7:05650582,190f:00680331,1:00740308,1:0077030A,1:0079030A,1:006102BE,b6:03C50313,2:03C503130300,2:03C503130301,2:03C503130342,2a:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F0003B9,1:1F0103B9,1:1F0203B9,1:1F0303B9,1:1F0403B9,1:1F0503B9,1:1F0603B9,1:1F0703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F2003B9,1:1F2103B9,1:1F2203B9,1:1F2303B9,1:1F2403B9,1:1F2503B9,1:1F2603B9,1:1F2703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,1:1F6003B9,1:1F6103B9,1:1F6203B9,1:1F6303B9,1:1F6403B9,1:1F6503B9,1:1F6603B9,1:1F6703B9,3:1F7003B9,1:03B103B9,1:03AC03B9,2:03B10342,1:03B1034203B9,5:03B103B9,6:1F7403B9,1:03B703B9,1:03AE03B9,2:03B70342,1:03B7034203B9,5:03B703B9,6:03B903080300,1:03B903080301,3:03B90342,1:03B903080342,b:03C503080300,1:03C503080301,1:03C10313,2:03C50342,1:03C503080342,b:1F7C03B9,1:03C903B9,1:03CE03B9,2:03C90342,1:03C9034203B9,5:03C903B9,ac:00720073,5b:00B00063,6:00B00066,d:006E006F,a:0073006D,1:00740065006C,1:0074006D,124f:006800700061,2:00610075,2:006F0076,b:00700061,1:006E0061,1:03BC0061,1:006D0061,1:006B0061,1:006B0062,1:006D0062,1:00670062,3:00700066,1:006E0066,1:03BC0066,4:0068007A,1:006B0068007A,1:006D0068007A,1:00670068007A,1:00740068007A,15:00700061,1:006B00700061,1:006D00700061,1:006700700061,8:00700076,1:006E0076,1:03BC0076,1:006D0076,1:006B0076,1:006D0076,1:00700077,1:006E0077,1:03BC0077,1:006D0077,1:006B0077,1:006D0077,1:006B03C9,1:006D03C9,2:00620071,3:00632215006B0067,1:0063006F002E,1:00640062,1:00670079,2:00680070,2:006B006B,1:006B006D,9:00700068,2:00700070006D,1:00700072,2:00730076,1:00770062,c723:00660066,1:00660069,1:0066006C,1:006600660069,1:00660066006C,1:00730074,1:00730074,d:05740576,1:05740565,1:0574056B,1:057E0576,1:0574056D", bytes2);
const Table_C_ranges = createRangeTable("80-20,2a0-,39c,32,f71,18e,7f2-f,19-7,30-4,7-5,f81-b,5,a800-20ff,4d1-1f,110,fa-6,d174-7,2e84-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,ffff-,2,1f-5f,ff7f-20001");
function flatten(values) {
    return values.reduce((accum, value) => {
        value.forEach((value) => { accum.push(value); });
        return accum;
    }, []);
}
function _nameprepTableA1(codepoint) {
    return !!matchMap(codepoint, Table_A_1_ranges);
}
function _nameprepTableB2(codepoint) {
    let range = matchMap(codepoint, Table_B_2_ranges);
    if (range) {
        return [codepoint + range.s];
    }
    let codes = Table_B_2_lut_abs[codepoint];
    if (codes) {
        return codes;
    }
    let shift = Table_B_2_lut_rel[codepoint];
    if (shift) {
        return [codepoint + shift[0]];
    }
    let complex = Table_B_2_complex[codepoint];
    if (complex) {
        return complex;
    }
    return null;
}
function _nameprepTableC(codepoint) {
    return !!matchMap(codepoint, Table_C_ranges);
}
function nameprep(value) {
    // This allows platforms with incomplete normalize to bypass
    // it for very basic names which the built-in toLowerCase
    // will certainly handle correctly
    if (value.match(/^[a-z0-9-]*$/i) && value.length <= 59) {
        return value.toLowerCase();
    }
    // Get the code points (keeping the current normalization)
    let codes = Object(_utf8__WEBPACK_IMPORTED_MODULE_0__["toUtf8CodePoints"])(value);
    codes = flatten(codes.map((code) => {
        // Substitute Table B.1 (Maps to Nothing)
        if (Table_B_1_flags.indexOf(code) >= 0) {
            return [];
        }
        if (code >= 0xfe00 && code <= 0xfe0f) {
            return [];
        }
        // Substitute Table B.2 (Case Folding)
        let codesTableB2 = _nameprepTableB2(code);
        if (codesTableB2) {
            return codesTableB2;
        }
        // No Substitution
        return [code];
    }));
    // Normalize using form KC
    codes = Object(_utf8__WEBPACK_IMPORTED_MODULE_0__["toUtf8CodePoints"])(Object(_utf8__WEBPACK_IMPORTED_MODULE_0__["_toUtf8String"])(codes), _utf8__WEBPACK_IMPORTED_MODULE_0__["UnicodeNormalizationForm"].NFKC);
    // Prohibit Tables C.1.2, C.2.2, C.3, C.4, C.5, C.6, C.7, C.8, C.9
    codes.forEach((code) => {
        if (_nameprepTableC(code)) {
            throw new Error("STRINGPREP_CONTAINS_PROHIBITED");
        }
    });
    // Prohibit Unassigned Code Points (Table A.1)
    codes.forEach((code) => {
        if (_nameprepTableA1(code)) {
            throw new Error("STRINGPREP_CONTAINS_UNASSIGNED");
        }
    });
    // IDNA extras
    let name = Object(_utf8__WEBPACK_IMPORTED_MODULE_0__["_toUtf8String"])(codes);
    // IDNA: 4.2.3.1
    if (name.substring(0, 1) === "-" || name.substring(2, 4) === "--" || name.substring(name.length - 1) === "-") {
        throw new Error("invalid hyphen");
    }
    // IDNA: 4.2.4
    if (name.length > 63) {
        throw new Error("too long");
    }
    return name;
}
//# sourceMappingURL=idna.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/strings/lib.esm/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@ethersproject/strings/lib.esm/index.js ***!
  \**************************************************************/
/*! exports provided: _toEscapedUtf8String, toUtf8Bytes, toUtf8CodePoints, toUtf8String, Utf8ErrorFuncs, Utf8ErrorReason, UnicodeNormalizationForm, formatBytes32String, parseBytes32String, nameprep */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _bytes32__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./bytes32 */ "./node_modules/@ethersproject/strings/lib.esm/bytes32.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatBytes32String", function() { return _bytes32__WEBPACK_IMPORTED_MODULE_0__["formatBytes32String"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseBytes32String", function() { return _bytes32__WEBPACK_IMPORTED_MODULE_0__["parseBytes32String"]; });

/* harmony import */ var _idna__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./idna */ "./node_modules/@ethersproject/strings/lib.esm/idna.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nameprep", function() { return _idna__WEBPACK_IMPORTED_MODULE_1__["nameprep"]; });

/* harmony import */ var _utf8__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utf8 */ "./node_modules/@ethersproject/strings/lib.esm/utf8.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_toEscapedUtf8String", function() { return _utf8__WEBPACK_IMPORTED_MODULE_2__["_toEscapedUtf8String"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toUtf8Bytes", function() { return _utf8__WEBPACK_IMPORTED_MODULE_2__["toUtf8Bytes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toUtf8CodePoints", function() { return _utf8__WEBPACK_IMPORTED_MODULE_2__["toUtf8CodePoints"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toUtf8String", function() { return _utf8__WEBPACK_IMPORTED_MODULE_2__["toUtf8String"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Utf8ErrorFuncs", function() { return _utf8__WEBPACK_IMPORTED_MODULE_2__["Utf8ErrorFuncs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Utf8ErrorReason", function() { return _utf8__WEBPACK_IMPORTED_MODULE_2__["Utf8ErrorReason"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnicodeNormalizationForm", function() { return _utf8__WEBPACK_IMPORTED_MODULE_2__["UnicodeNormalizationForm"]; });






//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/strings/lib.esm/utf8.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/strings/lib.esm/utf8.js ***!
  \*************************************************************/
/*! exports provided: UnicodeNormalizationForm, Utf8ErrorReason, Utf8ErrorFuncs, toUtf8Bytes, _toEscapedUtf8String, _toUtf8String, toUtf8String, toUtf8CodePoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnicodeNormalizationForm", function() { return UnicodeNormalizationForm; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Utf8ErrorReason", function() { return Utf8ErrorReason; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Utf8ErrorFuncs", function() { return Utf8ErrorFuncs; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toUtf8Bytes", function() { return toUtf8Bytes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_toEscapedUtf8String", function() { return _toEscapedUtf8String; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_toUtf8String", function() { return _toUtf8String; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toUtf8String", function() { return toUtf8String; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "toUtf8CodePoints", function() { return toUtf8CodePoints; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/strings/lib.esm/_version.js");




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"](_version__WEBPACK_IMPORTED_MODULE_2__["version"]);
///////////////////////////////
var UnicodeNormalizationForm;
(function (UnicodeNormalizationForm) {
    UnicodeNormalizationForm["current"] = "";
    UnicodeNormalizationForm["NFC"] = "NFC";
    UnicodeNormalizationForm["NFD"] = "NFD";
    UnicodeNormalizationForm["NFKC"] = "NFKC";
    UnicodeNormalizationForm["NFKD"] = "NFKD";
})(UnicodeNormalizationForm || (UnicodeNormalizationForm = {}));
;
var Utf8ErrorReason;
(function (Utf8ErrorReason) {
    // A continuation byte was present where there was nothing to continue
    // - offset = the index the codepoint began in
    Utf8ErrorReason["UNEXPECTED_CONTINUE"] = "unexpected continuation byte";
    // An invalid (non-continuation) byte to start a UTF-8 codepoint was found
    // - offset = the index the codepoint began in
    Utf8ErrorReason["BAD_PREFIX"] = "bad codepoint prefix";
    // The string is too short to process the expected codepoint
    // - offset = the index the codepoint began in
    Utf8ErrorReason["OVERRUN"] = "string overrun";
    // A missing continuation byte was expected but not found
    // - offset = the index the continuation byte was expected at
    Utf8ErrorReason["MISSING_CONTINUE"] = "missing continuation byte";
    // The computed code point is outside the range for UTF-8
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; outside the UTF-8 range
    Utf8ErrorReason["OUT_OF_RANGE"] = "out of UTF-8 range";
    // UTF-8 strings may not contain UTF-16 surrogate pairs
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; inside the UTF-16 surrogate range
    Utf8ErrorReason["UTF16_SURROGATE"] = "UTF-16 surrogate";
    // The string is an overlong representation
    // - offset       = start of this codepoint
    // - badCodepoint = the computed codepoint; already bounds checked
    Utf8ErrorReason["OVERLONG"] = "overlong representation";
})(Utf8ErrorReason || (Utf8ErrorReason = {}));
;
function errorFunc(reason, offset, bytes, output, badCodepoint) {
    return logger.throwArgumentError(`invalid codepoint at offset ${offset}; ${reason}`, "bytes", bytes);
}
function ignoreFunc(reason, offset, bytes, output, badCodepoint) {
    // If there is an invalid prefix (including stray continuation), skip any additional continuation bytes
    if (reason === Utf8ErrorReason.BAD_PREFIX || reason === Utf8ErrorReason.UNEXPECTED_CONTINUE) {
        let i = 0;
        for (let o = offset + 1; o < bytes.length; o++) {
            if (bytes[o] >> 6 !== 0x02) {
                break;
            }
            i++;
        }
        return i;
    }
    // This byte runs us past the end of the string, so just jump to the end
    // (but the first byte was read already read and therefore skipped)
    if (reason === Utf8ErrorReason.OVERRUN) {
        return bytes.length - offset - 1;
    }
    // Nothing to skip
    return 0;
}
function replaceFunc(reason, offset, bytes, output, badCodepoint) {
    // Overlong representations are otherwise "valid" code points; just non-deistingtished
    if (reason === Utf8ErrorReason.OVERLONG) {
        output.push(badCodepoint);
        return 0;
    }
    // Put the replacement character into the output
    output.push(0xfffd);
    // Otherwise, process as if ignoring errors
    return ignoreFunc(reason, offset, bytes, output, badCodepoint);
}
// Common error handing strategies
const Utf8ErrorFuncs = Object.freeze({
    error: errorFunc,
    ignore: ignoreFunc,
    replace: replaceFunc
});
// http://stackoverflow.com/questions/13356493/decode-utf-8-with-javascript#13691499
function getUtf8CodePoints(bytes, onError) {
    if (onError == null) {
        onError = Utf8ErrorFuncs.error;
    }
    bytes = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(bytes);
    const result = [];
    let i = 0;
    // Invalid bytes are ignored
    while (i < bytes.length) {
        const c = bytes[i++];
        // 0xxx xxxx
        if (c >> 7 === 0) {
            result.push(c);
            continue;
        }
        // Multibyte; how many bytes left for this character?
        let extraLength = null;
        let overlongMask = null;
        // 110x xxxx 10xx xxxx
        if ((c & 0xe0) === 0xc0) {
            extraLength = 1;
            overlongMask = 0x7f;
            // 1110 xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf0) === 0xe0) {
            extraLength = 2;
            overlongMask = 0x7ff;
            // 1111 0xxx 10xx xxxx 10xx xxxx 10xx xxxx
        }
        else if ((c & 0xf8) === 0xf0) {
            extraLength = 3;
            overlongMask = 0xffff;
        }
        else {
            if ((c & 0xc0) === 0x80) {
                i += onError(Utf8ErrorReason.UNEXPECTED_CONTINUE, i - 1, bytes, result);
            }
            else {
                i += onError(Utf8ErrorReason.BAD_PREFIX, i - 1, bytes, result);
            }
            continue;
        }
        // Do we have enough bytes in our data?
        if (i - 1 + extraLength >= bytes.length) {
            i += onError(Utf8ErrorReason.OVERRUN, i - 1, bytes, result);
            continue;
        }
        // Remove the length prefix from the char
        let res = c & ((1 << (8 - extraLength - 1)) - 1);
        for (let j = 0; j < extraLength; j++) {
            let nextChar = bytes[i];
            // Invalid continuation byte
            if ((nextChar & 0xc0) != 0x80) {
                i += onError(Utf8ErrorReason.MISSING_CONTINUE, i, bytes, result);
                res = null;
                break;
            }
            ;
            res = (res << 6) | (nextChar & 0x3f);
            i++;
        }
        // See above loop for invalid continuation byte
        if (res === null) {
            continue;
        }
        // Maximum code point
        if (res > 0x10ffff) {
            i += onError(Utf8ErrorReason.OUT_OF_RANGE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Reserved for UTF-16 surrogate halves
        if (res >= 0xd800 && res <= 0xdfff) {
            i += onError(Utf8ErrorReason.UTF16_SURROGATE, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        // Check for overlong sequences (more bytes than needed)
        if (res <= overlongMask) {
            i += onError(Utf8ErrorReason.OVERLONG, i - 1 - extraLength, bytes, result, res);
            continue;
        }
        result.push(res);
    }
    return result;
}
// http://stackoverflow.com/questions/18729405/how-to-convert-utf8-string-to-byte-array
function toUtf8Bytes(str, form = UnicodeNormalizationForm.current) {
    if (form != UnicodeNormalizationForm.current) {
        logger.checkNormalize();
        str = str.normalize(form);
    }
    let result = [];
    for (let i = 0; i < str.length; i++) {
        const c = str.charCodeAt(i);
        if (c < 0x80) {
            result.push(c);
        }
        else if (c < 0x800) {
            result.push((c >> 6) | 0xc0);
            result.push((c & 0x3f) | 0x80);
        }
        else if ((c & 0xfc00) == 0xd800) {
            i++;
            const c2 = str.charCodeAt(i);
            if (i >= str.length || (c2 & 0xfc00) !== 0xdc00) {
                throw new Error("invalid utf-8 string");
            }
            // Surrogate Pair
            const pair = 0x10000 + ((c & 0x03ff) << 10) + (c2 & 0x03ff);
            result.push((pair >> 18) | 0xf0);
            result.push(((pair >> 12) & 0x3f) | 0x80);
            result.push(((pair >> 6) & 0x3f) | 0x80);
            result.push((pair & 0x3f) | 0x80);
        }
        else {
            result.push((c >> 12) | 0xe0);
            result.push(((c >> 6) & 0x3f) | 0x80);
            result.push((c & 0x3f) | 0x80);
        }
    }
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(result);
}
;
function escapeChar(value) {
    const hex = ("0000" + value.toString(16));
    return "\\u" + hex.substring(hex.length - 4);
}
function _toEscapedUtf8String(bytes, onError) {
    return '"' + getUtf8CodePoints(bytes, onError).map((codePoint) => {
        if (codePoint < 256) {
            switch (codePoint) {
                case 8: return "\\b";
                case 9: return "\\t";
                case 10: return "\\n";
                case 13: return "\\r";
                case 34: return "\\\"";
                case 92: return "\\\\";
            }
            if (codePoint >= 32 && codePoint < 127) {
                return String.fromCharCode(codePoint);
            }
        }
        if (codePoint <= 0xffff) {
            return escapeChar(codePoint);
        }
        codePoint -= 0x10000;
        return escapeChar(((codePoint >> 10) & 0x3ff) + 0xd800) + escapeChar((codePoint & 0x3ff) + 0xdc00);
    }).join("") + '"';
}
function _toUtf8String(codePoints) {
    return codePoints.map((codePoint) => {
        if (codePoint <= 0xffff) {
            return String.fromCharCode(codePoint);
        }
        codePoint -= 0x10000;
        return String.fromCharCode((((codePoint >> 10) & 0x3ff) + 0xd800), ((codePoint & 0x3ff) + 0xdc00));
    }).join("");
}
function toUtf8String(bytes, onError) {
    return _toUtf8String(getUtf8CodePoints(bytes, onError));
}
function toUtf8CodePoints(str, form = UnicodeNormalizationForm.current) {
    return getUtf8CodePoints(toUtf8Bytes(str, form));
}
//# sourceMappingURL=utf8.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/transactions/lib.esm/_version.js":
/*!**********************************************************************!*\
  !*** ./node_modules/@ethersproject/transactions/lib.esm/_version.js ***!
  \**********************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "transactions/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/transactions/lib.esm/index.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/transactions/lib.esm/index.js ***!
  \*******************************************************************/
/*! exports provided: TransactionTypes, computeAddress, recoverAddress, accessListify, serialize, parse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TransactionTypes", function() { return TransactionTypes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "computeAddress", function() { return computeAddress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "recoverAddress", function() { return recoverAddress; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "accessListify", function() { return accessListify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "serialize", function() { return serialize; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parse", function() { return parse; });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/constants */ "./node_modules/@ethersproject/constants/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/rlp */ "./node_modules/@ethersproject/rlp/lib.esm/index.js");
/* harmony import */ var _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/signing-key */ "./node_modules/@ethersproject/signing-key/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/transactions/lib.esm/_version.js");











const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"](_version__WEBPACK_IMPORTED_MODULE_9__["version"]);
var TransactionTypes;
(function (TransactionTypes) {
    TransactionTypes[TransactionTypes["legacy"] = 0] = "legacy";
    TransactionTypes[TransactionTypes["eip2930"] = 1] = "eip2930";
    TransactionTypes[TransactionTypes["eip1559"] = 2] = "eip1559";
})(TransactionTypes || (TransactionTypes = {}));
;
///////////////////////////////
function handleAddress(value) {
    if (value === "0x") {
        return null;
    }
    return Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(value);
}
function handleNumber(value) {
    if (value === "0x") {
        return _ethersproject_constants__WEBPACK_IMPORTED_MODULE_3__["Zero"];
    }
    return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(value);
}
// Legacy Transaction Fields
const transactionFields = [
    { name: "nonce", maxLength: 32, numeric: true },
    { name: "gasPrice", maxLength: 32, numeric: true },
    { name: "gasLimit", maxLength: 32, numeric: true },
    { name: "to", length: 20 },
    { name: "value", maxLength: 32, numeric: true },
    { name: "data" },
];
const allowedTransactionKeys = {
    chainId: true, data: true, gasLimit: true, gasPrice: true, nonce: true, to: true, type: true, value: true
};
function computeAddress(key) {
    const publicKey = Object(_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_7__["computePublicKey"])(key);
    return Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexDataSlice"])(Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__["keccak256"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexDataSlice"])(publicKey, 1)), 12));
}
function recoverAddress(digest, signature) {
    return computeAddress(Object(_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_7__["recoverPublicKey"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(digest), signature));
}
function formatNumber(value, name) {
    const result = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["stripZeros"])(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(value).toHexString());
    if (result.length > 32) {
        logger.throwArgumentError("invalid length for " + name, ("transaction:" + name), value);
    }
    return result;
}
function accessSetify(addr, storageKeys) {
    return {
        address: Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(addr),
        storageKeys: (storageKeys || []).map((storageKey, index) => {
            if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexDataLength"])(storageKey) !== 32) {
                logger.throwArgumentError("invalid access list storageKey", `accessList[${addr}:${index}]`, storageKey);
            }
            return storageKey.toLowerCase();
        })
    };
}
function accessListify(value) {
    if (Array.isArray(value)) {
        return value.map((set, index) => {
            if (Array.isArray(set)) {
                if (set.length > 2) {
                    logger.throwArgumentError("access list expected to be [ address, storageKeys[] ]", `value[${index}]`, set);
                }
                return accessSetify(set[0], set[1]);
            }
            return accessSetify(set.address, set.storageKeys);
        });
    }
    const result = Object.keys(value).map((addr) => {
        const storageKeys = value[addr].reduce((accum, storageKey) => {
            accum[storageKey] = true;
            return accum;
        }, {});
        return accessSetify(addr, Object.keys(storageKeys).sort());
    });
    result.sort((a, b) => (a.address.localeCompare(b.address)));
    return result;
}
function formatAccessList(value) {
    return accessListify(value).map((set) => [set.address, set.storageKeys]);
}
function _serializeEip1559(transaction, signature) {
    // If there is an explicit gasPrice, make sure it matches the
    // EIP-1559 fees; otherwise they may not understand what they
    // think they are setting in terms of fee.
    if (transaction.gasPrice != null) {
        const gasPrice = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(transaction.gasPrice);
        const maxFeePerGas = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(transaction.maxFeePerGas || 0);
        if (!gasPrice.eq(maxFeePerGas)) {
            logger.throwArgumentError("mismatch EIP-1559 gasPrice != maxFeePerGas", "tx", {
                gasPrice, maxFeePerGas
            });
        }
    }
    const fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.maxPriorityFeePerGas || 0, "maxPriorityFeePerGas"),
        formatNumber(transaction.maxFeePerGas || 0, "maxFeePerGas"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        ((transaction.to != null) ? Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(transaction.to) : "0x"),
        formatNumber(transaction.value || 0, "value"),
        (transaction.data || "0x"),
        (formatAccessList(transaction.accessList || []))
    ];
    if (signature) {
        const sig = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["splitSignature"])(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["stripZeros"])(sig.r));
        fields.push(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["stripZeros"])(sig.s));
    }
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexConcat"])(["0x02", _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_6__["encode"](fields)]);
}
function _serializeEip2930(transaction, signature) {
    const fields = [
        formatNumber(transaction.chainId || 0, "chainId"),
        formatNumber(transaction.nonce || 0, "nonce"),
        formatNumber(transaction.gasPrice || 0, "gasPrice"),
        formatNumber(transaction.gasLimit || 0, "gasLimit"),
        ((transaction.to != null) ? Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(transaction.to) : "0x"),
        formatNumber(transaction.value || 0, "value"),
        (transaction.data || "0x"),
        (formatAccessList(transaction.accessList || []))
    ];
    if (signature) {
        const sig = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["splitSignature"])(signature);
        fields.push(formatNumber(sig.recoveryParam, "recoveryParam"));
        fields.push(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["stripZeros"])(sig.r));
        fields.push(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["stripZeros"])(sig.s));
    }
    return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexConcat"])(["0x01", _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_6__["encode"](fields)]);
}
// Legacy Transactions and EIP-155
function _serialize(transaction, signature) {
    Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_5__["checkProperties"])(transaction, allowedTransactionKeys);
    const raw = [];
    transactionFields.forEach(function (fieldInfo) {
        let value = transaction[fieldInfo.name] || ([]);
        const options = {};
        if (fieldInfo.numeric) {
            options.hexPad = "left";
        }
        value = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(value, options));
        // Fixed-width field
        if (fieldInfo.length && value.length !== fieldInfo.length && value.length > 0) {
            logger.throwArgumentError("invalid length for " + fieldInfo.name, ("transaction:" + fieldInfo.name), value);
        }
        // Variable-width (with a maximum)
        if (fieldInfo.maxLength) {
            value = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["stripZeros"])(value);
            if (value.length > fieldInfo.maxLength) {
                logger.throwArgumentError("invalid length for " + fieldInfo.name, ("transaction:" + fieldInfo.name), value);
            }
        }
        raw.push(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(value));
    });
    let chainId = 0;
    if (transaction.chainId != null) {
        // A chainId was provided; if non-zero we'll use EIP-155
        chainId = transaction.chainId;
        if (typeof (chainId) !== "number") {
            logger.throwArgumentError("invalid transaction.chainId", "transaction", transaction);
        }
    }
    else if (signature && !Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["isBytesLike"])(signature) && signature.v > 28) {
        // No chainId provided, but the signature is signing with EIP-155; derive chainId
        chainId = Math.floor((signature.v - 35) / 2);
    }
    // We have an EIP-155 transaction (chainId was specified and non-zero)
    if (chainId !== 0) {
        raw.push(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(chainId)); // @TODO: hexValue?
        raw.push("0x");
        raw.push("0x");
    }
    // Requesting an unsigned transaction
    if (!signature) {
        return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_6__["encode"](raw);
    }
    // The splitSignature will ensure the transaction has a recoveryParam in the
    // case that the signTransaction function only adds a v.
    const sig = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["splitSignature"])(signature);
    // We pushed a chainId and null r, s on for hashing only; remove those
    let v = 27 + sig.recoveryParam;
    if (chainId !== 0) {
        raw.pop();
        raw.pop();
        raw.pop();
        v += chainId * 2 + 8;
        // If an EIP-155 v (directly or indirectly; maybe _vs) was provided, check it!
        if (sig.v > 28 && sig.v !== v) {
            logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
        }
    }
    else if (sig.v !== v) {
        logger.throwArgumentError("transaction.chainId/signature.v mismatch", "signature", signature);
    }
    raw.push(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(v));
    raw.push(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["stripZeros"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(sig.r)));
    raw.push(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["stripZeros"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(sig.s)));
    return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_6__["encode"](raw);
}
function serialize(transaction, signature) {
    // Legacy and EIP-155 Transactions
    if (transaction.type == null || transaction.type === 0) {
        if (transaction.accessList != null) {
            logger.throwArgumentError("untyped transactions do not support accessList; include type: 1", "transaction", transaction);
        }
        return _serialize(transaction, signature);
    }
    // Typed Transactions (EIP-2718)
    switch (transaction.type) {
        case 1:
            return _serializeEip2930(transaction, signature);
        case 2:
            return _serializeEip1559(transaction, signature);
        default:
            break;
    }
    return logger.throwError(`unsupported transaction type: ${transaction.type}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
        operation: "serializeTransaction",
        transactionType: transaction.type
    });
}
function _parseEipSignature(tx, fields, serialize) {
    try {
        const recid = handleNumber(fields[0]).toNumber();
        if (recid !== 0 && recid !== 1) {
            throw new Error("bad recid");
        }
        tx.v = recid;
    }
    catch (error) {
        logger.throwArgumentError("invalid v for transaction type: 1", "v", fields[0]);
    }
    tx.r = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexZeroPad"])(fields[1], 32);
    tx.s = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexZeroPad"])(fields[2], 32);
    try {
        const digest = Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__["keccak256"])(serialize(tx));
        tx.from = recoverAddress(digest, { r: tx.r, s: tx.s, recoveryParam: tx.v });
    }
    catch (error) {
        console.log(error);
    }
}
function _parseEip1559(payload) {
    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_6__["decode"](payload.slice(1));
    if (transaction.length !== 9 && transaction.length !== 12) {
        logger.throwArgumentError("invalid component count for transaction type: 2", "payload", Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(payload));
    }
    const maxPriorityFeePerGas = handleNumber(transaction[2]);
    const maxFeePerGas = handleNumber(transaction[3]);
    const tx = {
        type: 2,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        maxPriorityFeePerGas: maxPriorityFeePerGas,
        maxFeePerGas: maxFeePerGas,
        gasPrice: null,
        gasLimit: handleNumber(transaction[4]),
        to: handleAddress(transaction[5]),
        value: handleNumber(transaction[6]),
        data: transaction[7],
        accessList: accessListify(transaction[8]),
    };
    // Unsigned EIP-1559 Transaction
    if (transaction.length === 9) {
        return tx;
    }
    tx.hash = Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__["keccak256"])(payload);
    _parseEipSignature(tx, transaction.slice(9), _serializeEip1559);
    return tx;
}
function _parseEip2930(payload) {
    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_6__["decode"](payload.slice(1));
    if (transaction.length !== 8 && transaction.length !== 11) {
        logger.throwArgumentError("invalid component count for transaction type: 1", "payload", Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(payload));
    }
    const tx = {
        type: 1,
        chainId: handleNumber(transaction[0]).toNumber(),
        nonce: handleNumber(transaction[1]).toNumber(),
        gasPrice: handleNumber(transaction[2]),
        gasLimit: handleNumber(transaction[3]),
        to: handleAddress(transaction[4]),
        value: handleNumber(transaction[5]),
        data: transaction[6],
        accessList: accessListify(transaction[7])
    };
    // Unsigned EIP-2930 Transaction
    if (transaction.length === 8) {
        return tx;
    }
    tx.hash = Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__["keccak256"])(payload);
    _parseEipSignature(tx, transaction.slice(8), _serializeEip2930);
    return tx;
}
// Legacy Transactions and EIP-155
function _parse(rawTransaction) {
    const transaction = _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_6__["decode"](rawTransaction);
    if (transaction.length !== 9 && transaction.length !== 6) {
        logger.throwArgumentError("invalid raw transaction", "rawTransaction", rawTransaction);
    }
    const tx = {
        nonce: handleNumber(transaction[0]).toNumber(),
        gasPrice: handleNumber(transaction[1]),
        gasLimit: handleNumber(transaction[2]),
        to: handleAddress(transaction[3]),
        value: handleNumber(transaction[4]),
        data: transaction[5],
        chainId: 0
    };
    // Legacy unsigned transaction
    if (transaction.length === 6) {
        return tx;
    }
    try {
        tx.v = _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(transaction[6]).toNumber();
    }
    catch (error) {
        console.log(error);
        return tx;
    }
    tx.r = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexZeroPad"])(transaction[7], 32);
    tx.s = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexZeroPad"])(transaction[8], 32);
    if (_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(tx.r).isZero() && _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"].from(tx.s).isZero()) {
        // EIP-155 unsigned transaction
        tx.chainId = tx.v;
        tx.v = 0;
    }
    else {
        // Signed Transaction
        tx.chainId = Math.floor((tx.v - 35) / 2);
        if (tx.chainId < 0) {
            tx.chainId = 0;
        }
        let recoveryParam = tx.v - 27;
        const raw = transaction.slice(0, 6);
        if (tx.chainId !== 0) {
            raw.push(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(tx.chainId));
            raw.push("0x");
            raw.push("0x");
            recoveryParam -= tx.chainId * 2 + 8;
        }
        const digest = Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__["keccak256"])(_ethersproject_rlp__WEBPACK_IMPORTED_MODULE_6__["encode"](raw));
        try {
            tx.from = recoverAddress(digest, { r: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(tx.r), s: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["hexlify"])(tx.s), recoveryParam: recoveryParam });
        }
        catch (error) {
            console.log(error);
        }
        tx.hash = Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_4__["keccak256"])(rawTransaction);
    }
    tx.type = null;
    return tx;
}
function parse(rawTransaction) {
    const payload = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_2__["arrayify"])(rawTransaction);
    // Legacy and EIP-155 Transactions
    if (payload[0] > 0x7f) {
        return _parse(payload);
    }
    // Typed Transaction (EIP-2718)
    switch (payload[0]) {
        case 1:
            return _parseEip2930(payload);
        case 2:
            return _parseEip1559(payload);
        default:
            break;
    }
    return logger.throwError(`unsupported transaction type: ${payload[0]}`, _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"].errors.UNSUPPORTED_OPERATION, {
        operation: "parseTransaction",
        transactionType: payload[0]
    });
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/units/lib.esm/_version.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ethersproject/units/lib.esm/_version.js ***!
  \***************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "units/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/units/lib.esm/index.js":
/*!************************************************************!*\
  !*** ./node_modules/@ethersproject/units/lib.esm/index.js ***!
  \************************************************************/
/*! exports provided: commify, formatUnits, parseUnits, formatEther, parseEther */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "commify", function() { return commify; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatUnits", function() { return formatUnits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseUnits", function() { return parseUnits; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatEther", function() { return formatEther; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseEther", function() { return parseEther; });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/units/lib.esm/_version.js");




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_1__["Logger"](_version__WEBPACK_IMPORTED_MODULE_2__["version"]);
const names = [
    "wei",
    "kwei",
    "mwei",
    "gwei",
    "szabo",
    "finney",
    "ether",
];
// Some environments have issues with RegEx that contain back-tracking, so we cannot
// use them.
function commify(value) {
    const comps = String(value).split(".");
    if (comps.length > 2 || !comps[0].match(/^-?[0-9]*$/) || (comps[1] && !comps[1].match(/^[0-9]*$/)) || value === "." || value === "-.") {
        logger.throwArgumentError("invalid value", "value", value);
    }
    // Make sure we have at least one whole digit (0 if none)
    let whole = comps[0];
    let negative = "";
    if (whole.substring(0, 1) === "-") {
        negative = "-";
        whole = whole.substring(1);
    }
    // Make sure we have at least 1 whole digit with no leading zeros
    while (whole.substring(0, 1) === "0") {
        whole = whole.substring(1);
    }
    if (whole === "") {
        whole = "0";
    }
    let suffix = "";
    if (comps.length === 2) {
        suffix = "." + (comps[1] || "0");
    }
    while (suffix.length > 2 && suffix[suffix.length - 1] === "0") {
        suffix = suffix.substring(0, suffix.length - 1);
    }
    const formatted = [];
    while (whole.length) {
        if (whole.length <= 3) {
            formatted.unshift(whole);
            break;
        }
        else {
            const index = whole.length - 3;
            formatted.unshift(whole.substring(index));
            whole = whole.substring(0, index);
        }
    }
    return negative + formatted.join(",") + suffix;
}
function formatUnits(value, unitName) {
    if (typeof (unitName) === "string") {
        const index = names.indexOf(unitName);
        if (index !== -1) {
            unitName = 3 * index;
        }
    }
    return Object(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["formatFixed"])(value, (unitName != null) ? unitName : 18);
}
function parseUnits(value, unitName) {
    if (typeof (value) !== "string") {
        logger.throwArgumentError("value must be a string", "value", value);
    }
    if (typeof (unitName) === "string") {
        const index = names.indexOf(unitName);
        if (index !== -1) {
            unitName = 3 * index;
        }
    }
    return Object(_ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["parseFixed"])(value, (unitName != null) ? unitName : 18);
}
function formatEther(wei) {
    return formatUnits(wei, 18);
}
function parseEther(ether) {
    return parseUnits(ether, 18);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/wallet/lib.esm/_version.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/wallet/lib.esm/_version.js ***!
  \****************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "wallet/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/wallet/lib.esm/index.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/wallet/lib.esm/index.js ***!
  \*************************************************************/
/*! exports provided: Wallet, verifyMessage, verifyTypedData */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Wallet", function() { return Wallet; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyMessage", function() { return verifyMessage; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "verifyTypedData", function() { return verifyTypedData; });
/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony import */ var _ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/abstract-provider */ "./node_modules/@ethersproject/abstract-provider/lib.esm/index.js");
/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/abstract-signer */ "./node_modules/@ethersproject/abstract-signer/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/index.js");
/* harmony import */ var _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/hdnode */ "./node_modules/@ethersproject/hdnode/lib.esm/index.js");
/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_random__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/random */ "./node_modules/@ethersproject/random/lib.esm/index.js");
/* harmony import */ var _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/signing-key */ "./node_modules/@ethersproject/signing-key/lib.esm/index.js");
/* harmony import */ var _ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/json-wallets */ "./node_modules/@ethersproject/json-wallets/lib.esm/index.js");
/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/wallet/lib.esm/_version.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};














const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"](_version__WEBPACK_IMPORTED_MODULE_13__["version"]);
function isAccount(value) {
    return (value != null && Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["isHexString"])(value.privateKey, 32) && value.address != null);
}
function hasMnemonic(value) {
    const mnemonic = value.mnemonic;
    return (mnemonic && mnemonic.phrase);
}
class Wallet extends _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_2__["Signer"] {
    constructor(privateKey, provider) {
        logger.checkNew(new.target, Wallet);
        super();
        if (isAccount(privateKey)) {
            const signingKey = new _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_9__["SigningKey"](privateKey.privateKey);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "_signingKey", () => signingKey);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "address", Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_11__["computeAddress"])(this.publicKey));
            if (this.address !== Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(privateKey.address)) {
                logger.throwArgumentError("privateKey/address mismatch", "privateKey", "[REDACTED]");
            }
            if (hasMnemonic(privateKey)) {
                const srcMnemonic = privateKey.mnemonic;
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "_mnemonic", () => ({
                    phrase: srcMnemonic.phrase,
                    path: srcMnemonic.path || _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_5__["defaultPath"],
                    locale: srcMnemonic.locale || "en"
                }));
                const mnemonic = this.mnemonic;
                const node = _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_5__["HDNode"].fromMnemonic(mnemonic.phrase, null, mnemonic.locale).derivePath(mnemonic.path);
                if (Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_11__["computeAddress"])(node.privateKey) !== this.address) {
                    logger.throwArgumentError("mnemonic/address mismatch", "privateKey", "[REDACTED]");
                }
            }
            else {
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "_mnemonic", () => null);
            }
        }
        else {
            if (_ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_9__["SigningKey"].isSigningKey(privateKey)) {
                /* istanbul ignore if */
                if (privateKey.curve !== "secp256k1") {
                    logger.throwArgumentError("unsupported curve; must be secp256k1", "privateKey", "[REDACTED]");
                }
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "_signingKey", () => privateKey);
            }
            else {
                // A lot of common tools do not prefix private keys with a 0x (see: #1166)
                if (typeof (privateKey) === "string") {
                    if (privateKey.match(/^[0-9a-f]*$/i) && privateKey.length === 64) {
                        privateKey = "0x" + privateKey;
                    }
                }
                const signingKey = new _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_9__["SigningKey"](privateKey);
                Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "_signingKey", () => signingKey);
            }
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "_mnemonic", () => null);
            Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "address", Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_11__["computeAddress"])(this.publicKey));
        }
        /* istanbul ignore if */
        if (provider && !_ethersproject_abstract_provider__WEBPACK_IMPORTED_MODULE_1__["Provider"].isProvider(provider)) {
            logger.throwArgumentError("invalid provider", "provider", provider);
        }
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["defineReadOnly"])(this, "provider", provider || null);
    }
    get mnemonic() { return this._mnemonic(); }
    get privateKey() { return this._signingKey().privateKey; }
    get publicKey() { return this._signingKey().publicKey; }
    getAddress() {
        return Promise.resolve(this.address);
    }
    connect(provider) {
        return new Wallet(this, provider);
    }
    signTransaction(transaction) {
        return Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_7__["resolveProperties"])(transaction).then((tx) => {
            if (tx.from != null) {
                if (Object(_ethersproject_address__WEBPACK_IMPORTED_MODULE_0__["getAddress"])(tx.from) !== this.address) {
                    logger.throwArgumentError("transaction from address mismatch", "transaction.from", transaction.from);
                }
                delete tx.from;
            }
            const signature = this._signingKey().signDigest(Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_6__["keccak256"])(Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_11__["serialize"])(tx)));
            return Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_11__["serialize"])(tx, signature);
        });
    }
    signMessage(message) {
        return __awaiter(this, void 0, void 0, function* () {
            return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["joinSignature"])(this._signingKey().signDigest(Object(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_4__["hashMessage"])(message)));
        });
    }
    _signTypedData(domain, types, value) {
        return __awaiter(this, void 0, void 0, function* () {
            // Populate any ENS names
            const populated = yield _ethersproject_hash__WEBPACK_IMPORTED_MODULE_4__["_TypedDataEncoder"].resolveNames(domain, types, value, (name) => {
                if (this.provider == null) {
                    logger.throwError("cannot resolve ENS names without a provider", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_12__["Logger"].errors.UNSUPPORTED_OPERATION, {
                        operation: "resolveName",
                        value: name
                    });
                }
                return this.provider.resolveName(name);
            });
            return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["joinSignature"])(this._signingKey().signDigest(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_4__["_TypedDataEncoder"].hash(populated.domain, types, populated.value)));
        });
    }
    encrypt(password, options, progressCallback) {
        if (typeof (options) === "function" && !progressCallback) {
            progressCallback = options;
            options = {};
        }
        if (progressCallback && typeof (progressCallback) !== "function") {
            throw new Error("invalid callback");
        }
        if (!options) {
            options = {};
        }
        return Object(_ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_10__["encryptKeystore"])(this, password, options, progressCallback);
    }
    /**
     *  Static methods to create Wallet instances.
     */
    static createRandom(options) {
        let entropy = Object(_ethersproject_random__WEBPACK_IMPORTED_MODULE_8__["randomBytes"])(16);
        if (!options) {
            options = {};
        }
        if (options.extraEntropy) {
            entropy = Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["arrayify"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["hexDataSlice"])(Object(_ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_6__["keccak256"])(Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_3__["concat"])([entropy, options.extraEntropy])), 0, 16));
        }
        const mnemonic = Object(_ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_5__["entropyToMnemonic"])(entropy, options.locale);
        return Wallet.fromMnemonic(mnemonic, options.path, options.locale);
    }
    static fromEncryptedJson(json, password, progressCallback) {
        return Object(_ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_10__["decryptJsonWallet"])(json, password, progressCallback).then((account) => {
            return new Wallet(account);
        });
    }
    static fromEncryptedJsonSync(json, password) {
        return new Wallet(Object(_ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_10__["decryptJsonWalletSync"])(json, password));
    }
    static fromMnemonic(mnemonic, path, wordlist) {
        if (!path) {
            path = _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_5__["defaultPath"];
        }
        return new Wallet(_ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_5__["HDNode"].fromMnemonic(mnemonic, null, wordlist).derivePath(path));
    }
}
function verifyMessage(message, signature) {
    return Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_11__["recoverAddress"])(Object(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_4__["hashMessage"])(message), signature);
}
function verifyTypedData(domain, types, value, signature) {
    return Object(_ethersproject_transactions__WEBPACK_IMPORTED_MODULE_11__["recoverAddress"])(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_4__["_TypedDataEncoder"].hash(domain, types, value), signature);
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/web/lib.esm/_version.js":
/*!*************************************************************!*\
  !*** ./node_modules/@ethersproject/web/lib.esm/_version.js ***!
  \*************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "web/5.5.1";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/web/lib.esm/geturl.js":
/*!***********************************************************!*\
  !*** ./node_modules/@ethersproject/web/lib.esm/geturl.js ***!
  \***********************************************************/
/*! exports provided: getUrl */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getUrl", function() { return getUrl; });
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

function getUrl(href, options) {
    return __awaiter(this, void 0, void 0, function* () {
        if (options == null) {
            options = {};
        }
        const request = {
            method: (options.method || "GET"),
            headers: (options.headers || {}),
            body: (options.body || undefined),
        };
        if (options.skipFetchSetup !== true) {
            request.mode = "cors"; // no-cors, cors, *same-origin
            request.cache = "no-cache"; // *default, no-cache, reload, force-cache, only-if-cached
            request.credentials = "same-origin"; // include, *same-origin, omit
            request.redirect = "follow"; // manual, *follow, error
            request.referrer = "client"; // no-referrer, *client
        }
        ;
        const response = yield fetch(href, request);
        const body = yield response.arrayBuffer();
        const headers = {};
        if (response.headers.forEach) {
            response.headers.forEach((value, key) => {
                headers[key.toLowerCase()] = value;
            });
        }
        else {
            ((response.headers).keys)().forEach((key) => {
                headers[key.toLowerCase()] = response.headers.get(key);
            });
        }
        return {
            headers: headers,
            statusCode: response.status,
            statusMessage: response.statusText,
            body: Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_0__["arrayify"])(new Uint8Array(body)),
        };
    });
}
//# sourceMappingURL=geturl.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/web/lib.esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@ethersproject/web/lib.esm/index.js ***!
  \**********************************************************/
/*! exports provided: _fetchData, fetchJson, poll */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "_fetchData", function() { return _fetchData; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fetchJson", function() { return fetchJson; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "poll", function() { return poll; });
/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/base64 */ "./node_modules/@ethersproject/base64/lib.esm/index.js");
/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/web/lib.esm/_version.js");
/* harmony import */ var _geturl__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./geturl */ "./node_modules/@ethersproject/web/lib.esm/geturl.js");

var __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};






const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"](_version__WEBPACK_IMPORTED_MODULE_5__["version"]);

function staller(duration) {
    return new Promise((resolve) => {
        setTimeout(resolve, duration);
    });
}
function bodyify(value, type) {
    if (value == null) {
        return null;
    }
    if (typeof (value) === "string") {
        return value;
    }
    if (Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["isBytesLike"])(value)) {
        if (type && (type.split("/")[0] === "text" || type.split(";")[0].trim() === "application/json")) {
            try {
                return Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__["toUtf8String"])(value);
            }
            catch (error) { }
            ;
        }
        return Object(_ethersproject_bytes__WEBPACK_IMPORTED_MODULE_1__["hexlify"])(value);
    }
    return value;
}
// This API is still a work in progress; the future changes will likely be:
// - ConnectionInfo => FetchDataRequest<T = any>
// - FetchDataRequest.body? = string | Uint8Array | { contentType: string, data: string | Uint8Array }
//   - If string => text/plain, Uint8Array => application/octet-stream (if content-type unspecified)
// - FetchDataRequest.processFunc = (body: Uint8Array, response: FetchDataResponse) => T
// For this reason, it should be considered internal until the API is finalized
function _fetchData(connection, body, processFunc) {
    // How many times to retry in the event of a throttle
    const attemptLimit = (typeof (connection) === "object" && connection.throttleLimit != null) ? connection.throttleLimit : 12;
    logger.assertArgument((attemptLimit > 0 && (attemptLimit % 1) === 0), "invalid connection throttle limit", "connection.throttleLimit", attemptLimit);
    const throttleCallback = ((typeof (connection) === "object") ? connection.throttleCallback : null);
    const throttleSlotInterval = ((typeof (connection) === "object" && typeof (connection.throttleSlotInterval) === "number") ? connection.throttleSlotInterval : 100);
    logger.assertArgument((throttleSlotInterval > 0 && (throttleSlotInterval % 1) === 0), "invalid connection throttle slot interval", "connection.throttleSlotInterval", throttleSlotInterval);
    const headers = {};
    let url = null;
    // @TODO: Allow ConnectionInfo to override some of these values
    const options = {
        method: "GET",
    };
    let allow304 = false;
    let timeout = 2 * 60 * 1000;
    if (typeof (connection) === "string") {
        url = connection;
    }
    else if (typeof (connection) === "object") {
        if (connection == null || connection.url == null) {
            logger.throwArgumentError("missing URL", "connection.url", connection);
        }
        url = connection.url;
        if (typeof (connection.timeout) === "number" && connection.timeout > 0) {
            timeout = connection.timeout;
        }
        if (connection.headers) {
            for (const key in connection.headers) {
                headers[key.toLowerCase()] = { key: key, value: String(connection.headers[key]) };
                if (["if-none-match", "if-modified-since"].indexOf(key.toLowerCase()) >= 0) {
                    allow304 = true;
                }
            }
        }
        options.allowGzip = !!connection.allowGzip;
        if (connection.user != null && connection.password != null) {
            if (url.substring(0, 6) !== "https:" && connection.allowInsecureAuthentication !== true) {
                logger.throwError("basic authentication requires a secure https url", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].errors.INVALID_ARGUMENT, { argument: "url", url: url, user: connection.user, password: "[REDACTED]" });
            }
            const authorization = connection.user + ":" + connection.password;
            headers["authorization"] = {
                key: "Authorization",
                value: "Basic " + Object(_ethersproject_base64__WEBPACK_IMPORTED_MODULE_0__["encode"])(Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__["toUtf8Bytes"])(authorization))
            };
        }
    }
    const reData = new RegExp("^data:([a-z0-9-]+/[a-z0-9-]+);base64,(.*)$", "i");
    const dataMatch = ((url) ? url.match(reData) : null);
    if (dataMatch) {
        try {
            const response = {
                statusCode: 200,
                statusMessage: "OK",
                headers: { "content-type": dataMatch[1] },
                body: Object(_ethersproject_base64__WEBPACK_IMPORTED_MODULE_0__["decode"])(dataMatch[2])
            };
            let result = response.body;
            if (processFunc) {
                result = processFunc(response.body, response);
            }
            return Promise.resolve(result);
        }
        catch (error) {
            logger.throwError("processing response error", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].errors.SERVER_ERROR, {
                body: bodyify(dataMatch[1], dataMatch[2]),
                error: error,
                requestBody: null,
                requestMethod: "GET",
                url: url
            });
        }
    }
    if (body) {
        options.method = "POST";
        options.body = body;
        if (headers["content-type"] == null) {
            headers["content-type"] = { key: "Content-Type", value: "application/octet-stream" };
        }
        if (headers["content-length"] == null) {
            headers["content-length"] = { key: "Content-Length", value: String(body.length) };
        }
    }
    const flatHeaders = {};
    Object.keys(headers).forEach((key) => {
        const header = headers[key];
        flatHeaders[header.key] = header.value;
    });
    options.headers = flatHeaders;
    const runningTimeout = (function () {
        let timer = null;
        const promise = new Promise(function (resolve, reject) {
            if (timeout) {
                timer = setTimeout(() => {
                    if (timer == null) {
                        return;
                    }
                    timer = null;
                    reject(logger.makeError("timeout", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].errors.TIMEOUT, {
                        requestBody: bodyify(options.body, flatHeaders["content-type"]),
                        requestMethod: options.method,
                        timeout: timeout,
                        url: url
                    }));
                }, timeout);
            }
        });
        const cancel = function () {
            if (timer == null) {
                return;
            }
            clearTimeout(timer);
            timer = null;
        };
        return { promise, cancel };
    })();
    const runningFetch = (function () {
        return __awaiter(this, void 0, void 0, function* () {
            for (let attempt = 0; attempt < attemptLimit; attempt++) {
                let response = null;
                try {
                    response = yield Object(_geturl__WEBPACK_IMPORTED_MODULE_6__["getUrl"])(url, options);
                    if (attempt < attemptLimit) {
                        if (response.statusCode === 301 || response.statusCode === 302) {
                            // Redirection; for now we only support absolute locataions
                            const location = response.headers.location || "";
                            if (options.method === "GET" && location.match(/^https:/)) {
                                url = response.headers.location;
                                continue;
                            }
                        }
                        else if (response.statusCode === 429) {
                            // Exponential back-off throttling
                            let tryAgain = true;
                            if (throttleCallback) {
                                tryAgain = yield throttleCallback(attempt, url);
                            }
                            if (tryAgain) {
                                let stall = 0;
                                const retryAfter = response.headers["retry-after"];
                                if (typeof (retryAfter) === "string" && retryAfter.match(/^[1-9][0-9]*$/)) {
                                    stall = parseInt(retryAfter) * 1000;
                                }
                                else {
                                    stall = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                                }
                                //console.log("Stalling 429");
                                yield staller(stall);
                                continue;
                            }
                        }
                    }
                }
                catch (error) {
                    response = error.response;
                    if (response == null) {
                        runningTimeout.cancel();
                        logger.throwError("missing response", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].errors.SERVER_ERROR, {
                            requestBody: bodyify(options.body, flatHeaders["content-type"]),
                            requestMethod: options.method,
                            serverError: error,
                            url: url
                        });
                    }
                }
                let body = response.body;
                if (allow304 && response.statusCode === 304) {
                    body = null;
                }
                else if (response.statusCode < 200 || response.statusCode >= 300) {
                    runningTimeout.cancel();
                    logger.throwError("bad response", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].errors.SERVER_ERROR, {
                        status: response.statusCode,
                        headers: response.headers,
                        body: bodyify(body, ((response.headers) ? response.headers["content-type"] : null)),
                        requestBody: bodyify(options.body, flatHeaders["content-type"]),
                        requestMethod: options.method,
                        url: url
                    });
                }
                if (processFunc) {
                    try {
                        const result = yield processFunc(body, response);
                        runningTimeout.cancel();
                        return result;
                    }
                    catch (error) {
                        // Allow the processFunc to trigger a throttle
                        if (error.throttleRetry && attempt < attemptLimit) {
                            let tryAgain = true;
                            if (throttleCallback) {
                                tryAgain = yield throttleCallback(attempt, url);
                            }
                            if (tryAgain) {
                                const timeout = throttleSlotInterval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                                //console.log("Stalling callback");
                                yield staller(timeout);
                                continue;
                            }
                        }
                        runningTimeout.cancel();
                        logger.throwError("processing response error", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].errors.SERVER_ERROR, {
                            body: bodyify(body, ((response.headers) ? response.headers["content-type"] : null)),
                            error: error,
                            requestBody: bodyify(options.body, flatHeaders["content-type"]),
                            requestMethod: options.method,
                            url: url
                        });
                    }
                }
                runningTimeout.cancel();
                // If we had a processFunc, it either returned a T or threw above.
                // The "body" is now a Uint8Array.
                return body;
            }
            return logger.throwError("failed response", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].errors.SERVER_ERROR, {
                requestBody: bodyify(options.body, flatHeaders["content-type"]),
                requestMethod: options.method,
                url: url
            });
        });
    })();
    return Promise.race([runningTimeout.promise, runningFetch]);
}
function fetchJson(connection, json, processFunc) {
    let processJsonFunc = (value, response) => {
        let result = null;
        if (value != null) {
            try {
                result = JSON.parse(Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__["toUtf8String"])(value));
            }
            catch (error) {
                logger.throwError("invalid JSON", _ethersproject_logger__WEBPACK_IMPORTED_MODULE_4__["Logger"].errors.SERVER_ERROR, {
                    body: value,
                    error: error
                });
            }
        }
        if (processFunc) {
            result = processFunc(result, response);
        }
        return result;
    };
    // If we have json to send, we must
    // - add content-type of application/json (unless already overridden)
    // - convert the json to bytes
    let body = null;
    if (json != null) {
        body = Object(_ethersproject_strings__WEBPACK_IMPORTED_MODULE_3__["toUtf8Bytes"])(json);
        // Create a connection with the content-type set for JSON
        const updated = (typeof (connection) === "string") ? ({ url: connection }) : Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["shallowCopy"])(connection);
        if (updated.headers) {
            const hasContentType = (Object.keys(updated.headers).filter((k) => (k.toLowerCase() === "content-type")).length) !== 0;
            if (!hasContentType) {
                updated.headers = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["shallowCopy"])(updated.headers);
                updated.headers["content-type"] = "application/json";
            }
        }
        else {
            updated.headers = { "content-type": "application/json" };
        }
        connection = updated;
    }
    return _fetchData(connection, body, processJsonFunc);
}
function poll(func, options) {
    if (!options) {
        options = {};
    }
    options = Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_2__["shallowCopy"])(options);
    if (options.floor == null) {
        options.floor = 0;
    }
    if (options.ceiling == null) {
        options.ceiling = 10000;
    }
    if (options.interval == null) {
        options.interval = 250;
    }
    return new Promise(function (resolve, reject) {
        let timer = null;
        let done = false;
        // Returns true if cancel was successful. Unsuccessful cancel means we're already done.
        const cancel = () => {
            if (done) {
                return false;
            }
            done = true;
            if (timer) {
                clearTimeout(timer);
            }
            return true;
        };
        if (options.timeout) {
            timer = setTimeout(() => {
                if (cancel()) {
                    reject(new Error("timeout"));
                }
            }, options.timeout);
        }
        const retryLimit = options.retryLimit;
        let attempt = 0;
        function check() {
            return func().then(function (result) {
                // If we have a result, or are allowed null then we're done
                if (result !== undefined) {
                    if (cancel()) {
                        resolve(result);
                    }
                }
                else if (options.oncePoll) {
                    options.oncePoll.once("poll", check);
                }
                else if (options.onceBlock) {
                    options.onceBlock.once("block", check);
                    // Otherwise, exponential back-off (up to 10s) our next request
                }
                else if (!done) {
                    attempt++;
                    if (attempt > retryLimit) {
                        if (cancel()) {
                            reject(new Error("retry limit reached"));
                        }
                        return;
                    }
                    let timeout = options.interval * parseInt(String(Math.random() * Math.pow(2, attempt)));
                    if (timeout < options.floor) {
                        timeout = options.floor;
                    }
                    if (timeout > options.ceiling) {
                        timeout = options.ceiling;
                    }
                    setTimeout(check, timeout);
                }
                return null;
            }, function (error) {
                if (cancel()) {
                    reject(error);
                }
            });
        }
        check();
    });
}
//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/wordlists/lib.esm/_version.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/wordlists/lib.esm/_version.js ***!
  \*******************************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "wordlists/5.5.0";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/wordlists/lib.esm/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/@ethersproject/wordlists/lib.esm/index.js ***!
  \****************************************************************/
/*! exports provided: logger, Wordlist, wordlists */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _wordlist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist */ "./node_modules/@ethersproject/wordlists/lib.esm/wordlist.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logger", function() { return _wordlist__WEBPACK_IMPORTED_MODULE_0__["logger"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Wordlist", function() { return _wordlist__WEBPACK_IMPORTED_MODULE_0__["Wordlist"]; });

/* harmony import */ var _wordlists__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./wordlists */ "./node_modules/@ethersproject/wordlists/lib.esm/wordlists.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "wordlists", function() { return _wordlists__WEBPACK_IMPORTED_MODULE_1__["wordlists"]; });


// Wordlists
// See: https://github.com/bitcoin/bips/blob/master/bip-0039/bip-0039-wordlists.md



//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/wordlists/lib.esm/lang-en.js":
/*!******************************************************************!*\
  !*** ./node_modules/@ethersproject/wordlists/lib.esm/lang-en.js ***!
  \******************************************************************/
/*! exports provided: langEn */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "langEn", function() { return langEn; });
/* harmony import */ var _wordlist__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./wordlist */ "./node_modules/@ethersproject/wordlists/lib.esm/wordlist.js");


const words = "AbandonAbilityAbleAboutAboveAbsentAbsorbAbstractAbsurdAbuseAccessAccidentAccountAccuseAchieveAcidAcousticAcquireAcrossActActionActorActressActualAdaptAddAddictAddressAdjustAdmitAdultAdvanceAdviceAerobicAffairAffordAfraidAgainAgeAgentAgreeAheadAimAirAirportAisleAlarmAlbumAlcoholAlertAlienAllAlleyAllowAlmostAloneAlphaAlreadyAlsoAlterAlwaysAmateurAmazingAmongAmountAmusedAnalystAnchorAncientAngerAngleAngryAnimalAnkleAnnounceAnnualAnotherAnswerAntennaAntiqueAnxietyAnyApartApologyAppearAppleApproveAprilArchArcticAreaArenaArgueArmArmedArmorArmyAroundArrangeArrestArriveArrowArtArtefactArtistArtworkAskAspectAssaultAssetAssistAssumeAsthmaAthleteAtomAttackAttendAttitudeAttractAuctionAuditAugustAuntAuthorAutoAutumnAverageAvocadoAvoidAwakeAwareAwayAwesomeAwfulAwkwardAxisBabyBachelorBaconBadgeBagBalanceBalconyBallBambooBananaBannerBarBarelyBargainBarrelBaseBasicBasketBattleBeachBeanBeautyBecauseBecomeBeefBeforeBeginBehaveBehindBelieveBelowBeltBenchBenefitBestBetrayBetterBetweenBeyondBicycleBidBikeBindBiologyBirdBirthBitterBlackBladeBlameBlanketBlastBleakBlessBlindBloodBlossomBlouseBlueBlurBlushBoardBoatBodyBoilBombBoneBonusBookBoostBorderBoringBorrowBossBottomBounceBoxBoyBracketBrainBrandBrassBraveBreadBreezeBrickBridgeBriefBrightBringBriskBroccoliBrokenBronzeBroomBrotherBrownBrushBubbleBuddyBudgetBuffaloBuildBulbBulkBulletBundleBunkerBurdenBurgerBurstBusBusinessBusyButterBuyerBuzzCabbageCabinCableCactusCageCakeCallCalmCameraCampCanCanalCancelCandyCannonCanoeCanvasCanyonCapableCapitalCaptainCarCarbonCardCargoCarpetCarryCartCaseCashCasinoCastleCasualCatCatalogCatchCategoryCattleCaughtCauseCautionCaveCeilingCeleryCementCensusCenturyCerealCertainChairChalkChampionChangeChaosChapterChargeChaseChatCheapCheckCheeseChefCherryChestChickenChiefChildChimneyChoiceChooseChronicChuckleChunkChurnCigarCinnamonCircleCitizenCityCivilClaimClapClarifyClawClayCleanClerkCleverClickClientCliffClimbClinicClipClockClogCloseClothCloudClownClubClumpClusterClutchCoachCoastCoconutCodeCoffeeCoilCoinCollectColorColumnCombineComeComfortComicCommonCompanyConcertConductConfirmCongressConnectConsiderControlConvinceCookCoolCopperCopyCoralCoreCornCorrectCostCottonCouchCountryCoupleCourseCousinCoverCoyoteCrackCradleCraftCramCraneCrashCraterCrawlCrazyCreamCreditCreekCrewCricketCrimeCrispCriticCropCrossCrouchCrowdCrucialCruelCruiseCrumbleCrunchCrushCryCrystalCubeCultureCupCupboardCuriousCurrentCurtainCurveCushionCustomCuteCycleDadDamageDampDanceDangerDaringDashDaughterDawnDayDealDebateDebrisDecadeDecemberDecideDeclineDecorateDecreaseDeerDefenseDefineDefyDegreeDelayDeliverDemandDemiseDenialDentistDenyDepartDependDepositDepthDeputyDeriveDescribeDesertDesignDeskDespairDestroyDetailDetectDevelopDeviceDevoteDiagramDialDiamondDiaryDiceDieselDietDifferDigitalDignityDilemmaDinnerDinosaurDirectDirtDisagreeDiscoverDiseaseDishDismissDisorderDisplayDistanceDivertDivideDivorceDizzyDoctorDocumentDogDollDolphinDomainDonateDonkeyDonorDoorDoseDoubleDoveDraftDragonDramaDrasticDrawDreamDressDriftDrillDrinkDripDriveDropDrumDryDuckDumbDuneDuringDustDutchDutyDwarfDynamicEagerEagleEarlyEarnEarthEasilyEastEasyEchoEcologyEconomyEdgeEditEducateEffortEggEightEitherElbowElderElectricElegantElementElephantElevatorEliteElseEmbarkEmbodyEmbraceEmergeEmotionEmployEmpowerEmptyEnableEnactEndEndlessEndorseEnemyEnergyEnforceEngageEngineEnhanceEnjoyEnlistEnoughEnrichEnrollEnsureEnterEntireEntryEnvelopeEpisodeEqualEquipEraEraseErodeErosionErrorEruptEscapeEssayEssenceEstateEternalEthicsEvidenceEvilEvokeEvolveExactExampleExcessExchangeExciteExcludeExcuseExecuteExerciseExhaustExhibitExileExistExitExoticExpandExpectExpireExplainExposeExpressExtendExtraEyeEyebrowFabricFaceFacultyFadeFaintFaithFallFalseFameFamilyFamousFanFancyFantasyFarmFashionFatFatalFatherFatigueFaultFavoriteFeatureFebruaryFederalFeeFeedFeelFemaleFenceFestivalFetchFeverFewFiberFictionFieldFigureFileFilmFilterFinalFindFineFingerFinishFireFirmFirstFiscalFishFitFitnessFixFlagFlameFlashFlatFlavorFleeFlightFlipFloatFlockFloorFlowerFluidFlushFlyFoamFocusFogFoilFoldFollowFoodFootForceForestForgetForkFortuneForumForwardFossilFosterFoundFoxFragileFrameFrequentFreshFriendFringeFrogFrontFrostFrownFrozenFruitFuelFunFunnyFurnaceFuryFutureGadgetGainGalaxyGalleryGameGapGarageGarbageGardenGarlicGarmentGasGaspGateGatherGaugeGazeGeneralGeniusGenreGentleGenuineGestureGhostGiantGiftGiggleGingerGiraffeGirlGiveGladGlanceGlareGlassGlideGlimpseGlobeGloomGloryGloveGlowGlueGoatGoddessGoldGoodGooseGorillaGospelGossipGovernGownGrabGraceGrainGrantGrapeGrassGravityGreatGreenGridGriefGritGroceryGroupGrowGruntGuardGuessGuideGuiltGuitarGunGymHabitHairHalfHammerHamsterHandHappyHarborHardHarshHarvestHatHaveHawkHazardHeadHealthHeartHeavyHedgehogHeightHelloHelmetHelpHenHeroHiddenHighHillHintHipHireHistoryHobbyHockeyHoldHoleHolidayHollowHomeHoneyHoodHopeHornHorrorHorseHospitalHostHotelHourHoverHubHugeHumanHumbleHumorHundredHungryHuntHurdleHurryHurtHusbandHybridIceIconIdeaIdentifyIdleIgnoreIllIllegalIllnessImageImitateImmenseImmuneImpactImposeImproveImpulseInchIncludeIncomeIncreaseIndexIndicateIndoorIndustryInfantInflictInformInhaleInheritInitialInjectInjuryInmateInnerInnocentInputInquiryInsaneInsectInsideInspireInstallIntactInterestIntoInvestInviteInvolveIronIslandIsolateIssueItemIvoryJacketJaguarJarJazzJealousJeansJellyJewelJobJoinJokeJourneyJoyJudgeJuiceJumpJungleJuniorJunkJustKangarooKeenKeepKetchupKeyKickKidKidneyKindKingdomKissKitKitchenKiteKittenKiwiKneeKnifeKnockKnowLabLabelLaborLadderLadyLakeLampLanguageLaptopLargeLaterLatinLaughLaundryLavaLawLawnLawsuitLayerLazyLeaderLeafLearnLeaveLectureLeftLegLegalLegendLeisureLemonLendLengthLensLeopardLessonLetterLevelLiarLibertyLibraryLicenseLifeLiftLightLikeLimbLimitLinkLionLiquidListLittleLiveLizardLoadLoanLobsterLocalLockLogicLonelyLongLoopLotteryLoudLoungeLoveLoyalLuckyLuggageLumberLunarLunchLuxuryLyricsMachineMadMagicMagnetMaidMailMainMajorMakeMammalManManageMandateMangoMansionManualMapleMarbleMarchMarginMarineMarketMarriageMaskMassMasterMatchMaterialMathMatrixMatterMaximumMazeMeadowMeanMeasureMeatMechanicMedalMediaMelodyMeltMemberMemoryMentionMenuMercyMergeMeritMerryMeshMessageMetalMethodMiddleMidnightMilkMillionMimicMindMinimumMinorMinuteMiracleMirrorMiseryMissMistakeMixMixedMixtureMobileModelModifyMomMomentMonitorMonkeyMonsterMonthMoonMoralMoreMorningMosquitoMotherMotionMotorMountainMouseMoveMovieMuchMuffinMuleMultiplyMuscleMuseumMushroomMusicMustMutualMyselfMysteryMythNaiveNameNapkinNarrowNastyNationNatureNearNeckNeedNegativeNeglectNeitherNephewNerveNestNetNetworkNeutralNeverNewsNextNiceNightNobleNoiseNomineeNoodleNormalNorthNoseNotableNoteNothingNoticeNovelNowNuclearNumberNurseNutOakObeyObjectObligeObscureObserveObtainObviousOccurOceanOctoberOdorOffOfferOfficeOftenOilOkayOldOliveOlympicOmitOnceOneOnionOnlineOnlyOpenOperaOpinionOpposeOptionOrangeOrbitOrchardOrderOrdinaryOrganOrientOriginalOrphanOstrichOtherOutdoorOuterOutputOutsideOvalOvenOverOwnOwnerOxygenOysterOzonePactPaddlePagePairPalacePalmPandaPanelPanicPantherPaperParadeParentParkParrotPartyPassPatchPathPatientPatrolPatternPausePavePaymentPeacePeanutPearPeasantPelicanPenPenaltyPencilPeoplePepperPerfectPermitPersonPetPhonePhotoPhrasePhysicalPianoPicnicPicturePiecePigPigeonPillPilotPinkPioneerPipePistolPitchPizzaPlacePlanetPlasticPlatePlayPleasePledgePluckPlugPlungePoemPoetPointPolarPolePolicePondPonyPoolPopularPortionPositionPossiblePostPotatoPotteryPovertyPowderPowerPracticePraisePredictPreferPreparePresentPrettyPreventPricePridePrimaryPrintPriorityPrisonPrivatePrizeProblemProcessProduceProfitProgramProjectPromoteProofPropertyProsperProtectProudProvidePublicPuddingPullPulpPulsePumpkinPunchPupilPuppyPurchasePurityPurposePursePushPutPuzzlePyramidQualityQuantumQuarterQuestionQuickQuitQuizQuoteRabbitRaccoonRaceRackRadarRadioRailRainRaiseRallyRampRanchRandomRangeRapidRareRateRatherRavenRawRazorReadyRealReasonRebelRebuildRecallReceiveRecipeRecordRecycleReduceReflectReformRefuseRegionRegretRegularRejectRelaxReleaseReliefRelyRemainRememberRemindRemoveRenderRenewRentReopenRepairRepeatReplaceReportRequireRescueResembleResistResourceResponseResultRetireRetreatReturnReunionRevealReviewRewardRhythmRibRibbonRiceRichRideRidgeRifleRightRigidRingRiotRippleRiskRitualRivalRiverRoadRoastRobotRobustRocketRomanceRoofRookieRoomRoseRotateRoughRoundRouteRoyalRubberRudeRugRuleRunRunwayRuralSadSaddleSadnessSafeSailSaladSalmonSalonSaltSaluteSameSampleSandSatisfySatoshiSauceSausageSaveSayScaleScanScareScatterSceneSchemeSchoolScienceScissorsScorpionScoutScrapScreenScriptScrubSeaSearchSeasonSeatSecondSecretSectionSecuritySeedSeekSegmentSelectSellSeminarSeniorSenseSentenceSeriesServiceSessionSettleSetupSevenShadowShaftShallowShareShedShellSheriffShieldShiftShineShipShiverShockShoeShootShopShortShoulderShoveShrimpShrugShuffleShySiblingSickSideSiegeSightSignSilentSilkSillySilverSimilarSimpleSinceSingSirenSisterSituateSixSizeSkateSketchSkiSkillSkinSkirtSkullSlabSlamSleepSlenderSliceSlideSlightSlimSloganSlotSlowSlushSmallSmartSmileSmokeSmoothSnackSnakeSnapSniffSnowSoapSoccerSocialSockSodaSoftSolarSoldierSolidSolutionSolveSomeoneSongSoonSorrySortSoulSoundSoupSourceSouthSpaceSpareSpatialSpawnSpeakSpecialSpeedSpellSpendSphereSpiceSpiderSpikeSpinSpiritSplitSpoilSponsorSpoonSportSpotSpraySpreadSpringSpySquareSqueezeSquirrelStableStadiumStaffStageStairsStampStandStartStateStaySteakSteelStemStepStereoStickStillStingStockStomachStoneStoolStoryStoveStrategyStreetStrikeStrongStruggleStudentStuffStumbleStyleSubjectSubmitSubwaySuccessSuchSuddenSufferSugarSuggestSuitSummerSunSunnySunsetSuperSupplySupremeSureSurfaceSurgeSurpriseSurroundSurveySuspectSustainSwallowSwampSwapSwarmSwearSweetSwiftSwimSwingSwitchSwordSymbolSymptomSyrupSystemTableTackleTagTailTalentTalkTankTapeTargetTaskTasteTattooTaxiTeachTeamTellTenTenantTennisTentTermTestTextThankThatThemeThenTheoryThereTheyThingThisThoughtThreeThriveThrowThumbThunderTicketTideTigerTiltTimberTimeTinyTipTiredTissueTitleToastTobaccoTodayToddlerToeTogetherToiletTokenTomatoTomorrowToneTongueTonightToolToothTopTopicToppleTorchTornadoTortoiseTossTotalTouristTowardTowerTownToyTrackTradeTrafficTragicTrainTransferTrapTrashTravelTrayTreatTreeTrendTrialTribeTrickTriggerTrimTripTrophyTroubleTruckTrueTrulyTrumpetTrustTruthTryTubeTuitionTumbleTunaTunnelTurkeyTurnTurtleTwelveTwentyTwiceTwinTwistTwoTypeTypicalUglyUmbrellaUnableUnawareUncleUncoverUnderUndoUnfairUnfoldUnhappyUniformUniqueUnitUniverseUnknownUnlockUntilUnusualUnveilUpdateUpgradeUpholdUponUpperUpsetUrbanUrgeUsageUseUsedUsefulUselessUsualUtilityVacantVacuumVagueValidValleyValveVanVanishVaporVariousVastVaultVehicleVelvetVendorVentureVenueVerbVerifyVersionVeryVesselVeteranViableVibrantViciousVictoryVideoViewVillageVintageViolinVirtualVirusVisaVisitVisualVitalVividVocalVoiceVoidVolcanoVolumeVoteVoyageWageWagonWaitWalkWallWalnutWantWarfareWarmWarriorWashWaspWasteWaterWaveWayWealthWeaponWearWeaselWeatherWebWeddingWeekendWeirdWelcomeWestWetWhaleWhatWheatWheelWhenWhereWhipWhisperWideWidthWifeWildWillWinWindowWineWingWinkWinnerWinterWireWisdomWiseWishWitnessWolfWomanWonderWoodWoolWordWorkWorldWorryWorthWrapWreckWrestleWristWriteWrongYardYearYellowYouYoungYouthZebraZeroZoneZoo";
let wordlist = null;
function loadWords(lang) {
    if (wordlist != null) {
        return;
    }
    wordlist = words.replace(/([A-Z])/g, " $1").toLowerCase().substring(1).split(" ");
    // Verify the computed list matches the official list
    /* istanbul ignore if */
    if (_wordlist__WEBPACK_IMPORTED_MODULE_0__["Wordlist"].check(lang) !== "0x3c8acc1e7b08d8e76f9fda015ef48dc8c710a73cb7e0f77b2c18a9b5a7adde60") {
        wordlist = null;
        throw new Error("BIP39 Wordlist for en (English) FAILED");
    }
}
class LangEn extends _wordlist__WEBPACK_IMPORTED_MODULE_0__["Wordlist"] {
    constructor() {
        super("en");
    }
    getWord(index) {
        loadWords(this);
        return wordlist[index];
    }
    getWordIndex(word) {
        loadWords(this);
        return wordlist.indexOf(word);
    }
}
const langEn = new LangEn();
_wordlist__WEBPACK_IMPORTED_MODULE_0__["Wordlist"].register(langEn);

//# sourceMappingURL=lang-en.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/wordlists/lib.esm/wordlist.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@ethersproject/wordlists/lib.esm/wordlist.js ***!
  \*******************************************************************/
/*! exports provided: logger, Wordlist */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logger", function() { return logger; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Wordlist", function() { return Wordlist; });
/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/index.js");
/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./_version */ "./node_modules/@ethersproject/wordlists/lib.esm/_version.js");

// This gets overridden by rollup
const exportWordlist = false;




const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_2__["Logger"](_version__WEBPACK_IMPORTED_MODULE_3__["version"]);
class Wordlist {
    constructor(locale) {
        logger.checkAbstract(new.target, Wordlist);
        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(this, "locale", locale);
    }
    // Subclasses may override this
    split(mnemonic) {
        return mnemonic.toLowerCase().split(/ +/g);
    }
    // Subclasses may override this
    join(words) {
        return words.join(" ");
    }
    static check(wordlist) {
        const words = [];
        for (let i = 0; i < 2048; i++) {
            const word = wordlist.getWord(i);
            /* istanbul ignore if */
            if (i !== wordlist.getWordIndex(word)) {
                return "0x";
            }
            words.push(word);
        }
        return Object(_ethersproject_hash__WEBPACK_IMPORTED_MODULE_0__["id"])(words.join("\n") + "\n");
    }
    static register(lang, name) {
        if (!name) {
            name = lang.locale;
        }
        /* istanbul ignore if */
        if (exportWordlist) {
            try {
                const anyGlobal = window;
                if (anyGlobal._ethers && anyGlobal._ethers.wordlists) {
                    if (!anyGlobal._ethers.wordlists[name]) {
                        Object(_ethersproject_properties__WEBPACK_IMPORTED_MODULE_1__["defineReadOnly"])(anyGlobal._ethers.wordlists, name, lang);
                    }
                }
            }
            catch (error) { }
        }
    }
}
//# sourceMappingURL=wordlist.js.map

/***/ }),

/***/ "./node_modules/@ethersproject/wordlists/lib.esm/wordlists.js":
/*!********************************************************************!*\
  !*** ./node_modules/@ethersproject/wordlists/lib.esm/wordlists.js ***!
  \********************************************************************/
/*! exports provided: wordlists */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "wordlists", function() { return wordlists; });
/* harmony import */ var _lang_en__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./lang-en */ "./node_modules/@ethersproject/wordlists/lib.esm/lang-en.js");


const wordlists = {
    en: _lang_en__WEBPACK_IMPORTED_MODULE_0__["langEn"]
};
//# sourceMappingURL=wordlists.js.map

/***/ }),

/***/ "./node_modules/aes-js/index.js":
/*!**************************************!*\
  !*** ./node_modules/aes-js/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


(function(root) {

    function checkInt(value) {
        return (parseInt(value) === value);
    }

    function checkInts(arrayish) {
        if (!checkInt(arrayish.length)) { return false; }

        for (var i = 0; i < arrayish.length; i++) {
            if (!checkInt(arrayish[i]) || arrayish[i] < 0 || arrayish[i] > 255) {
                return false;
            }
        }

        return true;
    }

    function coerceArray(arg, copy) {

        // ArrayBuffer view
        if (arg.buffer && ArrayBuffer.isView(arg) && arg.name === 'Uint8Array') {

            if (copy) {
                if (arg.slice) {
                    arg = arg.slice();
                } else {
                    arg = Array.prototype.slice.call(arg);
                }
            }

            return arg;
        }

        // It's an array; check it is a valid representation of a byte
        if (Array.isArray(arg)) {
            if (!checkInts(arg)) {
                throw new Error('Array contains invalid value: ' + arg);
            }

            return new Uint8Array(arg);
        }

        // Something else, but behaves like an array (maybe a Buffer? Arguments?)
        if (checkInt(arg.length) && checkInts(arg)) {
            return new Uint8Array(arg);
        }

        throw new Error('unsupported array-like object');
    }

    function createArray(length) {
        return new Uint8Array(length);
    }

    function copyArray(sourceArray, targetArray, targetStart, sourceStart, sourceEnd) {
        if (sourceStart != null || sourceEnd != null) {
            if (sourceArray.slice) {
                sourceArray = sourceArray.slice(sourceStart, sourceEnd);
            } else {
                sourceArray = Array.prototype.slice.call(sourceArray, sourceStart, sourceEnd);
            }
        }
        targetArray.set(sourceArray, targetStart);
    }



    var convertUtf8 = (function() {
        function toBytes(text) {
            var result = [], i = 0;
            text = encodeURI(text);
            while (i < text.length) {
                var c = text.charCodeAt(i++);

                // if it is a % sign, encode the following 2 bytes as a hex value
                if (c === 37) {
                    result.push(parseInt(text.substr(i, 2), 16))
                    i += 2;

                // otherwise, just the actual byte
                } else {
                    result.push(c)
                }
            }

            return coerceArray(result);
        }

        function fromBytes(bytes) {
            var result = [], i = 0;

            while (i < bytes.length) {
                var c = bytes[i];

                if (c < 128) {
                    result.push(String.fromCharCode(c));
                    i++;
                } else if (c > 191 && c < 224) {
                    result.push(String.fromCharCode(((c & 0x1f) << 6) | (bytes[i + 1] & 0x3f)));
                    i += 2;
                } else {
                    result.push(String.fromCharCode(((c & 0x0f) << 12) | ((bytes[i + 1] & 0x3f) << 6) | (bytes[i + 2] & 0x3f)));
                    i += 3;
                }
            }

            return result.join('');
        }

        return {
            toBytes: toBytes,
            fromBytes: fromBytes,
        }
    })();

    var convertHex = (function() {
        function toBytes(text) {
            var result = [];
            for (var i = 0; i < text.length; i += 2) {
                result.push(parseInt(text.substr(i, 2), 16));
            }

            return result;
        }

        // http://ixti.net/development/javascript/2011/11/11/base64-encodedecode-of-utf8-in-browser-with-js.html
        var Hex = '0123456789abcdef';

        function fromBytes(bytes) {
                var result = [];
                for (var i = 0; i < bytes.length; i++) {
                    var v = bytes[i];
                    result.push(Hex[(v & 0xf0) >> 4] + Hex[v & 0x0f]);
                }
                return result.join('');
        }

        return {
            toBytes: toBytes,
            fromBytes: fromBytes,
        }
    })();


    // Number of rounds by keysize
    var numberOfRounds = {16: 10, 24: 12, 32: 14}

    // Round constant words
    var rcon = [0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36, 0x6c, 0xd8, 0xab, 0x4d, 0x9a, 0x2f, 0x5e, 0xbc, 0x63, 0xc6, 0x97, 0x35, 0x6a, 0xd4, 0xb3, 0x7d, 0xfa, 0xef, 0xc5, 0x91];

    // S-box and Inverse S-box (S is for Substitution)
    var S = [0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf, 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16];
    var Si =[0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61, 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d];

    // Transformations for encryption
    var T1 = [0xc66363a5, 0xf87c7c84, 0xee777799, 0xf67b7b8d, 0xfff2f20d, 0xd66b6bbd, 0xde6f6fb1, 0x91c5c554, 0x60303050, 0x02010103, 0xce6767a9, 0x562b2b7d, 0xe7fefe19, 0xb5d7d762, 0x4dababe6, 0xec76769a, 0x8fcaca45, 0x1f82829d, 0x89c9c940, 0xfa7d7d87, 0xeffafa15, 0xb25959eb, 0x8e4747c9, 0xfbf0f00b, 0x41adadec, 0xb3d4d467, 0x5fa2a2fd, 0x45afafea, 0x239c9cbf, 0x53a4a4f7, 0xe4727296, 0x9bc0c05b, 0x75b7b7c2, 0xe1fdfd1c, 0x3d9393ae, 0x4c26266a, 0x6c36365a, 0x7e3f3f41, 0xf5f7f702, 0x83cccc4f, 0x6834345c, 0x51a5a5f4, 0xd1e5e534, 0xf9f1f108, 0xe2717193, 0xabd8d873, 0x62313153, 0x2a15153f, 0x0804040c, 0x95c7c752, 0x46232365, 0x9dc3c35e, 0x30181828, 0x379696a1, 0x0a05050f, 0x2f9a9ab5, 0x0e070709, 0x24121236, 0x1b80809b, 0xdfe2e23d, 0xcdebeb26, 0x4e272769, 0x7fb2b2cd, 0xea75759f, 0x1209091b, 0x1d83839e, 0x582c2c74, 0x341a1a2e, 0x361b1b2d, 0xdc6e6eb2, 0xb45a5aee, 0x5ba0a0fb, 0xa45252f6, 0x763b3b4d, 0xb7d6d661, 0x7db3b3ce, 0x5229297b, 0xdde3e33e, 0x5e2f2f71, 0x13848497, 0xa65353f5, 0xb9d1d168, 0x00000000, 0xc1eded2c, 0x40202060, 0xe3fcfc1f, 0x79b1b1c8, 0xb65b5bed, 0xd46a6abe, 0x8dcbcb46, 0x67bebed9, 0x7239394b, 0x944a4ade, 0x984c4cd4, 0xb05858e8, 0x85cfcf4a, 0xbbd0d06b, 0xc5efef2a, 0x4faaaae5, 0xedfbfb16, 0x864343c5, 0x9a4d4dd7, 0x66333355, 0x11858594, 0x8a4545cf, 0xe9f9f910, 0x04020206, 0xfe7f7f81, 0xa05050f0, 0x783c3c44, 0x259f9fba, 0x4ba8a8e3, 0xa25151f3, 0x5da3a3fe, 0x804040c0, 0x058f8f8a, 0x3f9292ad, 0x219d9dbc, 0x70383848, 0xf1f5f504, 0x63bcbcdf, 0x77b6b6c1, 0xafdada75, 0x42212163, 0x20101030, 0xe5ffff1a, 0xfdf3f30e, 0xbfd2d26d, 0x81cdcd4c, 0x180c0c14, 0x26131335, 0xc3ecec2f, 0xbe5f5fe1, 0x359797a2, 0x884444cc, 0x2e171739, 0x93c4c457, 0x55a7a7f2, 0xfc7e7e82, 0x7a3d3d47, 0xc86464ac, 0xba5d5de7, 0x3219192b, 0xe6737395, 0xc06060a0, 0x19818198, 0x9e4f4fd1, 0xa3dcdc7f, 0x44222266, 0x542a2a7e, 0x3b9090ab, 0x0b888883, 0x8c4646ca, 0xc7eeee29, 0x6bb8b8d3, 0x2814143c, 0xa7dede79, 0xbc5e5ee2, 0x160b0b1d, 0xaddbdb76, 0xdbe0e03b, 0x64323256, 0x743a3a4e, 0x140a0a1e, 0x924949db, 0x0c06060a, 0x4824246c, 0xb85c5ce4, 0x9fc2c25d, 0xbdd3d36e, 0x43acacef, 0xc46262a6, 0x399191a8, 0x319595a4, 0xd3e4e437, 0xf279798b, 0xd5e7e732, 0x8bc8c843, 0x6e373759, 0xda6d6db7, 0x018d8d8c, 0xb1d5d564, 0x9c4e4ed2, 0x49a9a9e0, 0xd86c6cb4, 0xac5656fa, 0xf3f4f407, 0xcfeaea25, 0xca6565af, 0xf47a7a8e, 0x47aeaee9, 0x10080818, 0x6fbabad5, 0xf0787888, 0x4a25256f, 0x5c2e2e72, 0x381c1c24, 0x57a6a6f1, 0x73b4b4c7, 0x97c6c651, 0xcbe8e823, 0xa1dddd7c, 0xe874749c, 0x3e1f1f21, 0x964b4bdd, 0x61bdbddc, 0x0d8b8b86, 0x0f8a8a85, 0xe0707090, 0x7c3e3e42, 0x71b5b5c4, 0xcc6666aa, 0x904848d8, 0x06030305, 0xf7f6f601, 0x1c0e0e12, 0xc26161a3, 0x6a35355f, 0xae5757f9, 0x69b9b9d0, 0x17868691, 0x99c1c158, 0x3a1d1d27, 0x279e9eb9, 0xd9e1e138, 0xebf8f813, 0x2b9898b3, 0x22111133, 0xd26969bb, 0xa9d9d970, 0x078e8e89, 0x339494a7, 0x2d9b9bb6, 0x3c1e1e22, 0x15878792, 0xc9e9e920, 0x87cece49, 0xaa5555ff, 0x50282878, 0xa5dfdf7a, 0x038c8c8f, 0x59a1a1f8, 0x09898980, 0x1a0d0d17, 0x65bfbfda, 0xd7e6e631, 0x844242c6, 0xd06868b8, 0x824141c3, 0x299999b0, 0x5a2d2d77, 0x1e0f0f11, 0x7bb0b0cb, 0xa85454fc, 0x6dbbbbd6, 0x2c16163a];
    var T2 = [0xa5c66363, 0x84f87c7c, 0x99ee7777, 0x8df67b7b, 0x0dfff2f2, 0xbdd66b6b, 0xb1de6f6f, 0x5491c5c5, 0x50603030, 0x03020101, 0xa9ce6767, 0x7d562b2b, 0x19e7fefe, 0x62b5d7d7, 0xe64dabab, 0x9aec7676, 0x458fcaca, 0x9d1f8282, 0x4089c9c9, 0x87fa7d7d, 0x15effafa, 0xebb25959, 0xc98e4747, 0x0bfbf0f0, 0xec41adad, 0x67b3d4d4, 0xfd5fa2a2, 0xea45afaf, 0xbf239c9c, 0xf753a4a4, 0x96e47272, 0x5b9bc0c0, 0xc275b7b7, 0x1ce1fdfd, 0xae3d9393, 0x6a4c2626, 0x5a6c3636, 0x417e3f3f, 0x02f5f7f7, 0x4f83cccc, 0x5c683434, 0xf451a5a5, 0x34d1e5e5, 0x08f9f1f1, 0x93e27171, 0x73abd8d8, 0x53623131, 0x3f2a1515, 0x0c080404, 0x5295c7c7, 0x65462323, 0x5e9dc3c3, 0x28301818, 0xa1379696, 0x0f0a0505, 0xb52f9a9a, 0x090e0707, 0x36241212, 0x9b1b8080, 0x3ddfe2e2, 0x26cdebeb, 0x694e2727, 0xcd7fb2b2, 0x9fea7575, 0x1b120909, 0x9e1d8383, 0x74582c2c, 0x2e341a1a, 0x2d361b1b, 0xb2dc6e6e, 0xeeb45a5a, 0xfb5ba0a0, 0xf6a45252, 0x4d763b3b, 0x61b7d6d6, 0xce7db3b3, 0x7b522929, 0x3edde3e3, 0x715e2f2f, 0x97138484, 0xf5a65353, 0x68b9d1d1, 0x00000000, 0x2cc1eded, 0x60402020, 0x1fe3fcfc, 0xc879b1b1, 0xedb65b5b, 0xbed46a6a, 0x468dcbcb, 0xd967bebe, 0x4b723939, 0xde944a4a, 0xd4984c4c, 0xe8b05858, 0x4a85cfcf, 0x6bbbd0d0, 0x2ac5efef, 0xe54faaaa, 0x16edfbfb, 0xc5864343, 0xd79a4d4d, 0x55663333, 0x94118585, 0xcf8a4545, 0x10e9f9f9, 0x06040202, 0x81fe7f7f, 0xf0a05050, 0x44783c3c, 0xba259f9f, 0xe34ba8a8, 0xf3a25151, 0xfe5da3a3, 0xc0804040, 0x8a058f8f, 0xad3f9292, 0xbc219d9d, 0x48703838, 0x04f1f5f5, 0xdf63bcbc, 0xc177b6b6, 0x75afdada, 0x63422121, 0x30201010, 0x1ae5ffff, 0x0efdf3f3, 0x6dbfd2d2, 0x4c81cdcd, 0x14180c0c, 0x35261313, 0x2fc3ecec, 0xe1be5f5f, 0xa2359797, 0xcc884444, 0x392e1717, 0x5793c4c4, 0xf255a7a7, 0x82fc7e7e, 0x477a3d3d, 0xacc86464, 0xe7ba5d5d, 0x2b321919, 0x95e67373, 0xa0c06060, 0x98198181, 0xd19e4f4f, 0x7fa3dcdc, 0x66442222, 0x7e542a2a, 0xab3b9090, 0x830b8888, 0xca8c4646, 0x29c7eeee, 0xd36bb8b8, 0x3c281414, 0x79a7dede, 0xe2bc5e5e, 0x1d160b0b, 0x76addbdb, 0x3bdbe0e0, 0x56643232, 0x4e743a3a, 0x1e140a0a, 0xdb924949, 0x0a0c0606, 0x6c482424, 0xe4b85c5c, 0x5d9fc2c2, 0x6ebdd3d3, 0xef43acac, 0xa6c46262, 0xa8399191, 0xa4319595, 0x37d3e4e4, 0x8bf27979, 0x32d5e7e7, 0x438bc8c8, 0x596e3737, 0xb7da6d6d, 0x8c018d8d, 0x64b1d5d5, 0xd29c4e4e, 0xe049a9a9, 0xb4d86c6c, 0xfaac5656, 0x07f3f4f4, 0x25cfeaea, 0xafca6565, 0x8ef47a7a, 0xe947aeae, 0x18100808, 0xd56fbaba, 0x88f07878, 0x6f4a2525, 0x725c2e2e, 0x24381c1c, 0xf157a6a6, 0xc773b4b4, 0x5197c6c6, 0x23cbe8e8, 0x7ca1dddd, 0x9ce87474, 0x213e1f1f, 0xdd964b4b, 0xdc61bdbd, 0x860d8b8b, 0x850f8a8a, 0x90e07070, 0x427c3e3e, 0xc471b5b5, 0xaacc6666, 0xd8904848, 0x05060303, 0x01f7f6f6, 0x121c0e0e, 0xa3c26161, 0x5f6a3535, 0xf9ae5757, 0xd069b9b9, 0x91178686, 0x5899c1c1, 0x273a1d1d, 0xb9279e9e, 0x38d9e1e1, 0x13ebf8f8, 0xb32b9898, 0x33221111, 0xbbd26969, 0x70a9d9d9, 0x89078e8e, 0xa7339494, 0xb62d9b9b, 0x223c1e1e, 0x92158787, 0x20c9e9e9, 0x4987cece, 0xffaa5555, 0x78502828, 0x7aa5dfdf, 0x8f038c8c, 0xf859a1a1, 0x80098989, 0x171a0d0d, 0xda65bfbf, 0x31d7e6e6, 0xc6844242, 0xb8d06868, 0xc3824141, 0xb0299999, 0x775a2d2d, 0x111e0f0f, 0xcb7bb0b0, 0xfca85454, 0xd66dbbbb, 0x3a2c1616];
    var T3 = [0x63a5c663, 0x7c84f87c, 0x7799ee77, 0x7b8df67b, 0xf20dfff2, 0x6bbdd66b, 0x6fb1de6f, 0xc55491c5, 0x30506030, 0x01030201, 0x67a9ce67, 0x2b7d562b, 0xfe19e7fe, 0xd762b5d7, 0xabe64dab, 0x769aec76, 0xca458fca, 0x829d1f82, 0xc94089c9, 0x7d87fa7d, 0xfa15effa, 0x59ebb259, 0x47c98e47, 0xf00bfbf0, 0xadec41ad, 0xd467b3d4, 0xa2fd5fa2, 0xafea45af, 0x9cbf239c, 0xa4f753a4, 0x7296e472, 0xc05b9bc0, 0xb7c275b7, 0xfd1ce1fd, 0x93ae3d93, 0x266a4c26, 0x365a6c36, 0x3f417e3f, 0xf702f5f7, 0xcc4f83cc, 0x345c6834, 0xa5f451a5, 0xe534d1e5, 0xf108f9f1, 0x7193e271, 0xd873abd8, 0x31536231, 0x153f2a15, 0x040c0804, 0xc75295c7, 0x23654623, 0xc35e9dc3, 0x18283018, 0x96a13796, 0x050f0a05, 0x9ab52f9a, 0x07090e07, 0x12362412, 0x809b1b80, 0xe23ddfe2, 0xeb26cdeb, 0x27694e27, 0xb2cd7fb2, 0x759fea75, 0x091b1209, 0x839e1d83, 0x2c74582c, 0x1a2e341a, 0x1b2d361b, 0x6eb2dc6e, 0x5aeeb45a, 0xa0fb5ba0, 0x52f6a452, 0x3b4d763b, 0xd661b7d6, 0xb3ce7db3, 0x297b5229, 0xe33edde3, 0x2f715e2f, 0x84971384, 0x53f5a653, 0xd168b9d1, 0x00000000, 0xed2cc1ed, 0x20604020, 0xfc1fe3fc, 0xb1c879b1, 0x5bedb65b, 0x6abed46a, 0xcb468dcb, 0xbed967be, 0x394b7239, 0x4ade944a, 0x4cd4984c, 0x58e8b058, 0xcf4a85cf, 0xd06bbbd0, 0xef2ac5ef, 0xaae54faa, 0xfb16edfb, 0x43c58643, 0x4dd79a4d, 0x33556633, 0x85941185, 0x45cf8a45, 0xf910e9f9, 0x02060402, 0x7f81fe7f, 0x50f0a050, 0x3c44783c, 0x9fba259f, 0xa8e34ba8, 0x51f3a251, 0xa3fe5da3, 0x40c08040, 0x8f8a058f, 0x92ad3f92, 0x9dbc219d, 0x38487038, 0xf504f1f5, 0xbcdf63bc, 0xb6c177b6, 0xda75afda, 0x21634221, 0x10302010, 0xff1ae5ff, 0xf30efdf3, 0xd26dbfd2, 0xcd4c81cd, 0x0c14180c, 0x13352613, 0xec2fc3ec, 0x5fe1be5f, 0x97a23597, 0x44cc8844, 0x17392e17, 0xc45793c4, 0xa7f255a7, 0x7e82fc7e, 0x3d477a3d, 0x64acc864, 0x5de7ba5d, 0x192b3219, 0x7395e673, 0x60a0c060, 0x81981981, 0x4fd19e4f, 0xdc7fa3dc, 0x22664422, 0x2a7e542a, 0x90ab3b90, 0x88830b88, 0x46ca8c46, 0xee29c7ee, 0xb8d36bb8, 0x143c2814, 0xde79a7de, 0x5ee2bc5e, 0x0b1d160b, 0xdb76addb, 0xe03bdbe0, 0x32566432, 0x3a4e743a, 0x0a1e140a, 0x49db9249, 0x060a0c06, 0x246c4824, 0x5ce4b85c, 0xc25d9fc2, 0xd36ebdd3, 0xacef43ac, 0x62a6c462, 0x91a83991, 0x95a43195, 0xe437d3e4, 0x798bf279, 0xe732d5e7, 0xc8438bc8, 0x37596e37, 0x6db7da6d, 0x8d8c018d, 0xd564b1d5, 0x4ed29c4e, 0xa9e049a9, 0x6cb4d86c, 0x56faac56, 0xf407f3f4, 0xea25cfea, 0x65afca65, 0x7a8ef47a, 0xaee947ae, 0x08181008, 0xbad56fba, 0x7888f078, 0x256f4a25, 0x2e725c2e, 0x1c24381c, 0xa6f157a6, 0xb4c773b4, 0xc65197c6, 0xe823cbe8, 0xdd7ca1dd, 0x749ce874, 0x1f213e1f, 0x4bdd964b, 0xbddc61bd, 0x8b860d8b, 0x8a850f8a, 0x7090e070, 0x3e427c3e, 0xb5c471b5, 0x66aacc66, 0x48d89048, 0x03050603, 0xf601f7f6, 0x0e121c0e, 0x61a3c261, 0x355f6a35, 0x57f9ae57, 0xb9d069b9, 0x86911786, 0xc15899c1, 0x1d273a1d, 0x9eb9279e, 0xe138d9e1, 0xf813ebf8, 0x98b32b98, 0x11332211, 0x69bbd269, 0xd970a9d9, 0x8e89078e, 0x94a73394, 0x9bb62d9b, 0x1e223c1e, 0x87921587, 0xe920c9e9, 0xce4987ce, 0x55ffaa55, 0x28785028, 0xdf7aa5df, 0x8c8f038c, 0xa1f859a1, 0x89800989, 0x0d171a0d, 0xbfda65bf, 0xe631d7e6, 0x42c68442, 0x68b8d068, 0x41c38241, 0x99b02999, 0x2d775a2d, 0x0f111e0f, 0xb0cb7bb0, 0x54fca854, 0xbbd66dbb, 0x163a2c16];
    var T4 = [0x6363a5c6, 0x7c7c84f8, 0x777799ee, 0x7b7b8df6, 0xf2f20dff, 0x6b6bbdd6, 0x6f6fb1de, 0xc5c55491, 0x30305060, 0x01010302, 0x6767a9ce, 0x2b2b7d56, 0xfefe19e7, 0xd7d762b5, 0xababe64d, 0x76769aec, 0xcaca458f, 0x82829d1f, 0xc9c94089, 0x7d7d87fa, 0xfafa15ef, 0x5959ebb2, 0x4747c98e, 0xf0f00bfb, 0xadadec41, 0xd4d467b3, 0xa2a2fd5f, 0xafafea45, 0x9c9cbf23, 0xa4a4f753, 0x727296e4, 0xc0c05b9b, 0xb7b7c275, 0xfdfd1ce1, 0x9393ae3d, 0x26266a4c, 0x36365a6c, 0x3f3f417e, 0xf7f702f5, 0xcccc4f83, 0x34345c68, 0xa5a5f451, 0xe5e534d1, 0xf1f108f9, 0x717193e2, 0xd8d873ab, 0x31315362, 0x15153f2a, 0x04040c08, 0xc7c75295, 0x23236546, 0xc3c35e9d, 0x18182830, 0x9696a137, 0x05050f0a, 0x9a9ab52f, 0x0707090e, 0x12123624, 0x80809b1b, 0xe2e23ddf, 0xebeb26cd, 0x2727694e, 0xb2b2cd7f, 0x75759fea, 0x09091b12, 0x83839e1d, 0x2c2c7458, 0x1a1a2e34, 0x1b1b2d36, 0x6e6eb2dc, 0x5a5aeeb4, 0xa0a0fb5b, 0x5252f6a4, 0x3b3b4d76, 0xd6d661b7, 0xb3b3ce7d, 0x29297b52, 0xe3e33edd, 0x2f2f715e, 0x84849713, 0x5353f5a6, 0xd1d168b9, 0x00000000, 0xeded2cc1, 0x20206040, 0xfcfc1fe3, 0xb1b1c879, 0x5b5bedb6, 0x6a6abed4, 0xcbcb468d, 0xbebed967, 0x39394b72, 0x4a4ade94, 0x4c4cd498, 0x5858e8b0, 0xcfcf4a85, 0xd0d06bbb, 0xefef2ac5, 0xaaaae54f, 0xfbfb16ed, 0x4343c586, 0x4d4dd79a, 0x33335566, 0x85859411, 0x4545cf8a, 0xf9f910e9, 0x02020604, 0x7f7f81fe, 0x5050f0a0, 0x3c3c4478, 0x9f9fba25, 0xa8a8e34b, 0x5151f3a2, 0xa3a3fe5d, 0x4040c080, 0x8f8f8a05, 0x9292ad3f, 0x9d9dbc21, 0x38384870, 0xf5f504f1, 0xbcbcdf63, 0xb6b6c177, 0xdada75af, 0x21216342, 0x10103020, 0xffff1ae5, 0xf3f30efd, 0xd2d26dbf, 0xcdcd4c81, 0x0c0c1418, 0x13133526, 0xecec2fc3, 0x5f5fe1be, 0x9797a235, 0x4444cc88, 0x1717392e, 0xc4c45793, 0xa7a7f255, 0x7e7e82fc, 0x3d3d477a, 0x6464acc8, 0x5d5de7ba, 0x19192b32, 0x737395e6, 0x6060a0c0, 0x81819819, 0x4f4fd19e, 0xdcdc7fa3, 0x22226644, 0x2a2a7e54, 0x9090ab3b, 0x8888830b, 0x4646ca8c, 0xeeee29c7, 0xb8b8d36b, 0x14143c28, 0xdede79a7, 0x5e5ee2bc, 0x0b0b1d16, 0xdbdb76ad, 0xe0e03bdb, 0x32325664, 0x3a3a4e74, 0x0a0a1e14, 0x4949db92, 0x06060a0c, 0x24246c48, 0x5c5ce4b8, 0xc2c25d9f, 0xd3d36ebd, 0xacacef43, 0x6262a6c4, 0x9191a839, 0x9595a431, 0xe4e437d3, 0x79798bf2, 0xe7e732d5, 0xc8c8438b, 0x3737596e, 0x6d6db7da, 0x8d8d8c01, 0xd5d564b1, 0x4e4ed29c, 0xa9a9e049, 0x6c6cb4d8, 0x5656faac, 0xf4f407f3, 0xeaea25cf, 0x6565afca, 0x7a7a8ef4, 0xaeaee947, 0x08081810, 0xbabad56f, 0x787888f0, 0x25256f4a, 0x2e2e725c, 0x1c1c2438, 0xa6a6f157, 0xb4b4c773, 0xc6c65197, 0xe8e823cb, 0xdddd7ca1, 0x74749ce8, 0x1f1f213e, 0x4b4bdd96, 0xbdbddc61, 0x8b8b860d, 0x8a8a850f, 0x707090e0, 0x3e3e427c, 0xb5b5c471, 0x6666aacc, 0x4848d890, 0x03030506, 0xf6f601f7, 0x0e0e121c, 0x6161a3c2, 0x35355f6a, 0x5757f9ae, 0xb9b9d069, 0x86869117, 0xc1c15899, 0x1d1d273a, 0x9e9eb927, 0xe1e138d9, 0xf8f813eb, 0x9898b32b, 0x11113322, 0x6969bbd2, 0xd9d970a9, 0x8e8e8907, 0x9494a733, 0x9b9bb62d, 0x1e1e223c, 0x87879215, 0xe9e920c9, 0xcece4987, 0x5555ffaa, 0x28287850, 0xdfdf7aa5, 0x8c8c8f03, 0xa1a1f859, 0x89898009, 0x0d0d171a, 0xbfbfda65, 0xe6e631d7, 0x4242c684, 0x6868b8d0, 0x4141c382, 0x9999b029, 0x2d2d775a, 0x0f0f111e, 0xb0b0cb7b, 0x5454fca8, 0xbbbbd66d, 0x16163a2c];

    // Transformations for decryption
    var T5 = [0x51f4a750, 0x7e416553, 0x1a17a4c3, 0x3a275e96, 0x3bab6bcb, 0x1f9d45f1, 0xacfa58ab, 0x4be30393, 0x2030fa55, 0xad766df6, 0x88cc7691, 0xf5024c25, 0x4fe5d7fc, 0xc52acbd7, 0x26354480, 0xb562a38f, 0xdeb15a49, 0x25ba1b67, 0x45ea0e98, 0x5dfec0e1, 0xc32f7502, 0x814cf012, 0x8d4697a3, 0x6bd3f9c6, 0x038f5fe7, 0x15929c95, 0xbf6d7aeb, 0x955259da, 0xd4be832d, 0x587421d3, 0x49e06929, 0x8ec9c844, 0x75c2896a, 0xf48e7978, 0x99583e6b, 0x27b971dd, 0xbee14fb6, 0xf088ad17, 0xc920ac66, 0x7dce3ab4, 0x63df4a18, 0xe51a3182, 0x97513360, 0x62537f45, 0xb16477e0, 0xbb6bae84, 0xfe81a01c, 0xf9082b94, 0x70486858, 0x8f45fd19, 0x94de6c87, 0x527bf8b7, 0xab73d323, 0x724b02e2, 0xe31f8f57, 0x6655ab2a, 0xb2eb2807, 0x2fb5c203, 0x86c57b9a, 0xd33708a5, 0x302887f2, 0x23bfa5b2, 0x02036aba, 0xed16825c, 0x8acf1c2b, 0xa779b492, 0xf307f2f0, 0x4e69e2a1, 0x65daf4cd, 0x0605bed5, 0xd134621f, 0xc4a6fe8a, 0x342e539d, 0xa2f355a0, 0x058ae132, 0xa4f6eb75, 0x0b83ec39, 0x4060efaa, 0x5e719f06, 0xbd6e1051, 0x3e218af9, 0x96dd063d, 0xdd3e05ae, 0x4de6bd46, 0x91548db5, 0x71c45d05, 0x0406d46f, 0x605015ff, 0x1998fb24, 0xd6bde997, 0x894043cc, 0x67d99e77, 0xb0e842bd, 0x07898b88, 0xe7195b38, 0x79c8eedb, 0xa17c0a47, 0x7c420fe9, 0xf8841ec9, 0x00000000, 0x09808683, 0x322bed48, 0x1e1170ac, 0x6c5a724e, 0xfd0efffb, 0x0f853856, 0x3daed51e, 0x362d3927, 0x0a0fd964, 0x685ca621, 0x9b5b54d1, 0x24362e3a, 0x0c0a67b1, 0x9357e70f, 0xb4ee96d2, 0x1b9b919e, 0x80c0c54f, 0x61dc20a2, 0x5a774b69, 0x1c121a16, 0xe293ba0a, 0xc0a02ae5, 0x3c22e043, 0x121b171d, 0x0e090d0b, 0xf28bc7ad, 0x2db6a8b9, 0x141ea9c8, 0x57f11985, 0xaf75074c, 0xee99ddbb, 0xa37f60fd, 0xf701269f, 0x5c72f5bc, 0x44663bc5, 0x5bfb7e34, 0x8b432976, 0xcb23c6dc, 0xb6edfc68, 0xb8e4f163, 0xd731dcca, 0x42638510, 0x13972240, 0x84c61120, 0x854a247d, 0xd2bb3df8, 0xaef93211, 0xc729a16d, 0x1d9e2f4b, 0xdcb230f3, 0x0d8652ec, 0x77c1e3d0, 0x2bb3166c, 0xa970b999, 0x119448fa, 0x47e96422, 0xa8fc8cc4, 0xa0f03f1a, 0x567d2cd8, 0x223390ef, 0x87494ec7, 0xd938d1c1, 0x8ccaa2fe, 0x98d40b36, 0xa6f581cf, 0xa57ade28, 0xdab78e26, 0x3fadbfa4, 0x2c3a9de4, 0x5078920d, 0x6a5fcc9b, 0x547e4662, 0xf68d13c2, 0x90d8b8e8, 0x2e39f75e, 0x82c3aff5, 0x9f5d80be, 0x69d0937c, 0x6fd52da9, 0xcf2512b3, 0xc8ac993b, 0x10187da7, 0xe89c636e, 0xdb3bbb7b, 0xcd267809, 0x6e5918f4, 0xec9ab701, 0x834f9aa8, 0xe6956e65, 0xaaffe67e, 0x21bccf08, 0xef15e8e6, 0xbae79bd9, 0x4a6f36ce, 0xea9f09d4, 0x29b07cd6, 0x31a4b2af, 0x2a3f2331, 0xc6a59430, 0x35a266c0, 0x744ebc37, 0xfc82caa6, 0xe090d0b0, 0x33a7d815, 0xf104984a, 0x41ecdaf7, 0x7fcd500e, 0x1791f62f, 0x764dd68d, 0x43efb04d, 0xccaa4d54, 0xe49604df, 0x9ed1b5e3, 0x4c6a881b, 0xc12c1fb8, 0x4665517f, 0x9d5eea04, 0x018c355d, 0xfa877473, 0xfb0b412e, 0xb3671d5a, 0x92dbd252, 0xe9105633, 0x6dd64713, 0x9ad7618c, 0x37a10c7a, 0x59f8148e, 0xeb133c89, 0xcea927ee, 0xb761c935, 0xe11ce5ed, 0x7a47b13c, 0x9cd2df59, 0x55f2733f, 0x1814ce79, 0x73c737bf, 0x53f7cdea, 0x5ffdaa5b, 0xdf3d6f14, 0x7844db86, 0xcaaff381, 0xb968c43e, 0x3824342c, 0xc2a3405f, 0x161dc372, 0xbce2250c, 0x283c498b, 0xff0d9541, 0x39a80171, 0x080cb3de, 0xd8b4e49c, 0x6456c190, 0x7bcb8461, 0xd532b670, 0x486c5c74, 0xd0b85742];
    var T6 = [0x5051f4a7, 0x537e4165, 0xc31a17a4, 0x963a275e, 0xcb3bab6b, 0xf11f9d45, 0xabacfa58, 0x934be303, 0x552030fa, 0xf6ad766d, 0x9188cc76, 0x25f5024c, 0xfc4fe5d7, 0xd7c52acb, 0x80263544, 0x8fb562a3, 0x49deb15a, 0x6725ba1b, 0x9845ea0e, 0xe15dfec0, 0x02c32f75, 0x12814cf0, 0xa38d4697, 0xc66bd3f9, 0xe7038f5f, 0x9515929c, 0xebbf6d7a, 0xda955259, 0x2dd4be83, 0xd3587421, 0x2949e069, 0x448ec9c8, 0x6a75c289, 0x78f48e79, 0x6b99583e, 0xdd27b971, 0xb6bee14f, 0x17f088ad, 0x66c920ac, 0xb47dce3a, 0x1863df4a, 0x82e51a31, 0x60975133, 0x4562537f, 0xe0b16477, 0x84bb6bae, 0x1cfe81a0, 0x94f9082b, 0x58704868, 0x198f45fd, 0x8794de6c, 0xb7527bf8, 0x23ab73d3, 0xe2724b02, 0x57e31f8f, 0x2a6655ab, 0x07b2eb28, 0x032fb5c2, 0x9a86c57b, 0xa5d33708, 0xf2302887, 0xb223bfa5, 0xba02036a, 0x5ced1682, 0x2b8acf1c, 0x92a779b4, 0xf0f307f2, 0xa14e69e2, 0xcd65daf4, 0xd50605be, 0x1fd13462, 0x8ac4a6fe, 0x9d342e53, 0xa0a2f355, 0x32058ae1, 0x75a4f6eb, 0x390b83ec, 0xaa4060ef, 0x065e719f, 0x51bd6e10, 0xf93e218a, 0x3d96dd06, 0xaedd3e05, 0x464de6bd, 0xb591548d, 0x0571c45d, 0x6f0406d4, 0xff605015, 0x241998fb, 0x97d6bde9, 0xcc894043, 0x7767d99e, 0xbdb0e842, 0x8807898b, 0x38e7195b, 0xdb79c8ee, 0x47a17c0a, 0xe97c420f, 0xc9f8841e, 0x00000000, 0x83098086, 0x48322bed, 0xac1e1170, 0x4e6c5a72, 0xfbfd0eff, 0x560f8538, 0x1e3daed5, 0x27362d39, 0x640a0fd9, 0x21685ca6, 0xd19b5b54, 0x3a24362e, 0xb10c0a67, 0x0f9357e7, 0xd2b4ee96, 0x9e1b9b91, 0x4f80c0c5, 0xa261dc20, 0x695a774b, 0x161c121a, 0x0ae293ba, 0xe5c0a02a, 0x433c22e0, 0x1d121b17, 0x0b0e090d, 0xadf28bc7, 0xb92db6a8, 0xc8141ea9, 0x8557f119, 0x4caf7507, 0xbbee99dd, 0xfda37f60, 0x9ff70126, 0xbc5c72f5, 0xc544663b, 0x345bfb7e, 0x768b4329, 0xdccb23c6, 0x68b6edfc, 0x63b8e4f1, 0xcad731dc, 0x10426385, 0x40139722, 0x2084c611, 0x7d854a24, 0xf8d2bb3d, 0x11aef932, 0x6dc729a1, 0x4b1d9e2f, 0xf3dcb230, 0xec0d8652, 0xd077c1e3, 0x6c2bb316, 0x99a970b9, 0xfa119448, 0x2247e964, 0xc4a8fc8c, 0x1aa0f03f, 0xd8567d2c, 0xef223390, 0xc787494e, 0xc1d938d1, 0xfe8ccaa2, 0x3698d40b, 0xcfa6f581, 0x28a57ade, 0x26dab78e, 0xa43fadbf, 0xe42c3a9d, 0x0d507892, 0x9b6a5fcc, 0x62547e46, 0xc2f68d13, 0xe890d8b8, 0x5e2e39f7, 0xf582c3af, 0xbe9f5d80, 0x7c69d093, 0xa96fd52d, 0xb3cf2512, 0x3bc8ac99, 0xa710187d, 0x6ee89c63, 0x7bdb3bbb, 0x09cd2678, 0xf46e5918, 0x01ec9ab7, 0xa8834f9a, 0x65e6956e, 0x7eaaffe6, 0x0821bccf, 0xe6ef15e8, 0xd9bae79b, 0xce4a6f36, 0xd4ea9f09, 0xd629b07c, 0xaf31a4b2, 0x312a3f23, 0x30c6a594, 0xc035a266, 0x37744ebc, 0xa6fc82ca, 0xb0e090d0, 0x1533a7d8, 0x4af10498, 0xf741ecda, 0x0e7fcd50, 0x2f1791f6, 0x8d764dd6, 0x4d43efb0, 0x54ccaa4d, 0xdfe49604, 0xe39ed1b5, 0x1b4c6a88, 0xb8c12c1f, 0x7f466551, 0x049d5eea, 0x5d018c35, 0x73fa8774, 0x2efb0b41, 0x5ab3671d, 0x5292dbd2, 0x33e91056, 0x136dd647, 0x8c9ad761, 0x7a37a10c, 0x8e59f814, 0x89eb133c, 0xeecea927, 0x35b761c9, 0xede11ce5, 0x3c7a47b1, 0x599cd2df, 0x3f55f273, 0x791814ce, 0xbf73c737, 0xea53f7cd, 0x5b5ffdaa, 0x14df3d6f, 0x867844db, 0x81caaff3, 0x3eb968c4, 0x2c382434, 0x5fc2a340, 0x72161dc3, 0x0cbce225, 0x8b283c49, 0x41ff0d95, 0x7139a801, 0xde080cb3, 0x9cd8b4e4, 0x906456c1, 0x617bcb84, 0x70d532b6, 0x74486c5c, 0x42d0b857];
    var T7 = [0xa75051f4, 0x65537e41, 0xa4c31a17, 0x5e963a27, 0x6bcb3bab, 0x45f11f9d, 0x58abacfa, 0x03934be3, 0xfa552030, 0x6df6ad76, 0x769188cc, 0x4c25f502, 0xd7fc4fe5, 0xcbd7c52a, 0x44802635, 0xa38fb562, 0x5a49deb1, 0x1b6725ba, 0x0e9845ea, 0xc0e15dfe, 0x7502c32f, 0xf012814c, 0x97a38d46, 0xf9c66bd3, 0x5fe7038f, 0x9c951592, 0x7aebbf6d, 0x59da9552, 0x832dd4be, 0x21d35874, 0x692949e0, 0xc8448ec9, 0x896a75c2, 0x7978f48e, 0x3e6b9958, 0x71dd27b9, 0x4fb6bee1, 0xad17f088, 0xac66c920, 0x3ab47dce, 0x4a1863df, 0x3182e51a, 0x33609751, 0x7f456253, 0x77e0b164, 0xae84bb6b, 0xa01cfe81, 0x2b94f908, 0x68587048, 0xfd198f45, 0x6c8794de, 0xf8b7527b, 0xd323ab73, 0x02e2724b, 0x8f57e31f, 0xab2a6655, 0x2807b2eb, 0xc2032fb5, 0x7b9a86c5, 0x08a5d337, 0x87f23028, 0xa5b223bf, 0x6aba0203, 0x825ced16, 0x1c2b8acf, 0xb492a779, 0xf2f0f307, 0xe2a14e69, 0xf4cd65da, 0xbed50605, 0x621fd134, 0xfe8ac4a6, 0x539d342e, 0x55a0a2f3, 0xe132058a, 0xeb75a4f6, 0xec390b83, 0xefaa4060, 0x9f065e71, 0x1051bd6e, 0x8af93e21, 0x063d96dd, 0x05aedd3e, 0xbd464de6, 0x8db59154, 0x5d0571c4, 0xd46f0406, 0x15ff6050, 0xfb241998, 0xe997d6bd, 0x43cc8940, 0x9e7767d9, 0x42bdb0e8, 0x8b880789, 0x5b38e719, 0xeedb79c8, 0x0a47a17c, 0x0fe97c42, 0x1ec9f884, 0x00000000, 0x86830980, 0xed48322b, 0x70ac1e11, 0x724e6c5a, 0xfffbfd0e, 0x38560f85, 0xd51e3dae, 0x3927362d, 0xd9640a0f, 0xa621685c, 0x54d19b5b, 0x2e3a2436, 0x67b10c0a, 0xe70f9357, 0x96d2b4ee, 0x919e1b9b, 0xc54f80c0, 0x20a261dc, 0x4b695a77, 0x1a161c12, 0xba0ae293, 0x2ae5c0a0, 0xe0433c22, 0x171d121b, 0x0d0b0e09, 0xc7adf28b, 0xa8b92db6, 0xa9c8141e, 0x198557f1, 0x074caf75, 0xddbbee99, 0x60fda37f, 0x269ff701, 0xf5bc5c72, 0x3bc54466, 0x7e345bfb, 0x29768b43, 0xc6dccb23, 0xfc68b6ed, 0xf163b8e4, 0xdccad731, 0x85104263, 0x22401397, 0x112084c6, 0x247d854a, 0x3df8d2bb, 0x3211aef9, 0xa16dc729, 0x2f4b1d9e, 0x30f3dcb2, 0x52ec0d86, 0xe3d077c1, 0x166c2bb3, 0xb999a970, 0x48fa1194, 0x642247e9, 0x8cc4a8fc, 0x3f1aa0f0, 0x2cd8567d, 0x90ef2233, 0x4ec78749, 0xd1c1d938, 0xa2fe8cca, 0x0b3698d4, 0x81cfa6f5, 0xde28a57a, 0x8e26dab7, 0xbfa43fad, 0x9de42c3a, 0x920d5078, 0xcc9b6a5f, 0x4662547e, 0x13c2f68d, 0xb8e890d8, 0xf75e2e39, 0xaff582c3, 0x80be9f5d, 0x937c69d0, 0x2da96fd5, 0x12b3cf25, 0x993bc8ac, 0x7da71018, 0x636ee89c, 0xbb7bdb3b, 0x7809cd26, 0x18f46e59, 0xb701ec9a, 0x9aa8834f, 0x6e65e695, 0xe67eaaff, 0xcf0821bc, 0xe8e6ef15, 0x9bd9bae7, 0x36ce4a6f, 0x09d4ea9f, 0x7cd629b0, 0xb2af31a4, 0x23312a3f, 0x9430c6a5, 0x66c035a2, 0xbc37744e, 0xcaa6fc82, 0xd0b0e090, 0xd81533a7, 0x984af104, 0xdaf741ec, 0x500e7fcd, 0xf62f1791, 0xd68d764d, 0xb04d43ef, 0x4d54ccaa, 0x04dfe496, 0xb5e39ed1, 0x881b4c6a, 0x1fb8c12c, 0x517f4665, 0xea049d5e, 0x355d018c, 0x7473fa87, 0x412efb0b, 0x1d5ab367, 0xd25292db, 0x5633e910, 0x47136dd6, 0x618c9ad7, 0x0c7a37a1, 0x148e59f8, 0x3c89eb13, 0x27eecea9, 0xc935b761, 0xe5ede11c, 0xb13c7a47, 0xdf599cd2, 0x733f55f2, 0xce791814, 0x37bf73c7, 0xcdea53f7, 0xaa5b5ffd, 0x6f14df3d, 0xdb867844, 0xf381caaf, 0xc43eb968, 0x342c3824, 0x405fc2a3, 0xc372161d, 0x250cbce2, 0x498b283c, 0x9541ff0d, 0x017139a8, 0xb3de080c, 0xe49cd8b4, 0xc1906456, 0x84617bcb, 0xb670d532, 0x5c74486c, 0x5742d0b8];
    var T8 = [0xf4a75051, 0x4165537e, 0x17a4c31a, 0x275e963a, 0xab6bcb3b, 0x9d45f11f, 0xfa58abac, 0xe303934b, 0x30fa5520, 0x766df6ad, 0xcc769188, 0x024c25f5, 0xe5d7fc4f, 0x2acbd7c5, 0x35448026, 0x62a38fb5, 0xb15a49de, 0xba1b6725, 0xea0e9845, 0xfec0e15d, 0x2f7502c3, 0x4cf01281, 0x4697a38d, 0xd3f9c66b, 0x8f5fe703, 0x929c9515, 0x6d7aebbf, 0x5259da95, 0xbe832dd4, 0x7421d358, 0xe0692949, 0xc9c8448e, 0xc2896a75, 0x8e7978f4, 0x583e6b99, 0xb971dd27, 0xe14fb6be, 0x88ad17f0, 0x20ac66c9, 0xce3ab47d, 0xdf4a1863, 0x1a3182e5, 0x51336097, 0x537f4562, 0x6477e0b1, 0x6bae84bb, 0x81a01cfe, 0x082b94f9, 0x48685870, 0x45fd198f, 0xde6c8794, 0x7bf8b752, 0x73d323ab, 0x4b02e272, 0x1f8f57e3, 0x55ab2a66, 0xeb2807b2, 0xb5c2032f, 0xc57b9a86, 0x3708a5d3, 0x2887f230, 0xbfa5b223, 0x036aba02, 0x16825ced, 0xcf1c2b8a, 0x79b492a7, 0x07f2f0f3, 0x69e2a14e, 0xdaf4cd65, 0x05bed506, 0x34621fd1, 0xa6fe8ac4, 0x2e539d34, 0xf355a0a2, 0x8ae13205, 0xf6eb75a4, 0x83ec390b, 0x60efaa40, 0x719f065e, 0x6e1051bd, 0x218af93e, 0xdd063d96, 0x3e05aedd, 0xe6bd464d, 0x548db591, 0xc45d0571, 0x06d46f04, 0x5015ff60, 0x98fb2419, 0xbde997d6, 0x4043cc89, 0xd99e7767, 0xe842bdb0, 0x898b8807, 0x195b38e7, 0xc8eedb79, 0x7c0a47a1, 0x420fe97c, 0x841ec9f8, 0x00000000, 0x80868309, 0x2bed4832, 0x1170ac1e, 0x5a724e6c, 0x0efffbfd, 0x8538560f, 0xaed51e3d, 0x2d392736, 0x0fd9640a, 0x5ca62168, 0x5b54d19b, 0x362e3a24, 0x0a67b10c, 0x57e70f93, 0xee96d2b4, 0x9b919e1b, 0xc0c54f80, 0xdc20a261, 0x774b695a, 0x121a161c, 0x93ba0ae2, 0xa02ae5c0, 0x22e0433c, 0x1b171d12, 0x090d0b0e, 0x8bc7adf2, 0xb6a8b92d, 0x1ea9c814, 0xf1198557, 0x75074caf, 0x99ddbbee, 0x7f60fda3, 0x01269ff7, 0x72f5bc5c, 0x663bc544, 0xfb7e345b, 0x4329768b, 0x23c6dccb, 0xedfc68b6, 0xe4f163b8, 0x31dccad7, 0x63851042, 0x97224013, 0xc6112084, 0x4a247d85, 0xbb3df8d2, 0xf93211ae, 0x29a16dc7, 0x9e2f4b1d, 0xb230f3dc, 0x8652ec0d, 0xc1e3d077, 0xb3166c2b, 0x70b999a9, 0x9448fa11, 0xe9642247, 0xfc8cc4a8, 0xf03f1aa0, 0x7d2cd856, 0x3390ef22, 0x494ec787, 0x38d1c1d9, 0xcaa2fe8c, 0xd40b3698, 0xf581cfa6, 0x7ade28a5, 0xb78e26da, 0xadbfa43f, 0x3a9de42c, 0x78920d50, 0x5fcc9b6a, 0x7e466254, 0x8d13c2f6, 0xd8b8e890, 0x39f75e2e, 0xc3aff582, 0x5d80be9f, 0xd0937c69, 0xd52da96f, 0x2512b3cf, 0xac993bc8, 0x187da710, 0x9c636ee8, 0x3bbb7bdb, 0x267809cd, 0x5918f46e, 0x9ab701ec, 0x4f9aa883, 0x956e65e6, 0xffe67eaa, 0xbccf0821, 0x15e8e6ef, 0xe79bd9ba, 0x6f36ce4a, 0x9f09d4ea, 0xb07cd629, 0xa4b2af31, 0x3f23312a, 0xa59430c6, 0xa266c035, 0x4ebc3774, 0x82caa6fc, 0x90d0b0e0, 0xa7d81533, 0x04984af1, 0xecdaf741, 0xcd500e7f, 0x91f62f17, 0x4dd68d76, 0xefb04d43, 0xaa4d54cc, 0x9604dfe4, 0xd1b5e39e, 0x6a881b4c, 0x2c1fb8c1, 0x65517f46, 0x5eea049d, 0x8c355d01, 0x877473fa, 0x0b412efb, 0x671d5ab3, 0xdbd25292, 0x105633e9, 0xd647136d, 0xd7618c9a, 0xa10c7a37, 0xf8148e59, 0x133c89eb, 0xa927eece, 0x61c935b7, 0x1ce5ede1, 0x47b13c7a, 0xd2df599c, 0xf2733f55, 0x14ce7918, 0xc737bf73, 0xf7cdea53, 0xfdaa5b5f, 0x3d6f14df, 0x44db8678, 0xaff381ca, 0x68c43eb9, 0x24342c38, 0xa3405fc2, 0x1dc37216, 0xe2250cbc, 0x3c498b28, 0x0d9541ff, 0xa8017139, 0x0cb3de08, 0xb4e49cd8, 0x56c19064, 0xcb84617b, 0x32b670d5, 0x6c5c7448, 0xb85742d0];

    // Transformations for decryption key expansion
    var U1 = [0x00000000, 0x0e090d0b, 0x1c121a16, 0x121b171d, 0x3824342c, 0x362d3927, 0x24362e3a, 0x2a3f2331, 0x70486858, 0x7e416553, 0x6c5a724e, 0x62537f45, 0x486c5c74, 0x4665517f, 0x547e4662, 0x5a774b69, 0xe090d0b0, 0xee99ddbb, 0xfc82caa6, 0xf28bc7ad, 0xd8b4e49c, 0xd6bde997, 0xc4a6fe8a, 0xcaaff381, 0x90d8b8e8, 0x9ed1b5e3, 0x8ccaa2fe, 0x82c3aff5, 0xa8fc8cc4, 0xa6f581cf, 0xb4ee96d2, 0xbae79bd9, 0xdb3bbb7b, 0xd532b670, 0xc729a16d, 0xc920ac66, 0xe31f8f57, 0xed16825c, 0xff0d9541, 0xf104984a, 0xab73d323, 0xa57ade28, 0xb761c935, 0xb968c43e, 0x9357e70f, 0x9d5eea04, 0x8f45fd19, 0x814cf012, 0x3bab6bcb, 0x35a266c0, 0x27b971dd, 0x29b07cd6, 0x038f5fe7, 0x0d8652ec, 0x1f9d45f1, 0x119448fa, 0x4be30393, 0x45ea0e98, 0x57f11985, 0x59f8148e, 0x73c737bf, 0x7dce3ab4, 0x6fd52da9, 0x61dc20a2, 0xad766df6, 0xa37f60fd, 0xb16477e0, 0xbf6d7aeb, 0x955259da, 0x9b5b54d1, 0x894043cc, 0x87494ec7, 0xdd3e05ae, 0xd33708a5, 0xc12c1fb8, 0xcf2512b3, 0xe51a3182, 0xeb133c89, 0xf9082b94, 0xf701269f, 0x4de6bd46, 0x43efb04d, 0x51f4a750, 0x5ffdaa5b, 0x75c2896a, 0x7bcb8461, 0x69d0937c, 0x67d99e77, 0x3daed51e, 0x33a7d815, 0x21bccf08, 0x2fb5c203, 0x058ae132, 0x0b83ec39, 0x1998fb24, 0x1791f62f, 0x764dd68d, 0x7844db86, 0x6a5fcc9b, 0x6456c190, 0x4e69e2a1, 0x4060efaa, 0x527bf8b7, 0x5c72f5bc, 0x0605bed5, 0x080cb3de, 0x1a17a4c3, 0x141ea9c8, 0x3e218af9, 0x302887f2, 0x223390ef, 0x2c3a9de4, 0x96dd063d, 0x98d40b36, 0x8acf1c2b, 0x84c61120, 0xaef93211, 0xa0f03f1a, 0xb2eb2807, 0xbce2250c, 0xe6956e65, 0xe89c636e, 0xfa877473, 0xf48e7978, 0xdeb15a49, 0xd0b85742, 0xc2a3405f, 0xccaa4d54, 0x41ecdaf7, 0x4fe5d7fc, 0x5dfec0e1, 0x53f7cdea, 0x79c8eedb, 0x77c1e3d0, 0x65daf4cd, 0x6bd3f9c6, 0x31a4b2af, 0x3fadbfa4, 0x2db6a8b9, 0x23bfa5b2, 0x09808683, 0x07898b88, 0x15929c95, 0x1b9b919e, 0xa17c0a47, 0xaf75074c, 0xbd6e1051, 0xb3671d5a, 0x99583e6b, 0x97513360, 0x854a247d, 0x8b432976, 0xd134621f, 0xdf3d6f14, 0xcd267809, 0xc32f7502, 0xe9105633, 0xe7195b38, 0xf5024c25, 0xfb0b412e, 0x9ad7618c, 0x94de6c87, 0x86c57b9a, 0x88cc7691, 0xa2f355a0, 0xacfa58ab, 0xbee14fb6, 0xb0e842bd, 0xea9f09d4, 0xe49604df, 0xf68d13c2, 0xf8841ec9, 0xd2bb3df8, 0xdcb230f3, 0xcea927ee, 0xc0a02ae5, 0x7a47b13c, 0x744ebc37, 0x6655ab2a, 0x685ca621, 0x42638510, 0x4c6a881b, 0x5e719f06, 0x5078920d, 0x0a0fd964, 0x0406d46f, 0x161dc372, 0x1814ce79, 0x322bed48, 0x3c22e043, 0x2e39f75e, 0x2030fa55, 0xec9ab701, 0xe293ba0a, 0xf088ad17, 0xfe81a01c, 0xd4be832d, 0xdab78e26, 0xc8ac993b, 0xc6a59430, 0x9cd2df59, 0x92dbd252, 0x80c0c54f, 0x8ec9c844, 0xa4f6eb75, 0xaaffe67e, 0xb8e4f163, 0xb6edfc68, 0x0c0a67b1, 0x02036aba, 0x10187da7, 0x1e1170ac, 0x342e539d, 0x3a275e96, 0x283c498b, 0x26354480, 0x7c420fe9, 0x724b02e2, 0x605015ff, 0x6e5918f4, 0x44663bc5, 0x4a6f36ce, 0x587421d3, 0x567d2cd8, 0x37a10c7a, 0x39a80171, 0x2bb3166c, 0x25ba1b67, 0x0f853856, 0x018c355d, 0x13972240, 0x1d9e2f4b, 0x47e96422, 0x49e06929, 0x5bfb7e34, 0x55f2733f, 0x7fcd500e, 0x71c45d05, 0x63df4a18, 0x6dd64713, 0xd731dcca, 0xd938d1c1, 0xcb23c6dc, 0xc52acbd7, 0xef15e8e6, 0xe11ce5ed, 0xf307f2f0, 0xfd0efffb, 0xa779b492, 0xa970b999, 0xbb6bae84, 0xb562a38f, 0x9f5d80be, 0x91548db5, 0x834f9aa8, 0x8d4697a3];
    var U2 = [0x00000000, 0x0b0e090d, 0x161c121a, 0x1d121b17, 0x2c382434, 0x27362d39, 0x3a24362e, 0x312a3f23, 0x58704868, 0x537e4165, 0x4e6c5a72, 0x4562537f, 0x74486c5c, 0x7f466551, 0x62547e46, 0x695a774b, 0xb0e090d0, 0xbbee99dd, 0xa6fc82ca, 0xadf28bc7, 0x9cd8b4e4, 0x97d6bde9, 0x8ac4a6fe, 0x81caaff3, 0xe890d8b8, 0xe39ed1b5, 0xfe8ccaa2, 0xf582c3af, 0xc4a8fc8c, 0xcfa6f581, 0xd2b4ee96, 0xd9bae79b, 0x7bdb3bbb, 0x70d532b6, 0x6dc729a1, 0x66c920ac, 0x57e31f8f, 0x5ced1682, 0x41ff0d95, 0x4af10498, 0x23ab73d3, 0x28a57ade, 0x35b761c9, 0x3eb968c4, 0x0f9357e7, 0x049d5eea, 0x198f45fd, 0x12814cf0, 0xcb3bab6b, 0xc035a266, 0xdd27b971, 0xd629b07c, 0xe7038f5f, 0xec0d8652, 0xf11f9d45, 0xfa119448, 0x934be303, 0x9845ea0e, 0x8557f119, 0x8e59f814, 0xbf73c737, 0xb47dce3a, 0xa96fd52d, 0xa261dc20, 0xf6ad766d, 0xfda37f60, 0xe0b16477, 0xebbf6d7a, 0xda955259, 0xd19b5b54, 0xcc894043, 0xc787494e, 0xaedd3e05, 0xa5d33708, 0xb8c12c1f, 0xb3cf2512, 0x82e51a31, 0x89eb133c, 0x94f9082b, 0x9ff70126, 0x464de6bd, 0x4d43efb0, 0x5051f4a7, 0x5b5ffdaa, 0x6a75c289, 0x617bcb84, 0x7c69d093, 0x7767d99e, 0x1e3daed5, 0x1533a7d8, 0x0821bccf, 0x032fb5c2, 0x32058ae1, 0x390b83ec, 0x241998fb, 0x2f1791f6, 0x8d764dd6, 0x867844db, 0x9b6a5fcc, 0x906456c1, 0xa14e69e2, 0xaa4060ef, 0xb7527bf8, 0xbc5c72f5, 0xd50605be, 0xde080cb3, 0xc31a17a4, 0xc8141ea9, 0xf93e218a, 0xf2302887, 0xef223390, 0xe42c3a9d, 0x3d96dd06, 0x3698d40b, 0x2b8acf1c, 0x2084c611, 0x11aef932, 0x1aa0f03f, 0x07b2eb28, 0x0cbce225, 0x65e6956e, 0x6ee89c63, 0x73fa8774, 0x78f48e79, 0x49deb15a, 0x42d0b857, 0x5fc2a340, 0x54ccaa4d, 0xf741ecda, 0xfc4fe5d7, 0xe15dfec0, 0xea53f7cd, 0xdb79c8ee, 0xd077c1e3, 0xcd65daf4, 0xc66bd3f9, 0xaf31a4b2, 0xa43fadbf, 0xb92db6a8, 0xb223bfa5, 0x83098086, 0x8807898b, 0x9515929c, 0x9e1b9b91, 0x47a17c0a, 0x4caf7507, 0x51bd6e10, 0x5ab3671d, 0x6b99583e, 0x60975133, 0x7d854a24, 0x768b4329, 0x1fd13462, 0x14df3d6f, 0x09cd2678, 0x02c32f75, 0x33e91056, 0x38e7195b, 0x25f5024c, 0x2efb0b41, 0x8c9ad761, 0x8794de6c, 0x9a86c57b, 0x9188cc76, 0xa0a2f355, 0xabacfa58, 0xb6bee14f, 0xbdb0e842, 0xd4ea9f09, 0xdfe49604, 0xc2f68d13, 0xc9f8841e, 0xf8d2bb3d, 0xf3dcb230, 0xeecea927, 0xe5c0a02a, 0x3c7a47b1, 0x37744ebc, 0x2a6655ab, 0x21685ca6, 0x10426385, 0x1b4c6a88, 0x065e719f, 0x0d507892, 0x640a0fd9, 0x6f0406d4, 0x72161dc3, 0x791814ce, 0x48322bed, 0x433c22e0, 0x5e2e39f7, 0x552030fa, 0x01ec9ab7, 0x0ae293ba, 0x17f088ad, 0x1cfe81a0, 0x2dd4be83, 0x26dab78e, 0x3bc8ac99, 0x30c6a594, 0x599cd2df, 0x5292dbd2, 0x4f80c0c5, 0x448ec9c8, 0x75a4f6eb, 0x7eaaffe6, 0x63b8e4f1, 0x68b6edfc, 0xb10c0a67, 0xba02036a, 0xa710187d, 0xac1e1170, 0x9d342e53, 0x963a275e, 0x8b283c49, 0x80263544, 0xe97c420f, 0xe2724b02, 0xff605015, 0xf46e5918, 0xc544663b, 0xce4a6f36, 0xd3587421, 0xd8567d2c, 0x7a37a10c, 0x7139a801, 0x6c2bb316, 0x6725ba1b, 0x560f8538, 0x5d018c35, 0x40139722, 0x4b1d9e2f, 0x2247e964, 0x2949e069, 0x345bfb7e, 0x3f55f273, 0x0e7fcd50, 0x0571c45d, 0x1863df4a, 0x136dd647, 0xcad731dc, 0xc1d938d1, 0xdccb23c6, 0xd7c52acb, 0xe6ef15e8, 0xede11ce5, 0xf0f307f2, 0xfbfd0eff, 0x92a779b4, 0x99a970b9, 0x84bb6bae, 0x8fb562a3, 0xbe9f5d80, 0xb591548d, 0xa8834f9a, 0xa38d4697];
    var U3 = [0x00000000, 0x0d0b0e09, 0x1a161c12, 0x171d121b, 0x342c3824, 0x3927362d, 0x2e3a2436, 0x23312a3f, 0x68587048, 0x65537e41, 0x724e6c5a, 0x7f456253, 0x5c74486c, 0x517f4665, 0x4662547e, 0x4b695a77, 0xd0b0e090, 0xddbbee99, 0xcaa6fc82, 0xc7adf28b, 0xe49cd8b4, 0xe997d6bd, 0xfe8ac4a6, 0xf381caaf, 0xb8e890d8, 0xb5e39ed1, 0xa2fe8cca, 0xaff582c3, 0x8cc4a8fc, 0x81cfa6f5, 0x96d2b4ee, 0x9bd9bae7, 0xbb7bdb3b, 0xb670d532, 0xa16dc729, 0xac66c920, 0x8f57e31f, 0x825ced16, 0x9541ff0d, 0x984af104, 0xd323ab73, 0xde28a57a, 0xc935b761, 0xc43eb968, 0xe70f9357, 0xea049d5e, 0xfd198f45, 0xf012814c, 0x6bcb3bab, 0x66c035a2, 0x71dd27b9, 0x7cd629b0, 0x5fe7038f, 0x52ec0d86, 0x45f11f9d, 0x48fa1194, 0x03934be3, 0x0e9845ea, 0x198557f1, 0x148e59f8, 0x37bf73c7, 0x3ab47dce, 0x2da96fd5, 0x20a261dc, 0x6df6ad76, 0x60fda37f, 0x77e0b164, 0x7aebbf6d, 0x59da9552, 0x54d19b5b, 0x43cc8940, 0x4ec78749, 0x05aedd3e, 0x08a5d337, 0x1fb8c12c, 0x12b3cf25, 0x3182e51a, 0x3c89eb13, 0x2b94f908, 0x269ff701, 0xbd464de6, 0xb04d43ef, 0xa75051f4, 0xaa5b5ffd, 0x896a75c2, 0x84617bcb, 0x937c69d0, 0x9e7767d9, 0xd51e3dae, 0xd81533a7, 0xcf0821bc, 0xc2032fb5, 0xe132058a, 0xec390b83, 0xfb241998, 0xf62f1791, 0xd68d764d, 0xdb867844, 0xcc9b6a5f, 0xc1906456, 0xe2a14e69, 0xefaa4060, 0xf8b7527b, 0xf5bc5c72, 0xbed50605, 0xb3de080c, 0xa4c31a17, 0xa9c8141e, 0x8af93e21, 0x87f23028, 0x90ef2233, 0x9de42c3a, 0x063d96dd, 0x0b3698d4, 0x1c2b8acf, 0x112084c6, 0x3211aef9, 0x3f1aa0f0, 0x2807b2eb, 0x250cbce2, 0x6e65e695, 0x636ee89c, 0x7473fa87, 0x7978f48e, 0x5a49deb1, 0x5742d0b8, 0x405fc2a3, 0x4d54ccaa, 0xdaf741ec, 0xd7fc4fe5, 0xc0e15dfe, 0xcdea53f7, 0xeedb79c8, 0xe3d077c1, 0xf4cd65da, 0xf9c66bd3, 0xb2af31a4, 0xbfa43fad, 0xa8b92db6, 0xa5b223bf, 0x86830980, 0x8b880789, 0x9c951592, 0x919e1b9b, 0x0a47a17c, 0x074caf75, 0x1051bd6e, 0x1d5ab367, 0x3e6b9958, 0x33609751, 0x247d854a, 0x29768b43, 0x621fd134, 0x6f14df3d, 0x7809cd26, 0x7502c32f, 0x5633e910, 0x5b38e719, 0x4c25f502, 0x412efb0b, 0x618c9ad7, 0x6c8794de, 0x7b9a86c5, 0x769188cc, 0x55a0a2f3, 0x58abacfa, 0x4fb6bee1, 0x42bdb0e8, 0x09d4ea9f, 0x04dfe496, 0x13c2f68d, 0x1ec9f884, 0x3df8d2bb, 0x30f3dcb2, 0x27eecea9, 0x2ae5c0a0, 0xb13c7a47, 0xbc37744e, 0xab2a6655, 0xa621685c, 0x85104263, 0x881b4c6a, 0x9f065e71, 0x920d5078, 0xd9640a0f, 0xd46f0406, 0xc372161d, 0xce791814, 0xed48322b, 0xe0433c22, 0xf75e2e39, 0xfa552030, 0xb701ec9a, 0xba0ae293, 0xad17f088, 0xa01cfe81, 0x832dd4be, 0x8e26dab7, 0x993bc8ac, 0x9430c6a5, 0xdf599cd2, 0xd25292db, 0xc54f80c0, 0xc8448ec9, 0xeb75a4f6, 0xe67eaaff, 0xf163b8e4, 0xfc68b6ed, 0x67b10c0a, 0x6aba0203, 0x7da71018, 0x70ac1e11, 0x539d342e, 0x5e963a27, 0x498b283c, 0x44802635, 0x0fe97c42, 0x02e2724b, 0x15ff6050, 0x18f46e59, 0x3bc54466, 0x36ce4a6f, 0x21d35874, 0x2cd8567d, 0x0c7a37a1, 0x017139a8, 0x166c2bb3, 0x1b6725ba, 0x38560f85, 0x355d018c, 0x22401397, 0x2f4b1d9e, 0x642247e9, 0x692949e0, 0x7e345bfb, 0x733f55f2, 0x500e7fcd, 0x5d0571c4, 0x4a1863df, 0x47136dd6, 0xdccad731, 0xd1c1d938, 0xc6dccb23, 0xcbd7c52a, 0xe8e6ef15, 0xe5ede11c, 0xf2f0f307, 0xfffbfd0e, 0xb492a779, 0xb999a970, 0xae84bb6b, 0xa38fb562, 0x80be9f5d, 0x8db59154, 0x9aa8834f, 0x97a38d46];
    var U4 = [0x00000000, 0x090d0b0e, 0x121a161c, 0x1b171d12, 0x24342c38, 0x2d392736, 0x362e3a24, 0x3f23312a, 0x48685870, 0x4165537e, 0x5a724e6c, 0x537f4562, 0x6c5c7448, 0x65517f46, 0x7e466254, 0x774b695a, 0x90d0b0e0, 0x99ddbbee, 0x82caa6fc, 0x8bc7adf2, 0xb4e49cd8, 0xbde997d6, 0xa6fe8ac4, 0xaff381ca, 0xd8b8e890, 0xd1b5e39e, 0xcaa2fe8c, 0xc3aff582, 0xfc8cc4a8, 0xf581cfa6, 0xee96d2b4, 0xe79bd9ba, 0x3bbb7bdb, 0x32b670d5, 0x29a16dc7, 0x20ac66c9, 0x1f8f57e3, 0x16825ced, 0x0d9541ff, 0x04984af1, 0x73d323ab, 0x7ade28a5, 0x61c935b7, 0x68c43eb9, 0x57e70f93, 0x5eea049d, 0x45fd198f, 0x4cf01281, 0xab6bcb3b, 0xa266c035, 0xb971dd27, 0xb07cd629, 0x8f5fe703, 0x8652ec0d, 0x9d45f11f, 0x9448fa11, 0xe303934b, 0xea0e9845, 0xf1198557, 0xf8148e59, 0xc737bf73, 0xce3ab47d, 0xd52da96f, 0xdc20a261, 0x766df6ad, 0x7f60fda3, 0x6477e0b1, 0x6d7aebbf, 0x5259da95, 0x5b54d19b, 0x4043cc89, 0x494ec787, 0x3e05aedd, 0x3708a5d3, 0x2c1fb8c1, 0x2512b3cf, 0x1a3182e5, 0x133c89eb, 0x082b94f9, 0x01269ff7, 0xe6bd464d, 0xefb04d43, 0xf4a75051, 0xfdaa5b5f, 0xc2896a75, 0xcb84617b, 0xd0937c69, 0xd99e7767, 0xaed51e3d, 0xa7d81533, 0xbccf0821, 0xb5c2032f, 0x8ae13205, 0x83ec390b, 0x98fb2419, 0x91f62f17, 0x4dd68d76, 0x44db8678, 0x5fcc9b6a, 0x56c19064, 0x69e2a14e, 0x60efaa40, 0x7bf8b752, 0x72f5bc5c, 0x05bed506, 0x0cb3de08, 0x17a4c31a, 0x1ea9c814, 0x218af93e, 0x2887f230, 0x3390ef22, 0x3a9de42c, 0xdd063d96, 0xd40b3698, 0xcf1c2b8a, 0xc6112084, 0xf93211ae, 0xf03f1aa0, 0xeb2807b2, 0xe2250cbc, 0x956e65e6, 0x9c636ee8, 0x877473fa, 0x8e7978f4, 0xb15a49de, 0xb85742d0, 0xa3405fc2, 0xaa4d54cc, 0xecdaf741, 0xe5d7fc4f, 0xfec0e15d, 0xf7cdea53, 0xc8eedb79, 0xc1e3d077, 0xdaf4cd65, 0xd3f9c66b, 0xa4b2af31, 0xadbfa43f, 0xb6a8b92d, 0xbfa5b223, 0x80868309, 0x898b8807, 0x929c9515, 0x9b919e1b, 0x7c0a47a1, 0x75074caf, 0x6e1051bd, 0x671d5ab3, 0x583e6b99, 0x51336097, 0x4a247d85, 0x4329768b, 0x34621fd1, 0x3d6f14df, 0x267809cd, 0x2f7502c3, 0x105633e9, 0x195b38e7, 0x024c25f5, 0x0b412efb, 0xd7618c9a, 0xde6c8794, 0xc57b9a86, 0xcc769188, 0xf355a0a2, 0xfa58abac, 0xe14fb6be, 0xe842bdb0, 0x9f09d4ea, 0x9604dfe4, 0x8d13c2f6, 0x841ec9f8, 0xbb3df8d2, 0xb230f3dc, 0xa927eece, 0xa02ae5c0, 0x47b13c7a, 0x4ebc3774, 0x55ab2a66, 0x5ca62168, 0x63851042, 0x6a881b4c, 0x719f065e, 0x78920d50, 0x0fd9640a, 0x06d46f04, 0x1dc37216, 0x14ce7918, 0x2bed4832, 0x22e0433c, 0x39f75e2e, 0x30fa5520, 0x9ab701ec, 0x93ba0ae2, 0x88ad17f0, 0x81a01cfe, 0xbe832dd4, 0xb78e26da, 0xac993bc8, 0xa59430c6, 0xd2df599c, 0xdbd25292, 0xc0c54f80, 0xc9c8448e, 0xf6eb75a4, 0xffe67eaa, 0xe4f163b8, 0xedfc68b6, 0x0a67b10c, 0x036aba02, 0x187da710, 0x1170ac1e, 0x2e539d34, 0x275e963a, 0x3c498b28, 0x35448026, 0x420fe97c, 0x4b02e272, 0x5015ff60, 0x5918f46e, 0x663bc544, 0x6f36ce4a, 0x7421d358, 0x7d2cd856, 0xa10c7a37, 0xa8017139, 0xb3166c2b, 0xba1b6725, 0x8538560f, 0x8c355d01, 0x97224013, 0x9e2f4b1d, 0xe9642247, 0xe0692949, 0xfb7e345b, 0xf2733f55, 0xcd500e7f, 0xc45d0571, 0xdf4a1863, 0xd647136d, 0x31dccad7, 0x38d1c1d9, 0x23c6dccb, 0x2acbd7c5, 0x15e8e6ef, 0x1ce5ede1, 0x07f2f0f3, 0x0efffbfd, 0x79b492a7, 0x70b999a9, 0x6bae84bb, 0x62a38fb5, 0x5d80be9f, 0x548db591, 0x4f9aa883, 0x4697a38d];

    function convertToInt32(bytes) {
        var result = [];
        for (var i = 0; i < bytes.length; i += 4) {
            result.push(
                (bytes[i    ] << 24) |
                (bytes[i + 1] << 16) |
                (bytes[i + 2] <<  8) |
                 bytes[i + 3]
            );
        }
        return result;
    }

    var AES = function(key) {
        if (!(this instanceof AES)) {
            throw Error('AES must be instanitated with `new`');
        }

        Object.defineProperty(this, 'key', {
            value: coerceArray(key, true)
        });

        this._prepare();
    }


    AES.prototype._prepare = function() {

        var rounds = numberOfRounds[this.key.length];
        if (rounds == null) {
            throw new Error('invalid key size (must be 16, 24 or 32 bytes)');
        }

        // encryption round keys
        this._Ke = [];

        // decryption round keys
        this._Kd = [];

        for (var i = 0; i <= rounds; i++) {
            this._Ke.push([0, 0, 0, 0]);
            this._Kd.push([0, 0, 0, 0]);
        }

        var roundKeyCount = (rounds + 1) * 4;
        var KC = this.key.length / 4;

        // convert the key into ints
        var tk = convertToInt32(this.key);

        // copy values into round key arrays
        var index;
        for (var i = 0; i < KC; i++) {
            index = i >> 2;
            this._Ke[index][i % 4] = tk[i];
            this._Kd[rounds - index][i % 4] = tk[i];
        }

        // key expansion (fips-197 section 5.2)
        var rconpointer = 0;
        var t = KC, tt;
        while (t < roundKeyCount) {
            tt = tk[KC - 1];
            tk[0] ^= ((S[(tt >> 16) & 0xFF] << 24) ^
                      (S[(tt >>  8) & 0xFF] << 16) ^
                      (S[ tt        & 0xFF] <<  8) ^
                       S[(tt >> 24) & 0xFF]        ^
                      (rcon[rconpointer] << 24));
            rconpointer += 1;

            // key expansion (for non-256 bit)
            if (KC != 8) {
                for (var i = 1; i < KC; i++) {
                    tk[i] ^= tk[i - 1];
                }

            // key expansion for 256-bit keys is "slightly different" (fips-197)
            } else {
                for (var i = 1; i < (KC / 2); i++) {
                    tk[i] ^= tk[i - 1];
                }
                tt = tk[(KC / 2) - 1];

                tk[KC / 2] ^= (S[ tt        & 0xFF]        ^
                              (S[(tt >>  8) & 0xFF] <<  8) ^
                              (S[(tt >> 16) & 0xFF] << 16) ^
                              (S[(tt >> 24) & 0xFF] << 24));

                for (var i = (KC / 2) + 1; i < KC; i++) {
                    tk[i] ^= tk[i - 1];
                }
            }

            // copy values into round key arrays
            var i = 0, r, c;
            while (i < KC && t < roundKeyCount) {
                r = t >> 2;
                c = t % 4;
                this._Ke[r][c] = tk[i];
                this._Kd[rounds - r][c] = tk[i++];
                t++;
            }
        }

        // inverse-cipher-ify the decryption round key (fips-197 section 5.3)
        for (var r = 1; r < rounds; r++) {
            for (var c = 0; c < 4; c++) {
                tt = this._Kd[r][c];
                this._Kd[r][c] = (U1[(tt >> 24) & 0xFF] ^
                                  U2[(tt >> 16) & 0xFF] ^
                                  U3[(tt >>  8) & 0xFF] ^
                                  U4[ tt        & 0xFF]);
            }
        }
    }

    AES.prototype.encrypt = function(plaintext) {
        if (plaintext.length != 16) {
            throw new Error('invalid plaintext size (must be 16 bytes)');
        }

        var rounds = this._Ke.length - 1;
        var a = [0, 0, 0, 0];

        // convert plaintext to (ints ^ key)
        var t = convertToInt32(plaintext);
        for (var i = 0; i < 4; i++) {
            t[i] ^= this._Ke[0][i];
        }

        // apply round transforms
        for (var r = 1; r < rounds; r++) {
            for (var i = 0; i < 4; i++) {
                a[i] = (T1[(t[ i         ] >> 24) & 0xff] ^
                        T2[(t[(i + 1) % 4] >> 16) & 0xff] ^
                        T3[(t[(i + 2) % 4] >>  8) & 0xff] ^
                        T4[ t[(i + 3) % 4]        & 0xff] ^
                        this._Ke[r][i]);
            }
            t = a.slice();
        }

        // the last round is special
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
            tt = this._Ke[rounds][i];
            result[4 * i    ] = (S[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
            result[4 * i + 1] = (S[(t[(i + 1) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
            result[4 * i + 2] = (S[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
            result[4 * i + 3] = (S[ t[(i + 3) % 4]        & 0xff] ^  tt       ) & 0xff;
        }

        return result;
    }

    AES.prototype.decrypt = function(ciphertext) {
        if (ciphertext.length != 16) {
            throw new Error('invalid ciphertext size (must be 16 bytes)');
        }

        var rounds = this._Kd.length - 1;
        var a = [0, 0, 0, 0];

        // convert plaintext to (ints ^ key)
        var t = convertToInt32(ciphertext);
        for (var i = 0; i < 4; i++) {
            t[i] ^= this._Kd[0][i];
        }

        // apply round transforms
        for (var r = 1; r < rounds; r++) {
            for (var i = 0; i < 4; i++) {
                a[i] = (T5[(t[ i          ] >> 24) & 0xff] ^
                        T6[(t[(i + 3) % 4] >> 16) & 0xff] ^
                        T7[(t[(i + 2) % 4] >>  8) & 0xff] ^
                        T8[ t[(i + 1) % 4]        & 0xff] ^
                        this._Kd[r][i]);
            }
            t = a.slice();
        }

        // the last round is special
        var result = createArray(16), tt;
        for (var i = 0; i < 4; i++) {
            tt = this._Kd[rounds][i];
            result[4 * i    ] = (Si[(t[ i         ] >> 24) & 0xff] ^ (tt >> 24)) & 0xff;
            result[4 * i + 1] = (Si[(t[(i + 3) % 4] >> 16) & 0xff] ^ (tt >> 16)) & 0xff;
            result[4 * i + 2] = (Si[(t[(i + 2) % 4] >>  8) & 0xff] ^ (tt >>  8)) & 0xff;
            result[4 * i + 3] = (Si[ t[(i + 1) % 4]        & 0xff] ^  tt       ) & 0xff;
        }

        return result;
    }


    /**
     *  Mode Of Operation - Electonic Codebook (ECB)
     */
    var ModeOfOperationECB = function(key) {
        if (!(this instanceof ModeOfOperationECB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Electronic Code Block";
        this.name = "ecb";

        this._aes = new AES(key);
    }

    ModeOfOperationECB.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);

        if ((plaintext.length % 16) !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
        }

        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);

        for (var i = 0; i < plaintext.length; i += 16) {
            copyArray(plaintext, block, 0, i, i + 16);
            block = this._aes.encrypt(block);
            copyArray(block, ciphertext, i);
        }

        return ciphertext;
    }

    ModeOfOperationECB.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);

        if ((ciphertext.length % 16) !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        }

        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);

        for (var i = 0; i < ciphertext.length; i += 16) {
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);
            copyArray(block, plaintext, i);
        }

        return plaintext;
    }


    /**
     *  Mode Of Operation - Cipher Block Chaining (CBC)
     */
    var ModeOfOperationCBC = function(key, iv) {
        if (!(this instanceof ModeOfOperationCBC)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Cipher Block Chaining";
        this.name = "cbc";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
        }

        this._lastCipherblock = coerceArray(iv, true);

        this._aes = new AES(key);
    }

    ModeOfOperationCBC.prototype.encrypt = function(plaintext) {
        plaintext = coerceArray(plaintext);

        if ((plaintext.length % 16) !== 0) {
            throw new Error('invalid plaintext size (must be multiple of 16 bytes)');
        }

        var ciphertext = createArray(plaintext.length);
        var block = createArray(16);

        for (var i = 0; i < plaintext.length; i += 16) {
            copyArray(plaintext, block, 0, i, i + 16);

            for (var j = 0; j < 16; j++) {
                block[j] ^= this._lastCipherblock[j];
            }

            this._lastCipherblock = this._aes.encrypt(block);
            copyArray(this._lastCipherblock, ciphertext, i);
        }

        return ciphertext;
    }

    ModeOfOperationCBC.prototype.decrypt = function(ciphertext) {
        ciphertext = coerceArray(ciphertext);

        if ((ciphertext.length % 16) !== 0) {
            throw new Error('invalid ciphertext size (must be multiple of 16 bytes)');
        }

        var plaintext = createArray(ciphertext.length);
        var block = createArray(16);

        for (var i = 0; i < ciphertext.length; i += 16) {
            copyArray(ciphertext, block, 0, i, i + 16);
            block = this._aes.decrypt(block);

            for (var j = 0; j < 16; j++) {
                plaintext[i + j] = block[j] ^ this._lastCipherblock[j];
            }

            copyArray(ciphertext, this._lastCipherblock, 0, i, i + 16);
        }

        return plaintext;
    }


    /**
     *  Mode Of Operation - Cipher Feedback (CFB)
     */
    var ModeOfOperationCFB = function(key, iv, segmentSize) {
        if (!(this instanceof ModeOfOperationCFB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Cipher Feedback";
        this.name = "cfb";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 size)');
        }

        if (!segmentSize) { segmentSize = 1; }

        this.segmentSize = segmentSize;

        this._shiftRegister = coerceArray(iv, true);

        this._aes = new AES(key);
    }

    ModeOfOperationCFB.prototype.encrypt = function(plaintext) {
        if ((plaintext.length % this.segmentSize) != 0) {
            throw new Error('invalid plaintext size (must be segmentSize bytes)');
        }

        var encrypted = coerceArray(plaintext, true);

        var xorSegment;
        for (var i = 0; i < encrypted.length; i += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);
            for (var j = 0; j < this.segmentSize; j++) {
                encrypted[i + j] ^= xorSegment[j];
            }

            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(encrypted, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }

        return encrypted;
    }

    ModeOfOperationCFB.prototype.decrypt = function(ciphertext) {
        if ((ciphertext.length % this.segmentSize) != 0) {
            throw new Error('invalid ciphertext size (must be segmentSize bytes)');
        }

        var plaintext = coerceArray(ciphertext, true);

        var xorSegment;
        for (var i = 0; i < plaintext.length; i += this.segmentSize) {
            xorSegment = this._aes.encrypt(this._shiftRegister);

            for (var j = 0; j < this.segmentSize; j++) {
                plaintext[i + j] ^= xorSegment[j];
            }

            // Shift the register
            copyArray(this._shiftRegister, this._shiftRegister, 0, this.segmentSize);
            copyArray(ciphertext, this._shiftRegister, 16 - this.segmentSize, i, i + this.segmentSize);
        }

        return plaintext;
    }

    /**
     *  Mode Of Operation - Output Feedback (OFB)
     */
    var ModeOfOperationOFB = function(key, iv) {
        if (!(this instanceof ModeOfOperationOFB)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Output Feedback";
        this.name = "ofb";

        if (!iv) {
            iv = createArray(16);

        } else if (iv.length != 16) {
            throw new Error('invalid initialation vector size (must be 16 bytes)');
        }

        this._lastPrecipher = coerceArray(iv, true);
        this._lastPrecipherIndex = 16;

        this._aes = new AES(key);
    }

    ModeOfOperationOFB.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);

        for (var i = 0; i < encrypted.length; i++) {
            if (this._lastPrecipherIndex === 16) {
                this._lastPrecipher = this._aes.encrypt(this._lastPrecipher);
                this._lastPrecipherIndex = 0;
            }
            encrypted[i] ^= this._lastPrecipher[this._lastPrecipherIndex++];
        }

        return encrypted;
    }

    // Decryption is symetric
    ModeOfOperationOFB.prototype.decrypt = ModeOfOperationOFB.prototype.encrypt;


    /**
     *  Counter object for CTR common mode of operation
     */
    var Counter = function(initialValue) {
        if (!(this instanceof Counter)) {
            throw Error('Counter must be instanitated with `new`');
        }

        // We allow 0, but anything false-ish uses the default 1
        if (initialValue !== 0 && !initialValue) { initialValue = 1; }

        if (typeof(initialValue) === 'number') {
            this._counter = createArray(16);
            this.setValue(initialValue);

        } else {
            this.setBytes(initialValue);
        }
    }

    Counter.prototype.setValue = function(value) {
        if (typeof(value) !== 'number' || parseInt(value) != value) {
            throw new Error('invalid counter value (must be an integer)');
        }

        for (var index = 15; index >= 0; --index) {
            this._counter[index] = value % 256;
            value = value >> 8;
        }
    }

    Counter.prototype.setBytes = function(bytes) {
        bytes = coerceArray(bytes, true);

        if (bytes.length != 16) {
            throw new Error('invalid counter bytes size (must be 16 bytes)');
        }

        this._counter = bytes;
    };

    Counter.prototype.increment = function() {
        for (var i = 15; i >= 0; i--) {
            if (this._counter[i] === 255) {
                this._counter[i] = 0;
            } else {
                this._counter[i]++;
                break;
            }
        }
    }


    /**
     *  Mode Of Operation - Counter (CTR)
     */
    var ModeOfOperationCTR = function(key, counter) {
        if (!(this instanceof ModeOfOperationCTR)) {
            throw Error('AES must be instanitated with `new`');
        }

        this.description = "Counter";
        this.name = "ctr";

        if (!(counter instanceof Counter)) {
            counter = new Counter(counter)
        }

        this._counter = counter;

        this._remainingCounter = null;
        this._remainingCounterIndex = 16;

        this._aes = new AES(key);
    }

    ModeOfOperationCTR.prototype.encrypt = function(plaintext) {
        var encrypted = coerceArray(plaintext, true);

        for (var i = 0; i < encrypted.length; i++) {
            if (this._remainingCounterIndex === 16) {
                this._remainingCounter = this._aes.encrypt(this._counter._counter);
                this._remainingCounterIndex = 0;
                this._counter.increment();
            }
            encrypted[i] ^= this._remainingCounter[this._remainingCounterIndex++];
        }

        return encrypted;
    }

    // Decryption is symetric
    ModeOfOperationCTR.prototype.decrypt = ModeOfOperationCTR.prototype.encrypt;


    ///////////////////////
    // Padding

    // See:https://tools.ietf.org/html/rfc2315
    function pkcs7pad(data) {
        data = coerceArray(data, true);
        var padder = 16 - (data.length % 16);
        var result = createArray(data.length + padder);
        copyArray(data, result);
        for (var i = data.length; i < result.length; i++) {
            result[i] = padder;
        }
        return result;
    }

    function pkcs7strip(data) {
        data = coerceArray(data, true);
        if (data.length < 16) { throw new Error('PKCS#7 invalid length'); }

        var padder = data[data.length - 1];
        if (padder > 16) { throw new Error('PKCS#7 padding byte out of range'); }

        var length = data.length - padder;
        for (var i = 0; i < padder; i++) {
            if (data[length + i] !== padder) {
                throw new Error('PKCS#7 invalid padding byte');
            }
        }

        var result = createArray(length);
        copyArray(data, result, 0, 0, length);
        return result;
    }

    ///////////////////////
    // Exporting


    // The block cipher
    var aesjs = {
        AES: AES,
        Counter: Counter,

        ModeOfOperation: {
            ecb: ModeOfOperationECB,
            cbc: ModeOfOperationCBC,
            cfb: ModeOfOperationCFB,
            ofb: ModeOfOperationOFB,
            ctr: ModeOfOperationCTR
        },

        utils: {
            hex: convertHex,
            utf8: convertUtf8
        },

        padding: {
            pkcs7: {
                pad: pkcs7pad,
                strip: pkcs7strip
            }
        },

        _arrayTest: {
            coerceArray: coerceArray,
            createArray: createArray,
            copyArray: copyArray,
        }
    };


    // node.js
    if (true) {
        module.exports = aesjs

    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
    } else {}


})(this);


/***/ }),

/***/ "./node_modules/bech32/index.js":
/*!**************************************!*\
  !*** ./node_modules/bech32/index.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l'

// pre-compute lookup table
var ALPHABET_MAP = {}
for (var z = 0; z < ALPHABET.length; z++) {
  var x = ALPHABET.charAt(z)

  if (ALPHABET_MAP[x] !== undefined) throw new TypeError(x + ' is ambiguous')
  ALPHABET_MAP[x] = z
}

function polymodStep (pre) {
  var b = pre >> 25
  return ((pre & 0x1FFFFFF) << 5) ^
    (-((b >> 0) & 1) & 0x3b6a57b2) ^
    (-((b >> 1) & 1) & 0x26508e6d) ^
    (-((b >> 2) & 1) & 0x1ea119fa) ^
    (-((b >> 3) & 1) & 0x3d4233dd) ^
    (-((b >> 4) & 1) & 0x2a1462b3)
}

function prefixChk (prefix) {
  var chk = 1
  for (var i = 0; i < prefix.length; ++i) {
    var c = prefix.charCodeAt(i)
    if (c < 33 || c > 126) return 'Invalid prefix (' + prefix + ')'

    chk = polymodStep(chk) ^ (c >> 5)
  }
  chk = polymodStep(chk)

  for (i = 0; i < prefix.length; ++i) {
    var v = prefix.charCodeAt(i)
    chk = polymodStep(chk) ^ (v & 0x1f)
  }
  return chk
}

function encode (prefix, words, LIMIT) {
  LIMIT = LIMIT || 90
  if ((prefix.length + 7 + words.length) > LIMIT) throw new TypeError('Exceeds length limit')

  prefix = prefix.toLowerCase()

  // determine chk mod
  var chk = prefixChk(prefix)
  if (typeof chk === 'string') throw new Error(chk)

  var result = prefix + '1'
  for (var i = 0; i < words.length; ++i) {
    var x = words[i]
    if ((x >> 5) !== 0) throw new Error('Non 5-bit word')

    chk = polymodStep(chk) ^ x
    result += ALPHABET.charAt(x)
  }

  for (i = 0; i < 6; ++i) {
    chk = polymodStep(chk)
  }
  chk ^= 1

  for (i = 0; i < 6; ++i) {
    var v = (chk >> ((5 - i) * 5)) & 0x1f
    result += ALPHABET.charAt(v)
  }

  return result
}

function __decode (str, LIMIT) {
  LIMIT = LIMIT || 90
  if (str.length < 8) return str + ' too short'
  if (str.length > LIMIT) return 'Exceeds length limit'

  // don't allow mixed case
  var lowered = str.toLowerCase()
  var uppered = str.toUpperCase()
  if (str !== lowered && str !== uppered) return 'Mixed-case string ' + str
  str = lowered

  var split = str.lastIndexOf('1')
  if (split === -1) return 'No separator character for ' + str
  if (split === 0) return 'Missing prefix for ' + str

  var prefix = str.slice(0, split)
  var wordChars = str.slice(split + 1)
  if (wordChars.length < 6) return 'Data too short'

  var chk = prefixChk(prefix)
  if (typeof chk === 'string') return chk

  var words = []
  for (var i = 0; i < wordChars.length; ++i) {
    var c = wordChars.charAt(i)
    var v = ALPHABET_MAP[c]
    if (v === undefined) return 'Unknown character ' + c
    chk = polymodStep(chk) ^ v

    // not in the checksum?
    if (i + 6 >= wordChars.length) continue
    words.push(v)
  }

  if (chk !== 1) return 'Invalid checksum for ' + str
  return { prefix: prefix, words: words }
}

function decodeUnsafe () {
  var res = __decode.apply(null, arguments)
  if (typeof res === 'object') return res
}

function decode (str) {
  var res = __decode.apply(null, arguments)
  if (typeof res === 'object') return res

  throw new Error(res)
}

function convert (data, inBits, outBits, pad) {
  var value = 0
  var bits = 0
  var maxV = (1 << outBits) - 1

  var result = []
  for (var i = 0; i < data.length; ++i) {
    value = (value << inBits) | data[i]
    bits += inBits

    while (bits >= outBits) {
      bits -= outBits
      result.push((value >> bits) & maxV)
    }
  }

  if (pad) {
    if (bits > 0) {
      result.push((value << (outBits - bits)) & maxV)
    }
  } else {
    if (bits >= inBits) return 'Excess padding'
    if ((value << (outBits - bits)) & maxV) return 'Non-zero padding'
  }

  return result
}

function toWordsUnsafe (bytes) {
  var res = convert(bytes, 8, 5, true)
  if (Array.isArray(res)) return res
}

function toWords (bytes) {
  var res = convert(bytes, 8, 5, true)
  if (Array.isArray(res)) return res

  throw new Error(res)
}

function fromWordsUnsafe (words) {
  var res = convert(words, 5, 8, false)
  if (Array.isArray(res)) return res
}

function fromWords (words) {
  var res = convert(words, 5, 8, false)
  if (Array.isArray(res)) return res

  throw new Error(res)
}

module.exports = {
  decodeUnsafe: decodeUnsafe,
  decode: decode,
  encode: encode,
  toWordsUnsafe: toWordsUnsafe,
  toWords: toWords,
  fromWordsUnsafe: fromWordsUnsafe,
  fromWords: fromWords
}


/***/ }),

/***/ "./node_modules/bn.js/lib/bn.js":
/*!**************************************!*\
  !*** ./node_modules/bn.js/lib/bn.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(module) {(function (module, exports) {
  'use strict';

  // Utils
  function assert (val, msg) {
    if (!val) throw new Error(msg || 'Assertion failed');
  }

  // Could use `inherits` module, but don't want to move from single file
  // architecture yet.
  function inherits (ctor, superCtor) {
    ctor.super_ = superCtor;
    var TempCtor = function () {};
    TempCtor.prototype = superCtor.prototype;
    ctor.prototype = new TempCtor();
    ctor.prototype.constructor = ctor;
  }

  // BN

  function BN (number, base, endian) {
    if (BN.isBN(number)) {
      return number;
    }

    this.negative = 0;
    this.words = null;
    this.length = 0;

    // Reduction context
    this.red = null;

    if (number !== null) {
      if (base === 'le' || base === 'be') {
        endian = base;
        base = 10;
      }

      this._init(number || 0, base || 10, endian || 'be');
    }
  }
  if (typeof module === 'object') {
    module.exports = BN;
  } else {
    exports.BN = BN;
  }

  BN.BN = BN;
  BN.wordSize = 26;

  var Buffer;
  try {
    if (typeof window !== 'undefined' && typeof window.Buffer !== 'undefined') {
      Buffer = window.Buffer;
    } else {
      Buffer = __webpack_require__(/*! buffer */ 0).Buffer;
    }
  } catch (e) {
  }

  BN.isBN = function isBN (num) {
    if (num instanceof BN) {
      return true;
    }

    return num !== null && typeof num === 'object' &&
      num.constructor.wordSize === BN.wordSize && Array.isArray(num.words);
  };

  BN.max = function max (left, right) {
    if (left.cmp(right) > 0) return left;
    return right;
  };

  BN.min = function min (left, right) {
    if (left.cmp(right) < 0) return left;
    return right;
  };

  BN.prototype._init = function init (number, base, endian) {
    if (typeof number === 'number') {
      return this._initNumber(number, base, endian);
    }

    if (typeof number === 'object') {
      return this._initArray(number, base, endian);
    }

    if (base === 'hex') {
      base = 16;
    }
    assert(base === (base | 0) && base >= 2 && base <= 36);

    number = number.toString().replace(/\s+/g, '');
    var start = 0;
    if (number[0] === '-') {
      start++;
      this.negative = 1;
    }

    if (start < number.length) {
      if (base === 16) {
        this._parseHex(number, start, endian);
      } else {
        this._parseBase(number, base, start);
        if (endian === 'le') {
          this._initArray(this.toArray(), base, endian);
        }
      }
    }
  };

  BN.prototype._initNumber = function _initNumber (number, base, endian) {
    if (number < 0) {
      this.negative = 1;
      number = -number;
    }
    if (number < 0x4000000) {
      this.words = [ number & 0x3ffffff ];
      this.length = 1;
    } else if (number < 0x10000000000000) {
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff
      ];
      this.length = 2;
    } else {
      assert(number < 0x20000000000000); // 2 ^ 53 (unsafe)
      this.words = [
        number & 0x3ffffff,
        (number / 0x4000000) & 0x3ffffff,
        1
      ];
      this.length = 3;
    }

    if (endian !== 'le') return;

    // Reverse the bytes
    this._initArray(this.toArray(), base, endian);
  };

  BN.prototype._initArray = function _initArray (number, base, endian) {
    // Perhaps a Uint8Array
    assert(typeof number.length === 'number');
    if (number.length <= 0) {
      this.words = [ 0 ];
      this.length = 1;
      return this;
    }

    this.length = Math.ceil(number.length / 3);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    var j, w;
    var off = 0;
    if (endian === 'be') {
      for (i = number.length - 1, j = 0; i >= 0; i -= 3) {
        w = number[i] | (number[i - 1] << 8) | (number[i - 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    } else if (endian === 'le') {
      for (i = 0, j = 0; i < number.length; i += 3) {
        w = number[i] | (number[i + 1] << 8) | (number[i + 2] << 16);
        this.words[j] |= (w << off) & 0x3ffffff;
        this.words[j + 1] = (w >>> (26 - off)) & 0x3ffffff;
        off += 24;
        if (off >= 26) {
          off -= 26;
          j++;
        }
      }
    }
    return this.strip();
  };

  function parseHex4Bits (string, index) {
    var c = string.charCodeAt(index);
    // 'A' - 'F'
    if (c >= 65 && c <= 70) {
      return c - 55;
    // 'a' - 'f'
    } else if (c >= 97 && c <= 102) {
      return c - 87;
    // '0' - '9'
    } else {
      return (c - 48) & 0xf;
    }
  }

  function parseHexByte (string, lowerBound, index) {
    var r = parseHex4Bits(string, index);
    if (index - 1 >= lowerBound) {
      r |= parseHex4Bits(string, index - 1) << 4;
    }
    return r;
  }

  BN.prototype._parseHex = function _parseHex (number, start, endian) {
    // Create possibly bigger array to ensure that it fits the number
    this.length = Math.ceil((number.length - start) / 6);
    this.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      this.words[i] = 0;
    }

    // 24-bits chunks
    var off = 0;
    var j = 0;

    var w;
    if (endian === 'be') {
      for (i = number.length - 1; i >= start; i -= 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    } else {
      var parseLength = number.length - start;
      for (i = parseLength % 2 === 0 ? start + 1 : start; i < number.length; i += 2) {
        w = parseHexByte(number, start, i) << off;
        this.words[j] |= w & 0x3ffffff;
        if (off >= 18) {
          off -= 18;
          j += 1;
          this.words[j] |= w >>> 26;
        } else {
          off += 8;
        }
      }
    }

    this.strip();
  };

  function parseBase (str, start, end, mul) {
    var r = 0;
    var len = Math.min(str.length, end);
    for (var i = start; i < len; i++) {
      var c = str.charCodeAt(i) - 48;

      r *= mul;

      // 'a'
      if (c >= 49) {
        r += c - 49 + 0xa;

      // 'A'
      } else if (c >= 17) {
        r += c - 17 + 0xa;

      // '0' - '9'
      } else {
        r += c;
      }
    }
    return r;
  }

  BN.prototype._parseBase = function _parseBase (number, base, start) {
    // Initialize as zero
    this.words = [ 0 ];
    this.length = 1;

    // Find length of limb in base
    for (var limbLen = 0, limbPow = 1; limbPow <= 0x3ffffff; limbPow *= base) {
      limbLen++;
    }
    limbLen--;
    limbPow = (limbPow / base) | 0;

    var total = number.length - start;
    var mod = total % limbLen;
    var end = Math.min(total, total - mod) + start;

    var word = 0;
    for (var i = start; i < end; i += limbLen) {
      word = parseBase(number, i, i + limbLen, base);

      this.imuln(limbPow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    if (mod !== 0) {
      var pow = 1;
      word = parseBase(number, i, number.length, base);

      for (i = 0; i < mod; i++) {
        pow *= base;
      }

      this.imuln(pow);
      if (this.words[0] + word < 0x4000000) {
        this.words[0] += word;
      } else {
        this._iaddn(word);
      }
    }

    this.strip();
  };

  BN.prototype.copy = function copy (dest) {
    dest.words = new Array(this.length);
    for (var i = 0; i < this.length; i++) {
      dest.words[i] = this.words[i];
    }
    dest.length = this.length;
    dest.negative = this.negative;
    dest.red = this.red;
  };

  BN.prototype.clone = function clone () {
    var r = new BN(null);
    this.copy(r);
    return r;
  };

  BN.prototype._expand = function _expand (size) {
    while (this.length < size) {
      this.words[this.length++] = 0;
    }
    return this;
  };

  // Remove leading `0` from `this`
  BN.prototype.strip = function strip () {
    while (this.length > 1 && this.words[this.length - 1] === 0) {
      this.length--;
    }
    return this._normSign();
  };

  BN.prototype._normSign = function _normSign () {
    // -0 = 0
    if (this.length === 1 && this.words[0] === 0) {
      this.negative = 0;
    }
    return this;
  };

  BN.prototype.inspect = function inspect () {
    return (this.red ? '<BN-R: ' : '<BN: ') + this.toString(16) + '>';
  };

  /*

  var zeros = [];
  var groupSizes = [];
  var groupBases = [];

  var s = '';
  var i = -1;
  while (++i < BN.wordSize) {
    zeros[i] = s;
    s += '0';
  }
  groupSizes[0] = 0;
  groupSizes[1] = 0;
  groupBases[0] = 0;
  groupBases[1] = 0;
  var base = 2 - 1;
  while (++base < 36 + 1) {
    var groupSize = 0;
    var groupBase = 1;
    while (groupBase < (1 << BN.wordSize) / base) {
      groupBase *= base;
      groupSize += 1;
    }
    groupSizes[base] = groupSize;
    groupBases[base] = groupBase;
  }

  */

  var zeros = [
    '',
    '0',
    '00',
    '000',
    '0000',
    '00000',
    '000000',
    '0000000',
    '00000000',
    '000000000',
    '0000000000',
    '00000000000',
    '000000000000',
    '0000000000000',
    '00000000000000',
    '000000000000000',
    '0000000000000000',
    '00000000000000000',
    '000000000000000000',
    '0000000000000000000',
    '00000000000000000000',
    '000000000000000000000',
    '0000000000000000000000',
    '00000000000000000000000',
    '000000000000000000000000',
    '0000000000000000000000000'
  ];

  var groupSizes = [
    0, 0,
    25, 16, 12, 11, 10, 9, 8,
    8, 7, 7, 7, 7, 6, 6,
    6, 6, 6, 6, 6, 5, 5,
    5, 5, 5, 5, 5, 5, 5,
    5, 5, 5, 5, 5, 5, 5
  ];

  var groupBases = [
    0, 0,
    33554432, 43046721, 16777216, 48828125, 60466176, 40353607, 16777216,
    43046721, 10000000, 19487171, 35831808, 62748517, 7529536, 11390625,
    16777216, 24137569, 34012224, 47045881, 64000000, 4084101, 5153632,
    6436343, 7962624, 9765625, 11881376, 14348907, 17210368, 20511149,
    24300000, 28629151, 33554432, 39135393, 45435424, 52521875, 60466176
  ];

  BN.prototype.toString = function toString (base, padding) {
    base = base || 10;
    padding = padding | 0 || 1;

    var out;
    if (base === 16 || base === 'hex') {
      out = '';
      var off = 0;
      var carry = 0;
      for (var i = 0; i < this.length; i++) {
        var w = this.words[i];
        var word = (((w << off) | carry) & 0xffffff).toString(16);
        carry = (w >>> (24 - off)) & 0xffffff;
        if (carry !== 0 || i !== this.length - 1) {
          out = zeros[6 - word.length] + word + out;
        } else {
          out = word + out;
        }
        off += 2;
        if (off >= 26) {
          off -= 26;
          i--;
        }
      }
      if (carry !== 0) {
        out = carry.toString(16) + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    if (base === (base | 0) && base >= 2 && base <= 36) {
      // var groupSize = Math.floor(BN.wordSize * Math.LN2 / Math.log(base));
      var groupSize = groupSizes[base];
      // var groupBase = Math.pow(base, groupSize);
      var groupBase = groupBases[base];
      out = '';
      var c = this.clone();
      c.negative = 0;
      while (!c.isZero()) {
        var r = c.modn(groupBase).toString(base);
        c = c.idivn(groupBase);

        if (!c.isZero()) {
          out = zeros[groupSize - r.length] + r + out;
        } else {
          out = r + out;
        }
      }
      if (this.isZero()) {
        out = '0' + out;
      }
      while (out.length % padding !== 0) {
        out = '0' + out;
      }
      if (this.negative !== 0) {
        out = '-' + out;
      }
      return out;
    }

    assert(false, 'Base should be between 2 and 36');
  };

  BN.prototype.toNumber = function toNumber () {
    var ret = this.words[0];
    if (this.length === 2) {
      ret += this.words[1] * 0x4000000;
    } else if (this.length === 3 && this.words[2] === 0x01) {
      // NOTE: at this stage it is known that the top bit is set
      ret += 0x10000000000000 + (this.words[1] * 0x4000000);
    } else if (this.length > 2) {
      assert(false, 'Number can only safely store up to 53 bits');
    }
    return (this.negative !== 0) ? -ret : ret;
  };

  BN.prototype.toJSON = function toJSON () {
    return this.toString(16);
  };

  BN.prototype.toBuffer = function toBuffer (endian, length) {
    assert(typeof Buffer !== 'undefined');
    return this.toArrayLike(Buffer, endian, length);
  };

  BN.prototype.toArray = function toArray (endian, length) {
    return this.toArrayLike(Array, endian, length);
  };

  BN.prototype.toArrayLike = function toArrayLike (ArrayType, endian, length) {
    var byteLength = this.byteLength();
    var reqLength = length || Math.max(1, byteLength);
    assert(byteLength <= reqLength, 'byte array longer than desired length');
    assert(reqLength > 0, 'Requested array length <= 0');

    this.strip();
    var littleEndian = endian === 'le';
    var res = new ArrayType(reqLength);

    var b, i;
    var q = this.clone();
    if (!littleEndian) {
      // Assume big-endian
      for (i = 0; i < reqLength - byteLength; i++) {
        res[i] = 0;
      }

      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[reqLength - i - 1] = b;
      }
    } else {
      for (i = 0; !q.isZero(); i++) {
        b = q.andln(0xff);
        q.iushrn(8);

        res[i] = b;
      }

      for (; i < reqLength; i++) {
        res[i] = 0;
      }
    }

    return res;
  };

  if (Math.clz32) {
    BN.prototype._countBits = function _countBits (w) {
      return 32 - Math.clz32(w);
    };
  } else {
    BN.prototype._countBits = function _countBits (w) {
      var t = w;
      var r = 0;
      if (t >= 0x1000) {
        r += 13;
        t >>>= 13;
      }
      if (t >= 0x40) {
        r += 7;
        t >>>= 7;
      }
      if (t >= 0x8) {
        r += 4;
        t >>>= 4;
      }
      if (t >= 0x02) {
        r += 2;
        t >>>= 2;
      }
      return r + t;
    };
  }

  BN.prototype._zeroBits = function _zeroBits (w) {
    // Short-cut
    if (w === 0) return 26;

    var t = w;
    var r = 0;
    if ((t & 0x1fff) === 0) {
      r += 13;
      t >>>= 13;
    }
    if ((t & 0x7f) === 0) {
      r += 7;
      t >>>= 7;
    }
    if ((t & 0xf) === 0) {
      r += 4;
      t >>>= 4;
    }
    if ((t & 0x3) === 0) {
      r += 2;
      t >>>= 2;
    }
    if ((t & 0x1) === 0) {
      r++;
    }
    return r;
  };

  // Return number of used bits in a BN
  BN.prototype.bitLength = function bitLength () {
    var w = this.words[this.length - 1];
    var hi = this._countBits(w);
    return (this.length - 1) * 26 + hi;
  };

  function toBitArray (num) {
    var w = new Array(num.bitLength());

    for (var bit = 0; bit < w.length; bit++) {
      var off = (bit / 26) | 0;
      var wbit = bit % 26;

      w[bit] = (num.words[off] & (1 << wbit)) >>> wbit;
    }

    return w;
  }

  // Number of trailing zero bits
  BN.prototype.zeroBits = function zeroBits () {
    if (this.isZero()) return 0;

    var r = 0;
    for (var i = 0; i < this.length; i++) {
      var b = this._zeroBits(this.words[i]);
      r += b;
      if (b !== 26) break;
    }
    return r;
  };

  BN.prototype.byteLength = function byteLength () {
    return Math.ceil(this.bitLength() / 8);
  };

  BN.prototype.toTwos = function toTwos (width) {
    if (this.negative !== 0) {
      return this.abs().inotn(width).iaddn(1);
    }
    return this.clone();
  };

  BN.prototype.fromTwos = function fromTwos (width) {
    if (this.testn(width - 1)) {
      return this.notn(width).iaddn(1).ineg();
    }
    return this.clone();
  };

  BN.prototype.isNeg = function isNeg () {
    return this.negative !== 0;
  };

  // Return negative clone of `this`
  BN.prototype.neg = function neg () {
    return this.clone().ineg();
  };

  BN.prototype.ineg = function ineg () {
    if (!this.isZero()) {
      this.negative ^= 1;
    }

    return this;
  };

  // Or `num` with `this` in-place
  BN.prototype.iuor = function iuor (num) {
    while (this.length < num.length) {
      this.words[this.length++] = 0;
    }

    for (var i = 0; i < num.length; i++) {
      this.words[i] = this.words[i] | num.words[i];
    }

    return this.strip();
  };

  BN.prototype.ior = function ior (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuor(num);
  };

  // Or `num` with `this`
  BN.prototype.or = function or (num) {
    if (this.length > num.length) return this.clone().ior(num);
    return num.clone().ior(this);
  };

  BN.prototype.uor = function uor (num) {
    if (this.length > num.length) return this.clone().iuor(num);
    return num.clone().iuor(this);
  };

  // And `num` with `this` in-place
  BN.prototype.iuand = function iuand (num) {
    // b = min-length(num, this)
    var b;
    if (this.length > num.length) {
      b = num;
    } else {
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = this.words[i] & num.words[i];
    }

    this.length = b.length;

    return this.strip();
  };

  BN.prototype.iand = function iand (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuand(num);
  };

  // And `num` with `this`
  BN.prototype.and = function and (num) {
    if (this.length > num.length) return this.clone().iand(num);
    return num.clone().iand(this);
  };

  BN.prototype.uand = function uand (num) {
    if (this.length > num.length) return this.clone().iuand(num);
    return num.clone().iuand(this);
  };

  // Xor `num` with `this` in-place
  BN.prototype.iuxor = function iuxor (num) {
    // a.length > b.length
    var a;
    var b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    for (var i = 0; i < b.length; i++) {
      this.words[i] = a.words[i] ^ b.words[i];
    }

    if (this !== a) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = a.length;

    return this.strip();
  };

  BN.prototype.ixor = function ixor (num) {
    assert((this.negative | num.negative) === 0);
    return this.iuxor(num);
  };

  // Xor `num` with `this`
  BN.prototype.xor = function xor (num) {
    if (this.length > num.length) return this.clone().ixor(num);
    return num.clone().ixor(this);
  };

  BN.prototype.uxor = function uxor (num) {
    if (this.length > num.length) return this.clone().iuxor(num);
    return num.clone().iuxor(this);
  };

  // Not ``this`` with ``width`` bitwidth
  BN.prototype.inotn = function inotn (width) {
    assert(typeof width === 'number' && width >= 0);

    var bytesNeeded = Math.ceil(width / 26) | 0;
    var bitsLeft = width % 26;

    // Extend the buffer with leading zeroes
    this._expand(bytesNeeded);

    if (bitsLeft > 0) {
      bytesNeeded--;
    }

    // Handle complete words
    for (var i = 0; i < bytesNeeded; i++) {
      this.words[i] = ~this.words[i] & 0x3ffffff;
    }

    // Handle the residue
    if (bitsLeft > 0) {
      this.words[i] = ~this.words[i] & (0x3ffffff >> (26 - bitsLeft));
    }

    // And remove leading zeroes
    return this.strip();
  };

  BN.prototype.notn = function notn (width) {
    return this.clone().inotn(width);
  };

  // Set `bit` of `this`
  BN.prototype.setn = function setn (bit, val) {
    assert(typeof bit === 'number' && bit >= 0);

    var off = (bit / 26) | 0;
    var wbit = bit % 26;

    this._expand(off + 1);

    if (val) {
      this.words[off] = this.words[off] | (1 << wbit);
    } else {
      this.words[off] = this.words[off] & ~(1 << wbit);
    }

    return this.strip();
  };

  // Add `num` to `this` in-place
  BN.prototype.iadd = function iadd (num) {
    var r;

    // negative + positive
    if (this.negative !== 0 && num.negative === 0) {
      this.negative = 0;
      r = this.isub(num);
      this.negative ^= 1;
      return this._normSign();

    // positive + negative
    } else if (this.negative === 0 && num.negative !== 0) {
      num.negative = 0;
      r = this.isub(num);
      num.negative = 1;
      return r._normSign();
    }

    // a.length > b.length
    var a, b;
    if (this.length > num.length) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) + (b.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      this.words[i] = r & 0x3ffffff;
      carry = r >>> 26;
    }

    this.length = a.length;
    if (carry !== 0) {
      this.words[this.length] = carry;
      this.length++;
    // Copy the rest of the words
    } else if (a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    return this;
  };

  // Add `num` to `this`
  BN.prototype.add = function add (num) {
    var res;
    if (num.negative !== 0 && this.negative === 0) {
      num.negative = 0;
      res = this.sub(num);
      num.negative ^= 1;
      return res;
    } else if (num.negative === 0 && this.negative !== 0) {
      this.negative = 0;
      res = num.sub(this);
      this.negative = 1;
      return res;
    }

    if (this.length > num.length) return this.clone().iadd(num);

    return num.clone().iadd(this);
  };

  // Subtract `num` from `this` in-place
  BN.prototype.isub = function isub (num) {
    // this - (-num) = this + num
    if (num.negative !== 0) {
      num.negative = 0;
      var r = this.iadd(num);
      num.negative = 1;
      return r._normSign();

    // -this - num = -(this + num)
    } else if (this.negative !== 0) {
      this.negative = 0;
      this.iadd(num);
      this.negative = 1;
      return this._normSign();
    }

    // At this point both numbers are positive
    var cmp = this.cmp(num);

    // Optimization - zeroify
    if (cmp === 0) {
      this.negative = 0;
      this.length = 1;
      this.words[0] = 0;
      return this;
    }

    // a > b
    var a, b;
    if (cmp > 0) {
      a = this;
      b = num;
    } else {
      a = num;
      b = this;
    }

    var carry = 0;
    for (var i = 0; i < b.length; i++) {
      r = (a.words[i] | 0) - (b.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }
    for (; carry !== 0 && i < a.length; i++) {
      r = (a.words[i] | 0) + carry;
      carry = r >> 26;
      this.words[i] = r & 0x3ffffff;
    }

    // Copy rest of the words
    if (carry === 0 && i < a.length && a !== this) {
      for (; i < a.length; i++) {
        this.words[i] = a.words[i];
      }
    }

    this.length = Math.max(this.length, i);

    if (a !== this) {
      this.negative = 1;
    }

    return this.strip();
  };

  // Subtract `num` from `this`
  BN.prototype.sub = function sub (num) {
    return this.clone().isub(num);
  };

  function smallMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    var len = (self.length + num.length) | 0;
    out.length = len;
    len = (len - 1) | 0;

    // Peel one iteration (compiler can't do it, because of code complexity)
    var a = self.words[0] | 0;
    var b = num.words[0] | 0;
    var r = a * b;

    var lo = r & 0x3ffffff;
    var carry = (r / 0x4000000) | 0;
    out.words[0] = lo;

    for (var k = 1; k < len; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = carry >>> 26;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = (k - j) | 0;
        a = self.words[i] | 0;
        b = num.words[j] | 0;
        r = a * b + rword;
        ncarry += (r / 0x4000000) | 0;
        rword = r & 0x3ffffff;
      }
      out.words[k] = rword | 0;
      carry = ncarry | 0;
    }
    if (carry !== 0) {
      out.words[k] = carry | 0;
    } else {
      out.length--;
    }

    return out.strip();
  }

  // TODO(indutny): it may be reasonable to omit it for users who don't need
  // to work with 256-bit numbers, otherwise it gives 20% improvement for 256-bit
  // multiplication (like elliptic secp256k1).
  var comb10MulTo = function comb10MulTo (self, num, out) {
    var a = self.words;
    var b = num.words;
    var o = out.words;
    var c = 0;
    var lo;
    var mid;
    var hi;
    var a0 = a[0] | 0;
    var al0 = a0 & 0x1fff;
    var ah0 = a0 >>> 13;
    var a1 = a[1] | 0;
    var al1 = a1 & 0x1fff;
    var ah1 = a1 >>> 13;
    var a2 = a[2] | 0;
    var al2 = a2 & 0x1fff;
    var ah2 = a2 >>> 13;
    var a3 = a[3] | 0;
    var al3 = a3 & 0x1fff;
    var ah3 = a3 >>> 13;
    var a4 = a[4] | 0;
    var al4 = a4 & 0x1fff;
    var ah4 = a4 >>> 13;
    var a5 = a[5] | 0;
    var al5 = a5 & 0x1fff;
    var ah5 = a5 >>> 13;
    var a6 = a[6] | 0;
    var al6 = a6 & 0x1fff;
    var ah6 = a6 >>> 13;
    var a7 = a[7] | 0;
    var al7 = a7 & 0x1fff;
    var ah7 = a7 >>> 13;
    var a8 = a[8] | 0;
    var al8 = a8 & 0x1fff;
    var ah8 = a8 >>> 13;
    var a9 = a[9] | 0;
    var al9 = a9 & 0x1fff;
    var ah9 = a9 >>> 13;
    var b0 = b[0] | 0;
    var bl0 = b0 & 0x1fff;
    var bh0 = b0 >>> 13;
    var b1 = b[1] | 0;
    var bl1 = b1 & 0x1fff;
    var bh1 = b1 >>> 13;
    var b2 = b[2] | 0;
    var bl2 = b2 & 0x1fff;
    var bh2 = b2 >>> 13;
    var b3 = b[3] | 0;
    var bl3 = b3 & 0x1fff;
    var bh3 = b3 >>> 13;
    var b4 = b[4] | 0;
    var bl4 = b4 & 0x1fff;
    var bh4 = b4 >>> 13;
    var b5 = b[5] | 0;
    var bl5 = b5 & 0x1fff;
    var bh5 = b5 >>> 13;
    var b6 = b[6] | 0;
    var bl6 = b6 & 0x1fff;
    var bh6 = b6 >>> 13;
    var b7 = b[7] | 0;
    var bl7 = b7 & 0x1fff;
    var bh7 = b7 >>> 13;
    var b8 = b[8] | 0;
    var bl8 = b8 & 0x1fff;
    var bh8 = b8 >>> 13;
    var b9 = b[9] | 0;
    var bl9 = b9 & 0x1fff;
    var bh9 = b9 >>> 13;

    out.negative = self.negative ^ num.negative;
    out.length = 19;
    /* k = 0 */
    lo = Math.imul(al0, bl0);
    mid = Math.imul(al0, bh0);
    mid = (mid + Math.imul(ah0, bl0)) | 0;
    hi = Math.imul(ah0, bh0);
    var w0 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w0 >>> 26)) | 0;
    w0 &= 0x3ffffff;
    /* k = 1 */
    lo = Math.imul(al1, bl0);
    mid = Math.imul(al1, bh0);
    mid = (mid + Math.imul(ah1, bl0)) | 0;
    hi = Math.imul(ah1, bh0);
    lo = (lo + Math.imul(al0, bl1)) | 0;
    mid = (mid + Math.imul(al0, bh1)) | 0;
    mid = (mid + Math.imul(ah0, bl1)) | 0;
    hi = (hi + Math.imul(ah0, bh1)) | 0;
    var w1 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w1 >>> 26)) | 0;
    w1 &= 0x3ffffff;
    /* k = 2 */
    lo = Math.imul(al2, bl0);
    mid = Math.imul(al2, bh0);
    mid = (mid + Math.imul(ah2, bl0)) | 0;
    hi = Math.imul(ah2, bh0);
    lo = (lo + Math.imul(al1, bl1)) | 0;
    mid = (mid + Math.imul(al1, bh1)) | 0;
    mid = (mid + Math.imul(ah1, bl1)) | 0;
    hi = (hi + Math.imul(ah1, bh1)) | 0;
    lo = (lo + Math.imul(al0, bl2)) | 0;
    mid = (mid + Math.imul(al0, bh2)) | 0;
    mid = (mid + Math.imul(ah0, bl2)) | 0;
    hi = (hi + Math.imul(ah0, bh2)) | 0;
    var w2 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w2 >>> 26)) | 0;
    w2 &= 0x3ffffff;
    /* k = 3 */
    lo = Math.imul(al3, bl0);
    mid = Math.imul(al3, bh0);
    mid = (mid + Math.imul(ah3, bl0)) | 0;
    hi = Math.imul(ah3, bh0);
    lo = (lo + Math.imul(al2, bl1)) | 0;
    mid = (mid + Math.imul(al2, bh1)) | 0;
    mid = (mid + Math.imul(ah2, bl1)) | 0;
    hi = (hi + Math.imul(ah2, bh1)) | 0;
    lo = (lo + Math.imul(al1, bl2)) | 0;
    mid = (mid + Math.imul(al1, bh2)) | 0;
    mid = (mid + Math.imul(ah1, bl2)) | 0;
    hi = (hi + Math.imul(ah1, bh2)) | 0;
    lo = (lo + Math.imul(al0, bl3)) | 0;
    mid = (mid + Math.imul(al0, bh3)) | 0;
    mid = (mid + Math.imul(ah0, bl3)) | 0;
    hi = (hi + Math.imul(ah0, bh3)) | 0;
    var w3 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w3 >>> 26)) | 0;
    w3 &= 0x3ffffff;
    /* k = 4 */
    lo = Math.imul(al4, bl0);
    mid = Math.imul(al4, bh0);
    mid = (mid + Math.imul(ah4, bl0)) | 0;
    hi = Math.imul(ah4, bh0);
    lo = (lo + Math.imul(al3, bl1)) | 0;
    mid = (mid + Math.imul(al3, bh1)) | 0;
    mid = (mid + Math.imul(ah3, bl1)) | 0;
    hi = (hi + Math.imul(ah3, bh1)) | 0;
    lo = (lo + Math.imul(al2, bl2)) | 0;
    mid = (mid + Math.imul(al2, bh2)) | 0;
    mid = (mid + Math.imul(ah2, bl2)) | 0;
    hi = (hi + Math.imul(ah2, bh2)) | 0;
    lo = (lo + Math.imul(al1, bl3)) | 0;
    mid = (mid + Math.imul(al1, bh3)) | 0;
    mid = (mid + Math.imul(ah1, bl3)) | 0;
    hi = (hi + Math.imul(ah1, bh3)) | 0;
    lo = (lo + Math.imul(al0, bl4)) | 0;
    mid = (mid + Math.imul(al0, bh4)) | 0;
    mid = (mid + Math.imul(ah0, bl4)) | 0;
    hi = (hi + Math.imul(ah0, bh4)) | 0;
    var w4 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w4 >>> 26)) | 0;
    w4 &= 0x3ffffff;
    /* k = 5 */
    lo = Math.imul(al5, bl0);
    mid = Math.imul(al5, bh0);
    mid = (mid + Math.imul(ah5, bl0)) | 0;
    hi = Math.imul(ah5, bh0);
    lo = (lo + Math.imul(al4, bl1)) | 0;
    mid = (mid + Math.imul(al4, bh1)) | 0;
    mid = (mid + Math.imul(ah4, bl1)) | 0;
    hi = (hi + Math.imul(ah4, bh1)) | 0;
    lo = (lo + Math.imul(al3, bl2)) | 0;
    mid = (mid + Math.imul(al3, bh2)) | 0;
    mid = (mid + Math.imul(ah3, bl2)) | 0;
    hi = (hi + Math.imul(ah3, bh2)) | 0;
    lo = (lo + Math.imul(al2, bl3)) | 0;
    mid = (mid + Math.imul(al2, bh3)) | 0;
    mid = (mid + Math.imul(ah2, bl3)) | 0;
    hi = (hi + Math.imul(ah2, bh3)) | 0;
    lo = (lo + Math.imul(al1, bl4)) | 0;
    mid = (mid + Math.imul(al1, bh4)) | 0;
    mid = (mid + Math.imul(ah1, bl4)) | 0;
    hi = (hi + Math.imul(ah1, bh4)) | 0;
    lo = (lo + Math.imul(al0, bl5)) | 0;
    mid = (mid + Math.imul(al0, bh5)) | 0;
    mid = (mid + Math.imul(ah0, bl5)) | 0;
    hi = (hi + Math.imul(ah0, bh5)) | 0;
    var w5 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w5 >>> 26)) | 0;
    w5 &= 0x3ffffff;
    /* k = 6 */
    lo = Math.imul(al6, bl0);
    mid = Math.imul(al6, bh0);
    mid = (mid + Math.imul(ah6, bl0)) | 0;
    hi = Math.imul(ah6, bh0);
    lo = (lo + Math.imul(al5, bl1)) | 0;
    mid = (mid + Math.imul(al5, bh1)) | 0;
    mid = (mid + Math.imul(ah5, bl1)) | 0;
    hi = (hi + Math.imul(ah5, bh1)) | 0;
    lo = (lo + Math.imul(al4, bl2)) | 0;
    mid = (mid + Math.imul(al4, bh2)) | 0;
    mid = (mid + Math.imul(ah4, bl2)) | 0;
    hi = (hi + Math.imul(ah4, bh2)) | 0;
    lo = (lo + Math.imul(al3, bl3)) | 0;
    mid = (mid + Math.imul(al3, bh3)) | 0;
    mid = (mid + Math.imul(ah3, bl3)) | 0;
    hi = (hi + Math.imul(ah3, bh3)) | 0;
    lo = (lo + Math.imul(al2, bl4)) | 0;
    mid = (mid + Math.imul(al2, bh4)) | 0;
    mid = (mid + Math.imul(ah2, bl4)) | 0;
    hi = (hi + Math.imul(ah2, bh4)) | 0;
    lo = (lo + Math.imul(al1, bl5)) | 0;
    mid = (mid + Math.imul(al1, bh5)) | 0;
    mid = (mid + Math.imul(ah1, bl5)) | 0;
    hi = (hi + Math.imul(ah1, bh5)) | 0;
    lo = (lo + Math.imul(al0, bl6)) | 0;
    mid = (mid + Math.imul(al0, bh6)) | 0;
    mid = (mid + Math.imul(ah0, bl6)) | 0;
    hi = (hi + Math.imul(ah0, bh6)) | 0;
    var w6 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w6 >>> 26)) | 0;
    w6 &= 0x3ffffff;
    /* k = 7 */
    lo = Math.imul(al7, bl0);
    mid = Math.imul(al7, bh0);
    mid = (mid + Math.imul(ah7, bl0)) | 0;
    hi = Math.imul(ah7, bh0);
    lo = (lo + Math.imul(al6, bl1)) | 0;
    mid = (mid + Math.imul(al6, bh1)) | 0;
    mid = (mid + Math.imul(ah6, bl1)) | 0;
    hi = (hi + Math.imul(ah6, bh1)) | 0;
    lo = (lo + Math.imul(al5, bl2)) | 0;
    mid = (mid + Math.imul(al5, bh2)) | 0;
    mid = (mid + Math.imul(ah5, bl2)) | 0;
    hi = (hi + Math.imul(ah5, bh2)) | 0;
    lo = (lo + Math.imul(al4, bl3)) | 0;
    mid = (mid + Math.imul(al4, bh3)) | 0;
    mid = (mid + Math.imul(ah4, bl3)) | 0;
    hi = (hi + Math.imul(ah4, bh3)) | 0;
    lo = (lo + Math.imul(al3, bl4)) | 0;
    mid = (mid + Math.imul(al3, bh4)) | 0;
    mid = (mid + Math.imul(ah3, bl4)) | 0;
    hi = (hi + Math.imul(ah3, bh4)) | 0;
    lo = (lo + Math.imul(al2, bl5)) | 0;
    mid = (mid + Math.imul(al2, bh5)) | 0;
    mid = (mid + Math.imul(ah2, bl5)) | 0;
    hi = (hi + Math.imul(ah2, bh5)) | 0;
    lo = (lo + Math.imul(al1, bl6)) | 0;
    mid = (mid + Math.imul(al1, bh6)) | 0;
    mid = (mid + Math.imul(ah1, bl6)) | 0;
    hi = (hi + Math.imul(ah1, bh6)) | 0;
    lo = (lo + Math.imul(al0, bl7)) | 0;
    mid = (mid + Math.imul(al0, bh7)) | 0;
    mid = (mid + Math.imul(ah0, bl7)) | 0;
    hi = (hi + Math.imul(ah0, bh7)) | 0;
    var w7 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w7 >>> 26)) | 0;
    w7 &= 0x3ffffff;
    /* k = 8 */
    lo = Math.imul(al8, bl0);
    mid = Math.imul(al8, bh0);
    mid = (mid + Math.imul(ah8, bl0)) | 0;
    hi = Math.imul(ah8, bh0);
    lo = (lo + Math.imul(al7, bl1)) | 0;
    mid = (mid + Math.imul(al7, bh1)) | 0;
    mid = (mid + Math.imul(ah7, bl1)) | 0;
    hi = (hi + Math.imul(ah7, bh1)) | 0;
    lo = (lo + Math.imul(al6, bl2)) | 0;
    mid = (mid + Math.imul(al6, bh2)) | 0;
    mid = (mid + Math.imul(ah6, bl2)) | 0;
    hi = (hi + Math.imul(ah6, bh2)) | 0;
    lo = (lo + Math.imul(al5, bl3)) | 0;
    mid = (mid + Math.imul(al5, bh3)) | 0;
    mid = (mid + Math.imul(ah5, bl3)) | 0;
    hi = (hi + Math.imul(ah5, bh3)) | 0;
    lo = (lo + Math.imul(al4, bl4)) | 0;
    mid = (mid + Math.imul(al4, bh4)) | 0;
    mid = (mid + Math.imul(ah4, bl4)) | 0;
    hi = (hi + Math.imul(ah4, bh4)) | 0;
    lo = (lo + Math.imul(al3, bl5)) | 0;
    mid = (mid + Math.imul(al3, bh5)) | 0;
    mid = (mid + Math.imul(ah3, bl5)) | 0;
    hi = (hi + Math.imul(ah3, bh5)) | 0;
    lo = (lo + Math.imul(al2, bl6)) | 0;
    mid = (mid + Math.imul(al2, bh6)) | 0;
    mid = (mid + Math.imul(ah2, bl6)) | 0;
    hi = (hi + Math.imul(ah2, bh6)) | 0;
    lo = (lo + Math.imul(al1, bl7)) | 0;
    mid = (mid + Math.imul(al1, bh7)) | 0;
    mid = (mid + Math.imul(ah1, bl7)) | 0;
    hi = (hi + Math.imul(ah1, bh7)) | 0;
    lo = (lo + Math.imul(al0, bl8)) | 0;
    mid = (mid + Math.imul(al0, bh8)) | 0;
    mid = (mid + Math.imul(ah0, bl8)) | 0;
    hi = (hi + Math.imul(ah0, bh8)) | 0;
    var w8 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w8 >>> 26)) | 0;
    w8 &= 0x3ffffff;
    /* k = 9 */
    lo = Math.imul(al9, bl0);
    mid = Math.imul(al9, bh0);
    mid = (mid + Math.imul(ah9, bl0)) | 0;
    hi = Math.imul(ah9, bh0);
    lo = (lo + Math.imul(al8, bl1)) | 0;
    mid = (mid + Math.imul(al8, bh1)) | 0;
    mid = (mid + Math.imul(ah8, bl1)) | 0;
    hi = (hi + Math.imul(ah8, bh1)) | 0;
    lo = (lo + Math.imul(al7, bl2)) | 0;
    mid = (mid + Math.imul(al7, bh2)) | 0;
    mid = (mid + Math.imul(ah7, bl2)) | 0;
    hi = (hi + Math.imul(ah7, bh2)) | 0;
    lo = (lo + Math.imul(al6, bl3)) | 0;
    mid = (mid + Math.imul(al6, bh3)) | 0;
    mid = (mid + Math.imul(ah6, bl3)) | 0;
    hi = (hi + Math.imul(ah6, bh3)) | 0;
    lo = (lo + Math.imul(al5, bl4)) | 0;
    mid = (mid + Math.imul(al5, bh4)) | 0;
    mid = (mid + Math.imul(ah5, bl4)) | 0;
    hi = (hi + Math.imul(ah5, bh4)) | 0;
    lo = (lo + Math.imul(al4, bl5)) | 0;
    mid = (mid + Math.imul(al4, bh5)) | 0;
    mid = (mid + Math.imul(ah4, bl5)) | 0;
    hi = (hi + Math.imul(ah4, bh5)) | 0;
    lo = (lo + Math.imul(al3, bl6)) | 0;
    mid = (mid + Math.imul(al3, bh6)) | 0;
    mid = (mid + Math.imul(ah3, bl6)) | 0;
    hi = (hi + Math.imul(ah3, bh6)) | 0;
    lo = (lo + Math.imul(al2, bl7)) | 0;
    mid = (mid + Math.imul(al2, bh7)) | 0;
    mid = (mid + Math.imul(ah2, bl7)) | 0;
    hi = (hi + Math.imul(ah2, bh7)) | 0;
    lo = (lo + Math.imul(al1, bl8)) | 0;
    mid = (mid + Math.imul(al1, bh8)) | 0;
    mid = (mid + Math.imul(ah1, bl8)) | 0;
    hi = (hi + Math.imul(ah1, bh8)) | 0;
    lo = (lo + Math.imul(al0, bl9)) | 0;
    mid = (mid + Math.imul(al0, bh9)) | 0;
    mid = (mid + Math.imul(ah0, bl9)) | 0;
    hi = (hi + Math.imul(ah0, bh9)) | 0;
    var w9 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w9 >>> 26)) | 0;
    w9 &= 0x3ffffff;
    /* k = 10 */
    lo = Math.imul(al9, bl1);
    mid = Math.imul(al9, bh1);
    mid = (mid + Math.imul(ah9, bl1)) | 0;
    hi = Math.imul(ah9, bh1);
    lo = (lo + Math.imul(al8, bl2)) | 0;
    mid = (mid + Math.imul(al8, bh2)) | 0;
    mid = (mid + Math.imul(ah8, bl2)) | 0;
    hi = (hi + Math.imul(ah8, bh2)) | 0;
    lo = (lo + Math.imul(al7, bl3)) | 0;
    mid = (mid + Math.imul(al7, bh3)) | 0;
    mid = (mid + Math.imul(ah7, bl3)) | 0;
    hi = (hi + Math.imul(ah7, bh3)) | 0;
    lo = (lo + Math.imul(al6, bl4)) | 0;
    mid = (mid + Math.imul(al6, bh4)) | 0;
    mid = (mid + Math.imul(ah6, bl4)) | 0;
    hi = (hi + Math.imul(ah6, bh4)) | 0;
    lo = (lo + Math.imul(al5, bl5)) | 0;
    mid = (mid + Math.imul(al5, bh5)) | 0;
    mid = (mid + Math.imul(ah5, bl5)) | 0;
    hi = (hi + Math.imul(ah5, bh5)) | 0;
    lo = (lo + Math.imul(al4, bl6)) | 0;
    mid = (mid + Math.imul(al4, bh6)) | 0;
    mid = (mid + Math.imul(ah4, bl6)) | 0;
    hi = (hi + Math.imul(ah4, bh6)) | 0;
    lo = (lo + Math.imul(al3, bl7)) | 0;
    mid = (mid + Math.imul(al3, bh7)) | 0;
    mid = (mid + Math.imul(ah3, bl7)) | 0;
    hi = (hi + Math.imul(ah3, bh7)) | 0;
    lo = (lo + Math.imul(al2, bl8)) | 0;
    mid = (mid + Math.imul(al2, bh8)) | 0;
    mid = (mid + Math.imul(ah2, bl8)) | 0;
    hi = (hi + Math.imul(ah2, bh8)) | 0;
    lo = (lo + Math.imul(al1, bl9)) | 0;
    mid = (mid + Math.imul(al1, bh9)) | 0;
    mid = (mid + Math.imul(ah1, bl9)) | 0;
    hi = (hi + Math.imul(ah1, bh9)) | 0;
    var w10 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w10 >>> 26)) | 0;
    w10 &= 0x3ffffff;
    /* k = 11 */
    lo = Math.imul(al9, bl2);
    mid = Math.imul(al9, bh2);
    mid = (mid + Math.imul(ah9, bl2)) | 0;
    hi = Math.imul(ah9, bh2);
    lo = (lo + Math.imul(al8, bl3)) | 0;
    mid = (mid + Math.imul(al8, bh3)) | 0;
    mid = (mid + Math.imul(ah8, bl3)) | 0;
    hi = (hi + Math.imul(ah8, bh3)) | 0;
    lo = (lo + Math.imul(al7, bl4)) | 0;
    mid = (mid + Math.imul(al7, bh4)) | 0;
    mid = (mid + Math.imul(ah7, bl4)) | 0;
    hi = (hi + Math.imul(ah7, bh4)) | 0;
    lo = (lo + Math.imul(al6, bl5)) | 0;
    mid = (mid + Math.imul(al6, bh5)) | 0;
    mid = (mid + Math.imul(ah6, bl5)) | 0;
    hi = (hi + Math.imul(ah6, bh5)) | 0;
    lo = (lo + Math.imul(al5, bl6)) | 0;
    mid = (mid + Math.imul(al5, bh6)) | 0;
    mid = (mid + Math.imul(ah5, bl6)) | 0;
    hi = (hi + Math.imul(ah5, bh6)) | 0;
    lo = (lo + Math.imul(al4, bl7)) | 0;
    mid = (mid + Math.imul(al4, bh7)) | 0;
    mid = (mid + Math.imul(ah4, bl7)) | 0;
    hi = (hi + Math.imul(ah4, bh7)) | 0;
    lo = (lo + Math.imul(al3, bl8)) | 0;
    mid = (mid + Math.imul(al3, bh8)) | 0;
    mid = (mid + Math.imul(ah3, bl8)) | 0;
    hi = (hi + Math.imul(ah3, bh8)) | 0;
    lo = (lo + Math.imul(al2, bl9)) | 0;
    mid = (mid + Math.imul(al2, bh9)) | 0;
    mid = (mid + Math.imul(ah2, bl9)) | 0;
    hi = (hi + Math.imul(ah2, bh9)) | 0;
    var w11 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w11 >>> 26)) | 0;
    w11 &= 0x3ffffff;
    /* k = 12 */
    lo = Math.imul(al9, bl3);
    mid = Math.imul(al9, bh3);
    mid = (mid + Math.imul(ah9, bl3)) | 0;
    hi = Math.imul(ah9, bh3);
    lo = (lo + Math.imul(al8, bl4)) | 0;
    mid = (mid + Math.imul(al8, bh4)) | 0;
    mid = (mid + Math.imul(ah8, bl4)) | 0;
    hi = (hi + Math.imul(ah8, bh4)) | 0;
    lo = (lo + Math.imul(al7, bl5)) | 0;
    mid = (mid + Math.imul(al7, bh5)) | 0;
    mid = (mid + Math.imul(ah7, bl5)) | 0;
    hi = (hi + Math.imul(ah7, bh5)) | 0;
    lo = (lo + Math.imul(al6, bl6)) | 0;
    mid = (mid + Math.imul(al6, bh6)) | 0;
    mid = (mid + Math.imul(ah6, bl6)) | 0;
    hi = (hi + Math.imul(ah6, bh6)) | 0;
    lo = (lo + Math.imul(al5, bl7)) | 0;
    mid = (mid + Math.imul(al5, bh7)) | 0;
    mid = (mid + Math.imul(ah5, bl7)) | 0;
    hi = (hi + Math.imul(ah5, bh7)) | 0;
    lo = (lo + Math.imul(al4, bl8)) | 0;
    mid = (mid + Math.imul(al4, bh8)) | 0;
    mid = (mid + Math.imul(ah4, bl8)) | 0;
    hi = (hi + Math.imul(ah4, bh8)) | 0;
    lo = (lo + Math.imul(al3, bl9)) | 0;
    mid = (mid + Math.imul(al3, bh9)) | 0;
    mid = (mid + Math.imul(ah3, bl9)) | 0;
    hi = (hi + Math.imul(ah3, bh9)) | 0;
    var w12 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w12 >>> 26)) | 0;
    w12 &= 0x3ffffff;
    /* k = 13 */
    lo = Math.imul(al9, bl4);
    mid = Math.imul(al9, bh4);
    mid = (mid + Math.imul(ah9, bl4)) | 0;
    hi = Math.imul(ah9, bh4);
    lo = (lo + Math.imul(al8, bl5)) | 0;
    mid = (mid + Math.imul(al8, bh5)) | 0;
    mid = (mid + Math.imul(ah8, bl5)) | 0;
    hi = (hi + Math.imul(ah8, bh5)) | 0;
    lo = (lo + Math.imul(al7, bl6)) | 0;
    mid = (mid + Math.imul(al7, bh6)) | 0;
    mid = (mid + Math.imul(ah7, bl6)) | 0;
    hi = (hi + Math.imul(ah7, bh6)) | 0;
    lo = (lo + Math.imul(al6, bl7)) | 0;
    mid = (mid + Math.imul(al6, bh7)) | 0;
    mid = (mid + Math.imul(ah6, bl7)) | 0;
    hi = (hi + Math.imul(ah6, bh7)) | 0;
    lo = (lo + Math.imul(al5, bl8)) | 0;
    mid = (mid + Math.imul(al5, bh8)) | 0;
    mid = (mid + Math.imul(ah5, bl8)) | 0;
    hi = (hi + Math.imul(ah5, bh8)) | 0;
    lo = (lo + Math.imul(al4, bl9)) | 0;
    mid = (mid + Math.imul(al4, bh9)) | 0;
    mid = (mid + Math.imul(ah4, bl9)) | 0;
    hi = (hi + Math.imul(ah4, bh9)) | 0;
    var w13 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w13 >>> 26)) | 0;
    w13 &= 0x3ffffff;
    /* k = 14 */
    lo = Math.imul(al9, bl5);
    mid = Math.imul(al9, bh5);
    mid = (mid + Math.imul(ah9, bl5)) | 0;
    hi = Math.imul(ah9, bh5);
    lo = (lo + Math.imul(al8, bl6)) | 0;
    mid = (mid + Math.imul(al8, bh6)) | 0;
    mid = (mid + Math.imul(ah8, bl6)) | 0;
    hi = (hi + Math.imul(ah8, bh6)) | 0;
    lo = (lo + Math.imul(al7, bl7)) | 0;
    mid = (mid + Math.imul(al7, bh7)) | 0;
    mid = (mid + Math.imul(ah7, bl7)) | 0;
    hi = (hi + Math.imul(ah7, bh7)) | 0;
    lo = (lo + Math.imul(al6, bl8)) | 0;
    mid = (mid + Math.imul(al6, bh8)) | 0;
    mid = (mid + Math.imul(ah6, bl8)) | 0;
    hi = (hi + Math.imul(ah6, bh8)) | 0;
    lo = (lo + Math.imul(al5, bl9)) | 0;
    mid = (mid + Math.imul(al5, bh9)) | 0;
    mid = (mid + Math.imul(ah5, bl9)) | 0;
    hi = (hi + Math.imul(ah5, bh9)) | 0;
    var w14 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w14 >>> 26)) | 0;
    w14 &= 0x3ffffff;
    /* k = 15 */
    lo = Math.imul(al9, bl6);
    mid = Math.imul(al9, bh6);
    mid = (mid + Math.imul(ah9, bl6)) | 0;
    hi = Math.imul(ah9, bh6);
    lo = (lo + Math.imul(al8, bl7)) | 0;
    mid = (mid + Math.imul(al8, bh7)) | 0;
    mid = (mid + Math.imul(ah8, bl7)) | 0;
    hi = (hi + Math.imul(ah8, bh7)) | 0;
    lo = (lo + Math.imul(al7, bl8)) | 0;
    mid = (mid + Math.imul(al7, bh8)) | 0;
    mid = (mid + Math.imul(ah7, bl8)) | 0;
    hi = (hi + Math.imul(ah7, bh8)) | 0;
    lo = (lo + Math.imul(al6, bl9)) | 0;
    mid = (mid + Math.imul(al6, bh9)) | 0;
    mid = (mid + Math.imul(ah6, bl9)) | 0;
    hi = (hi + Math.imul(ah6, bh9)) | 0;
    var w15 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w15 >>> 26)) | 0;
    w15 &= 0x3ffffff;
    /* k = 16 */
    lo = Math.imul(al9, bl7);
    mid = Math.imul(al9, bh7);
    mid = (mid + Math.imul(ah9, bl7)) | 0;
    hi = Math.imul(ah9, bh7);
    lo = (lo + Math.imul(al8, bl8)) | 0;
    mid = (mid + Math.imul(al8, bh8)) | 0;
    mid = (mid + Math.imul(ah8, bl8)) | 0;
    hi = (hi + Math.imul(ah8, bh8)) | 0;
    lo = (lo + Math.imul(al7, bl9)) | 0;
    mid = (mid + Math.imul(al7, bh9)) | 0;
    mid = (mid + Math.imul(ah7, bl9)) | 0;
    hi = (hi + Math.imul(ah7, bh9)) | 0;
    var w16 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w16 >>> 26)) | 0;
    w16 &= 0x3ffffff;
    /* k = 17 */
    lo = Math.imul(al9, bl8);
    mid = Math.imul(al9, bh8);
    mid = (mid + Math.imul(ah9, bl8)) | 0;
    hi = Math.imul(ah9, bh8);
    lo = (lo + Math.imul(al8, bl9)) | 0;
    mid = (mid + Math.imul(al8, bh9)) | 0;
    mid = (mid + Math.imul(ah8, bl9)) | 0;
    hi = (hi + Math.imul(ah8, bh9)) | 0;
    var w17 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w17 >>> 26)) | 0;
    w17 &= 0x3ffffff;
    /* k = 18 */
    lo = Math.imul(al9, bl9);
    mid = Math.imul(al9, bh9);
    mid = (mid + Math.imul(ah9, bl9)) | 0;
    hi = Math.imul(ah9, bh9);
    var w18 = (((c + lo) | 0) + ((mid & 0x1fff) << 13)) | 0;
    c = (((hi + (mid >>> 13)) | 0) + (w18 >>> 26)) | 0;
    w18 &= 0x3ffffff;
    o[0] = w0;
    o[1] = w1;
    o[2] = w2;
    o[3] = w3;
    o[4] = w4;
    o[5] = w5;
    o[6] = w6;
    o[7] = w7;
    o[8] = w8;
    o[9] = w9;
    o[10] = w10;
    o[11] = w11;
    o[12] = w12;
    o[13] = w13;
    o[14] = w14;
    o[15] = w15;
    o[16] = w16;
    o[17] = w17;
    o[18] = w18;
    if (c !== 0) {
      o[19] = c;
      out.length++;
    }
    return out;
  };

  // Polyfill comb
  if (!Math.imul) {
    comb10MulTo = smallMulTo;
  }

  function bigMulTo (self, num, out) {
    out.negative = num.negative ^ self.negative;
    out.length = self.length + num.length;

    var carry = 0;
    var hncarry = 0;
    for (var k = 0; k < out.length - 1; k++) {
      // Sum all words with the same `i + j = k` and accumulate `ncarry`,
      // note that ncarry could be >= 0x3ffffff
      var ncarry = hncarry;
      hncarry = 0;
      var rword = carry & 0x3ffffff;
      var maxJ = Math.min(k, num.length - 1);
      for (var j = Math.max(0, k - self.length + 1); j <= maxJ; j++) {
        var i = k - j;
        var a = self.words[i] | 0;
        var b = num.words[j] | 0;
        var r = a * b;

        var lo = r & 0x3ffffff;
        ncarry = (ncarry + ((r / 0x4000000) | 0)) | 0;
        lo = (lo + rword) | 0;
        rword = lo & 0x3ffffff;
        ncarry = (ncarry + (lo >>> 26)) | 0;

        hncarry += ncarry >>> 26;
        ncarry &= 0x3ffffff;
      }
      out.words[k] = rword;
      carry = ncarry;
      ncarry = hncarry;
    }
    if (carry !== 0) {
      out.words[k] = carry;
    } else {
      out.length--;
    }

    return out.strip();
  }

  function jumboMulTo (self, num, out) {
    var fftm = new FFTM();
    return fftm.mulp(self, num, out);
  }

  BN.prototype.mulTo = function mulTo (num, out) {
    var res;
    var len = this.length + num.length;
    if (this.length === 10 && num.length === 10) {
      res = comb10MulTo(this, num, out);
    } else if (len < 63) {
      res = smallMulTo(this, num, out);
    } else if (len < 1024) {
      res = bigMulTo(this, num, out);
    } else {
      res = jumboMulTo(this, num, out);
    }

    return res;
  };

  // Cooley-Tukey algorithm for FFT
  // slightly revisited to rely on looping instead of recursion

  function FFTM (x, y) {
    this.x = x;
    this.y = y;
  }

  FFTM.prototype.makeRBT = function makeRBT (N) {
    var t = new Array(N);
    var l = BN.prototype._countBits(N) - 1;
    for (var i = 0; i < N; i++) {
      t[i] = this.revBin(i, l, N);
    }

    return t;
  };

  // Returns binary-reversed representation of `x`
  FFTM.prototype.revBin = function revBin (x, l, N) {
    if (x === 0 || x === N - 1) return x;

    var rb = 0;
    for (var i = 0; i < l; i++) {
      rb |= (x & 1) << (l - i - 1);
      x >>= 1;
    }

    return rb;
  };

  // Performs "tweedling" phase, therefore 'emulating'
  // behaviour of the recursive algorithm
  FFTM.prototype.permute = function permute (rbt, rws, iws, rtws, itws, N) {
    for (var i = 0; i < N; i++) {
      rtws[i] = rws[rbt[i]];
      itws[i] = iws[rbt[i]];
    }
  };

  FFTM.prototype.transform = function transform (rws, iws, rtws, itws, N, rbt) {
    this.permute(rbt, rws, iws, rtws, itws, N);

    for (var s = 1; s < N; s <<= 1) {
      var l = s << 1;

      var rtwdf = Math.cos(2 * Math.PI / l);
      var itwdf = Math.sin(2 * Math.PI / l);

      for (var p = 0; p < N; p += l) {
        var rtwdf_ = rtwdf;
        var itwdf_ = itwdf;

        for (var j = 0; j < s; j++) {
          var re = rtws[p + j];
          var ie = itws[p + j];

          var ro = rtws[p + j + s];
          var io = itws[p + j + s];

          var rx = rtwdf_ * ro - itwdf_ * io;

          io = rtwdf_ * io + itwdf_ * ro;
          ro = rx;

          rtws[p + j] = re + ro;
          itws[p + j] = ie + io;

          rtws[p + j + s] = re - ro;
          itws[p + j + s] = ie - io;

          /* jshint maxdepth : false */
          if (j !== l) {
            rx = rtwdf * rtwdf_ - itwdf * itwdf_;

            itwdf_ = rtwdf * itwdf_ + itwdf * rtwdf_;
            rtwdf_ = rx;
          }
        }
      }
    }
  };

  FFTM.prototype.guessLen13b = function guessLen13b (n, m) {
    var N = Math.max(m, n) | 1;
    var odd = N & 1;
    var i = 0;
    for (N = N / 2 | 0; N; N = N >>> 1) {
      i++;
    }

    return 1 << i + 1 + odd;
  };

  FFTM.prototype.conjugate = function conjugate (rws, iws, N) {
    if (N <= 1) return;

    for (var i = 0; i < N / 2; i++) {
      var t = rws[i];

      rws[i] = rws[N - i - 1];
      rws[N - i - 1] = t;

      t = iws[i];

      iws[i] = -iws[N - i - 1];
      iws[N - i - 1] = -t;
    }
  };

  FFTM.prototype.normalize13b = function normalize13b (ws, N) {
    var carry = 0;
    for (var i = 0; i < N / 2; i++) {
      var w = Math.round(ws[2 * i + 1] / N) * 0x2000 +
        Math.round(ws[2 * i] / N) +
        carry;

      ws[i] = w & 0x3ffffff;

      if (w < 0x4000000) {
        carry = 0;
      } else {
        carry = w / 0x4000000 | 0;
      }
    }

    return ws;
  };

  FFTM.prototype.convert13b = function convert13b (ws, len, rws, N) {
    var carry = 0;
    for (var i = 0; i < len; i++) {
      carry = carry + (ws[i] | 0);

      rws[2 * i] = carry & 0x1fff; carry = carry >>> 13;
      rws[2 * i + 1] = carry & 0x1fff; carry = carry >>> 13;
    }

    // Pad with zeroes
    for (i = 2 * len; i < N; ++i) {
      rws[i] = 0;
    }

    assert(carry === 0);
    assert((carry & ~0x1fff) === 0);
  };

  FFTM.prototype.stub = function stub (N) {
    var ph = new Array(N);
    for (var i = 0; i < N; i++) {
      ph[i] = 0;
    }

    return ph;
  };

  FFTM.prototype.mulp = function mulp (x, y, out) {
    var N = 2 * this.guessLen13b(x.length, y.length);

    var rbt = this.makeRBT(N);

    var _ = this.stub(N);

    var rws = new Array(N);
    var rwst = new Array(N);
    var iwst = new Array(N);

    var nrws = new Array(N);
    var nrwst = new Array(N);
    var niwst = new Array(N);

    var rmws = out.words;
    rmws.length = N;

    this.convert13b(x.words, x.length, rws, N);
    this.convert13b(y.words, y.length, nrws, N);

    this.transform(rws, _, rwst, iwst, N, rbt);
    this.transform(nrws, _, nrwst, niwst, N, rbt);

    for (var i = 0; i < N; i++) {
      var rx = rwst[i] * nrwst[i] - iwst[i] * niwst[i];
      iwst[i] = rwst[i] * niwst[i] + iwst[i] * nrwst[i];
      rwst[i] = rx;
    }

    this.conjugate(rwst, iwst, N);
    this.transform(rwst, iwst, rmws, _, N, rbt);
    this.conjugate(rmws, _, N);
    this.normalize13b(rmws, N);

    out.negative = x.negative ^ y.negative;
    out.length = x.length + y.length;
    return out.strip();
  };

  // Multiply `this` by `num`
  BN.prototype.mul = function mul (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return this.mulTo(num, out);
  };

  // Multiply employing FFT
  BN.prototype.mulf = function mulf (num) {
    var out = new BN(null);
    out.words = new Array(this.length + num.length);
    return jumboMulTo(this, num, out);
  };

  // In-place Multiplication
  BN.prototype.imul = function imul (num) {
    return this.clone().mulTo(num, this);
  };

  BN.prototype.imuln = function imuln (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);

    // Carry
    var carry = 0;
    for (var i = 0; i < this.length; i++) {
      var w = (this.words[i] | 0) * num;
      var lo = (w & 0x3ffffff) + (carry & 0x3ffffff);
      carry >>= 26;
      carry += (w / 0x4000000) | 0;
      // NOTE: lo is 27bit maximum
      carry += lo >>> 26;
      this.words[i] = lo & 0x3ffffff;
    }

    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }

    return this;
  };

  BN.prototype.muln = function muln (num) {
    return this.clone().imuln(num);
  };

  // `this` * `this`
  BN.prototype.sqr = function sqr () {
    return this.mul(this);
  };

  // `this` * `this` in-place
  BN.prototype.isqr = function isqr () {
    return this.imul(this.clone());
  };

  // Math.pow(`this`, `num`)
  BN.prototype.pow = function pow (num) {
    var w = toBitArray(num);
    if (w.length === 0) return new BN(1);

    // Skip leading zeroes
    var res = this;
    for (var i = 0; i < w.length; i++, res = res.sqr()) {
      if (w[i] !== 0) break;
    }

    if (++i < w.length) {
      for (var q = res.sqr(); i < w.length; i++, q = q.sqr()) {
        if (w[i] === 0) continue;

        res = res.mul(q);
      }
    }

    return res;
  };

  // Shift-left in-place
  BN.prototype.iushln = function iushln (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;
    var carryMask = (0x3ffffff >>> (26 - r)) << (26 - r);
    var i;

    if (r !== 0) {
      var carry = 0;

      for (i = 0; i < this.length; i++) {
        var newCarry = this.words[i] & carryMask;
        var c = ((this.words[i] | 0) - newCarry) << r;
        this.words[i] = c | carry;
        carry = newCarry >>> (26 - r);
      }

      if (carry) {
        this.words[i] = carry;
        this.length++;
      }
    }

    if (s !== 0) {
      for (i = this.length - 1; i >= 0; i--) {
        this.words[i + s] = this.words[i];
      }

      for (i = 0; i < s; i++) {
        this.words[i] = 0;
      }

      this.length += s;
    }

    return this.strip();
  };

  BN.prototype.ishln = function ishln (bits) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushln(bits);
  };

  // Shift-right in-place
  // NOTE: `hint` is a lowest bit before trailing zeroes
  // NOTE: if `extended` is present - it will be filled with destroyed bits
  BN.prototype.iushrn = function iushrn (bits, hint, extended) {
    assert(typeof bits === 'number' && bits >= 0);
    var h;
    if (hint) {
      h = (hint - (hint % 26)) / 26;
    } else {
      h = 0;
    }

    var r = bits % 26;
    var s = Math.min((bits - r) / 26, this.length);
    var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
    var maskedWords = extended;

    h -= s;
    h = Math.max(0, h);

    // Extended mode, copy masked part
    if (maskedWords) {
      for (var i = 0; i < s; i++) {
        maskedWords.words[i] = this.words[i];
      }
      maskedWords.length = s;
    }

    if (s === 0) {
      // No-op, we should not move anything at all
    } else if (this.length > s) {
      this.length -= s;
      for (i = 0; i < this.length; i++) {
        this.words[i] = this.words[i + s];
      }
    } else {
      this.words[0] = 0;
      this.length = 1;
    }

    var carry = 0;
    for (i = this.length - 1; i >= 0 && (carry !== 0 || i >= h); i--) {
      var word = this.words[i] | 0;
      this.words[i] = (carry << (26 - r)) | (word >>> r);
      carry = word & mask;
    }

    // Push carried bits as a mask
    if (maskedWords && carry !== 0) {
      maskedWords.words[maskedWords.length++] = carry;
    }

    if (this.length === 0) {
      this.words[0] = 0;
      this.length = 1;
    }

    return this.strip();
  };

  BN.prototype.ishrn = function ishrn (bits, hint, extended) {
    // TODO(indutny): implement me
    assert(this.negative === 0);
    return this.iushrn(bits, hint, extended);
  };

  // Shift-left
  BN.prototype.shln = function shln (bits) {
    return this.clone().ishln(bits);
  };

  BN.prototype.ushln = function ushln (bits) {
    return this.clone().iushln(bits);
  };

  // Shift-right
  BN.prototype.shrn = function shrn (bits) {
    return this.clone().ishrn(bits);
  };

  BN.prototype.ushrn = function ushrn (bits) {
    return this.clone().iushrn(bits);
  };

  // Test if n bit is set
  BN.prototype.testn = function testn (bit) {
    assert(typeof bit === 'number' && bit >= 0);
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) return false;

    // Check bit and return
    var w = this.words[s];

    return !!(w & q);
  };

  // Return only lowers bits of number (in-place)
  BN.prototype.imaskn = function imaskn (bits) {
    assert(typeof bits === 'number' && bits >= 0);
    var r = bits % 26;
    var s = (bits - r) / 26;

    assert(this.negative === 0, 'imaskn works only with positive numbers');

    if (this.length <= s) {
      return this;
    }

    if (r !== 0) {
      s++;
    }
    this.length = Math.min(s, this.length);

    if (r !== 0) {
      var mask = 0x3ffffff ^ ((0x3ffffff >>> r) << r);
      this.words[this.length - 1] &= mask;
    }

    return this.strip();
  };

  // Return only lowers bits of number
  BN.prototype.maskn = function maskn (bits) {
    return this.clone().imaskn(bits);
  };

  // Add plain number `num` to `this`
  BN.prototype.iaddn = function iaddn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.isubn(-num);

    // Possible sign change
    if (this.negative !== 0) {
      if (this.length === 1 && (this.words[0] | 0) < num) {
        this.words[0] = num - (this.words[0] | 0);
        this.negative = 0;
        return this;
      }

      this.negative = 0;
      this.isubn(num);
      this.negative = 1;
      return this;
    }

    // Add without checks
    return this._iaddn(num);
  };

  BN.prototype._iaddn = function _iaddn (num) {
    this.words[0] += num;

    // Carry
    for (var i = 0; i < this.length && this.words[i] >= 0x4000000; i++) {
      this.words[i] -= 0x4000000;
      if (i === this.length - 1) {
        this.words[i + 1] = 1;
      } else {
        this.words[i + 1]++;
      }
    }
    this.length = Math.max(this.length, i + 1);

    return this;
  };

  // Subtract plain number `num` from `this`
  BN.prototype.isubn = function isubn (num) {
    assert(typeof num === 'number');
    assert(num < 0x4000000);
    if (num < 0) return this.iaddn(-num);

    if (this.negative !== 0) {
      this.negative = 0;
      this.iaddn(num);
      this.negative = 1;
      return this;
    }

    this.words[0] -= num;

    if (this.length === 1 && this.words[0] < 0) {
      this.words[0] = -this.words[0];
      this.negative = 1;
    } else {
      // Carry
      for (var i = 0; i < this.length && this.words[i] < 0; i++) {
        this.words[i] += 0x4000000;
        this.words[i + 1] -= 1;
      }
    }

    return this.strip();
  };

  BN.prototype.addn = function addn (num) {
    return this.clone().iaddn(num);
  };

  BN.prototype.subn = function subn (num) {
    return this.clone().isubn(num);
  };

  BN.prototype.iabs = function iabs () {
    this.negative = 0;

    return this;
  };

  BN.prototype.abs = function abs () {
    return this.clone().iabs();
  };

  BN.prototype._ishlnsubmul = function _ishlnsubmul (num, mul, shift) {
    var len = num.length + shift;
    var i;

    this._expand(len);

    var w;
    var carry = 0;
    for (i = 0; i < num.length; i++) {
      w = (this.words[i + shift] | 0) + carry;
      var right = (num.words[i] | 0) * mul;
      w -= right & 0x3ffffff;
      carry = (w >> 26) - ((right / 0x4000000) | 0);
      this.words[i + shift] = w & 0x3ffffff;
    }
    for (; i < this.length - shift; i++) {
      w = (this.words[i + shift] | 0) + carry;
      carry = w >> 26;
      this.words[i + shift] = w & 0x3ffffff;
    }

    if (carry === 0) return this.strip();

    // Subtraction overflow
    assert(carry === -1);
    carry = 0;
    for (i = 0; i < this.length; i++) {
      w = -(this.words[i] | 0) + carry;
      carry = w >> 26;
      this.words[i] = w & 0x3ffffff;
    }
    this.negative = 1;

    return this.strip();
  };

  BN.prototype._wordDiv = function _wordDiv (num, mode) {
    var shift = this.length - num.length;

    var a = this.clone();
    var b = num;

    // Normalize
    var bhi = b.words[b.length - 1] | 0;
    var bhiBits = this._countBits(bhi);
    shift = 26 - bhiBits;
    if (shift !== 0) {
      b = b.ushln(shift);
      a.iushln(shift);
      bhi = b.words[b.length - 1] | 0;
    }

    // Initialize quotient
    var m = a.length - b.length;
    var q;

    if (mode !== 'mod') {
      q = new BN(null);
      q.length = m + 1;
      q.words = new Array(q.length);
      for (var i = 0; i < q.length; i++) {
        q.words[i] = 0;
      }
    }

    var diff = a.clone()._ishlnsubmul(b, 1, m);
    if (diff.negative === 0) {
      a = diff;
      if (q) {
        q.words[m] = 1;
      }
    }

    for (var j = m - 1; j >= 0; j--) {
      var qj = (a.words[b.length + j] | 0) * 0x4000000 +
        (a.words[b.length + j - 1] | 0);

      // NOTE: (qj / bhi) is (0x3ffffff * 0x4000000 + 0x3ffffff) / 0x2000000 max
      // (0x7ffffff)
      qj = Math.min((qj / bhi) | 0, 0x3ffffff);

      a._ishlnsubmul(b, qj, j);
      while (a.negative !== 0) {
        qj--;
        a.negative = 0;
        a._ishlnsubmul(b, 1, j);
        if (!a.isZero()) {
          a.negative ^= 1;
        }
      }
      if (q) {
        q.words[j] = qj;
      }
    }
    if (q) {
      q.strip();
    }
    a.strip();

    // Denormalize
    if (mode !== 'div' && shift !== 0) {
      a.iushrn(shift);
    }

    return {
      div: q || null,
      mod: a
    };
  };

  // NOTE: 1) `mode` can be set to `mod` to request mod only,
  //       to `div` to request div only, or be absent to
  //       request both div & mod
  //       2) `positive` is true if unsigned mod is requested
  BN.prototype.divmod = function divmod (num, mode, positive) {
    assert(!num.isZero());

    if (this.isZero()) {
      return {
        div: new BN(0),
        mod: new BN(0)
      };
    }

    var div, mod, res;
    if (this.negative !== 0 && num.negative === 0) {
      res = this.neg().divmod(num, mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.iadd(num);
        }
      }

      return {
        div: div,
        mod: mod
      };
    }

    if (this.negative === 0 && num.negative !== 0) {
      res = this.divmod(num.neg(), mode);

      if (mode !== 'mod') {
        div = res.div.neg();
      }

      return {
        div: div,
        mod: res.mod
      };
    }

    if ((this.negative & num.negative) !== 0) {
      res = this.neg().divmod(num.neg(), mode);

      if (mode !== 'div') {
        mod = res.mod.neg();
        if (positive && mod.negative !== 0) {
          mod.isub(num);
        }
      }

      return {
        div: res.div,
        mod: mod
      };
    }

    // Both numbers are positive at this point

    // Strip both numbers to approximate shift value
    if (num.length > this.length || this.cmp(num) < 0) {
      return {
        div: new BN(0),
        mod: this
      };
    }

    // Very short reduction
    if (num.length === 1) {
      if (mode === 'div') {
        return {
          div: this.divn(num.words[0]),
          mod: null
        };
      }

      if (mode === 'mod') {
        return {
          div: null,
          mod: new BN(this.modn(num.words[0]))
        };
      }

      return {
        div: this.divn(num.words[0]),
        mod: new BN(this.modn(num.words[0]))
      };
    }

    return this._wordDiv(num, mode);
  };

  // Find `this` / `num`
  BN.prototype.div = function div (num) {
    return this.divmod(num, 'div', false).div;
  };

  // Find `this` % `num`
  BN.prototype.mod = function mod (num) {
    return this.divmod(num, 'mod', false).mod;
  };

  BN.prototype.umod = function umod (num) {
    return this.divmod(num, 'mod', true).mod;
  };

  // Find Round(`this` / `num`)
  BN.prototype.divRound = function divRound (num) {
    var dm = this.divmod(num);

    // Fast case - exact division
    if (dm.mod.isZero()) return dm.div;

    var mod = dm.div.negative !== 0 ? dm.mod.isub(num) : dm.mod;

    var half = num.ushrn(1);
    var r2 = num.andln(1);
    var cmp = mod.cmp(half);

    // Round down
    if (cmp < 0 || r2 === 1 && cmp === 0) return dm.div;

    // Round up
    return dm.div.negative !== 0 ? dm.div.isubn(1) : dm.div.iaddn(1);
  };

  BN.prototype.modn = function modn (num) {
    assert(num <= 0x3ffffff);
    var p = (1 << 26) % num;

    var acc = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      acc = (p * acc + (this.words[i] | 0)) % num;
    }

    return acc;
  };

  // In-place division by number
  BN.prototype.idivn = function idivn (num) {
    assert(num <= 0x3ffffff);

    var carry = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var w = (this.words[i] | 0) + carry * 0x4000000;
      this.words[i] = (w / num) | 0;
      carry = w % num;
    }

    return this.strip();
  };

  BN.prototype.divn = function divn (num) {
    return this.clone().idivn(num);
  };

  BN.prototype.egcd = function egcd (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var x = this;
    var y = p.clone();

    if (x.negative !== 0) {
      x = x.umod(p);
    } else {
      x = x.clone();
    }

    // A * x + B * y = x
    var A = new BN(1);
    var B = new BN(0);

    // C * x + D * y = y
    var C = new BN(0);
    var D = new BN(1);

    var g = 0;

    while (x.isEven() && y.isEven()) {
      x.iushrn(1);
      y.iushrn(1);
      ++g;
    }

    var yp = y.clone();
    var xp = x.clone();

    while (!x.isZero()) {
      for (var i = 0, im = 1; (x.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        x.iushrn(i);
        while (i-- > 0) {
          if (A.isOdd() || B.isOdd()) {
            A.iadd(yp);
            B.isub(xp);
          }

          A.iushrn(1);
          B.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (y.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        y.iushrn(j);
        while (j-- > 0) {
          if (C.isOdd() || D.isOdd()) {
            C.iadd(yp);
            D.isub(xp);
          }

          C.iushrn(1);
          D.iushrn(1);
        }
      }

      if (x.cmp(y) >= 0) {
        x.isub(y);
        A.isub(C);
        B.isub(D);
      } else {
        y.isub(x);
        C.isub(A);
        D.isub(B);
      }
    }

    return {
      a: C,
      b: D,
      gcd: y.iushln(g)
    };
  };

  // This is reduced incarnation of the binary EEA
  // above, designated to invert members of the
  // _prime_ fields F(p) at a maximal speed
  BN.prototype._invmp = function _invmp (p) {
    assert(p.negative === 0);
    assert(!p.isZero());

    var a = this;
    var b = p.clone();

    if (a.negative !== 0) {
      a = a.umod(p);
    } else {
      a = a.clone();
    }

    var x1 = new BN(1);
    var x2 = new BN(0);

    var delta = b.clone();

    while (a.cmpn(1) > 0 && b.cmpn(1) > 0) {
      for (var i = 0, im = 1; (a.words[0] & im) === 0 && i < 26; ++i, im <<= 1);
      if (i > 0) {
        a.iushrn(i);
        while (i-- > 0) {
          if (x1.isOdd()) {
            x1.iadd(delta);
          }

          x1.iushrn(1);
        }
      }

      for (var j = 0, jm = 1; (b.words[0] & jm) === 0 && j < 26; ++j, jm <<= 1);
      if (j > 0) {
        b.iushrn(j);
        while (j-- > 0) {
          if (x2.isOdd()) {
            x2.iadd(delta);
          }

          x2.iushrn(1);
        }
      }

      if (a.cmp(b) >= 0) {
        a.isub(b);
        x1.isub(x2);
      } else {
        b.isub(a);
        x2.isub(x1);
      }
    }

    var res;
    if (a.cmpn(1) === 0) {
      res = x1;
    } else {
      res = x2;
    }

    if (res.cmpn(0) < 0) {
      res.iadd(p);
    }

    return res;
  };

  BN.prototype.gcd = function gcd (num) {
    if (this.isZero()) return num.abs();
    if (num.isZero()) return this.abs();

    var a = this.clone();
    var b = num.clone();
    a.negative = 0;
    b.negative = 0;

    // Remove common factor of two
    for (var shift = 0; a.isEven() && b.isEven(); shift++) {
      a.iushrn(1);
      b.iushrn(1);
    }

    do {
      while (a.isEven()) {
        a.iushrn(1);
      }
      while (b.isEven()) {
        b.iushrn(1);
      }

      var r = a.cmp(b);
      if (r < 0) {
        // Swap `a` and `b` to make `a` always bigger than `b`
        var t = a;
        a = b;
        b = t;
      } else if (r === 0 || b.cmpn(1) === 0) {
        break;
      }

      a.isub(b);
    } while (true);

    return b.iushln(shift);
  };

  // Invert number in the field F(num)
  BN.prototype.invm = function invm (num) {
    return this.egcd(num).a.umod(num);
  };

  BN.prototype.isEven = function isEven () {
    return (this.words[0] & 1) === 0;
  };

  BN.prototype.isOdd = function isOdd () {
    return (this.words[0] & 1) === 1;
  };

  // And first word and num
  BN.prototype.andln = function andln (num) {
    return this.words[0] & num;
  };

  // Increment at the bit position in-line
  BN.prototype.bincn = function bincn (bit) {
    assert(typeof bit === 'number');
    var r = bit % 26;
    var s = (bit - r) / 26;
    var q = 1 << r;

    // Fast case: bit is much higher than all existing words
    if (this.length <= s) {
      this._expand(s + 1);
      this.words[s] |= q;
      return this;
    }

    // Add bit and propagate, if needed
    var carry = q;
    for (var i = s; carry !== 0 && i < this.length; i++) {
      var w = this.words[i] | 0;
      w += carry;
      carry = w >>> 26;
      w &= 0x3ffffff;
      this.words[i] = w;
    }
    if (carry !== 0) {
      this.words[i] = carry;
      this.length++;
    }
    return this;
  };

  BN.prototype.isZero = function isZero () {
    return this.length === 1 && this.words[0] === 0;
  };

  BN.prototype.cmpn = function cmpn (num) {
    var negative = num < 0;

    if (this.negative !== 0 && !negative) return -1;
    if (this.negative === 0 && negative) return 1;

    this.strip();

    var res;
    if (this.length > 1) {
      res = 1;
    } else {
      if (negative) {
        num = -num;
      }

      assert(num <= 0x3ffffff, 'Number is too big');

      var w = this.words[0] | 0;
      res = w === num ? 0 : w < num ? -1 : 1;
    }
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Compare two numbers and return:
  // 1 - if `this` > `num`
  // 0 - if `this` == `num`
  // -1 - if `this` < `num`
  BN.prototype.cmp = function cmp (num) {
    if (this.negative !== 0 && num.negative === 0) return -1;
    if (this.negative === 0 && num.negative !== 0) return 1;

    var res = this.ucmp(num);
    if (this.negative !== 0) return -res | 0;
    return res;
  };

  // Unsigned comparison
  BN.prototype.ucmp = function ucmp (num) {
    // At this point both numbers have the same sign
    if (this.length > num.length) return 1;
    if (this.length < num.length) return -1;

    var res = 0;
    for (var i = this.length - 1; i >= 0; i--) {
      var a = this.words[i] | 0;
      var b = num.words[i] | 0;

      if (a === b) continue;
      if (a < b) {
        res = -1;
      } else if (a > b) {
        res = 1;
      }
      break;
    }
    return res;
  };

  BN.prototype.gtn = function gtn (num) {
    return this.cmpn(num) === 1;
  };

  BN.prototype.gt = function gt (num) {
    return this.cmp(num) === 1;
  };

  BN.prototype.gten = function gten (num) {
    return this.cmpn(num) >= 0;
  };

  BN.prototype.gte = function gte (num) {
    return this.cmp(num) >= 0;
  };

  BN.prototype.ltn = function ltn (num) {
    return this.cmpn(num) === -1;
  };

  BN.prototype.lt = function lt (num) {
    return this.cmp(num) === -1;
  };

  BN.prototype.lten = function lten (num) {
    return this.cmpn(num) <= 0;
  };

  BN.prototype.lte = function lte (num) {
    return this.cmp(num) <= 0;
  };

  BN.prototype.eqn = function eqn (num) {
    return this.cmpn(num) === 0;
  };

  BN.prototype.eq = function eq (num) {
    return this.cmp(num) === 0;
  };

  //
  // A reduce context, could be using montgomery or something better, depending
  // on the `m` itself.
  //
  BN.red = function red (num) {
    return new Red(num);
  };

  BN.prototype.toRed = function toRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    assert(this.negative === 0, 'red works only with positives');
    return ctx.convertTo(this)._forceRed(ctx);
  };

  BN.prototype.fromRed = function fromRed () {
    assert(this.red, 'fromRed works only with numbers in reduction context');
    return this.red.convertFrom(this);
  };

  BN.prototype._forceRed = function _forceRed (ctx) {
    this.red = ctx;
    return this;
  };

  BN.prototype.forceRed = function forceRed (ctx) {
    assert(!this.red, 'Already a number in reduction context');
    return this._forceRed(ctx);
  };

  BN.prototype.redAdd = function redAdd (num) {
    assert(this.red, 'redAdd works only with red numbers');
    return this.red.add(this, num);
  };

  BN.prototype.redIAdd = function redIAdd (num) {
    assert(this.red, 'redIAdd works only with red numbers');
    return this.red.iadd(this, num);
  };

  BN.prototype.redSub = function redSub (num) {
    assert(this.red, 'redSub works only with red numbers');
    return this.red.sub(this, num);
  };

  BN.prototype.redISub = function redISub (num) {
    assert(this.red, 'redISub works only with red numbers');
    return this.red.isub(this, num);
  };

  BN.prototype.redShl = function redShl (num) {
    assert(this.red, 'redShl works only with red numbers');
    return this.red.shl(this, num);
  };

  BN.prototype.redMul = function redMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.mul(this, num);
  };

  BN.prototype.redIMul = function redIMul (num) {
    assert(this.red, 'redMul works only with red numbers');
    this.red._verify2(this, num);
    return this.red.imul(this, num);
  };

  BN.prototype.redSqr = function redSqr () {
    assert(this.red, 'redSqr works only with red numbers');
    this.red._verify1(this);
    return this.red.sqr(this);
  };

  BN.prototype.redISqr = function redISqr () {
    assert(this.red, 'redISqr works only with red numbers');
    this.red._verify1(this);
    return this.red.isqr(this);
  };

  // Square root over p
  BN.prototype.redSqrt = function redSqrt () {
    assert(this.red, 'redSqrt works only with red numbers');
    this.red._verify1(this);
    return this.red.sqrt(this);
  };

  BN.prototype.redInvm = function redInvm () {
    assert(this.red, 'redInvm works only with red numbers');
    this.red._verify1(this);
    return this.red.invm(this);
  };

  // Return negative clone of `this` % `red modulo`
  BN.prototype.redNeg = function redNeg () {
    assert(this.red, 'redNeg works only with red numbers');
    this.red._verify1(this);
    return this.red.neg(this);
  };

  BN.prototype.redPow = function redPow (num) {
    assert(this.red && !num.red, 'redPow(normalNum)');
    this.red._verify1(this);
    return this.red.pow(this, num);
  };

  // Prime numbers with efficient reduction
  var primes = {
    k256: null,
    p224: null,
    p192: null,
    p25519: null
  };

  // Pseudo-Mersenne prime
  function MPrime (name, p) {
    // P = 2 ^ N - K
    this.name = name;
    this.p = new BN(p, 16);
    this.n = this.p.bitLength();
    this.k = new BN(1).iushln(this.n).isub(this.p);

    this.tmp = this._tmp();
  }

  MPrime.prototype._tmp = function _tmp () {
    var tmp = new BN(null);
    tmp.words = new Array(Math.ceil(this.n / 13));
    return tmp;
  };

  MPrime.prototype.ireduce = function ireduce (num) {
    // Assumes that `num` is less than `P^2`
    // num = HI * (2 ^ N - K) + HI * K + LO = HI * K + LO (mod P)
    var r = num;
    var rlen;

    do {
      this.split(r, this.tmp);
      r = this.imulK(r);
      r = r.iadd(this.tmp);
      rlen = r.bitLength();
    } while (rlen > this.n);

    var cmp = rlen < this.n ? -1 : r.ucmp(this.p);
    if (cmp === 0) {
      r.words[0] = 0;
      r.length = 1;
    } else if (cmp > 0) {
      r.isub(this.p);
    } else {
      if (r.strip !== undefined) {
        // r is BN v4 instance
        r.strip();
      } else {
        // r is BN v5 instance
        r._strip();
      }
    }

    return r;
  };

  MPrime.prototype.split = function split (input, out) {
    input.iushrn(this.n, 0, out);
  };

  MPrime.prototype.imulK = function imulK (num) {
    return num.imul(this.k);
  };

  function K256 () {
    MPrime.call(
      this,
      'k256',
      'ffffffff ffffffff ffffffff ffffffff ffffffff ffffffff fffffffe fffffc2f');
  }
  inherits(K256, MPrime);

  K256.prototype.split = function split (input, output) {
    // 256 = 9 * 26 + 22
    var mask = 0x3fffff;

    var outLen = Math.min(input.length, 9);
    for (var i = 0; i < outLen; i++) {
      output.words[i] = input.words[i];
    }
    output.length = outLen;

    if (input.length <= 9) {
      input.words[0] = 0;
      input.length = 1;
      return;
    }

    // Shift by 9 limbs
    var prev = input.words[9];
    output.words[output.length++] = prev & mask;

    for (i = 10; i < input.length; i++) {
      var next = input.words[i] | 0;
      input.words[i - 10] = ((next & mask) << 4) | (prev >>> 22);
      prev = next;
    }
    prev >>>= 22;
    input.words[i - 10] = prev;
    if (prev === 0 && input.length > 10) {
      input.length -= 10;
    } else {
      input.length -= 9;
    }
  };

  K256.prototype.imulK = function imulK (num) {
    // K = 0x1000003d1 = [ 0x40, 0x3d1 ]
    num.words[num.length] = 0;
    num.words[num.length + 1] = 0;
    num.length += 2;

    // bounded at: 0x40 * 0x3ffffff + 0x3d0 = 0x100000390
    var lo = 0;
    for (var i = 0; i < num.length; i++) {
      var w = num.words[i] | 0;
      lo += w * 0x3d1;
      num.words[i] = lo & 0x3ffffff;
      lo = w * 0x40 + ((lo / 0x4000000) | 0);
    }

    // Fast length reduction
    if (num.words[num.length - 1] === 0) {
      num.length--;
      if (num.words[num.length - 1] === 0) {
        num.length--;
      }
    }
    return num;
  };

  function P224 () {
    MPrime.call(
      this,
      'p224',
      'ffffffff ffffffff ffffffff ffffffff 00000000 00000000 00000001');
  }
  inherits(P224, MPrime);

  function P192 () {
    MPrime.call(
      this,
      'p192',
      'ffffffff ffffffff ffffffff fffffffe ffffffff ffffffff');
  }
  inherits(P192, MPrime);

  function P25519 () {
    // 2 ^ 255 - 19
    MPrime.call(
      this,
      '25519',
      '7fffffffffffffff ffffffffffffffff ffffffffffffffff ffffffffffffffed');
  }
  inherits(P25519, MPrime);

  P25519.prototype.imulK = function imulK (num) {
    // K = 0x13
    var carry = 0;
    for (var i = 0; i < num.length; i++) {
      var hi = (num.words[i] | 0) * 0x13 + carry;
      var lo = hi & 0x3ffffff;
      hi >>>= 26;

      num.words[i] = lo;
      carry = hi;
    }
    if (carry !== 0) {
      num.words[num.length++] = carry;
    }
    return num;
  };

  // Exported mostly for testing purposes, use plain name instead
  BN._prime = function prime (name) {
    // Cached version of prime
    if (primes[name]) return primes[name];

    var prime;
    if (name === 'k256') {
      prime = new K256();
    } else if (name === 'p224') {
      prime = new P224();
    } else if (name === 'p192') {
      prime = new P192();
    } else if (name === 'p25519') {
      prime = new P25519();
    } else {
      throw new Error('Unknown prime ' + name);
    }
    primes[name] = prime;

    return prime;
  };

  //
  // Base reduction engine
  //
  function Red (m) {
    if (typeof m === 'string') {
      var prime = BN._prime(m);
      this.m = prime.p;
      this.prime = prime;
    } else {
      assert(m.gtn(1), 'modulus must be greater than 1');
      this.m = m;
      this.prime = null;
    }
  }

  Red.prototype._verify1 = function _verify1 (a) {
    assert(a.negative === 0, 'red works only with positives');
    assert(a.red, 'red works only with red numbers');
  };

  Red.prototype._verify2 = function _verify2 (a, b) {
    assert((a.negative | b.negative) === 0, 'red works only with positives');
    assert(a.red && a.red === b.red,
      'red works only with red numbers');
  };

  Red.prototype.imod = function imod (a) {
    if (this.prime) return this.prime.ireduce(a)._forceRed(this);
    return a.umod(this.m)._forceRed(this);
  };

  Red.prototype.neg = function neg (a) {
    if (a.isZero()) {
      return a.clone();
    }

    return this.m.sub(a)._forceRed(this);
  };

  Red.prototype.add = function add (a, b) {
    this._verify2(a, b);

    var res = a.add(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.iadd = function iadd (a, b) {
    this._verify2(a, b);

    var res = a.iadd(b);
    if (res.cmp(this.m) >= 0) {
      res.isub(this.m);
    }
    return res;
  };

  Red.prototype.sub = function sub (a, b) {
    this._verify2(a, b);

    var res = a.sub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res._forceRed(this);
  };

  Red.prototype.isub = function isub (a, b) {
    this._verify2(a, b);

    var res = a.isub(b);
    if (res.cmpn(0) < 0) {
      res.iadd(this.m);
    }
    return res;
  };

  Red.prototype.shl = function shl (a, num) {
    this._verify1(a);
    return this.imod(a.ushln(num));
  };

  Red.prototype.imul = function imul (a, b) {
    this._verify2(a, b);
    return this.imod(a.imul(b));
  };

  Red.prototype.mul = function mul (a, b) {
    this._verify2(a, b);
    return this.imod(a.mul(b));
  };

  Red.prototype.isqr = function isqr (a) {
    return this.imul(a, a.clone());
  };

  Red.prototype.sqr = function sqr (a) {
    return this.mul(a, a);
  };

  Red.prototype.sqrt = function sqrt (a) {
    if (a.isZero()) return a.clone();

    var mod3 = this.m.andln(3);
    assert(mod3 % 2 === 1);

    // Fast case
    if (mod3 === 3) {
      var pow = this.m.add(new BN(1)).iushrn(2);
      return this.pow(a, pow);
    }

    // Tonelli-Shanks algorithm (Totally unoptimized and slow)
    //
    // Find Q and S, that Q * 2 ^ S = (P - 1)
    var q = this.m.subn(1);
    var s = 0;
    while (!q.isZero() && q.andln(1) === 0) {
      s++;
      q.iushrn(1);
    }
    assert(!q.isZero());

    var one = new BN(1).toRed(this);
    var nOne = one.redNeg();

    // Find quadratic non-residue
    // NOTE: Max is such because of generalized Riemann hypothesis.
    var lpow = this.m.subn(1).iushrn(1);
    var z = this.m.bitLength();
    z = new BN(2 * z * z).toRed(this);

    while (this.pow(z, lpow).cmp(nOne) !== 0) {
      z.redIAdd(nOne);
    }

    var c = this.pow(z, q);
    var r = this.pow(a, q.addn(1).iushrn(1));
    var t = this.pow(a, q);
    var m = s;
    while (t.cmp(one) !== 0) {
      var tmp = t;
      for (var i = 0; tmp.cmp(one) !== 0; i++) {
        tmp = tmp.redSqr();
      }
      assert(i < m);
      var b = this.pow(c, new BN(1).iushln(m - i - 1));

      r = r.redMul(b);
      c = b.redSqr();
      t = t.redMul(c);
      m = i;
    }

    return r;
  };

  Red.prototype.invm = function invm (a) {
    var inv = a._invmp(this.m);
    if (inv.negative !== 0) {
      inv.negative = 0;
      return this.imod(inv).redNeg();
    } else {
      return this.imod(inv);
    }
  };

  Red.prototype.pow = function pow (a, num) {
    if (num.isZero()) return new BN(1).toRed(this);
    if (num.cmpn(1) === 0) return a.clone();

    var windowSize = 4;
    var wnd = new Array(1 << windowSize);
    wnd[0] = new BN(1).toRed(this);
    wnd[1] = a;
    for (var i = 2; i < wnd.length; i++) {
      wnd[i] = this.mul(wnd[i - 1], a);
    }

    var res = wnd[0];
    var current = 0;
    var currentLen = 0;
    var start = num.bitLength() % 26;
    if (start === 0) {
      start = 26;
    }

    for (i = num.length - 1; i >= 0; i--) {
      var word = num.words[i];
      for (var j = start - 1; j >= 0; j--) {
        var bit = (word >> j) & 1;
        if (res !== wnd[0]) {
          res = this.sqr(res);
        }

        if (bit === 0 && current === 0) {
          currentLen = 0;
          continue;
        }

        current <<= 1;
        current |= bit;
        currentLen++;
        if (currentLen !== windowSize && (i !== 0 || j !== 0)) continue;

        res = this.mul(res, wnd[current]);
        currentLen = 0;
        current = 0;
      }
      start = 26;
    }

    return res;
  };

  Red.prototype.convertTo = function convertTo (num) {
    var r = num.umod(this.m);

    return r === num ? r.clone() : r;
  };

  Red.prototype.convertFrom = function convertFrom (num) {
    var res = num.clone();
    res.red = null;
    return res;
  };

  //
  // Montgomery method engine
  //

  BN.mont = function mont (num) {
    return new Mont(num);
  };

  function Mont (m) {
    Red.call(this, m);

    this.shift = this.m.bitLength();
    if (this.shift % 26 !== 0) {
      this.shift += 26 - (this.shift % 26);
    }

    this.r = new BN(1).iushln(this.shift);
    this.r2 = this.imod(this.r.sqr());
    this.rinv = this.r._invmp(this.m);

    this.minv = this.rinv.mul(this.r).isubn(1).div(this.m);
    this.minv = this.minv.umod(this.r);
    this.minv = this.r.sub(this.minv);
  }
  inherits(Mont, Red);

  Mont.prototype.convertTo = function convertTo (num) {
    return this.imod(num.ushln(this.shift));
  };

  Mont.prototype.convertFrom = function convertFrom (num) {
    var r = this.imod(num.mul(this.rinv));
    r.red = null;
    return r;
  };

  Mont.prototype.imul = function imul (a, b) {
    if (a.isZero() || b.isZero()) {
      a.words[0] = 0;
      a.length = 1;
      return a;
    }

    var t = a.imul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;

    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.mul = function mul (a, b) {
    if (a.isZero() || b.isZero()) return new BN(0)._forceRed(this);

    var t = a.mul(b);
    var c = t.maskn(this.shift).mul(this.minv).imaskn(this.shift).mul(this.m);
    var u = t.isub(c).iushrn(this.shift);
    var res = u;
    if (u.cmp(this.m) >= 0) {
      res = u.isub(this.m);
    } else if (u.cmpn(0) < 0) {
      res = u.iadd(this.m);
    }

    return res._forceRed(this);
  };

  Mont.prototype.invm = function invm (a) {
    // (AR)^-1 * R^2 = (A^-1 * R^-1) * R^2 = A^-1 * R
    var res = this.imod(a._invmp(this.m).mul(this.r2));
    return res._forceRed(this);
  };
})( false || module, this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/module.js */ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/module.js")(module)))

/***/ }),

/***/ "./node_modules/ethers/lib.esm/_version.js":
/*!*************************************************!*\
  !*** ./node_modules/ethers/lib.esm/_version.js ***!
  \*************************************************/
/*! exports provided: version */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "version", function() { return version; });
const version = "ethers/5.5.2";
//# sourceMappingURL=_version.js.map

/***/ }),

/***/ "./node_modules/ethers/lib.esm/ethers.js":
/*!***********************************************!*\
  !*** ./node_modules/ethers/lib.esm/ethers.js ***!
  \***********************************************/
/*! exports provided: Signer, Wallet, VoidSigner, getDefaultProvider, providers, BaseContract, Contract, ContractFactory, BigNumber, FixedNumber, constants, errors, logger, utils, wordlists, version, Wordlist */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "logger", function() { return logger; });
/* harmony import */ var _ethersproject_contracts__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/contracts */ "./node_modules/@ethersproject/contracts/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseContract", function() { return _ethersproject_contracts__WEBPACK_IMPORTED_MODULE_0__["BaseContract"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Contract", function() { return _ethersproject_contracts__WEBPACK_IMPORTED_MODULE_0__["Contract"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ContractFactory", function() { return _ethersproject_contracts__WEBPACK_IMPORTED_MODULE_0__["ContractFactory"]; });

/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BigNumber", function() { return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["BigNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FixedNumber", function() { return _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_1__["FixedNumber"]; });

/* harmony import */ var _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/abstract-signer */ "./node_modules/@ethersproject/abstract-signer/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Signer", function() { return _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_2__["Signer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VoidSigner", function() { return _ethersproject_abstract_signer__WEBPACK_IMPORTED_MODULE_2__["VoidSigner"]; });

/* harmony import */ var _ethersproject_wallet__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/wallet */ "./node_modules/@ethersproject/wallet/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Wallet", function() { return _ethersproject_wallet__WEBPACK_IMPORTED_MODULE_3__["Wallet"]; });

/* harmony import */ var _ethersproject_constants__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/constants */ "./node_modules/@ethersproject/constants/lib.esm/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "constants", function() { return _ethersproject_constants__WEBPACK_IMPORTED_MODULE_4__; });
/* harmony import */ var _ethersproject_providers__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/providers */ "./node_modules/@ethersproject/providers/lib.esm/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "providers", function() { return _ethersproject_providers__WEBPACK_IMPORTED_MODULE_5__; });
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefaultProvider", function() { return _ethersproject_providers__WEBPACK_IMPORTED_MODULE_5__["getDefaultProvider"]; });

/* harmony import */ var _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/wordlists */ "./node_modules/@ethersproject/wordlists/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "wordlists", function() { return _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_6__["wordlists"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Wordlist", function() { return _ethersproject_wordlists__WEBPACK_IMPORTED_MODULE_6__["Wordlist"]; });

/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils */ "./node_modules/ethers/lib.esm/utils.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "utils", function() { return _utils__WEBPACK_IMPORTED_MODULE_7__; });
/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "errors", function() { return _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["ErrorCode"]; });

/* harmony import */ var _version__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./_version */ "./node_modules/ethers/lib.esm/_version.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version", function() { return _version__WEBPACK_IMPORTED_MODULE_9__["version"]; });












////////////////////////
// Compile-Time Constants
// This is generated by "npm run dist"

const logger = new _ethersproject_logger__WEBPACK_IMPORTED_MODULE_8__["Logger"](_version__WEBPACK_IMPORTED_MODULE_9__["version"]);
////////////////////////
// Exports

//# sourceMappingURL=ethers.js.map

/***/ }),

/***/ "./node_modules/ethers/lib.esm/index.js":
/*!**********************************************!*\
  !*** ./node_modules/ethers/lib.esm/index.js ***!
  \**********************************************/
/*! exports provided: ethers, Signer, Wallet, VoidSigner, getDefaultProvider, providers, BaseContract, Contract, ContractFactory, BigNumber, FixedNumber, constants, errors, logger, utils, wordlists, version, Wordlist */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ethers */ "./node_modules/ethers/lib.esm/ethers.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "ethers", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__; });
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Signer", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["Signer"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Wallet", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["Wallet"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "VoidSigner", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["VoidSigner"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getDefaultProvider", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["getDefaultProvider"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "providers", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["providers"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BaseContract", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["BaseContract"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Contract", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["Contract"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ContractFactory", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["ContractFactory"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "BigNumber", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FixedNumber", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["FixedNumber"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "constants", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["constants"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "errors", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["errors"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "logger", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["logger"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "utils", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["utils"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "wordlists", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["wordlists"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "version", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["version"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Wordlist", function() { return _ethers__WEBPACK_IMPORTED_MODULE_0__["Wordlist"]; });


// To modify this file, you must update ./misc/admin/lib/cmds/update-exports.js

try {
    const anyGlobal = window;
    if (anyGlobal._ethers == null) {
        anyGlobal._ethers = _ethers__WEBPACK_IMPORTED_MODULE_0__;
    }
}
catch (error) { }


//# sourceMappingURL=index.js.map

/***/ }),

/***/ "./node_modules/ethers/lib.esm/utils.js":
/*!**********************************************!*\
  !*** ./node_modules/ethers/lib.esm/utils.js ***!
  \**********************************************/
/*! exports provided: AbiCoder, defaultAbiCoder, Fragment, ConstructorFragment, ErrorFragment, EventFragment, FunctionFragment, ParamType, FormatTypes, checkResultErrors, Logger, RLP, _fetchData, fetchJson, poll, checkProperties, deepCopy, defineReadOnly, getStatic, resolveProperties, shallowCopy, arrayify, concat, stripZeros, zeroPad, isBytes, isBytesLike, defaultPath, HDNode, SigningKey, Interface, LogDescription, TransactionDescription, base58, base64, hexlify, isHexString, hexConcat, hexStripZeros, hexValue, hexZeroPad, hexDataLength, hexDataSlice, nameprep, _toEscapedUtf8String, toUtf8Bytes, toUtf8CodePoints, toUtf8String, Utf8ErrorFuncs, formatBytes32String, parseBytes32String, hashMessage, namehash, isValidName, id, _TypedDataEncoder, getAddress, getIcapAddress, getContractAddress, getCreate2Address, isAddress, formatEther, parseEther, formatUnits, parseUnits, commify, computeHmac, keccak256, ripemd160, sha256, sha512, randomBytes, shuffled, solidityPack, solidityKeccak256, soliditySha256, splitSignature, joinSignature, accessListify, parseTransaction, serializeTransaction, TransactionTypes, getJsonWalletAddress, computeAddress, recoverAddress, computePublicKey, recoverPublicKey, verifyMessage, verifyTypedData, getAccountPath, mnemonicToEntropy, entropyToMnemonic, isValidMnemonic, mnemonicToSeed, SupportedAlgorithm, UnicodeNormalizationForm, Utf8ErrorReason, Indexed */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/abi */ "./node_modules/@ethersproject/abi/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "AbiCoder", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["AbiCoder"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultAbiCoder", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["defaultAbiCoder"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Fragment", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["Fragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ConstructorFragment", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["ConstructorFragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ErrorFragment", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["ErrorFragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "EventFragment", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["EventFragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FunctionFragment", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["FunctionFragment"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ParamType", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["ParamType"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "FormatTypes", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["FormatTypes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkResultErrors", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["checkResultErrors"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Interface", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["Interface"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "LogDescription", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["LogDescription"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransactionDescription", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["TransactionDescription"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Indexed", function() { return _ethersproject_abi__WEBPACK_IMPORTED_MODULE_0__["Indexed"]; });

/* harmony import */ var _ethersproject_address__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ethersproject/address */ "./node_modules/@ethersproject/address/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getAddress", function() { return _ethersproject_address__WEBPACK_IMPORTED_MODULE_1__["getAddress"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getIcapAddress", function() { return _ethersproject_address__WEBPACK_IMPORTED_MODULE_1__["getIcapAddress"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getContractAddress", function() { return _ethersproject_address__WEBPACK_IMPORTED_MODULE_1__["getContractAddress"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getCreate2Address", function() { return _ethersproject_address__WEBPACK_IMPORTED_MODULE_1__["getCreate2Address"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isAddress", function() { return _ethersproject_address__WEBPACK_IMPORTED_MODULE_1__["isAddress"]; });

/* harmony import */ var _ethersproject_base64__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ethersproject/base64 */ "./node_modules/@ethersproject/base64/lib.esm/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "base64", function() { return _ethersproject_base64__WEBPACK_IMPORTED_MODULE_2__; });
/* harmony import */ var _ethersproject_basex__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ethersproject/basex */ "./node_modules/@ethersproject/basex/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "base58", function() { return _ethersproject_basex__WEBPACK_IMPORTED_MODULE_3__["Base58"]; });

/* harmony import */ var _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ethersproject/bytes */ "./node_modules/@ethersproject/bytes/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "arrayify", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["arrayify"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "concat", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["concat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "stripZeros", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["stripZeros"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "zeroPad", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["zeroPad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBytes", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["isBytes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isBytesLike", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["isBytesLike"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexlify", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["hexlify"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isHexString", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["isHexString"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexConcat", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["hexConcat"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexStripZeros", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["hexStripZeros"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexValue", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["hexValue"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexZeroPad", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["hexZeroPad"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexDataLength", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["hexDataLength"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hexDataSlice", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["hexDataSlice"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "splitSignature", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["splitSignature"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "joinSignature", function() { return _ethersproject_bytes__WEBPACK_IMPORTED_MODULE_4__["joinSignature"]; });

/* harmony import */ var _ethersproject_hash__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @ethersproject/hash */ "./node_modules/@ethersproject/hash/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "hashMessage", function() { return _ethersproject_hash__WEBPACK_IMPORTED_MODULE_5__["hashMessage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "namehash", function() { return _ethersproject_hash__WEBPACK_IMPORTED_MODULE_5__["namehash"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isValidName", function() { return _ethersproject_hash__WEBPACK_IMPORTED_MODULE_5__["isValidName"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "id", function() { return _ethersproject_hash__WEBPACK_IMPORTED_MODULE_5__["id"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_TypedDataEncoder", function() { return _ethersproject_hash__WEBPACK_IMPORTED_MODULE_5__["_TypedDataEncoder"]; });

/* harmony import */ var _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! @ethersproject/hdnode */ "./node_modules/@ethersproject/hdnode/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defaultPath", function() { return _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_6__["defaultPath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "HDNode", function() { return _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_6__["HDNode"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getAccountPath", function() { return _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_6__["getAccountPath"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mnemonicToEntropy", function() { return _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_6__["mnemonicToEntropy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "entropyToMnemonic", function() { return _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_6__["entropyToMnemonic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "isValidMnemonic", function() { return _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_6__["isValidMnemonic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "mnemonicToSeed", function() { return _ethersproject_hdnode__WEBPACK_IMPORTED_MODULE_6__["mnemonicToSeed"]; });

/* harmony import */ var _ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! @ethersproject/json-wallets */ "./node_modules/@ethersproject/json-wallets/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getJsonWalletAddress", function() { return _ethersproject_json_wallets__WEBPACK_IMPORTED_MODULE_7__["getJsonWalletAddress"]; });

/* harmony import */ var _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! @ethersproject/keccak256 */ "./node_modules/@ethersproject/keccak256/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "keccak256", function() { return _ethersproject_keccak256__WEBPACK_IMPORTED_MODULE_8__["keccak256"]; });

/* harmony import */ var _ethersproject_logger__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! @ethersproject/logger */ "./node_modules/@ethersproject/logger/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Logger", function() { return _ethersproject_logger__WEBPACK_IMPORTED_MODULE_9__["Logger"]; });

/* harmony import */ var _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! @ethersproject/sha2 */ "./node_modules/@ethersproject/sha2/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeHmac", function() { return _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_10__["computeHmac"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "ripemd160", function() { return _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_10__["ripemd160"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sha256", function() { return _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_10__["sha256"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "sha512", function() { return _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_10__["sha512"]; });

/* harmony import */ var _ethersproject_solidity__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! @ethersproject/solidity */ "./node_modules/@ethersproject/solidity/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "solidityPack", function() { return _ethersproject_solidity__WEBPACK_IMPORTED_MODULE_11__["pack"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "solidityKeccak256", function() { return _ethersproject_solidity__WEBPACK_IMPORTED_MODULE_11__["keccak256"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "soliditySha256", function() { return _ethersproject_solidity__WEBPACK_IMPORTED_MODULE_11__["sha256"]; });

/* harmony import */ var _ethersproject_random__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! @ethersproject/random */ "./node_modules/@ethersproject/random/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "randomBytes", function() { return _ethersproject_random__WEBPACK_IMPORTED_MODULE_12__["randomBytes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shuffled", function() { return _ethersproject_random__WEBPACK_IMPORTED_MODULE_12__["shuffled"]; });

/* harmony import */ var _ethersproject_properties__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! @ethersproject/properties */ "./node_modules/@ethersproject/properties/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "checkProperties", function() { return _ethersproject_properties__WEBPACK_IMPORTED_MODULE_13__["checkProperties"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "deepCopy", function() { return _ethersproject_properties__WEBPACK_IMPORTED_MODULE_13__["deepCopy"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "defineReadOnly", function() { return _ethersproject_properties__WEBPACK_IMPORTED_MODULE_13__["defineReadOnly"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "getStatic", function() { return _ethersproject_properties__WEBPACK_IMPORTED_MODULE_13__["getStatic"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "resolveProperties", function() { return _ethersproject_properties__WEBPACK_IMPORTED_MODULE_13__["resolveProperties"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "shallowCopy", function() { return _ethersproject_properties__WEBPACK_IMPORTED_MODULE_13__["shallowCopy"]; });

/* harmony import */ var _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! @ethersproject/rlp */ "./node_modules/@ethersproject/rlp/lib.esm/index.js");
/* harmony reexport (module object) */ __webpack_require__.d(__webpack_exports__, "RLP", function() { return _ethersproject_rlp__WEBPACK_IMPORTED_MODULE_14__; });
/* harmony import */ var _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! @ethersproject/signing-key */ "./node_modules/@ethersproject/signing-key/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SigningKey", function() { return _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_15__["SigningKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computePublicKey", function() { return _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_15__["computePublicKey"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "recoverPublicKey", function() { return _ethersproject_signing_key__WEBPACK_IMPORTED_MODULE_15__["recoverPublicKey"]; });

/* harmony import */ var _ethersproject_strings__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! @ethersproject/strings */ "./node_modules/@ethersproject/strings/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "nameprep", function() { return _ethersproject_strings__WEBPACK_IMPORTED_MODULE_16__["nameprep"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_toEscapedUtf8String", function() { return _ethersproject_strings__WEBPACK_IMPORTED_MODULE_16__["_toEscapedUtf8String"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toUtf8Bytes", function() { return _ethersproject_strings__WEBPACK_IMPORTED_MODULE_16__["toUtf8Bytes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toUtf8CodePoints", function() { return _ethersproject_strings__WEBPACK_IMPORTED_MODULE_16__["toUtf8CodePoints"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "toUtf8String", function() { return _ethersproject_strings__WEBPACK_IMPORTED_MODULE_16__["toUtf8String"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Utf8ErrorFuncs", function() { return _ethersproject_strings__WEBPACK_IMPORTED_MODULE_16__["Utf8ErrorFuncs"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatBytes32String", function() { return _ethersproject_strings__WEBPACK_IMPORTED_MODULE_16__["formatBytes32String"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseBytes32String", function() { return _ethersproject_strings__WEBPACK_IMPORTED_MODULE_16__["parseBytes32String"]; });

/* harmony import */ var _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! @ethersproject/transactions */ "./node_modules/@ethersproject/transactions/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "accessListify", function() { return _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_17__["accessListify"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseTransaction", function() { return _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_17__["parse"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "serializeTransaction", function() { return _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_17__["serialize"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "TransactionTypes", function() { return _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_17__["TransactionTypes"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "computeAddress", function() { return _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_17__["computeAddress"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "recoverAddress", function() { return _ethersproject_transactions__WEBPACK_IMPORTED_MODULE_17__["recoverAddress"]; });

/* harmony import */ var _ethersproject_units__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! @ethersproject/units */ "./node_modules/@ethersproject/units/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatEther", function() { return _ethersproject_units__WEBPACK_IMPORTED_MODULE_18__["formatEther"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseEther", function() { return _ethersproject_units__WEBPACK_IMPORTED_MODULE_18__["parseEther"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "formatUnits", function() { return _ethersproject_units__WEBPACK_IMPORTED_MODULE_18__["formatUnits"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "parseUnits", function() { return _ethersproject_units__WEBPACK_IMPORTED_MODULE_18__["parseUnits"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "commify", function() { return _ethersproject_units__WEBPACK_IMPORTED_MODULE_18__["commify"]; });

/* harmony import */ var _ethersproject_wallet__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! @ethersproject/wallet */ "./node_modules/@ethersproject/wallet/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "verifyMessage", function() { return _ethersproject_wallet__WEBPACK_IMPORTED_MODULE_19__["verifyMessage"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "verifyTypedData", function() { return _ethersproject_wallet__WEBPACK_IMPORTED_MODULE_19__["verifyTypedData"]; });

/* harmony import */ var _ethersproject_web__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! @ethersproject/web */ "./node_modules/@ethersproject/web/lib.esm/index.js");
/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "_fetchData", function() { return _ethersproject_web__WEBPACK_IMPORTED_MODULE_20__["_fetchData"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "fetchJson", function() { return _ethersproject_web__WEBPACK_IMPORTED_MODULE_20__["fetchJson"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "poll", function() { return _ethersproject_web__WEBPACK_IMPORTED_MODULE_20__["poll"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "SupportedAlgorithm", function() { return _ethersproject_sha2__WEBPACK_IMPORTED_MODULE_10__["SupportedAlgorithm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "UnicodeNormalizationForm", function() { return _ethersproject_strings__WEBPACK_IMPORTED_MODULE_16__["UnicodeNormalizationForm"]; });

/* harmony reexport (safe) */ __webpack_require__.d(__webpack_exports__, "Utf8ErrorReason", function() { return _ethersproject_strings__WEBPACK_IMPORTED_MODULE_16__["Utf8ErrorReason"]; });























////////////////////////
// Enums


////////////////////////
// Exports

//# sourceMappingURL=utils.js.map

/***/ }),

/***/ "./node_modules/hash.js/lib/hash.js":
/*!******************************************!*\
  !*** ./node_modules/hash.js/lib/hash.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var hash = exports;

hash.utils = __webpack_require__(/*! ./hash/utils */ "./node_modules/hash.js/lib/hash/utils.js");
hash.common = __webpack_require__(/*! ./hash/common */ "./node_modules/hash.js/lib/hash/common.js");
hash.sha = __webpack_require__(/*! ./hash/sha */ "./node_modules/hash.js/lib/hash/sha.js");
hash.ripemd = __webpack_require__(/*! ./hash/ripemd */ "./node_modules/hash.js/lib/hash/ripemd.js");
hash.hmac = __webpack_require__(/*! ./hash/hmac */ "./node_modules/hash.js/lib/hash/hmac.js");

// Proxy hash functions to the main object
hash.sha1 = hash.sha.sha1;
hash.sha256 = hash.sha.sha256;
hash.sha224 = hash.sha.sha224;
hash.sha384 = hash.sha.sha384;
hash.sha512 = hash.sha.sha512;
hash.ripemd160 = hash.ripemd.ripemd160;


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/common.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/common.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function BlockHash() {
  this.pending = null;
  this.pendingTotal = 0;
  this.blockSize = this.constructor.blockSize;
  this.outSize = this.constructor.outSize;
  this.hmacStrength = this.constructor.hmacStrength;
  this.padLength = this.constructor.padLength / 8;
  this.endian = 'big';

  this._delta8 = this.blockSize / 8;
  this._delta32 = this.blockSize / 32;
}
exports.BlockHash = BlockHash;

BlockHash.prototype.update = function update(msg, enc) {
  // Convert message to array, pad it, and join into 32bit blocks
  msg = utils.toArray(msg, enc);
  if (!this.pending)
    this.pending = msg;
  else
    this.pending = this.pending.concat(msg);
  this.pendingTotal += msg.length;

  // Enough data, try updating
  if (this.pending.length >= this._delta8) {
    msg = this.pending;

    // Process pending data in blocks
    var r = msg.length % this._delta8;
    this.pending = msg.slice(msg.length - r, msg.length);
    if (this.pending.length === 0)
      this.pending = null;

    msg = utils.join32(msg, 0, msg.length - r, this.endian);
    for (var i = 0; i < msg.length; i += this._delta32)
      this._update(msg, i, i + this._delta32);
  }

  return this;
};

BlockHash.prototype.digest = function digest(enc) {
  this.update(this._pad());
  assert(this.pending === null);

  return this._digest(enc);
};

BlockHash.prototype._pad = function pad() {
  var len = this.pendingTotal;
  var bytes = this._delta8;
  var k = bytes - ((len + this.padLength) % bytes);
  var res = new Array(k + this.padLength);
  res[0] = 0x80;
  for (var i = 1; i < k; i++)
    res[i] = 0;

  // Append length
  len <<= 3;
  if (this.endian === 'big') {
    for (var t = 8; t < this.padLength; t++)
      res[i++] = 0;

    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = len & 0xff;
  } else {
    res[i++] = len & 0xff;
    res[i++] = (len >>> 8) & 0xff;
    res[i++] = (len >>> 16) & 0xff;
    res[i++] = (len >>> 24) & 0xff;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;
    res[i++] = 0;

    for (t = 8; t < this.padLength; t++)
      res[i++] = 0;
  }

  return res;
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/hmac.js":
/*!***********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/hmac.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

function Hmac(hash, key, enc) {
  if (!(this instanceof Hmac))
    return new Hmac(hash, key, enc);
  this.Hash = hash;
  this.blockSize = hash.blockSize / 8;
  this.outSize = hash.outSize / 8;
  this.inner = null;
  this.outer = null;

  this._init(utils.toArray(key, enc));
}
module.exports = Hmac;

Hmac.prototype._init = function init(key) {
  // Shorten key, if needed
  if (key.length > this.blockSize)
    key = new this.Hash().update(key).digest();
  assert(key.length <= this.blockSize);

  // Add padding to key
  for (var i = key.length; i < this.blockSize; i++)
    key.push(0);

  for (i = 0; i < key.length; i++)
    key[i] ^= 0x36;
  this.inner = new this.Hash().update(key);

  // 0x36 ^ 0x5c = 0x6a
  for (i = 0; i < key.length; i++)
    key[i] ^= 0x6a;
  this.outer = new this.Hash().update(key);
};

Hmac.prototype.update = function update(msg, enc) {
  this.inner.update(msg, enc);
  return this;
};

Hmac.prototype.digest = function digest(enc) {
  this.outer.update(this.inner.digest());
  return this.outer.digest(enc);
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/ripemd.js":
/*!*************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/ripemd.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ./utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_3 = utils.sum32_3;
var sum32_4 = utils.sum32_4;
var BlockHash = common.BlockHash;

function RIPEMD160() {
  if (!(this instanceof RIPEMD160))
    return new RIPEMD160();

  BlockHash.call(this);

  this.h = [ 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0 ];
  this.endian = 'little';
}
utils.inherits(RIPEMD160, BlockHash);
exports.ripemd160 = RIPEMD160;

RIPEMD160.blockSize = 512;
RIPEMD160.outSize = 160;
RIPEMD160.hmacStrength = 192;
RIPEMD160.padLength = 64;

RIPEMD160.prototype._update = function update(msg, start) {
  var A = this.h[0];
  var B = this.h[1];
  var C = this.h[2];
  var D = this.h[3];
  var E = this.h[4];
  var Ah = A;
  var Bh = B;
  var Ch = C;
  var Dh = D;
  var Eh = E;
  for (var j = 0; j < 80; j++) {
    var T = sum32(
      rotl32(
        sum32_4(A, f(j, B, C, D), msg[r[j] + start], K(j)),
        s[j]),
      E);
    A = E;
    E = D;
    D = rotl32(C, 10);
    C = B;
    B = T;
    T = sum32(
      rotl32(
        sum32_4(Ah, f(79 - j, Bh, Ch, Dh), msg[rh[j] + start], Kh(j)),
        sh[j]),
      Eh);
    Ah = Eh;
    Eh = Dh;
    Dh = rotl32(Ch, 10);
    Ch = Bh;
    Bh = T;
  }
  T = sum32_3(this.h[1], C, Dh);
  this.h[1] = sum32_3(this.h[2], D, Eh);
  this.h[2] = sum32_3(this.h[3], E, Ah);
  this.h[3] = sum32_3(this.h[4], A, Bh);
  this.h[4] = sum32_3(this.h[0], B, Ch);
  this.h[0] = T;
};

RIPEMD160.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'little');
  else
    return utils.split32(this.h, 'little');
};

function f(j, x, y, z) {
  if (j <= 15)
    return x ^ y ^ z;
  else if (j <= 31)
    return (x & y) | ((~x) & z);
  else if (j <= 47)
    return (x | (~y)) ^ z;
  else if (j <= 63)
    return (x & z) | (y & (~z));
  else
    return x ^ (y | (~z));
}

function K(j) {
  if (j <= 15)
    return 0x00000000;
  else if (j <= 31)
    return 0x5a827999;
  else if (j <= 47)
    return 0x6ed9eba1;
  else if (j <= 63)
    return 0x8f1bbcdc;
  else
    return 0xa953fd4e;
}

function Kh(j) {
  if (j <= 15)
    return 0x50a28be6;
  else if (j <= 31)
    return 0x5c4dd124;
  else if (j <= 47)
    return 0x6d703ef3;
  else if (j <= 63)
    return 0x7a6d76e9;
  else
    return 0x00000000;
}

var r = [
  0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
  7, 4, 13, 1, 10, 6, 15, 3, 12, 0, 9, 5, 2, 14, 11, 8,
  3, 10, 14, 4, 9, 15, 8, 1, 2, 7, 0, 6, 13, 11, 5, 12,
  1, 9, 11, 10, 0, 8, 12, 4, 13, 3, 7, 15, 14, 5, 6, 2,
  4, 0, 5, 9, 7, 12, 2, 10, 14, 1, 3, 8, 11, 6, 15, 13
];

var rh = [
  5, 14, 7, 0, 9, 2, 11, 4, 13, 6, 15, 8, 1, 10, 3, 12,
  6, 11, 3, 7, 0, 13, 5, 10, 14, 15, 8, 12, 4, 9, 1, 2,
  15, 5, 1, 3, 7, 14, 6, 9, 11, 8, 12, 2, 10, 0, 4, 13,
  8, 6, 4, 1, 3, 11, 15, 0, 5, 12, 2, 13, 9, 7, 10, 14,
  12, 15, 10, 4, 1, 5, 8, 7, 6, 2, 13, 14, 0, 3, 9, 11
];

var s = [
  11, 14, 15, 12, 5, 8, 7, 9, 11, 13, 14, 15, 6, 7, 9, 8,
  7, 6, 8, 13, 11, 9, 7, 15, 7, 12, 15, 9, 11, 7, 13, 12,
  11, 13, 6, 7, 14, 9, 13, 15, 14, 8, 13, 6, 5, 12, 7, 5,
  11, 12, 14, 15, 14, 15, 9, 8, 9, 14, 5, 6, 8, 6, 5, 12,
  9, 15, 5, 11, 6, 8, 13, 12, 5, 12, 13, 14, 11, 8, 5, 6
];

var sh = [
  8, 9, 9, 11, 13, 15, 15, 5, 7, 7, 8, 11, 14, 14, 12, 6,
  9, 13, 15, 7, 12, 8, 9, 11, 7, 7, 12, 7, 6, 15, 13, 11,
  9, 7, 15, 11, 8, 6, 6, 14, 12, 13, 5, 14, 13, 13, 7, 5,
  15, 5, 8, 11, 14, 14, 6, 14, 6, 9, 12, 9, 12, 5, 15, 8,
  8, 5, 12, 9, 12, 5, 14, 6, 8, 13, 6, 5, 15, 13, 11, 11
];


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha.js":
/*!**********************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


exports.sha1 = __webpack_require__(/*! ./sha/1 */ "./node_modules/hash.js/lib/hash/sha/1.js");
exports.sha224 = __webpack_require__(/*! ./sha/224 */ "./node_modules/hash.js/lib/hash/sha/224.js");
exports.sha256 = __webpack_require__(/*! ./sha/256 */ "./node_modules/hash.js/lib/hash/sha/256.js");
exports.sha384 = __webpack_require__(/*! ./sha/384 */ "./node_modules/hash.js/lib/hash/sha/384.js");
exports.sha512 = __webpack_require__(/*! ./sha/512 */ "./node_modules/hash.js/lib/hash/sha/512.js");


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/1.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/1.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/sha/common.js");

var rotl32 = utils.rotl32;
var sum32 = utils.sum32;
var sum32_5 = utils.sum32_5;
var ft_1 = shaCommon.ft_1;
var BlockHash = common.BlockHash;

var sha1_K = [
  0x5A827999, 0x6ED9EBA1,
  0x8F1BBCDC, 0xCA62C1D6
];

function SHA1() {
  if (!(this instanceof SHA1))
    return new SHA1();

  BlockHash.call(this);
  this.h = [
    0x67452301, 0xefcdab89, 0x98badcfe,
    0x10325476, 0xc3d2e1f0 ];
  this.W = new Array(80);
}

utils.inherits(SHA1, BlockHash);
module.exports = SHA1;

SHA1.blockSize = 512;
SHA1.outSize = 160;
SHA1.hmacStrength = 80;
SHA1.padLength = 64;

SHA1.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];

  for(; i < W.length; i++)
    W[i] = rotl32(W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16], 1);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];

  for (i = 0; i < W.length; i++) {
    var s = ~~(i / 20);
    var t = sum32_5(rotl32(a, 5), ft_1(s, b, c, d), e, W[i], sha1_K[s]);
    e = d;
    d = c;
    c = rotl32(b, 30);
    b = a;
    a = t;
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
};

SHA1.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/224.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/224.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var SHA256 = __webpack_require__(/*! ./256 */ "./node_modules/hash.js/lib/hash/sha/256.js");

function SHA224() {
  if (!(this instanceof SHA224))
    return new SHA224();

  SHA256.call(this);
  this.h = [
    0xc1059ed8, 0x367cd507, 0x3070dd17, 0xf70e5939,
    0xffc00b31, 0x68581511, 0x64f98fa7, 0xbefa4fa4 ];
}
utils.inherits(SHA224, SHA256);
module.exports = SHA224;

SHA224.blockSize = 512;
SHA224.outSize = 224;
SHA224.hmacStrength = 192;
SHA224.padLength = 64;

SHA224.prototype._digest = function digest(enc) {
  // Just truncate output
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 7), 'big');
  else
    return utils.split32(this.h.slice(0, 7), 'big');
};



/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/256.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/256.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var shaCommon = __webpack_require__(/*! ./common */ "./node_modules/hash.js/lib/hash/sha/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var sum32 = utils.sum32;
var sum32_4 = utils.sum32_4;
var sum32_5 = utils.sum32_5;
var ch32 = shaCommon.ch32;
var maj32 = shaCommon.maj32;
var s0_256 = shaCommon.s0_256;
var s1_256 = shaCommon.s1_256;
var g0_256 = shaCommon.g0_256;
var g1_256 = shaCommon.g1_256;

var BlockHash = common.BlockHash;

var sha256_K = [
  0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5,
  0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5,
  0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3,
  0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174,
  0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
  0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da,
  0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7,
  0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967,
  0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13,
  0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
  0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3,
  0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070,
  0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5,
  0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3,
  0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
  0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
];

function SHA256() {
  if (!(this instanceof SHA256))
    return new SHA256();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a,
    0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19
  ];
  this.k = sha256_K;
  this.W = new Array(64);
}
utils.inherits(SHA256, BlockHash);
module.exports = SHA256;

SHA256.blockSize = 512;
SHA256.outSize = 256;
SHA256.hmacStrength = 192;
SHA256.padLength = 64;

SHA256.prototype._update = function _update(msg, start) {
  var W = this.W;

  for (var i = 0; i < 16; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i++)
    W[i] = sum32_4(g1_256(W[i - 2]), W[i - 7], g0_256(W[i - 15]), W[i - 16]);

  var a = this.h[0];
  var b = this.h[1];
  var c = this.h[2];
  var d = this.h[3];
  var e = this.h[4];
  var f = this.h[5];
  var g = this.h[6];
  var h = this.h[7];

  assert(this.k.length === W.length);
  for (i = 0; i < W.length; i++) {
    var T1 = sum32_5(h, s1_256(e), ch32(e, f, g), this.k[i], W[i]);
    var T2 = sum32(s0_256(a), maj32(a, b, c));
    h = g;
    g = f;
    f = e;
    e = sum32(d, T1);
    d = c;
    c = b;
    b = a;
    a = sum32(T1, T2);
  }

  this.h[0] = sum32(this.h[0], a);
  this.h[1] = sum32(this.h[1], b);
  this.h[2] = sum32(this.h[2], c);
  this.h[3] = sum32(this.h[3], d);
  this.h[4] = sum32(this.h[4], e);
  this.h[5] = sum32(this.h[5], f);
  this.h[6] = sum32(this.h[6], g);
  this.h[7] = sum32(this.h[7], h);
};

SHA256.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/384.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/384.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");

var SHA512 = __webpack_require__(/*! ./512 */ "./node_modules/hash.js/lib/hash/sha/512.js");

function SHA384() {
  if (!(this instanceof SHA384))
    return new SHA384();

  SHA512.call(this);
  this.h = [
    0xcbbb9d5d, 0xc1059ed8,
    0x629a292a, 0x367cd507,
    0x9159015a, 0x3070dd17,
    0x152fecd8, 0xf70e5939,
    0x67332667, 0xffc00b31,
    0x8eb44a87, 0x68581511,
    0xdb0c2e0d, 0x64f98fa7,
    0x47b5481d, 0xbefa4fa4 ];
}
utils.inherits(SHA384, SHA512);
module.exports = SHA384;

SHA384.blockSize = 1024;
SHA384.outSize = 384;
SHA384.hmacStrength = 192;
SHA384.padLength = 128;

SHA384.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h.slice(0, 12), 'big');
  else
    return utils.split32(this.h.slice(0, 12), 'big');
};


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/512.js":
/*!**************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/512.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var common = __webpack_require__(/*! ../common */ "./node_modules/hash.js/lib/hash/common.js");
var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");

var rotr64_hi = utils.rotr64_hi;
var rotr64_lo = utils.rotr64_lo;
var shr64_hi = utils.shr64_hi;
var shr64_lo = utils.shr64_lo;
var sum64 = utils.sum64;
var sum64_hi = utils.sum64_hi;
var sum64_lo = utils.sum64_lo;
var sum64_4_hi = utils.sum64_4_hi;
var sum64_4_lo = utils.sum64_4_lo;
var sum64_5_hi = utils.sum64_5_hi;
var sum64_5_lo = utils.sum64_5_lo;

var BlockHash = common.BlockHash;

var sha512_K = [
  0x428a2f98, 0xd728ae22, 0x71374491, 0x23ef65cd,
  0xb5c0fbcf, 0xec4d3b2f, 0xe9b5dba5, 0x8189dbbc,
  0x3956c25b, 0xf348b538, 0x59f111f1, 0xb605d019,
  0x923f82a4, 0xaf194f9b, 0xab1c5ed5, 0xda6d8118,
  0xd807aa98, 0xa3030242, 0x12835b01, 0x45706fbe,
  0x243185be, 0x4ee4b28c, 0x550c7dc3, 0xd5ffb4e2,
  0x72be5d74, 0xf27b896f, 0x80deb1fe, 0x3b1696b1,
  0x9bdc06a7, 0x25c71235, 0xc19bf174, 0xcf692694,
  0xe49b69c1, 0x9ef14ad2, 0xefbe4786, 0x384f25e3,
  0x0fc19dc6, 0x8b8cd5b5, 0x240ca1cc, 0x77ac9c65,
  0x2de92c6f, 0x592b0275, 0x4a7484aa, 0x6ea6e483,
  0x5cb0a9dc, 0xbd41fbd4, 0x76f988da, 0x831153b5,
  0x983e5152, 0xee66dfab, 0xa831c66d, 0x2db43210,
  0xb00327c8, 0x98fb213f, 0xbf597fc7, 0xbeef0ee4,
  0xc6e00bf3, 0x3da88fc2, 0xd5a79147, 0x930aa725,
  0x06ca6351, 0xe003826f, 0x14292967, 0x0a0e6e70,
  0x27b70a85, 0x46d22ffc, 0x2e1b2138, 0x5c26c926,
  0x4d2c6dfc, 0x5ac42aed, 0x53380d13, 0x9d95b3df,
  0x650a7354, 0x8baf63de, 0x766a0abb, 0x3c77b2a8,
  0x81c2c92e, 0x47edaee6, 0x92722c85, 0x1482353b,
  0xa2bfe8a1, 0x4cf10364, 0xa81a664b, 0xbc423001,
  0xc24b8b70, 0xd0f89791, 0xc76c51a3, 0x0654be30,
  0xd192e819, 0xd6ef5218, 0xd6990624, 0x5565a910,
  0xf40e3585, 0x5771202a, 0x106aa070, 0x32bbd1b8,
  0x19a4c116, 0xb8d2d0c8, 0x1e376c08, 0x5141ab53,
  0x2748774c, 0xdf8eeb99, 0x34b0bcb5, 0xe19b48a8,
  0x391c0cb3, 0xc5c95a63, 0x4ed8aa4a, 0xe3418acb,
  0x5b9cca4f, 0x7763e373, 0x682e6ff3, 0xd6b2b8a3,
  0x748f82ee, 0x5defb2fc, 0x78a5636f, 0x43172f60,
  0x84c87814, 0xa1f0ab72, 0x8cc70208, 0x1a6439ec,
  0x90befffa, 0x23631e28, 0xa4506ceb, 0xde82bde9,
  0xbef9a3f7, 0xb2c67915, 0xc67178f2, 0xe372532b,
  0xca273ece, 0xea26619c, 0xd186b8c7, 0x21c0c207,
  0xeada7dd6, 0xcde0eb1e, 0xf57d4f7f, 0xee6ed178,
  0x06f067aa, 0x72176fba, 0x0a637dc5, 0xa2c898a6,
  0x113f9804, 0xbef90dae, 0x1b710b35, 0x131c471b,
  0x28db77f5, 0x23047d84, 0x32caab7b, 0x40c72493,
  0x3c9ebe0a, 0x15c9bebc, 0x431d67c4, 0x9c100d4c,
  0x4cc5d4be, 0xcb3e42b6, 0x597f299c, 0xfc657e2a,
  0x5fcb6fab, 0x3ad6faec, 0x6c44198c, 0x4a475817
];

function SHA512() {
  if (!(this instanceof SHA512))
    return new SHA512();

  BlockHash.call(this);
  this.h = [
    0x6a09e667, 0xf3bcc908,
    0xbb67ae85, 0x84caa73b,
    0x3c6ef372, 0xfe94f82b,
    0xa54ff53a, 0x5f1d36f1,
    0x510e527f, 0xade682d1,
    0x9b05688c, 0x2b3e6c1f,
    0x1f83d9ab, 0xfb41bd6b,
    0x5be0cd19, 0x137e2179 ];
  this.k = sha512_K;
  this.W = new Array(160);
}
utils.inherits(SHA512, BlockHash);
module.exports = SHA512;

SHA512.blockSize = 1024;
SHA512.outSize = 512;
SHA512.hmacStrength = 192;
SHA512.padLength = 128;

SHA512.prototype._prepareBlock = function _prepareBlock(msg, start) {
  var W = this.W;

  // 32 x 32bit words
  for (var i = 0; i < 32; i++)
    W[i] = msg[start + i];
  for (; i < W.length; i += 2) {
    var c0_hi = g1_512_hi(W[i - 4], W[i - 3]);  // i - 2
    var c0_lo = g1_512_lo(W[i - 4], W[i - 3]);
    var c1_hi = W[i - 14];  // i - 7
    var c1_lo = W[i - 13];
    var c2_hi = g0_512_hi(W[i - 30], W[i - 29]);  // i - 15
    var c2_lo = g0_512_lo(W[i - 30], W[i - 29]);
    var c3_hi = W[i - 32];  // i - 16
    var c3_lo = W[i - 31];

    W[i] = sum64_4_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
    W[i + 1] = sum64_4_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo);
  }
};

SHA512.prototype._update = function _update(msg, start) {
  this._prepareBlock(msg, start);

  var W = this.W;

  var ah = this.h[0];
  var al = this.h[1];
  var bh = this.h[2];
  var bl = this.h[3];
  var ch = this.h[4];
  var cl = this.h[5];
  var dh = this.h[6];
  var dl = this.h[7];
  var eh = this.h[8];
  var el = this.h[9];
  var fh = this.h[10];
  var fl = this.h[11];
  var gh = this.h[12];
  var gl = this.h[13];
  var hh = this.h[14];
  var hl = this.h[15];

  assert(this.k.length === W.length);
  for (var i = 0; i < W.length; i += 2) {
    var c0_hi = hh;
    var c0_lo = hl;
    var c1_hi = s1_512_hi(eh, el);
    var c1_lo = s1_512_lo(eh, el);
    var c2_hi = ch64_hi(eh, el, fh, fl, gh, gl);
    var c2_lo = ch64_lo(eh, el, fh, fl, gh, gl);
    var c3_hi = this.k[i];
    var c3_lo = this.k[i + 1];
    var c4_hi = W[i];
    var c4_lo = W[i + 1];

    var T1_hi = sum64_5_hi(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);
    var T1_lo = sum64_5_lo(
      c0_hi, c0_lo,
      c1_hi, c1_lo,
      c2_hi, c2_lo,
      c3_hi, c3_lo,
      c4_hi, c4_lo);

    c0_hi = s0_512_hi(ah, al);
    c0_lo = s0_512_lo(ah, al);
    c1_hi = maj64_hi(ah, al, bh, bl, ch, cl);
    c1_lo = maj64_lo(ah, al, bh, bl, ch, cl);

    var T2_hi = sum64_hi(c0_hi, c0_lo, c1_hi, c1_lo);
    var T2_lo = sum64_lo(c0_hi, c0_lo, c1_hi, c1_lo);

    hh = gh;
    hl = gl;

    gh = fh;
    gl = fl;

    fh = eh;
    fl = el;

    eh = sum64_hi(dh, dl, T1_hi, T1_lo);
    el = sum64_lo(dl, dl, T1_hi, T1_lo);

    dh = ch;
    dl = cl;

    ch = bh;
    cl = bl;

    bh = ah;
    bl = al;

    ah = sum64_hi(T1_hi, T1_lo, T2_hi, T2_lo);
    al = sum64_lo(T1_hi, T1_lo, T2_hi, T2_lo);
  }

  sum64(this.h, 0, ah, al);
  sum64(this.h, 2, bh, bl);
  sum64(this.h, 4, ch, cl);
  sum64(this.h, 6, dh, dl);
  sum64(this.h, 8, eh, el);
  sum64(this.h, 10, fh, fl);
  sum64(this.h, 12, gh, gl);
  sum64(this.h, 14, hh, hl);
};

SHA512.prototype._digest = function digest(enc) {
  if (enc === 'hex')
    return utils.toHex32(this.h, 'big');
  else
    return utils.split32(this.h, 'big');
};

function ch64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ ((~xh) & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function ch64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ ((~xl) & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_hi(xh, xl, yh, yl, zh) {
  var r = (xh & yh) ^ (xh & zh) ^ (yh & zh);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function maj64_lo(xh, xl, yh, yl, zh, zl) {
  var r = (xl & yl) ^ (xl & zl) ^ (yl & zl);
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 28);
  var c1_hi = rotr64_hi(xl, xh, 2);  // 34
  var c2_hi = rotr64_hi(xl, xh, 7);  // 39

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 28);
  var c1_lo = rotr64_lo(xl, xh, 2);  // 34
  var c2_lo = rotr64_lo(xl, xh, 7);  // 39

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 14);
  var c1_hi = rotr64_hi(xh, xl, 18);
  var c2_hi = rotr64_hi(xl, xh, 9);  // 41

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function s1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 14);
  var c1_lo = rotr64_lo(xh, xl, 18);
  var c2_lo = rotr64_lo(xl, xh, 9);  // 41

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 1);
  var c1_hi = rotr64_hi(xh, xl, 8);
  var c2_hi = shr64_hi(xh, xl, 7);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g0_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 1);
  var c1_lo = rotr64_lo(xh, xl, 8);
  var c2_lo = shr64_lo(xh, xl, 7);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_hi(xh, xl) {
  var c0_hi = rotr64_hi(xh, xl, 19);
  var c1_hi = rotr64_hi(xl, xh, 29);  // 61
  var c2_hi = shr64_hi(xh, xl, 6);

  var r = c0_hi ^ c1_hi ^ c2_hi;
  if (r < 0)
    r += 0x100000000;
  return r;
}

function g1_512_lo(xh, xl) {
  var c0_lo = rotr64_lo(xh, xl, 19);
  var c1_lo = rotr64_lo(xl, xh, 29);  // 61
  var c2_lo = shr64_lo(xh, xl, 6);

  var r = c0_lo ^ c1_lo ^ c2_lo;
  if (r < 0)
    r += 0x100000000;
  return r;
}


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/sha/common.js":
/*!*****************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/sha/common.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__(/*! ../utils */ "./node_modules/hash.js/lib/hash/utils.js");
var rotr32 = utils.rotr32;

function ft_1(s, x, y, z) {
  if (s === 0)
    return ch32(x, y, z);
  if (s === 1 || s === 3)
    return p32(x, y, z);
  if (s === 2)
    return maj32(x, y, z);
}
exports.ft_1 = ft_1;

function ch32(x, y, z) {
  return (x & y) ^ ((~x) & z);
}
exports.ch32 = ch32;

function maj32(x, y, z) {
  return (x & y) ^ (x & z) ^ (y & z);
}
exports.maj32 = maj32;

function p32(x, y, z) {
  return x ^ y ^ z;
}
exports.p32 = p32;

function s0_256(x) {
  return rotr32(x, 2) ^ rotr32(x, 13) ^ rotr32(x, 22);
}
exports.s0_256 = s0_256;

function s1_256(x) {
  return rotr32(x, 6) ^ rotr32(x, 11) ^ rotr32(x, 25);
}
exports.s1_256 = s1_256;

function g0_256(x) {
  return rotr32(x, 7) ^ rotr32(x, 18) ^ (x >>> 3);
}
exports.g0_256 = g0_256;

function g1_256(x) {
  return rotr32(x, 17) ^ rotr32(x, 19) ^ (x >>> 10);
}
exports.g1_256 = g1_256;


/***/ }),

/***/ "./node_modules/hash.js/lib/hash/utils.js":
/*!************************************************!*\
  !*** ./node_modules/hash.js/lib/hash/utils.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var assert = __webpack_require__(/*! minimalistic-assert */ "./node_modules/minimalistic-assert/index.js");
var inherits = __webpack_require__(/*! inherits */ "./node_modules/inherits/inherits_browser.js");

exports.inherits = inherits;

function isSurrogatePair(msg, i) {
  if ((msg.charCodeAt(i) & 0xFC00) !== 0xD800) {
    return false;
  }
  if (i < 0 || i + 1 >= msg.length) {
    return false;
  }
  return (msg.charCodeAt(i + 1) & 0xFC00) === 0xDC00;
}

function toArray(msg, enc) {
  if (Array.isArray(msg))
    return msg.slice();
  if (!msg)
    return [];
  var res = [];
  if (typeof msg === 'string') {
    if (!enc) {
      // Inspired by stringToUtf8ByteArray() in closure-library by Google
      // https://github.com/google/closure-library/blob/8598d87242af59aac233270742c8984e2b2bdbe0/closure/goog/crypt/crypt.js#L117-L143
      // Apache License 2.0
      // https://github.com/google/closure-library/blob/master/LICENSE
      var p = 0;
      for (var i = 0; i < msg.length; i++) {
        var c = msg.charCodeAt(i);
        if (c < 128) {
          res[p++] = c;
        } else if (c < 2048) {
          res[p++] = (c >> 6) | 192;
          res[p++] = (c & 63) | 128;
        } else if (isSurrogatePair(msg, i)) {
          c = 0x10000 + ((c & 0x03FF) << 10) + (msg.charCodeAt(++i) & 0x03FF);
          res[p++] = (c >> 18) | 240;
          res[p++] = ((c >> 12) & 63) | 128;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        } else {
          res[p++] = (c >> 12) | 224;
          res[p++] = ((c >> 6) & 63) | 128;
          res[p++] = (c & 63) | 128;
        }
      }
    } else if (enc === 'hex') {
      msg = msg.replace(/[^a-z0-9]+/ig, '');
      if (msg.length % 2 !== 0)
        msg = '0' + msg;
      for (i = 0; i < msg.length; i += 2)
        res.push(parseInt(msg[i] + msg[i + 1], 16));
    }
  } else {
    for (i = 0; i < msg.length; i++)
      res[i] = msg[i] | 0;
  }
  return res;
}
exports.toArray = toArray;

function toHex(msg) {
  var res = '';
  for (var i = 0; i < msg.length; i++)
    res += zero2(msg[i].toString(16));
  return res;
}
exports.toHex = toHex;

function htonl(w) {
  var res = (w >>> 24) |
            ((w >>> 8) & 0xff00) |
            ((w << 8) & 0xff0000) |
            ((w & 0xff) << 24);
  return res >>> 0;
}
exports.htonl = htonl;

function toHex32(msg, endian) {
  var res = '';
  for (var i = 0; i < msg.length; i++) {
    var w = msg[i];
    if (endian === 'little')
      w = htonl(w);
    res += zero8(w.toString(16));
  }
  return res;
}
exports.toHex32 = toHex32;

function zero2(word) {
  if (word.length === 1)
    return '0' + word;
  else
    return word;
}
exports.zero2 = zero2;

function zero8(word) {
  if (word.length === 7)
    return '0' + word;
  else if (word.length === 6)
    return '00' + word;
  else if (word.length === 5)
    return '000' + word;
  else if (word.length === 4)
    return '0000' + word;
  else if (word.length === 3)
    return '00000' + word;
  else if (word.length === 2)
    return '000000' + word;
  else if (word.length === 1)
    return '0000000' + word;
  else
    return word;
}
exports.zero8 = zero8;

function join32(msg, start, end, endian) {
  var len = end - start;
  assert(len % 4 === 0);
  var res = new Array(len / 4);
  for (var i = 0, k = start; i < res.length; i++, k += 4) {
    var w;
    if (endian === 'big')
      w = (msg[k] << 24) | (msg[k + 1] << 16) | (msg[k + 2] << 8) | msg[k + 3];
    else
      w = (msg[k + 3] << 24) | (msg[k + 2] << 16) | (msg[k + 1] << 8) | msg[k];
    res[i] = w >>> 0;
  }
  return res;
}
exports.join32 = join32;

function split32(msg, endian) {
  var res = new Array(msg.length * 4);
  for (var i = 0, k = 0; i < msg.length; i++, k += 4) {
    var m = msg[i];
    if (endian === 'big') {
      res[k] = m >>> 24;
      res[k + 1] = (m >>> 16) & 0xff;
      res[k + 2] = (m >>> 8) & 0xff;
      res[k + 3] = m & 0xff;
    } else {
      res[k + 3] = m >>> 24;
      res[k + 2] = (m >>> 16) & 0xff;
      res[k + 1] = (m >>> 8) & 0xff;
      res[k] = m & 0xff;
    }
  }
  return res;
}
exports.split32 = split32;

function rotr32(w, b) {
  return (w >>> b) | (w << (32 - b));
}
exports.rotr32 = rotr32;

function rotl32(w, b) {
  return (w << b) | (w >>> (32 - b));
}
exports.rotl32 = rotl32;

function sum32(a, b) {
  return (a + b) >>> 0;
}
exports.sum32 = sum32;

function sum32_3(a, b, c) {
  return (a + b + c) >>> 0;
}
exports.sum32_3 = sum32_3;

function sum32_4(a, b, c, d) {
  return (a + b + c + d) >>> 0;
}
exports.sum32_4 = sum32_4;

function sum32_5(a, b, c, d, e) {
  return (a + b + c + d + e) >>> 0;
}
exports.sum32_5 = sum32_5;

function sum64(buf, pos, ah, al) {
  var bh = buf[pos];
  var bl = buf[pos + 1];

  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  buf[pos] = hi >>> 0;
  buf[pos + 1] = lo;
}
exports.sum64 = sum64;

function sum64_hi(ah, al, bh, bl) {
  var lo = (al + bl) >>> 0;
  var hi = (lo < al ? 1 : 0) + ah + bh;
  return hi >>> 0;
}
exports.sum64_hi = sum64_hi;

function sum64_lo(ah, al, bh, bl) {
  var lo = al + bl;
  return lo >>> 0;
}
exports.sum64_lo = sum64_lo;

function sum64_4_hi(ah, al, bh, bl, ch, cl, dh, dl) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;

  var hi = ah + bh + ch + dh + carry;
  return hi >>> 0;
}
exports.sum64_4_hi = sum64_4_hi;

function sum64_4_lo(ah, al, bh, bl, ch, cl, dh, dl) {
  var lo = al + bl + cl + dl;
  return lo >>> 0;
}
exports.sum64_4_lo = sum64_4_lo;

function sum64_5_hi(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var carry = 0;
  var lo = al;
  lo = (lo + bl) >>> 0;
  carry += lo < al ? 1 : 0;
  lo = (lo + cl) >>> 0;
  carry += lo < cl ? 1 : 0;
  lo = (lo + dl) >>> 0;
  carry += lo < dl ? 1 : 0;
  lo = (lo + el) >>> 0;
  carry += lo < el ? 1 : 0;

  var hi = ah + bh + ch + dh + eh + carry;
  return hi >>> 0;
}
exports.sum64_5_hi = sum64_5_hi;

function sum64_5_lo(ah, al, bh, bl, ch, cl, dh, dl, eh, el) {
  var lo = al + bl + cl + dl + el;

  return lo >>> 0;
}
exports.sum64_5_lo = sum64_5_lo;

function rotr64_hi(ah, al, num) {
  var r = (al << (32 - num)) | (ah >>> num);
  return r >>> 0;
}
exports.rotr64_hi = rotr64_hi;

function rotr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.rotr64_lo = rotr64_lo;

function shr64_hi(ah, al, num) {
  return ah >>> num;
}
exports.shr64_hi = shr64_hi;

function shr64_lo(ah, al, num) {
  var r = (ah << (32 - num)) | (al >>> num);
  return r >>> 0;
}
exports.shr64_lo = shr64_lo;


/***/ }),

/***/ "./node_modules/inherits/inherits_browser.js":
/*!***************************************************!*\
  !*** ./node_modules/inherits/inherits_browser.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

if (typeof Object.create === 'function') {
  // implementation from standard node.js 'util' module
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      ctor.prototype = Object.create(superCtor.prototype, {
        constructor: {
          value: ctor,
          enumerable: false,
          writable: true,
          configurable: true
        }
      })
    }
  };
} else {
  // old school shim for old browsers
  module.exports = function inherits(ctor, superCtor) {
    if (superCtor) {
      ctor.super_ = superCtor
      var TempCtor = function () {}
      TempCtor.prototype = superCtor.prototype
      ctor.prototype = new TempCtor()
      ctor.prototype.constructor = ctor
    }
  }
}


/***/ }),

/***/ "./node_modules/js-sha3/src/sha3.js":
/*!******************************************!*\
  !*** ./node_modules/js-sha3/src/sha3.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process, global) {var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * [js-sha3]{@link https://github.com/emn178/js-sha3}
 *
 * @version 0.8.0
 * @author Chen, Yi-Cyuan [emn178@gmail.com]
 * @copyright Chen, Yi-Cyuan 2015-2018
 * @license MIT
 */
/*jslint bitwise: true */
(function () {
  'use strict';

  var INPUT_ERROR = 'input is invalid type';
  var FINALIZE_ERROR = 'finalize already called';
  var WINDOW = typeof window === 'object';
  var root = WINDOW ? window : {};
  if (root.JS_SHA3_NO_WINDOW) {
    WINDOW = false;
  }
  var WEB_WORKER = !WINDOW && typeof self === 'object';
  var NODE_JS = !root.JS_SHA3_NO_NODE_JS && typeof process === 'object' && process.versions && process.versions.node;
  if (NODE_JS) {
    root = global;
  } else if (WEB_WORKER) {
    root = self;
  }
  var COMMON_JS = !root.JS_SHA3_NO_COMMON_JS && typeof module === 'object' && module.exports;
  var AMD =  true && __webpack_require__(/*! !webpack amd options */ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/amd-options.js");
  var ARRAY_BUFFER = !root.JS_SHA3_NO_ARRAY_BUFFER && typeof ArrayBuffer !== 'undefined';
  var HEX_CHARS = '0123456789abcdef'.split('');
  var SHAKE_PADDING = [31, 7936, 2031616, 520093696];
  var CSHAKE_PADDING = [4, 1024, 262144, 67108864];
  var KECCAK_PADDING = [1, 256, 65536, 16777216];
  var PADDING = [6, 1536, 393216, 100663296];
  var SHIFT = [0, 8, 16, 24];
  var RC = [1, 0, 32898, 0, 32906, 2147483648, 2147516416, 2147483648, 32907, 0, 2147483649,
    0, 2147516545, 2147483648, 32777, 2147483648, 138, 0, 136, 0, 2147516425, 0,
    2147483658, 0, 2147516555, 0, 139, 2147483648, 32905, 2147483648, 32771,
    2147483648, 32770, 2147483648, 128, 2147483648, 32778, 0, 2147483658, 2147483648,
    2147516545, 2147483648, 32896, 2147483648, 2147483649, 0, 2147516424, 2147483648];
  var BITS = [224, 256, 384, 512];
  var SHAKE_BITS = [128, 256];
  var OUTPUT_TYPES = ['hex', 'buffer', 'arrayBuffer', 'array', 'digest'];
  var CSHAKE_BYTEPAD = {
    '128': 168,
    '256': 136
  };

  if (root.JS_SHA3_NO_NODE_JS || !Array.isArray) {
    Array.isArray = function (obj) {
      return Object.prototype.toString.call(obj) === '[object Array]';
    };
  }

  if (ARRAY_BUFFER && (root.JS_SHA3_NO_ARRAY_BUFFER_IS_VIEW || !ArrayBuffer.isView)) {
    ArrayBuffer.isView = function (obj) {
      return typeof obj === 'object' && obj.buffer && obj.buffer.constructor === ArrayBuffer;
    };
  }

  var createOutputMethod = function (bits, padding, outputType) {
    return function (message) {
      return new Keccak(bits, padding, bits).update(message)[outputType]();
    };
  };

  var createShakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits) {
      return new Keccak(bits, padding, outputBits).update(message)[outputType]();
    };
  };

  var createCshakeOutputMethod = function (bits, padding, outputType) {
    return function (message, outputBits, n, s) {
      return methods['cshake' + bits].update(message, outputBits, n, s)[outputType]();
    };
  };

  var createKmacOutputMethod = function (bits, padding, outputType) {
    return function (key, message, outputBits, s) {
      return methods['kmac' + bits].update(key, message, outputBits, s)[outputType]();
    };
  };

  var createOutputMethods = function (method, createMethod, bits, padding) {
    for (var i = 0; i < OUTPUT_TYPES.length; ++i) {
      var type = OUTPUT_TYPES[i];
      method[type] = createMethod(bits, padding, type);
    }
    return method;
  };

  var createMethod = function (bits, padding) {
    var method = createOutputMethod(bits, padding, 'hex');
    method.create = function () {
      return new Keccak(bits, padding, bits);
    };
    method.update = function (message) {
      return method.create().update(message);
    };
    return createOutputMethods(method, createOutputMethod, bits, padding);
  };

  var createShakeMethod = function (bits, padding) {
    var method = createShakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits) {
      return new Keccak(bits, padding, outputBits);
    };
    method.update = function (message, outputBits) {
      return method.create(outputBits).update(message);
    };
    return createOutputMethods(method, createShakeOutputMethod, bits, padding);
  };

  var createCshakeMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createCshakeOutputMethod(bits, padding, 'hex');
    method.create = function (outputBits, n, s) {
      if (!n && !s) {
        return methods['shake' + bits].create(outputBits);
      } else {
        return new Keccak(bits, padding, outputBits).bytepad([n, s], w);
      }
    };
    method.update = function (message, outputBits, n, s) {
      return method.create(outputBits, n, s).update(message);
    };
    return createOutputMethods(method, createCshakeOutputMethod, bits, padding);
  };

  var createKmacMethod = function (bits, padding) {
    var w = CSHAKE_BYTEPAD[bits];
    var method = createKmacOutputMethod(bits, padding, 'hex');
    method.create = function (key, outputBits, s) {
      return new Kmac(bits, padding, outputBits).bytepad(['KMAC', s], w).bytepad([key], w);
    };
    method.update = function (key, message, outputBits, s) {
      return method.create(key, outputBits, s).update(message);
    };
    return createOutputMethods(method, createKmacOutputMethod, bits, padding);
  };

  var algorithms = [
    { name: 'keccak', padding: KECCAK_PADDING, bits: BITS, createMethod: createMethod },
    { name: 'sha3', padding: PADDING, bits: BITS, createMethod: createMethod },
    { name: 'shake', padding: SHAKE_PADDING, bits: SHAKE_BITS, createMethod: createShakeMethod },
    { name: 'cshake', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createCshakeMethod },
    { name: 'kmac', padding: CSHAKE_PADDING, bits: SHAKE_BITS, createMethod: createKmacMethod }
  ];

  var methods = {}, methodNames = [];

  for (var i = 0; i < algorithms.length; ++i) {
    var algorithm = algorithms[i];
    var bits = algorithm.bits;
    for (var j = 0; j < bits.length; ++j) {
      var methodName = algorithm.name + '_' + bits[j];
      methodNames.push(methodName);
      methods[methodName] = algorithm.createMethod(bits[j], algorithm.padding);
      if (algorithm.name !== 'sha3') {
        var newMethodName = algorithm.name + bits[j];
        methodNames.push(newMethodName);
        methods[newMethodName] = methods[methodName];
      }
    }
  }

  function Keccak(bits, padding, outputBits) {
    this.blocks = [];
    this.s = [];
    this.padding = padding;
    this.outputBits = outputBits;
    this.reset = true;
    this.finalized = false;
    this.block = 0;
    this.start = 0;
    this.blockCount = (1600 - (bits << 1)) >> 5;
    this.byteCount = this.blockCount << 2;
    this.outputBlocks = outputBits >> 5;
    this.extraBytes = (outputBits & 31) >> 3;

    for (var i = 0; i < 50; ++i) {
      this.s[i] = 0;
    }
  }

  Keccak.prototype.update = function (message) {
    if (this.finalized) {
      throw new Error(FINALIZE_ERROR);
    }
    var notString, type = typeof message;
    if (type !== 'string') {
      if (type === 'object') {
        if (message === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && message.constructor === ArrayBuffer) {
          message = new Uint8Array(message);
        } else if (!Array.isArray(message)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(message)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var blocks = this.blocks, byteCount = this.byteCount, length = message.length,
      blockCount = this.blockCount, index = 0, s = this.s, i, code;

    while (index < length) {
      if (this.reset) {
        this.reset = false;
        blocks[0] = this.block;
        for (i = 1; i < blockCount + 1; ++i) {
          blocks[i] = 0;
        }
      }
      if (notString) {
        for (i = this.start; index < length && i < byteCount; ++index) {
          blocks[i >> 2] |= message[index] << SHIFT[i++ & 3];
        }
      } else {
        for (i = this.start; index < length && i < byteCount; ++index) {
          code = message.charCodeAt(index);
          if (code < 0x80) {
            blocks[i >> 2] |= code << SHIFT[i++ & 3];
          } else if (code < 0x800) {
            blocks[i >> 2] |= (0xc0 | (code >> 6)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else if (code < 0xd800 || code >= 0xe000) {
            blocks[i >> 2] |= (0xe0 | (code >> 12)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          } else {
            code = 0x10000 + (((code & 0x3ff) << 10) | (message.charCodeAt(++index) & 0x3ff));
            blocks[i >> 2] |= (0xf0 | (code >> 18)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 12) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | ((code >> 6) & 0x3f)) << SHIFT[i++ & 3];
            blocks[i >> 2] |= (0x80 | (code & 0x3f)) << SHIFT[i++ & 3];
          }
        }
      }
      this.lastByteIndex = i;
      if (i >= byteCount) {
        this.start = i - byteCount;
        this.block = blocks[blockCount];
        for (i = 0; i < blockCount; ++i) {
          s[i] ^= blocks[i];
        }
        f(s);
        this.reset = true;
      } else {
        this.start = i;
      }
    }
    return this;
  };

  Keccak.prototype.encode = function (x, right) {
    var o = x & 255, n = 1;
    var bytes = [o];
    x = x >> 8;
    o = x & 255;
    while (o > 0) {
      bytes.unshift(o);
      x = x >> 8;
      o = x & 255;
      ++n;
    }
    if (right) {
      bytes.push(n);
    } else {
      bytes.unshift(n);
    }
    this.update(bytes);
    return bytes.length;
  };

  Keccak.prototype.encodeString = function (str) {
    var notString, type = typeof str;
    if (type !== 'string') {
      if (type === 'object') {
        if (str === null) {
          throw new Error(INPUT_ERROR);
        } else if (ARRAY_BUFFER && str.constructor === ArrayBuffer) {
          str = new Uint8Array(str);
        } else if (!Array.isArray(str)) {
          if (!ARRAY_BUFFER || !ArrayBuffer.isView(str)) {
            throw new Error(INPUT_ERROR);
          }
        }
      } else {
        throw new Error(INPUT_ERROR);
      }
      notString = true;
    }
    var bytes = 0, length = str.length;
    if (notString) {
      bytes = length;
    } else {
      for (var i = 0; i < str.length; ++i) {
        var code = str.charCodeAt(i);
        if (code < 0x80) {
          bytes += 1;
        } else if (code < 0x800) {
          bytes += 2;
        } else if (code < 0xd800 || code >= 0xe000) {
          bytes += 3;
        } else {
          code = 0x10000 + (((code & 0x3ff) << 10) | (str.charCodeAt(++i) & 0x3ff));
          bytes += 4;
        }
      }
    }
    bytes += this.encode(bytes * 8);
    this.update(str);
    return bytes;
  };

  Keccak.prototype.bytepad = function (strs, w) {
    var bytes = this.encode(w);
    for (var i = 0; i < strs.length; ++i) {
      bytes += this.encodeString(strs[i]);
    }
    var paddingBytes = w - bytes % w;
    var zeros = [];
    zeros.length = paddingBytes;
    this.update(zeros);
    return this;
  };

  Keccak.prototype.finalize = function () {
    if (this.finalized) {
      return;
    }
    this.finalized = true;
    var blocks = this.blocks, i = this.lastByteIndex, blockCount = this.blockCount, s = this.s;
    blocks[i >> 2] |= this.padding[i & 3];
    if (this.lastByteIndex === this.byteCount) {
      blocks[0] = blocks[blockCount];
      for (i = 1; i < blockCount + 1; ++i) {
        blocks[i] = 0;
      }
    }
    blocks[blockCount - 1] |= 0x80000000;
    for (i = 0; i < blockCount; ++i) {
      s[i] ^= blocks[i];
    }
    f(s);
  };

  Keccak.prototype.toString = Keccak.prototype.hex = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var hex = '', block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        block = s[i];
        hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F] +
          HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F] +
          HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F] +
          HEX_CHARS[(block >> 28) & 0x0F] + HEX_CHARS[(block >> 24) & 0x0F];
      }
      if (j % blockCount === 0) {
        f(s);
        i = 0;
      }
    }
    if (extraBytes) {
      block = s[i];
      hex += HEX_CHARS[(block >> 4) & 0x0F] + HEX_CHARS[block & 0x0F];
      if (extraBytes > 1) {
        hex += HEX_CHARS[(block >> 12) & 0x0F] + HEX_CHARS[(block >> 8) & 0x0F];
      }
      if (extraBytes > 2) {
        hex += HEX_CHARS[(block >> 20) & 0x0F] + HEX_CHARS[(block >> 16) & 0x0F];
      }
    }
    return hex;
  };

  Keccak.prototype.arrayBuffer = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var bytes = this.outputBits >> 3;
    var buffer;
    if (extraBytes) {
      buffer = new ArrayBuffer((outputBlocks + 1) << 2);
    } else {
      buffer = new ArrayBuffer(bytes);
    }
    var array = new Uint32Array(buffer);
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        array[j] = s[i];
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      array[i] = s[i];
      buffer = buffer.slice(0, bytes);
    }
    return buffer;
  };

  Keccak.prototype.buffer = Keccak.prototype.arrayBuffer;

  Keccak.prototype.digest = Keccak.prototype.array = function () {
    this.finalize();

    var blockCount = this.blockCount, s = this.s, outputBlocks = this.outputBlocks,
      extraBytes = this.extraBytes, i = 0, j = 0;
    var array = [], offset, block;
    while (j < outputBlocks) {
      for (i = 0; i < blockCount && j < outputBlocks; ++i, ++j) {
        offset = j << 2;
        block = s[i];
        array[offset] = block & 0xFF;
        array[offset + 1] = (block >> 8) & 0xFF;
        array[offset + 2] = (block >> 16) & 0xFF;
        array[offset + 3] = (block >> 24) & 0xFF;
      }
      if (j % blockCount === 0) {
        f(s);
      }
    }
    if (extraBytes) {
      offset = j << 2;
      block = s[i];
      array[offset] = block & 0xFF;
      if (extraBytes > 1) {
        array[offset + 1] = (block >> 8) & 0xFF;
      }
      if (extraBytes > 2) {
        array[offset + 2] = (block >> 16) & 0xFF;
      }
    }
    return array;
  };

  function Kmac(bits, padding, outputBits) {
    Keccak.call(this, bits, padding, outputBits);
  }

  Kmac.prototype = new Keccak();

  Kmac.prototype.finalize = function () {
    this.encode(this.outputBits, true);
    return Keccak.prototype.finalize.call(this);
  };

  var f = function (s) {
    var h, l, n, c0, c1, c2, c3, c4, c5, c6, c7, c8, c9,
      b0, b1, b2, b3, b4, b5, b6, b7, b8, b9, b10, b11, b12, b13, b14, b15, b16, b17,
      b18, b19, b20, b21, b22, b23, b24, b25, b26, b27, b28, b29, b30, b31, b32, b33,
      b34, b35, b36, b37, b38, b39, b40, b41, b42, b43, b44, b45, b46, b47, b48, b49;
    for (n = 0; n < 48; n += 2) {
      c0 = s[0] ^ s[10] ^ s[20] ^ s[30] ^ s[40];
      c1 = s[1] ^ s[11] ^ s[21] ^ s[31] ^ s[41];
      c2 = s[2] ^ s[12] ^ s[22] ^ s[32] ^ s[42];
      c3 = s[3] ^ s[13] ^ s[23] ^ s[33] ^ s[43];
      c4 = s[4] ^ s[14] ^ s[24] ^ s[34] ^ s[44];
      c5 = s[5] ^ s[15] ^ s[25] ^ s[35] ^ s[45];
      c6 = s[6] ^ s[16] ^ s[26] ^ s[36] ^ s[46];
      c7 = s[7] ^ s[17] ^ s[27] ^ s[37] ^ s[47];
      c8 = s[8] ^ s[18] ^ s[28] ^ s[38] ^ s[48];
      c9 = s[9] ^ s[19] ^ s[29] ^ s[39] ^ s[49];

      h = c8 ^ ((c2 << 1) | (c3 >>> 31));
      l = c9 ^ ((c3 << 1) | (c2 >>> 31));
      s[0] ^= h;
      s[1] ^= l;
      s[10] ^= h;
      s[11] ^= l;
      s[20] ^= h;
      s[21] ^= l;
      s[30] ^= h;
      s[31] ^= l;
      s[40] ^= h;
      s[41] ^= l;
      h = c0 ^ ((c4 << 1) | (c5 >>> 31));
      l = c1 ^ ((c5 << 1) | (c4 >>> 31));
      s[2] ^= h;
      s[3] ^= l;
      s[12] ^= h;
      s[13] ^= l;
      s[22] ^= h;
      s[23] ^= l;
      s[32] ^= h;
      s[33] ^= l;
      s[42] ^= h;
      s[43] ^= l;
      h = c2 ^ ((c6 << 1) | (c7 >>> 31));
      l = c3 ^ ((c7 << 1) | (c6 >>> 31));
      s[4] ^= h;
      s[5] ^= l;
      s[14] ^= h;
      s[15] ^= l;
      s[24] ^= h;
      s[25] ^= l;
      s[34] ^= h;
      s[35] ^= l;
      s[44] ^= h;
      s[45] ^= l;
      h = c4 ^ ((c8 << 1) | (c9 >>> 31));
      l = c5 ^ ((c9 << 1) | (c8 >>> 31));
      s[6] ^= h;
      s[7] ^= l;
      s[16] ^= h;
      s[17] ^= l;
      s[26] ^= h;
      s[27] ^= l;
      s[36] ^= h;
      s[37] ^= l;
      s[46] ^= h;
      s[47] ^= l;
      h = c6 ^ ((c0 << 1) | (c1 >>> 31));
      l = c7 ^ ((c1 << 1) | (c0 >>> 31));
      s[8] ^= h;
      s[9] ^= l;
      s[18] ^= h;
      s[19] ^= l;
      s[28] ^= h;
      s[29] ^= l;
      s[38] ^= h;
      s[39] ^= l;
      s[48] ^= h;
      s[49] ^= l;

      b0 = s[0];
      b1 = s[1];
      b32 = (s[11] << 4) | (s[10] >>> 28);
      b33 = (s[10] << 4) | (s[11] >>> 28);
      b14 = (s[20] << 3) | (s[21] >>> 29);
      b15 = (s[21] << 3) | (s[20] >>> 29);
      b46 = (s[31] << 9) | (s[30] >>> 23);
      b47 = (s[30] << 9) | (s[31] >>> 23);
      b28 = (s[40] << 18) | (s[41] >>> 14);
      b29 = (s[41] << 18) | (s[40] >>> 14);
      b20 = (s[2] << 1) | (s[3] >>> 31);
      b21 = (s[3] << 1) | (s[2] >>> 31);
      b2 = (s[13] << 12) | (s[12] >>> 20);
      b3 = (s[12] << 12) | (s[13] >>> 20);
      b34 = (s[22] << 10) | (s[23] >>> 22);
      b35 = (s[23] << 10) | (s[22] >>> 22);
      b16 = (s[33] << 13) | (s[32] >>> 19);
      b17 = (s[32] << 13) | (s[33] >>> 19);
      b48 = (s[42] << 2) | (s[43] >>> 30);
      b49 = (s[43] << 2) | (s[42] >>> 30);
      b40 = (s[5] << 30) | (s[4] >>> 2);
      b41 = (s[4] << 30) | (s[5] >>> 2);
      b22 = (s[14] << 6) | (s[15] >>> 26);
      b23 = (s[15] << 6) | (s[14] >>> 26);
      b4 = (s[25] << 11) | (s[24] >>> 21);
      b5 = (s[24] << 11) | (s[25] >>> 21);
      b36 = (s[34] << 15) | (s[35] >>> 17);
      b37 = (s[35] << 15) | (s[34] >>> 17);
      b18 = (s[45] << 29) | (s[44] >>> 3);
      b19 = (s[44] << 29) | (s[45] >>> 3);
      b10 = (s[6] << 28) | (s[7] >>> 4);
      b11 = (s[7] << 28) | (s[6] >>> 4);
      b42 = (s[17] << 23) | (s[16] >>> 9);
      b43 = (s[16] << 23) | (s[17] >>> 9);
      b24 = (s[26] << 25) | (s[27] >>> 7);
      b25 = (s[27] << 25) | (s[26] >>> 7);
      b6 = (s[36] << 21) | (s[37] >>> 11);
      b7 = (s[37] << 21) | (s[36] >>> 11);
      b38 = (s[47] << 24) | (s[46] >>> 8);
      b39 = (s[46] << 24) | (s[47] >>> 8);
      b30 = (s[8] << 27) | (s[9] >>> 5);
      b31 = (s[9] << 27) | (s[8] >>> 5);
      b12 = (s[18] << 20) | (s[19] >>> 12);
      b13 = (s[19] << 20) | (s[18] >>> 12);
      b44 = (s[29] << 7) | (s[28] >>> 25);
      b45 = (s[28] << 7) | (s[29] >>> 25);
      b26 = (s[38] << 8) | (s[39] >>> 24);
      b27 = (s[39] << 8) | (s[38] >>> 24);
      b8 = (s[48] << 14) | (s[49] >>> 18);
      b9 = (s[49] << 14) | (s[48] >>> 18);

      s[0] = b0 ^ (~b2 & b4);
      s[1] = b1 ^ (~b3 & b5);
      s[10] = b10 ^ (~b12 & b14);
      s[11] = b11 ^ (~b13 & b15);
      s[20] = b20 ^ (~b22 & b24);
      s[21] = b21 ^ (~b23 & b25);
      s[30] = b30 ^ (~b32 & b34);
      s[31] = b31 ^ (~b33 & b35);
      s[40] = b40 ^ (~b42 & b44);
      s[41] = b41 ^ (~b43 & b45);
      s[2] = b2 ^ (~b4 & b6);
      s[3] = b3 ^ (~b5 & b7);
      s[12] = b12 ^ (~b14 & b16);
      s[13] = b13 ^ (~b15 & b17);
      s[22] = b22 ^ (~b24 & b26);
      s[23] = b23 ^ (~b25 & b27);
      s[32] = b32 ^ (~b34 & b36);
      s[33] = b33 ^ (~b35 & b37);
      s[42] = b42 ^ (~b44 & b46);
      s[43] = b43 ^ (~b45 & b47);
      s[4] = b4 ^ (~b6 & b8);
      s[5] = b5 ^ (~b7 & b9);
      s[14] = b14 ^ (~b16 & b18);
      s[15] = b15 ^ (~b17 & b19);
      s[24] = b24 ^ (~b26 & b28);
      s[25] = b25 ^ (~b27 & b29);
      s[34] = b34 ^ (~b36 & b38);
      s[35] = b35 ^ (~b37 & b39);
      s[44] = b44 ^ (~b46 & b48);
      s[45] = b45 ^ (~b47 & b49);
      s[6] = b6 ^ (~b8 & b0);
      s[7] = b7 ^ (~b9 & b1);
      s[16] = b16 ^ (~b18 & b10);
      s[17] = b17 ^ (~b19 & b11);
      s[26] = b26 ^ (~b28 & b20);
      s[27] = b27 ^ (~b29 & b21);
      s[36] = b36 ^ (~b38 & b30);
      s[37] = b37 ^ (~b39 & b31);
      s[46] = b46 ^ (~b48 & b40);
      s[47] = b47 ^ (~b49 & b41);
      s[8] = b8 ^ (~b0 & b2);
      s[9] = b9 ^ (~b1 & b3);
      s[18] = b18 ^ (~b10 & b12);
      s[19] = b19 ^ (~b11 & b13);
      s[28] = b28 ^ (~b20 & b22);
      s[29] = b29 ^ (~b21 & b23);
      s[38] = b38 ^ (~b30 & b32);
      s[39] = b39 ^ (~b31 & b33);
      s[48] = b48 ^ (~b40 & b42);
      s[49] = b49 ^ (~b41 & b43);

      s[0] ^= RC[n];
      s[1] ^= RC[n + 1];
    }
  };

  if (COMMON_JS) {
    module.exports = methods;
  } else {
    for (i = 0; i < methodNames.length; ++i) {
      root[methodNames[i]] = methods[methodNames[i]];
    }
    if (AMD) {
      !(__WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return methods;
      }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    }
  }
})();

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/process/browser.js */ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/process/browser.js"), __webpack_require__(/*! ./../../../../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/global.js */ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/minimalistic-assert/index.js":
/*!***************************************************!*\
  !*** ./node_modules/minimalistic-assert/index.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = assert;

function assert(val, msg) {
  if (!val)
    throw new Error(msg || 'Assertion failed');
}

assert.equal = function assertEqual(l, r, msg) {
  if (l != r)
    throw new Error(msg || ('Assertion failed: ' + l + ' != ' + r));
};


/***/ }),

/***/ "./node_modules/scrypt-js/scrypt.js":
/*!******************************************!*\
  !*** ./node_modules/scrypt-js/scrypt.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(setImmediate) {

(function(root) {
    const MAX_VALUE = 0x7fffffff;

    // The SHA256 and PBKDF2 implementation are from scrypt-async-js:
    // See: https://github.com/dchest/scrypt-async-js
    function SHA256(m) {
        const K = new Uint32Array([
           0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b,
           0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01,
           0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7,
           0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc,
           0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152,
           0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147,
           0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc,
           0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
           0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819,
           0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08,
           0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f,
           0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208,
           0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2
       ]);

        let h0 = 0x6a09e667, h1 = 0xbb67ae85, h2 = 0x3c6ef372, h3 = 0xa54ff53a;
        let h4 = 0x510e527f, h5 = 0x9b05688c, h6 = 0x1f83d9ab, h7 = 0x5be0cd19;
        const w = new Uint32Array(64);

        function blocks(p) {
            let off = 0, len = p.length;
            while (len >= 64) {
                let a = h0, b = h1, c = h2, d = h3, e = h4, f = h5, g = h6, h = h7, u, i, j, t1, t2;

                for (i = 0; i < 16; i++) {
                    j = off + i*4;
                    w[i] = ((p[j] & 0xff)<<24) | ((p[j+1] & 0xff)<<16) |
                    ((p[j+2] & 0xff)<<8) | (p[j+3] & 0xff);
                }

                for (i = 16; i < 64; i++) {
                    u = w[i-2];
                    t1 = ((u>>>17) | (u<<(32-17))) ^ ((u>>>19) | (u<<(32-19))) ^ (u>>>10);

                    u = w[i-15];
                    t2 = ((u>>>7) | (u<<(32-7))) ^ ((u>>>18) | (u<<(32-18))) ^ (u>>>3);

                    w[i] = (((t1 + w[i-7]) | 0) + ((t2 + w[i-16]) | 0)) | 0;
                }

                for (i = 0; i < 64; i++) {
                    t1 = ((((((e>>>6) | (e<<(32-6))) ^ ((e>>>11) | (e<<(32-11))) ^
                             ((e>>>25) | (e<<(32-25)))) + ((e & f) ^ (~e & g))) | 0) +
                          ((h + ((K[i] + w[i]) | 0)) | 0)) | 0;

                    t2 = ((((a>>>2) | (a<<(32-2))) ^ ((a>>>13) | (a<<(32-13))) ^
                           ((a>>>22) | (a<<(32-22)))) + ((a & b) ^ (a & c) ^ (b & c))) | 0;

                    h = g;
                    g = f;
                    f = e;
                    e = (d + t1) | 0;
                    d = c;
                    c = b;
                    b = a;
                    a = (t1 + t2) | 0;
                }

                h0 = (h0 + a) | 0;
                h1 = (h1 + b) | 0;
                h2 = (h2 + c) | 0;
                h3 = (h3 + d) | 0;
                h4 = (h4 + e) | 0;
                h5 = (h5 + f) | 0;
                h6 = (h6 + g) | 0;
                h7 = (h7 + h) | 0;

                off += 64;
                len -= 64;
            }
        }

        blocks(m);

        let i, bytesLeft = m.length % 64,
        bitLenHi = (m.length / 0x20000000) | 0,
        bitLenLo = m.length << 3,
        numZeros = (bytesLeft < 56) ? 56 : 120,
        p = m.slice(m.length - bytesLeft, m.length);

        p.push(0x80);
        for (i = bytesLeft + 1; i < numZeros; i++) { p.push(0); }
        p.push((bitLenHi >>> 24) & 0xff);
        p.push((bitLenHi >>> 16) & 0xff);
        p.push((bitLenHi >>> 8)  & 0xff);
        p.push((bitLenHi >>> 0)  & 0xff);
        p.push((bitLenLo >>> 24) & 0xff);
        p.push((bitLenLo >>> 16) & 0xff);
        p.push((bitLenLo >>> 8)  & 0xff);
        p.push((bitLenLo >>> 0)  & 0xff);

        blocks(p);

        return [
            (h0 >>> 24) & 0xff, (h0 >>> 16) & 0xff, (h0 >>> 8) & 0xff, (h0 >>> 0) & 0xff,
            (h1 >>> 24) & 0xff, (h1 >>> 16) & 0xff, (h1 >>> 8) & 0xff, (h1 >>> 0) & 0xff,
            (h2 >>> 24) & 0xff, (h2 >>> 16) & 0xff, (h2 >>> 8) & 0xff, (h2 >>> 0) & 0xff,
            (h3 >>> 24) & 0xff, (h3 >>> 16) & 0xff, (h3 >>> 8) & 0xff, (h3 >>> 0) & 0xff,
            (h4 >>> 24) & 0xff, (h4 >>> 16) & 0xff, (h4 >>> 8) & 0xff, (h4 >>> 0) & 0xff,
            (h5 >>> 24) & 0xff, (h5 >>> 16) & 0xff, (h5 >>> 8) & 0xff, (h5 >>> 0) & 0xff,
            (h6 >>> 24) & 0xff, (h6 >>> 16) & 0xff, (h6 >>> 8) & 0xff, (h6 >>> 0) & 0xff,
            (h7 >>> 24) & 0xff, (h7 >>> 16) & 0xff, (h7 >>> 8) & 0xff, (h7 >>> 0) & 0xff
        ];
    }

    function PBKDF2_HMAC_SHA256_OneIter(password, salt, dkLen) {
        // compress password if it's longer than hash block length
        password = (password.length <= 64) ? password : SHA256(password);

        const innerLen = 64 + salt.length + 4;
        const inner = new Array(innerLen);
        const outerKey = new Array(64);

        let i;
        let dk = [];

        // inner = (password ^ ipad) || salt || counter
        for (i = 0; i < 64; i++) { inner[i] = 0x36; }
        for (i = 0; i < password.length; i++) { inner[i] ^= password[i]; }
        for (i = 0; i < salt.length; i++) { inner[64 + i] = salt[i]; }
        for (i = innerLen - 4; i < innerLen; i++) { inner[i] = 0; }

        // outerKey = password ^ opad
        for (i = 0; i < 64; i++) outerKey[i] = 0x5c;
        for (i = 0; i < password.length; i++) outerKey[i] ^= password[i];

        // increments counter inside inner
        function incrementCounter() {
            for (let i = innerLen - 1; i >= innerLen - 4; i--) {
                inner[i]++;
                if (inner[i] <= 0xff) return;
                inner[i] = 0;
            }
        }

        // output blocks = SHA256(outerKey || SHA256(inner)) ...
        while (dkLen >= 32) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))));
            dkLen -= 32;
        }
        if (dkLen > 0) {
            incrementCounter();
            dk = dk.concat(SHA256(outerKey.concat(SHA256(inner))).slice(0, dkLen));
        }

        return dk;
    }

    // The following is an adaptation of scryptsy
    // See: https://www.npmjs.com/package/scryptsy
    function blockmix_salsa8(BY, Yi, r, x, _X) {
        let i;

        arraycopy(BY, (2 * r - 1) * 16, _X, 0, 16);
        for (i = 0; i < 2 * r; i++) {
            blockxor(BY, i * 16, _X, 16);
            salsa20_8(_X, x);
            arraycopy(_X, 0, BY, Yi + (i * 16), 16);
        }

        for (i = 0; i < r; i++) {
            arraycopy(BY, Yi + (i * 2) * 16, BY, (i * 16), 16);
        }

        for (i = 0; i < r; i++) {
            arraycopy(BY, Yi + (i * 2 + 1) * 16, BY, (i + r) * 16, 16);
        }
    }

    function R(a, b) {
        return (a << b) | (a >>> (32 - b));
    }

    function salsa20_8(B, x) {
        arraycopy(B, 0, x, 0, 16);

        for (let i = 8; i > 0; i -= 2) {
            x[ 4] ^= R(x[ 0] + x[12], 7);
            x[ 8] ^= R(x[ 4] + x[ 0], 9);
            x[12] ^= R(x[ 8] + x[ 4], 13);
            x[ 0] ^= R(x[12] + x[ 8], 18);
            x[ 9] ^= R(x[ 5] + x[ 1], 7);
            x[13] ^= R(x[ 9] + x[ 5], 9);
            x[ 1] ^= R(x[13] + x[ 9], 13);
            x[ 5] ^= R(x[ 1] + x[13], 18);
            x[14] ^= R(x[10] + x[ 6], 7);
            x[ 2] ^= R(x[14] + x[10], 9);
            x[ 6] ^= R(x[ 2] + x[14], 13);
            x[10] ^= R(x[ 6] + x[ 2], 18);
            x[ 3] ^= R(x[15] + x[11], 7);
            x[ 7] ^= R(x[ 3] + x[15], 9);
            x[11] ^= R(x[ 7] + x[ 3], 13);
            x[15] ^= R(x[11] + x[ 7], 18);
            x[ 1] ^= R(x[ 0] + x[ 3], 7);
            x[ 2] ^= R(x[ 1] + x[ 0], 9);
            x[ 3] ^= R(x[ 2] + x[ 1], 13);
            x[ 0] ^= R(x[ 3] + x[ 2], 18);
            x[ 6] ^= R(x[ 5] + x[ 4], 7);
            x[ 7] ^= R(x[ 6] + x[ 5], 9);
            x[ 4] ^= R(x[ 7] + x[ 6], 13);
            x[ 5] ^= R(x[ 4] + x[ 7], 18);
            x[11] ^= R(x[10] + x[ 9], 7);
            x[ 8] ^= R(x[11] + x[10], 9);
            x[ 9] ^= R(x[ 8] + x[11], 13);
            x[10] ^= R(x[ 9] + x[ 8], 18);
            x[12] ^= R(x[15] + x[14], 7);
            x[13] ^= R(x[12] + x[15], 9);
            x[14] ^= R(x[13] + x[12], 13);
            x[15] ^= R(x[14] + x[13], 18);
        }

        for (let i = 0; i < 16; ++i) {
            B[i] += x[i];
        }
    }

    // naive approach... going back to loop unrolling may yield additional performance
    function blockxor(S, Si, D, len) {
        for (let i = 0; i < len; i++) {
            D[i] ^= S[Si + i]
        }
    }

    function arraycopy(src, srcPos, dest, destPos, length) {
        while (length--) {
            dest[destPos++] = src[srcPos++];
        }
    }

    function checkBufferish(o) {
        if (!o || typeof(o.length) !== 'number') { return false; }

        for (let i = 0; i < o.length; i++) {
            const v = o[i];
            if (typeof(v) !== 'number' || v % 1 || v < 0 || v >= 256) {
                return false;
            }
        }

        return true;
    }

    function ensureInteger(value, name) {
        if (typeof(value) !== "number" || (value % 1)) { throw new Error('invalid ' + name); }
        return value;
    }

    // N = Cpu cost, r = Memory cost, p = parallelization cost
    // callback(error, progress, key)
    function _scrypt(password, salt, N, r, p, dkLen, callback) {

        N = ensureInteger(N, 'N');
        r = ensureInteger(r, 'r');
        p = ensureInteger(p, 'p');

        dkLen = ensureInteger(dkLen, 'dkLen');

        if (N === 0 || (N & (N - 1)) !== 0) { throw new Error('N must be power of 2'); }

        if (N > MAX_VALUE / 128 / r) { throw new Error('N too large'); }
        if (r > MAX_VALUE / 128 / p) { throw new Error('r too large'); }

        if (!checkBufferish(password)) {
            throw new Error('password must be an array or buffer');
        }
        password = Array.prototype.slice.call(password);

        if (!checkBufferish(salt)) {
            throw new Error('salt must be an array or buffer');
        }
        salt = Array.prototype.slice.call(salt);

        let b = PBKDF2_HMAC_SHA256_OneIter(password, salt, p * 128 * r);
        const B = new Uint32Array(p * 32 * r)
        for (let i = 0; i < B.length; i++) {
            const j = i * 4;
            B[i] = ((b[j + 3] & 0xff) << 24) |
                   ((b[j + 2] & 0xff) << 16) |
                   ((b[j + 1] & 0xff) << 8) |
                   ((b[j + 0] & 0xff) << 0);
        }

        const XY = new Uint32Array(64 * r);
        const V = new Uint32Array(32 * r * N);

        const Yi = 32 * r;

        // scratch space
        const x = new Uint32Array(16);       // salsa20_8
        const _X = new Uint32Array(16);      // blockmix_salsa8

        const totalOps = p * N * 2;
        let currentOp = 0;
        let lastPercent10 = null;

        // Set this to true to abandon the scrypt on the next step
        let stop = false;

        // State information
        let state = 0;
        let i0 = 0, i1;
        let Bi;

        // How many blockmix_salsa8 can we do per step?
        const limit = callback ? parseInt(1000 / r): 0xffffffff;

        // Trick from scrypt-async; if there is a setImmediate shim in place, use it
        const nextTick = (typeof(setImmediate) !== 'undefined') ? setImmediate : setTimeout;

        // This is really all I changed; making scryptsy a state machine so we occasionally
        // stop and give other evnts on the evnt loop a chance to run. ~RicMoo
        const incrementalSMix = function() {
            if (stop) {
                return callback(new Error('cancelled'), currentOp / totalOps);
            }

            let steps;

            switch (state) {
                case 0:
                    // for (var i = 0; i < p; i++)...
                    Bi = i0 * 32 * r;

                    arraycopy(B, Bi, XY, 0, Yi);                       // ROMix - 1

                    state = 1;                                         // Move to ROMix 2
                    i1 = 0;

                    // Fall through

                case 1:

                    // Run up to 1000 steps of the first inner smix loop
                    steps = N - i1;
                    if (steps > limit) { steps = limit; }
                    for (let i = 0; i < steps; i++) {                  // ROMix - 2
                        arraycopy(XY, 0, V, (i1 + i) * Yi, Yi)         // ROMix - 3
                        blockmix_salsa8(XY, Yi, r, x, _X);             // ROMix - 4
                    }

                    // for (var i = 0; i < N; i++)
                    i1 += steps;
                    currentOp += steps;

                    if (callback) {
                        // Call the callback with the progress (optionally stopping us)
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) { break; }
                            lastPercent10 = percent10;
                        }
                    }

                    if (i1 < N) { break; }

                    i1 = 0;                                          // Move to ROMix 6
                    state = 2;

                    // Fall through

                case 2:

                    // Run up to 1000 steps of the second inner smix loop
                    steps = N - i1;
                    if (steps > limit) { steps = limit; }
                    for (let i = 0; i < steps; i++) {                // ROMix - 6
                        const offset = (2 * r - 1) * 16;             // ROMix - 7
                        const j = XY[offset] & (N - 1);
                        blockxor(V, j * Yi, XY, Yi);                 // ROMix - 8 (inner)
                        blockmix_salsa8(XY, Yi, r, x, _X);           // ROMix - 9 (outer)
                    }

                    // for (var i = 0; i < N; i++)...
                    i1 += steps;
                    currentOp += steps;

                    // Call the callback with the progress (optionally stopping us)
                    if (callback) {
                        const percent10 = parseInt(1000 * currentOp / totalOps);
                        if (percent10 !== lastPercent10) {
                            stop = callback(null, currentOp / totalOps);
                            if (stop) { break; }
                            lastPercent10 = percent10;
                        }
                    }

                    if (i1 < N) { break; }

                    arraycopy(XY, 0, B, Bi, Yi);                     // ROMix - 10

                    // for (var i = 0; i < p; i++)...
                    i0++;
                    if (i0 < p) {
                        state = 0;
                        break;
                    }

                    b = [];
                    for (let i = 0; i < B.length; i++) {
                        b.push((B[i] >>  0) & 0xff);
                        b.push((B[i] >>  8) & 0xff);
                        b.push((B[i] >> 16) & 0xff);
                        b.push((B[i] >> 24) & 0xff);
                    }

                    const derivedKey = PBKDF2_HMAC_SHA256_OneIter(password, b, dkLen);

                    // Send the result to the callback
                    if (callback) { callback(null, 1.0, derivedKey); }

                    // Done; don't break (which would reschedule)
                    return derivedKey;
            }

            // Schedule the next steps
            if (callback) { nextTick(incrementalSMix); }
        }

        // Run the smix state machine until completion
        if (!callback) {
            while (true) {
                const derivedKey = incrementalSMix();
                if (derivedKey != undefined) { return derivedKey; }
            }
        }

        // Bootstrap the async incremental smix
        incrementalSMix();
    }

    const lib = {
        scrypt: function(password, salt, N, r, p, dkLen, progressCallback) {
            return new Promise(function(resolve, reject) {
                let lastProgress = 0;
                if (progressCallback) { progressCallback(0); }
                _scrypt(password, salt, N, r, p, dkLen, function(error, progress, key) {
                    if (error) {
                        reject(error);
                    } else if (key) {
                        if (progressCallback && lastProgress !== 1) {
                            progressCallback(1);
                        }
                        resolve(new Uint8Array(key));
                    } else if (progressCallback && progress !== lastProgress) {
                        lastProgress = progress;
                        return progressCallback(progress);
                    }
                });
            });
        },
        syncScrypt: function(password, salt, N, r, p, dkLen) {
            return new Uint8Array(_scrypt(password, salt, N, r, p, dkLen));
        }
    };

    // node.js
    if (true) {
       module.exports = lib;

    // RequireJS/AMD
    // http://www.requirejs.org/docs/api.html
    // https://github.com/amdjs/amdjs-api/wiki/AMD
    } else {}

})(this);

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/timers-browserify/main.js */ "../../../../Library/Caches/.wrangler/wranglerjs-1.19.5/node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./src/graph.ts":
/*!**********************!*\
  !*** ./src/graph.ts ***!
  \**********************/
/*! exports provided: formatGraphQuery, querySubgraph, trimHexZero, formatGraphResponse */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatGraphQuery", function() { return formatGraphQuery; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "querySubgraph", function() { return querySubgraph; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "trimHexZero", function() { return trimHexZero; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "formatGraphResponse", function() { return formatGraphResponse; });
/* harmony import */ var _models_distribute_to_payout_mod_event_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./models/distribute-to-payout-mod-event copy */ "./src/models/distribute-to-payout-mod-event copy.ts");
/* harmony import */ var _models_distribute_to_ticket_mod_event__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./models/distribute-to-ticket-mod-event */ "./src/models/distribute-to-ticket-mod-event.ts");
/* harmony import */ var _models_participant__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./models/participant */ "./src/models/participant.ts");
/* harmony import */ var _models_pay_event__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./models/pay-event */ "./src/models/pay-event.ts");
/* harmony import */ var _models_print_reserves_event__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./models/print-reserves-event */ "./src/models/print-reserves-event.ts");
/* harmony import */ var _models_project__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./models/project */ "./src/models/project.ts");
/* harmony import */ var _models_redeem_event__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./models/redeem-event */ "./src/models/redeem-event.ts");
/* harmony import */ var _models_tap_event__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./models/tap-event */ "./src/models/tap-event.ts");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }

/* eslint-disable @typescript-eslint/ban-ts-comment */








// https://thegraph.com/docs/graphql-api#filtering
var formatGraphQuery = opts => {
  var args = '';

  var addArg = (name, value) => {
    if (value === undefined) return;
    args += (args.length ? ', ' : '') + "".concat(name, ": ") + value;
  };

  addArg('first', opts.first);
  addArg('skip', opts.skip);
  addArg('orderBy', opts.orderBy);
  addArg('orderDirection', opts.orderDirection);

  if (opts.block) {
    if (opts.block.number) {
      addArg('block', "{ number: ".concat(opts.block.number, " }"));
    } else if (opts.block.hash) {
      addArg('block', "{ hash: ".concat(opts.block.hash, " }"));
    }
  }

  addArg('where', opts.where ? Array.isArray(opts.where) ? "{ ".concat(opts.where.map(w => "".concat(w.key).concat(w.operator ? '_' + w.operator : '', ": \"").concat(w.value, "\" ")), " }") : "{ ".concat(opts.where.key).concat(opts.where.operator ? '_' + opts.where.operator : '', ": \"").concat(opts.where.value, "\" }") : undefined);
  return "{ ".concat(opts.entity, "s").concat(args ? "(".concat(args, ")") : '', " { id").concat(opts.keys.reduce((acc, key) => typeof key === 'string' || typeof key === 'number' || typeof key === 'symbol' ? acc + ' ' + key.toString() : acc + " ".concat(key.entity, "{ ").concat(key.keys.map(k => k + ' '), " }"), ''), " } }");
};
var subgraphUrl = 'https://api.studio.thegraph.com/query/9534/juicebox-rinkeby/v0.0.2';
var querySubgraph = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (opts) {
    try {
      var res = yield fetch(subgraphUrl, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          query: formatGraphQuery(opts)
        })
      });
      var data = yield res.json();
      return data.data;
    } catch (error) {
      console.log(error);
    }
  });

  return function querySubgraph(_x) {
    return _ref.apply(this, arguments);
  };
}();
var trimHexZero = hexStr => hexStr.replace('0x0', '0x');
function formatGraphResponse(entity, response) {
  if (!response || typeof response !== 'object') {
    return [];
  } // This code works perfectly, but there's an unusual TypeScript issue that
  // makes it appear type unsafe...
  //
  // For example, `response.projects` is a ProjectJson[], as dictated by
  // SubgraphQueryReturnTypes['projects']
  // We then map over that array to return a Project[], but for some reason,
  // TypeScript isn't equating `Project` with `SubgraphEntities['project']`,
  // even though they're the same type.
  //
  // If you think you can solve it and remove the @ts-ignore, be my guest.
  // My best guess is a conditional resolver type, ie:
  // type EntityResolver<E extends EntityKey> = E extends 'project' ? Project : ...
  // in favor of the main SubgraphEntities type. I tried it, though, to no avail.


  switch (entity) {
    case 'project':
      if ('projects' in response) {
        // @ts-ignore
        return response.projects.map(_models_project__WEBPACK_IMPORTED_MODULE_5__["parseProjectJson"]);
      }

      break;

    case 'payEvent':
      if ('payEvents' in response) {
        // @ts-ignore
        return response.payEvents.map(_models_pay_event__WEBPACK_IMPORTED_MODULE_3__["parsePayEventJson"]);
      }

      break;

    case 'redeemEvent':
      if ('redeemEvents' in response) {
        // @ts-ignore
        return response.redeemEvents.map(_models_redeem_event__WEBPACK_IMPORTED_MODULE_6__["parseRedeemEventJson"]);
      }

      break;

    case 'participant':
      if ('participants' in response) {
        // @ts-ignore
        return response.participants.map(_models_participant__WEBPACK_IMPORTED_MODULE_2__["parseParticipantJson"]);
      }

      break;

    case 'tapEvent':
      if ('tapEvents' in response) {
        // @ts-ignore
        return response.tapEvents.map(_models_tap_event__WEBPACK_IMPORTED_MODULE_7__["parseTapEventJson"]);
      }

      break;

    case 'distributeToPayoutModEvent':
      if ('distributeToPayoutModEvents' in response) {
        // @ts-ignore
        return response.distributeToPayoutModEvents.map(_models_distribute_to_payout_mod_event_copy__WEBPACK_IMPORTED_MODULE_0__["parseDistributeToPayoutModEvent"]);
      }

      break;

    case 'distributeToTicketModEvent':
      if ('distributeToTicketModEvents' in response) {
        // @ts-ignore
        return response.distributeToTicketModEvents.map(_models_distribute_to_ticket_mod_event__WEBPACK_IMPORTED_MODULE_1__["parseDistributeToTicketModEvent"]);
      }

      break;

    case 'printReservesEvent':
      if ('printReservesEvents' in response) {
        // @ts-ignore
        return response.printReservesEvents.map(_models_print_reserves_event__WEBPACK_IMPORTED_MODULE_4__["parsePrintReservesEventJson"]);
      }

      break;
  }

  return [];
}

/***/ }),

/***/ "./src/handler.ts":
/*!************************!*\
  !*** ./src/handler.ts ***!
  \************************/
/*! exports provided: handleRequest */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "handleRequest", function() { return handleRequest; });
/* harmony import */ var _graph__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./graph */ "./src/graph.ts");
/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js");
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }

function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }




var getIpfsCidUrl = hash => 'https://jbx.mypinata.cloud/ipfs/' + hash;

var fetchProjectMetadata = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* (uriHash) {
    var url = getIpfsCidUrl(uriHash);
    var response = yield fetch(url);
    return yield response.json();
  });

  return function fetchProjectMetadata(_x) {
    return _ref.apply(this, arguments);
  };
}();

function isAssetRoute(url) {
  return url.includes('/assets/') || url.includes('/static/') || url.includes('/robots.txt');
}

class AttributeRewriter {
  constructor(name, value) {
    this.name = name;
    this.value = value;
  }

  element(element) {
    var attribute = element.getAttribute(this.name);

    if (attribute) {
      element.setAttribute(this.name, this.value);
    }
  }

}

function handleRequest(_x2) {
  return _handleRequest.apply(this, arguments);
}

function _handleRequest() {
  _handleRequest = _asyncToGenerator(function* (request) {
    // Asset Routes
    if (isAssetRoute(request.url)) {
      var _fetchUrl = request.url.replace('https://meta-tags.jnoh.workers.dev', 'http://3a70-73-189-98-123.ngrok.io');

      var _res = yield fetch(_fetchUrl, {
        cf: {
          cacheTtl: 0
        }
      });

      return _res;
    } // Project Routes


    if (request.url.includes('https://meta-tags.jnoh.workers.dev/p/')) {
      // parse url
      var handle = request.url.replace('https://meta-tags.jnoh.workers.dev/p/', ''); // fetch project

      var data = yield Object(_graph__WEBPACK_IMPORTED_MODULE_0__["querySubgraph"])({
        entity: 'project',
        keys: ['id', 'handle', 'uri'],
        where: {
          key: 'handle',
          value: ethers__WEBPACK_IMPORTED_MODULE_1__["utils"].formatBytes32String(handle)
        }
      });
      var project = data === null || data === void 0 ? void 0 : data.projects[0];

      if (project) {
        var _metadata$name, _metadata$description;

        var metadata = yield fetchProjectMetadata(project.uri);
        var rewriter = new HTMLRewriter().on('meta[property="og:title"]', new AttributeRewriter('content', (_metadata$name = metadata.name) !== null && _metadata$name !== void 0 ? _metadata$name : '')).on('meta[property="og:description"]', new AttributeRewriter('content', (_metadata$description = metadata.description) !== null && _metadata$description !== void 0 ? _metadata$description : '')).on('meta[property="og:url"]', new AttributeRewriter('content', request.url)); // add metatags

        var _fetchUrl2 = 'http://3a70-73-189-98-123.ngrok.io';

        var _res2 = yield fetch(_fetchUrl2, {
          cf: {
            cacheTtl: 0
          }
        });

        return rewriter.transform(_res2);
      }
    } // add metatags


    var fetchUrl = 'http://3a70-73-189-98-123.ngrok.io';
    var res = yield fetch(fetchUrl, {
      cf: {
        cacheTtl: 0
      }
    });
    return res;
  });
  return _handleRequest.apply(this, arguments);
}

/***/ }),

/***/ "./src/index.ts":
/*!**********************!*\
  !*** ./src/index.ts ***!
  \**********************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _handler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./handler */ "./src/handler.ts");

addEventListener('fetch', event => {
  event.respondWith(Object(_handler__WEBPACK_IMPORTED_MODULE_0__["handleRequest"])(event.request));
});

/***/ }),

/***/ "./src/models/distribute-to-payout-mod-event copy.ts":
/*!***********************************************************!*\
  !*** ./src/models/distribute-to-payout-mod-event copy.ts ***!
  \***********************************************************/
/*! exports provided: parseDistributeToPayoutModEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDistributeToPayoutModEvent", function() { return parseDistributeToPayoutModEvent; });
/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var parseDistributeToPayoutModEvent = json => _objectSpread(_objectSpread({}, json), {}, {
  fundingCycleId: json.fundingCycleId ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.fundingCycleId) : undefined,
  project: json.project ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.project) : undefined,
  projectId: json.projectId ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.projectId) : undefined,
  modPercent: json.modPercent ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.modPercent) : undefined,
  modProjectId: json.modProjectId ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.modProjectId) : undefined,
  modCut: json.modCut ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.modCut) : undefined,
  modPreferUnstaked: !!json.modPreferUnstaked,
  timestamp: json.timestamp ? parseInt(json.timestamp) : undefined
});

/***/ }),

/***/ "./src/models/distribute-to-ticket-mod-event.ts":
/*!******************************************************!*\
  !*** ./src/models/distribute-to-ticket-mod-event.ts ***!
  \******************************************************/
/*! exports provided: parseDistributeToTicketModEvent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseDistributeToTicketModEvent", function() { return parseDistributeToTicketModEvent; });
/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var parseDistributeToTicketModEvent = json => _objectSpread(_objectSpread({}, json), {}, {
  fundingCycleId: json.fundingCycleId ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.fundingCycleId) : undefined,
  project: json.project ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.project) : undefined,
  projectId: json.projectId ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.projectId) : undefined,
  modPercent: json.modPercent ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.modPercent) : undefined,
  modCut: json.modCut ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.modCut) : undefined,
  modPreferUnstaked: !!json.modPreferUnstaked,
  timestamp: json.timestamp ? parseInt(json.timestamp) : undefined
});

/***/ }),

/***/ "./src/models/participant.ts":
/*!***********************************!*\
  !*** ./src/models/participant.ts ***!
  \***********************************/
/*! exports provided: parseParticipantJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseParticipantJson", function() { return parseParticipantJson; });
/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var parseParticipantJson = json => _objectSpread(_objectSpread({}, json), {}, {
  totalPaid: json.totalPaid ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.totalPaid) : undefined,
  project: json.project ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.project) : undefined,
  tokenBalance: json.tokenBalance ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.tokenBalance) : undefined,
  lastPaidTimestamp: json.lastPaidTimestamp ? parseInt(json.lastPaidTimestamp) : undefined
});

/***/ }),

/***/ "./src/models/pay-event.ts":
/*!*********************************!*\
  !*** ./src/models/pay-event.ts ***!
  \*********************************/
/*! exports provided: parsePayEventJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePayEventJson", function() { return parsePayEventJson; });
/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var parsePayEventJson = json => {
  var _json$project;

  return _objectSpread(_objectSpread({}, json), {}, {
    fundingCycleId: json.fundingCycleId ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.fundingCycleId) : undefined,
    project: (_json$project = json.project) !== null && _json$project !== void 0 && _json$project.id ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.project.id) : undefined,
    timestamp: json.timestamp ? parseInt(json.timestamp) : undefined
  });
};

/***/ }),

/***/ "./src/models/print-reserves-event.ts":
/*!********************************************!*\
  !*** ./src/models/print-reserves-event.ts ***!
  \********************************************/
/*! exports provided: parsePrintReservesEventJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parsePrintReservesEventJson", function() { return parsePrintReservesEventJson; });
/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var parsePrintReservesEventJson = json => _objectSpread(_objectSpread({}, json), {}, {
  project: json.project ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.project) : undefined,
  fundingCycleId: json.fundingCycleId ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.fundingCycleId) : undefined,
  beneficiaryTicketAmount: json.beneficiaryTicketAmount ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.beneficiaryTicketAmount) : undefined,
  count: json.count ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.count) : undefined,
  timestamp: json.timestamp ? parseInt(json.timestamp) : undefined
});

/***/ }),

/***/ "./src/models/project.ts":
/*!*******************************!*\
  !*** ./src/models/project.ts ***!
  \*******************************/
/*! exports provided: parseProjectJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseProjectJson", function() { return parseProjectJson; });
/* harmony import */ var _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ethersproject/bignumber */ "./node_modules/@ethersproject/bignumber/lib.esm/index.js");
/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }



var parseProjectJson = project => {
  var _project$participants, _project$participants2;

  return _objectSpread(_objectSpread({}, project), {}, {
    id: project.id ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(project.id) : undefined,
    createdAt: project.createdAt ? parseInt(project.createdAt) : undefined,
    handle: project.handle ? ethers__WEBPACK_IMPORTED_MODULE_1__["utils"].parseBytes32String(project.handle) : undefined,
    currentBalance: project.currentBalance ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(project.currentBalance) : undefined,
    totalPaid: project.totalPaid ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(project.totalPaid) : undefined,
    totalRedeemed: project.totalRedeemed ? _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(project.totalRedeemed) : undefined,
    participants: (_project$participants = (_project$participants2 = project.participants) === null || _project$participants2 === void 0 ? void 0 : _project$participants2.map(p => {
      var payer = JSON.parse(p);
      return _objectSpread(_objectSpread({}, payer), {}, {
        totalPaid: _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(payer.totalPaid),
        project: _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(payer.project),
        lastPaidTimestamp: parseInt(payer.lastPaidTimestamp),
        tokenBalance: _ethersproject_bignumber__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(payer.tokenBalance)
      });
    })) !== null && _project$participants !== void 0 ? _project$participants : []
  });
};

/***/ }),

/***/ "./src/models/redeem-event.ts":
/*!************************************!*\
  !*** ./src/models/redeem-event.ts ***!
  \************************************/
/*! exports provided: parseRedeemEventJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseRedeemEventJson", function() { return parseRedeemEventJson; });
/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var parseRedeemEventJson = json => _objectSpread(_objectSpread({}, json), {}, {
  project: json.project ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.project) : undefined,
  amount: json.amount ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.amount) : undefined,
  returnAmount: json.returnAmount ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.returnAmount) : undefined,
  timestamp: json.timestamp ? parseInt(json.timestamp) : undefined
});

/***/ }),

/***/ "./src/models/tap-event.ts":
/*!*********************************!*\
  !*** ./src/models/tap-event.ts ***!
  \*********************************/
/*! exports provided: parseTapEventJson */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "parseTapEventJson", function() { return parseTapEventJson; });
/* harmony import */ var ethers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ethers */ "./node_modules/ethers/lib.esm/index.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }


var parseTapEventJson = json => _objectSpread(_objectSpread({}, json), {}, {
  project: json.project ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.project) : undefined,
  fundingCycleId: json.fundingCycleId ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.fundingCycleId) : undefined,
  amount: json.amount ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.amount) : undefined,
  currency: json.currency ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.currency) : undefined,
  netTransferAmount: json.netTransferAmount ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.netTransferAmount) : undefined,
  beneficiaryTransferAmount: json.beneficiaryTransferAmount ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.beneficiaryTransferAmount) : undefined,
  govFeeAmount: json.govFeeAmount ? ethers__WEBPACK_IMPORTED_MODULE_0__["BigNumber"].from(json.govFeeAmount) : undefined,
  timestamp: json.timestamp ? parseInt(json.timestamp) : undefined
});

/***/ }),

/***/ 0:
/*!************************!*\
  !*** buffer (ignored) ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* (ignored) */

/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9qbm9oL0xpYnJhcnkvQ2FjaGVzLy53cmFuZ2xlci93cmFuZ2xlcmpzLTEuMTkuNS9ub2RlX21vZHVsZXMvcHJvY2Vzcy9icm93c2VyLmpzIiwid2VicGFjazovLy8vVXNlcnMvam5vaC9MaWJyYXJ5L0NhY2hlcy8ud3JhbmdsZXIvd3JhbmdsZXJqcy0xLjE5LjUvbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCJ3ZWJwYWNrOi8vLy9Vc2Vycy9qbm9oL0xpYnJhcnkvQ2FjaGVzLy53cmFuZ2xlci93cmFuZ2xlcmpzLTEuMTkuNS9ub2RlX21vZHVsZXMvdGltZXJzLWJyb3dzZXJpZnkvbWFpbi5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vYW1kLW9wdGlvbnMuanMiLCJ3ZWJwYWNrOi8vLyh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsIndlYnBhY2s6Ly8vKHdlYnBhY2spL2J1aWxkaW4vbW9kdWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9fdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vYWJpLWNvZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYWJzdHJhY3QtY29kZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9hZGRyZXNzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYW5vbnltb3VzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYXJyYXkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9ib29sZWFuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9jb2RlcnMvYnl0ZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9maXhlZC1ieXRlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vY29kZXJzL251bGwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9udW1iZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy9zdHJpbmcuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FiaS9saWIuZXNtL2NvZGVycy90dXBsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vZnJhZ21lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYmkvbGliLmVzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJpL2xpYi5lc20vaW50ZXJmYWNlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIuZXNtL192ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlci9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1zaWduZXIvbGliLmVzbS9fdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyL2xpYi5lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2FkZHJlc3MvbGliLmVzbS9fdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYWRkcmVzcy9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iYXNlNjQvbGliLmVzbS9iYXNlNjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2Jhc2U2NC9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iYXNleC9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliLmVzbS9fdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vYmlnbnVtYmVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9iaWdudW1iZXIvbGliLmVzbS9maXhlZG51bWJlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyL2xpYi5lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2J5dGVzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2J5dGVzL2xpYi5lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnN0YW50cy9saWIuZXNtL2FkZHJlc3Nlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzL2xpYi5lc20vYmlnbnVtYmVycy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzL2xpYi5lc20vaGFzaGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9jb25zdGFudHMvbGliLmVzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzL2xpYi5lc20vc3RyaW5ncy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvY29udHJhY3RzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2NvbnRyYWN0cy9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hhc2gvbGliLmVzbS9pZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vbWVzc2FnZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGFzaC9saWIuZXNtL25hbWVoYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9oYXNoL2xpYi5lc20vdHlwZWQtZGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvaGRub2RlL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2hkbm9kZS9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9qc29uLXdhbGxldHMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvanNvbi13YWxsZXRzL2xpYi5lc20vY3Jvd2RzYWxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9qc29uLXdhbGxldHMvbGliLmVzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvanNvbi13YWxsZXRzL2xpYi5lc20vaW5zcGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvanNvbi13YWxsZXRzL2xpYi5lc20va2V5c3RvcmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2pzb24td2FsbGV0cy9saWIuZXNtL3V0aWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9rZWNjYWsyNTYvbGliLmVzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvbG9nZ2VyL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L2xvZ2dlci9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIuZXNtL192ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9uZXR3b3Jrcy9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wYmtkZjIvbGliLmVzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcGJrZGYyL2xpYi5lc20vcGJrZGYyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXMvbGliLmVzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2FsY2hlbXktcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Jhc2UtcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Nsb3VkZmxhcmUtcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2V0aGVyc2Nhbi1wcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vZmFsbGJhY2stcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2Zvcm1hdHRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL2luZnVyYS1wcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vaXBjLXByb3ZpZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS9qc29uLXJwYy1iYXRjaC1wcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vanNvbi1ycGMtcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL25vZGVzbWl0aC1wcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vcG9ja2V0LXByb3ZpZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9wcm92aWRlcnMvbGliLmVzbS91cmwtanNvbi1ycGMtcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3dlYjMtcHJvdmlkZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3Byb3ZpZGVycy9saWIuZXNtL3dlYnNvY2tldC1wcm92aWRlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcHJvdmlkZXJzL2xpYi5lc20vd3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3JhbmRvbS9saWIuZXNtL192ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9yYW5kb20vbGliLmVzbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcmFuZG9tL2xpYi5lc20vcmFuZG9tLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9yYW5kb20vbGliLmVzbS9zaHVmZmxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9ybHAvbGliLmVzbS9fdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvcmxwL2xpYi5lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3NoYTIvbGliLmVzbS9fdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaGEyL2xpYi5lc20vc2hhMi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc2hhMi9saWIuZXNtL3R5cGVzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL192ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL2VsbGlwdGljLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleS9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zb2xpZGl0eS9saWIuZXNtL192ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zb2xpZGl0eS9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3N0cmluZ3MvbGliLmVzbS9ieXRlczMyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi5lc20vaWRuYS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvc3RyaW5ncy9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC9zdHJpbmdzL2xpYi5lc20vdXRmOC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zL2xpYi5lc20vX3ZlcnNpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9ucy9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC91bml0cy9saWIuZXNtL192ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC91bml0cy9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93YWxsZXQvbGliLmVzbS9fdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd2FsbGV0L2xpYi5lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dlYi9saWIuZXNtL192ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93ZWIvbGliLmVzbS9nZXR1cmwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dlYi9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93b3JkbGlzdHMvbGliLmVzbS9fdmVyc2lvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQGV0aGVyc3Byb2plY3Qvd29yZGxpc3RzL2xpYi5lc20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dvcmRsaXN0cy9saWIuZXNtL2xhbmctZW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0BldGhlcnNwcm9qZWN0L3dvcmRsaXN0cy9saWIuZXNtL3dvcmRsaXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AZXRoZXJzcHJvamVjdC93b3JkbGlzdHMvbGliLmVzbS93b3JkbGlzdHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2Flcy1qcy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYmVjaDMyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ibi5qcy9saWIvYm4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL192ZXJzaW9uLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS9ldGhlcnMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2V0aGVycy9saWIuZXNtL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9ldGhlcnMvbGliLmVzbS91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvaG1hYy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9yaXBlbWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8xLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS8yMjQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhLzI1Ni5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC9zaGEvMzg0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9oYXNoLmpzL2xpYi9oYXNoL3NoYS81MTIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2hhc2guanMvbGliL2hhc2gvc2hhL2NvbW1vbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaGFzaC5qcy9saWIvaGFzaC91dGlscy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaW5oZXJpdHMvaW5oZXJpdHNfYnJvd3Nlci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanMtc2hhMy9zcmMvc2hhMy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvbWluaW1hbGlzdGljLWFzc2VydC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2NyeXB0LWpzL3NjcnlwdC5qcyIsIndlYnBhY2s6Ly8vLi9zcmMvZ3JhcGgudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2hhbmRsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2luZGV4LnRzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbHMvZGlzdHJpYnV0ZS10by1wYXlvdXQtbW9kLWV2ZW50IGNvcHkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVscy9kaXN0cmlidXRlLXRvLXRpY2tldC1tb2QtZXZlbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL21vZGVscy9wYXJ0aWNpcGFudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWxzL3BheS1ldmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWxzL3ByaW50LXJlc2VydmVzLWV2ZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9tb2RlbHMvcHJvamVjdC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWxzL3JlZGVlbS1ldmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvbW9kZWxzL3RhcC1ldmVudC50cyIsIndlYnBhY2s6Ly8vYnVmZmVyIChpZ25vcmVkKSJdLCJuYW1lcyI6WyJmb3JtYXRHcmFwaFF1ZXJ5Iiwib3B0cyIsImFyZ3MiLCJhZGRBcmciLCJuYW1lIiwidmFsdWUiLCJ1bmRlZmluZWQiLCJsZW5ndGgiLCJmaXJzdCIsInNraXAiLCJvcmRlckJ5Iiwib3JkZXJEaXJlY3Rpb24iLCJibG9jayIsIm51bWJlciIsImhhc2giLCJ3aGVyZSIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInciLCJrZXkiLCJvcGVyYXRvciIsImVudGl0eSIsImtleXMiLCJyZWR1Y2UiLCJhY2MiLCJ0b1N0cmluZyIsImsiLCJzdWJncmFwaFVybCIsInF1ZXJ5U3ViZ3JhcGgiLCJyZXMiLCJmZXRjaCIsIm1ldGhvZCIsImhlYWRlcnMiLCJib2R5IiwiSlNPTiIsInN0cmluZ2lmeSIsInF1ZXJ5IiwiZGF0YSIsImpzb24iLCJlcnJvciIsImNvbnNvbGUiLCJsb2ciLCJ0cmltSGV4WmVybyIsImhleFN0ciIsInJlcGxhY2UiLCJmb3JtYXRHcmFwaFJlc3BvbnNlIiwicmVzcG9uc2UiLCJwcm9qZWN0cyIsInBhcnNlUHJvamVjdEpzb24iLCJwYXlFdmVudHMiLCJwYXJzZVBheUV2ZW50SnNvbiIsInJlZGVlbUV2ZW50cyIsInBhcnNlUmVkZWVtRXZlbnRKc29uIiwicGFydGljaXBhbnRzIiwicGFyc2VQYXJ0aWNpcGFudEpzb24iLCJ0YXBFdmVudHMiLCJwYXJzZVRhcEV2ZW50SnNvbiIsImRpc3RyaWJ1dGVUb1BheW91dE1vZEV2ZW50cyIsInBhcnNlRGlzdHJpYnV0ZVRvUGF5b3V0TW9kRXZlbnQiLCJkaXN0cmlidXRlVG9UaWNrZXRNb2RFdmVudHMiLCJwYXJzZURpc3RyaWJ1dGVUb1RpY2tldE1vZEV2ZW50IiwicHJpbnRSZXNlcnZlc0V2ZW50cyIsInBhcnNlUHJpbnRSZXNlcnZlc0V2ZW50SnNvbiIsImdldElwZnNDaWRVcmwiLCJmZXRjaFByb2plY3RNZXRhZGF0YSIsInVyaUhhc2giLCJ1cmwiLCJpc0Fzc2V0Um91dGUiLCJpbmNsdWRlcyIsIkF0dHJpYnV0ZVJld3JpdGVyIiwiY29uc3RydWN0b3IiLCJlbGVtZW50IiwiYXR0cmlidXRlIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwiaGFuZGxlUmVxdWVzdCIsInJlcXVlc3QiLCJmZXRjaFVybCIsImNmIiwiY2FjaGVUdGwiLCJoYW5kbGUiLCJ1dGlscyIsImZvcm1hdEJ5dGVzMzJTdHJpbmciLCJwcm9qZWN0IiwibWV0YWRhdGEiLCJ1cmkiLCJyZXdyaXRlciIsIkhUTUxSZXdyaXRlciIsIm9uIiwiZGVzY3JpcHRpb24iLCJ0cmFuc2Zvcm0iLCJhZGRFdmVudExpc3RlbmVyIiwiZXZlbnQiLCJyZXNwb25kV2l0aCIsImZ1bmRpbmdDeWNsZUlkIiwiQmlnTnVtYmVyIiwiZnJvbSIsInByb2plY3RJZCIsIm1vZFBlcmNlbnQiLCJtb2RQcm9qZWN0SWQiLCJtb2RDdXQiLCJtb2RQcmVmZXJVbnN0YWtlZCIsInRpbWVzdGFtcCIsInBhcnNlSW50IiwidG90YWxQYWlkIiwidG9rZW5CYWxhbmNlIiwibGFzdFBhaWRUaW1lc3RhbXAiLCJpZCIsImJlbmVmaWNpYXJ5VGlja2V0QW1vdW50IiwiY291bnQiLCJjcmVhdGVkQXQiLCJwYXJzZUJ5dGVzMzJTdHJpbmciLCJjdXJyZW50QmFsYW5jZSIsInRvdGFsUmVkZWVtZWQiLCJwIiwicGF5ZXIiLCJwYXJzZSIsImFtb3VudCIsInJldHVybkFtb3VudCIsImN1cnJlbmN5IiwibmV0VHJhbnNmZXJBbW91bnQiLCJiZW5lZmljaWFyeVRyYW5zZmVyQW1vdW50IiwiZ292RmVlQW1vdW50Il0sIm1hcHBpbmdzIjoiO1FBQUE7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7OztRQUdBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSwwQ0FBMEMsZ0NBQWdDO1FBQzFFO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0Esd0RBQXdELGtCQUFrQjtRQUMxRTtRQUNBLGlEQUFpRCxjQUFjO1FBQy9EOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSx5Q0FBeUMsaUNBQWlDO1FBQzFFLGdIQUFnSCxtQkFBbUIsRUFBRTtRQUNySTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLDJCQUEyQiwwQkFBMEIsRUFBRTtRQUN2RCxpQ0FBaUMsZUFBZTtRQUNoRDtRQUNBO1FBQ0E7O1FBRUE7UUFDQSxzREFBc0QsK0RBQStEOztRQUVySDtRQUNBOzs7UUFHQTtRQUNBOzs7Ozs7Ozs7Ozs7QUNsRkE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixzQkFBc0I7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQzs7QUFFckM7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsVUFBVTs7Ozs7Ozs7Ozs7O0FDdkx0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsaUJBQWlCO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsc0JBQXNCLEVBQUU7QUFDbEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7Ozs7Ozs7Ozs7Ozs7QUN6TEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQSxzRUFBc0UsRUFBRTtBQUN4RTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsNkNBQTZDLGtCQUFrQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDZCQUE2QixrQkFBa0I7QUFDakU7QUFDQSxtQkFBbUIsa0JBQWtCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixrREFBa0Qsa0JBQWtCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdGQUFjO0FBQ3RCO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDTztBQUNQO0FBQ0E7QUFDQSxnREFBZ0QsNERBQU07QUFDdEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQSwwREFBMEQsNERBQU07QUFDaEU7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGtFQUFTO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EseUVBQXlFLDREQUFNO0FBQy9FO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixrRUFBUztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4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Q0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNPO0FBQ1Asa0RBQWtELGlCQUFpQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0U7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhCQUE4QjtBQUMvQjtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsa0JBQWtCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxvQ0FBb0MsS0FBSztBQUN6Qyx1Q0FBdUMsYUFBYTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUVBQXVFLGtCQUFrQjtBQUN6RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBHQUEwRyx5REFBeUQsc0NBQXNDO0FBQ3pNO0FBQ0E7QUFDQSx1RUFBdUUsa0JBQWtCO0FBQ3pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLGdEQUFPO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDOzs7Ozs7Ozs7Ozs7QUMzVEE7QUFBQTtBQUFPO0FBQ1Asb0M7Ozs7Ozs7Ozs7OztBQ0RBO0FBQUE7QUFBQTtBQUFBO0FBQWE7QUFDa0M7QUFDVjtBQUNyQyxtQkFBbUIsNERBQU0sQ0FBQyxnREFBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRDtBQUNBO0FBQ0EsYUFBYSw2QkFBNkI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLG9CQUFvQixxQ0FBcUM7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFdBQVcsNkJBQTZCO0FBQ3hDLFlBQVksOEJBQThCO0FBQzFDLGVBQWUsbUNBQW1DO0FBQ2xELGVBQWUsZ0NBQWdDO0FBQy9DLHVCQUF1QixzQ0FBc0M7QUFDN0Qsd0JBQXdCLHdDQUF3QztBQUNoRSxlQUFlLG1DQUFtQztBQUNsRCx5QkFBeUIsNENBQTRDO0FBQ3JFLFVBQVUsMkJBQTJCO0FBQ3JDLFdBQVcsNEJBQTRCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkU7QUFDM0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7Ozs7Ozs7O0FDOU5BO0FBQUE7QUFBQTtBQUFBO0FBQWtDO0FBQ2xDLGlDOzs7Ozs7Ozs7Ozs7QUNEQTtBQUFBO0FBQUE7QUFBQTtBQUFhO0FBQzRDO0FBQ1A7QUFDM0M7QUFDUCxlQUFlLHFFQUFRO0FBQ3ZCLFdBQVcscUVBQVE7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixRQUFRO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixxRUFBUSxDQUFDLHVFQUFXO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsZ0JBQWdCO0FBQ3ZDO0FBQ0EsZ0JBQWdCLHFFQUFRLENBQUMsdUVBQVc7QUFDcEMsMkJBQTJCLFVBQVU7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUVBQVE7QUFDdkI7QUFDQSxXQUFXLG9FQUFPO0FBQ2xCO0FBQ0Esa0M7Ozs7Ozs7Ozs7OztBQzNDQTtBQUFBO0FBQU87QUFDUCxvQzs7Ozs7Ozs7Ozs7O0FDREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBYTtBQUNiLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QiwyQkFBMkIsK0RBQStELGdCQUFnQixFQUFFLEVBQUU7QUFDOUc7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IscUZBQXFGO0FBQ3BIO0FBQ0EsS0FBSztBQUNMO0FBQytDO0FBQ1Y7QUFDckMsbUJBQW1CLDREQUFNLENBQUMsZ0RBQU87QUFDMUI7QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ087QUFDUCxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELHFCQUFxQjtBQUM3RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLElBQUk7QUFDYixLQUFLO0FBQ0w7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxnQkFBZ0I7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsZ0JBQWdCO0FBQ3hFO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQzs7Ozs7Ozs7Ozs7O0FDN0hBO0FBQUE7QUFBTztBQUNQLG9DOzs7Ozs7Ozs7Ozs7QUNEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBYTtBQUM4QztBQUNUO0FBQ087QUFDVjtBQUNWO0FBQ3JDLG1CQUFtQiw0REFBTSxDQUFDLGdEQUFPO0FBQzRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyx1Q0FBdUMscUVBQWlCO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdGQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw4QkFBOEIseUVBQWtCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0Isc0VBQW1CO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDOzs7Ozs7Ozs7Ozs7QUM1RkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFhO0FBQ2IsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDdUU7QUFDekI7QUFDTztBQUN1RjtBQUN4RjtBQUNMO0FBQ007QUFDb0M7QUFDNUM7QUFDc0I7QUFDZDtBQUN6QjtBQUNtQjtBQUNWO0FBQ3JDLG1CQUFtQiw2REFBTSxDQUFDLGlEQUFPO0FBQ087QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSwwRUFBYTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksMEVBQWE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSwwRUFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxRQUFRLGdGQUFjO0FBQ3RCLFFBQVEsZ0ZBQWM7QUFDdEIsUUFBUSxnRkFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsdURBQXVEO0FBQ2pFLFVBQVUsd0RBQXdEO0FBQ2xFLFVBQVUsMENBQTBDO0FBQ3BELFdBQVcsNEJBQTRCO0FBQ3ZDLFdBQVcsNEJBQTRCO0FBQ3ZDLFlBQVksNkJBQTZCO0FBQ3pDO0FBQ0E7QUFDQSxXQUFXLHVFQUFVLENBQUMsa0VBQVM7QUFDL0I7QUFDQTtBQUNBO0FBQ0EsV0FBVywyREFBTSxRQUFRLG1FQUFNLFFBQVEseUVBQVksQ0FBQyxrRUFBTSxDQUFDLGtFQUFNO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkVBQVk7QUFDM0I7QUFDQSxtQkFBbUI7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGtFQUFTLE1BQU0seUVBQVk7QUFDOUMsbUJBQW1CLGtFQUFTLE1BQU0seUVBQVk7QUFDOUMsV0FBVyx5RUFBWTtBQUN2QjtBQUNPO0FBQ1A7QUFDQTtBQUNBLFFBQVEsZ0ZBQWM7QUFDdEIsUUFBUSxnRkFBYztBQUN0QixRQUFRLGdGQUFjO0FBQ3RCLFFBQVEsZ0ZBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHNFQUFTLFlBQVksb0VBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyw2REFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxTQUFTLEdBQUcsNkRBQU07QUFDMUUseUNBQXlDLFNBQVM7QUFDbEQsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLHFFQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxtRUFBTTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUVBQU07QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qiw4Q0FBTTtBQUNwQztBQUNBLHVCQUF1Qiw4Q0FBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsb0VBQVE7QUFDdEQ7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGlFQUFRO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsNkRBQU07QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNFQUFzRSw2REFBTTtBQUM1RSw2Q0FBNkMsU0FBUztBQUN0RDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixxQkFBcUI7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLCtCQUErQjtBQUN6RSxvQ0FBb0M7QUFDcEM7QUFDQSwwQ0FBMEMsZ0NBQWdDO0FBQzFFLG9DQUFvQztBQUNwQztBQUNBLDBDQUEwQyxnQ0FBZ0M7QUFDMUUsb0NBQW9DLGdEQUFnRCxvQkFBb0I7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsa0NBQWtDO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHVFQUFVLENBQUMsa0VBQVM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsc0VBQVM7QUFDN0QsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxxQ0FBcUM7QUFDbkY7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELGtFQUFTO0FBQ3pELG9EQUFvRCxzRUFBUyxnQkFBZ0IsdUVBQVU7QUFDdkYsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QywrQ0FBK0M7QUFDN0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0VBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQyw2Q0FBNkM7QUFDdkYsMERBQTBELEdBQUc7QUFDN0Q7QUFDQSxvRUFBb0UsR0FBRztBQUN2RTtBQUNBO0FBQ0EsbURBQW1ELHFFQUFTO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLHNEQUFzRDtBQUNoRywwQ0FBMEMsdUNBQXVDO0FBQ2pGLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJEQUFNO0FBQzlDO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUZBQWlGLDZEQUFNO0FBQ3ZGO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLDBFQUFXO0FBQ3RDO0FBQ0E7QUFDQSx1QkFBdUIsbUVBQU07QUFDN0I7QUFDQTtBQUNBLDJCQUEyQixtRUFBTSxZQUFZLHVFQUFVO0FBQ3ZEO0FBQ0Esa0VBQWtFLG9FQUFPO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiwyRUFBWTtBQUMvQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDTywyQkFBMkIseUVBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MseUVBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRkFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JELHNDQUFzQyxFQUFFO0FBQ3hDO0FBQ0EsNENBQTRDLEVBQUU7QUFDOUM7QUFDQTtBQUNBLGlDQUFpQywyRUFBUztBQUMxQztBQUNBLGdCQUFnQixnRkFBYztBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQSw2REFBNkQsNkRBQU0seUJBQXlCO0FBQzVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdGQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0EsZUFBZSxnRUFBSTtBQUNuQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsbUNBQW1DLDZEQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMscURBQVM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMEVBQVU7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLG1GQUFpQjtBQUM5RCw4REFBOEQ7QUFDOUQ7QUFDQSxhQUFhLFNBQVMsNEJBQTRCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsa0VBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQsd0JBQXdCO0FBQ3hCLGFBQWE7QUFDYjtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCxrQ0FBa0Msb0JBQW9CLGNBQWMsWUFBWTtBQUN6SSxtRkFBbUYsNkRBQU07QUFDekY7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELGtCQUFrQjtBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixvQkFBb0IsMkJBQTJCLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QixvQkFBb0IsMkJBQTJCLEVBQUU7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLG9CQUFvQiwyQkFBMkIsRUFBRTtBQUM5RDtBQUNBLFNBQVM7QUFDVDtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRiw2REFBTTtBQUMxRjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZFQUE2RSw2REFBTTtBQUNuRjtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGNBQWMsRUFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxhQUFhLEVBQUU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsYUFBYSxFQUFFO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELFFBQVEsRUFBRTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msb0RBQW9ELEVBQUU7QUFDOUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELGdDQUFnQztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0ZBQWtGO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLDZEQUFNO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0UsNkRBQU0sa0JBQWtCLG1CQUFtQjtBQUMvRyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHFCQUFxQixFQUFFO0FBQ25FO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRDtBQUMvRDtBQUNBLHVCQUF1QixrRUFBUztBQUNoQztBQUNBO0FBQ0Esb0VBQW9FLDZEQUFNO0FBQzFFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUZBQWlCO0FBQ2xEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1QixrRUFBUztBQUNoQztBQUNBO0FBQ0Esb0VBQW9FLDZEQUFNO0FBQzFFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUZBQWlCO0FBQ2xEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1QixrRUFBUztBQUNoQztBQUNBO0FBQ0Esb0VBQW9FLDZEQUFNO0FBQzFFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUZBQWlCO0FBQ2xEO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1QixvRUFBTztBQUM5QjtBQUNBO0FBQ0Esb0VBQW9FLDZEQUFNO0FBQzFFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsbUZBQWlCO0FBQ2xEO0FBQ0E7QUFDQSxnRUFBZ0UscUVBQVE7QUFDeEUsYUFBYTtBQUNiO0FBQ0E7QUFDQSx1QkFBdUIsb0VBQU87QUFDOUI7QUFDQTtBQUNBLG9FQUFvRSw2REFBTTtBQUMxRTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QiwwRUFBYTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEZBQTBGLDZEQUFNLHdCQUF3Qiw0Q0FBNEM7QUFDcEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELDZEQUFNO0FBQzlEO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsb0VBQU87QUFDcEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FLDJCQUEyQjtBQUMvRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxrRUFBUztBQUNqRixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdFQUF3RSxvRUFBTztBQUMvRSxhQUFhO0FBQ2IsMkRBQTJELG1GQUFpQjtBQUM1RSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiwrQ0FBK0MsbUZBQWlCO0FBQ2hFLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtRkFBaUI7QUFDbEQ7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsdUJBQXVCLG9FQUFPO0FBQzlCO0FBQ0E7QUFDQSxvRUFBb0UsNkRBQU07QUFDMUU7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQyxtRkFBaUI7QUFDbEQ7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLHVCQUF1QixrRUFBUztBQUNoQztBQUNBO0FBQ0Esb0VBQW9FLDZEQUFNO0FBQzFFO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDZEQUFNO0FBQ25FLDhDQUE4Qyw4QkFBOEI7QUFDNUUsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0VBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3Qix3RUFBVztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnRUFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLCtCQUErQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUksaUJBQWlCO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLG1CQUFtQixnRUFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLElBQUksaUJBQWlCO0FBQ2xDLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLG1CQUFtQixnRUFBSTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsSUFBSSxpQkFBaUI7QUFDbEMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLG1GQUFpQixFQUFFLGtDQUFrQztBQUN0RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLG1CQUFtQixxREFBUztBQUM1QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsNkRBQU07QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0UsNkRBQU0sZ0NBQWdDLDBDQUEwQztBQUNsSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvRUFBUTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDZEQUFNO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdFQUFXO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHFFQUFRO0FBQ2hDO0FBQ0Esc0NBQXNDLG9FQUFRO0FBQzlDLGFBQWE7QUFDYjtBQUNBLHNDQUFzQyxrRUFBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGtFQUFTO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsMkVBQVk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHdFQUFXO0FBQzNCLDJCQUEyQjtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhEQUE4RCw2REFBTSwwQkFBMEIsb0JBQW9CO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyx3QkFBd0IsRUFBRTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULG9DQUFvQyx3QkFBd0IsRUFBRTtBQUM5RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLG9DQUFvQyx3QkFBd0IsRUFBRTtBQUM5RDtBQUNBO0FBQ0E7QUFDQSx5Qzs7Ozs7Ozs7Ozs7O0FDM3FEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWE7QUFDYixpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsMkJBQTJCLCtEQUErRCxnQkFBZ0IsRUFBRSxFQUFFO0FBQzlHO0FBQ0EsbUNBQW1DLE1BQU0sNkJBQTZCLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDakcsa0NBQWtDLE1BQU0saUNBQWlDLEVBQUUsWUFBWSxXQUFXLEVBQUU7QUFDcEcsK0JBQStCLHFGQUFxRjtBQUNwSDtBQUNBLEtBQUs7QUFDTDtBQUM2RDtBQUNkO0FBQ1Y7QUFDckMsbUJBQW1CLDREQUFNLENBQUMsZ0RBQU87QUFDMUIsaUNBQWlDLHlFQUFrQjtBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUscUJBQXFCO0FBQ2hHO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0M7Ozs7Ozs7Ozs7OztBQy9DQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFhO0FBQ2IsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDc0U7QUFDRDtBQUNUO0FBQ2I7QUFDRztBQUNIO0FBQ1Y7QUFDckMsbUJBQW1CLDREQUFNLENBQUMsZ0RBQU87QUFDYztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLHNIQUFzSDtBQUNuSSxvQkFBb0IscUVBQVEsQ0FBQyxvRUFBTztBQUNwQztBQUNBO0FBQ0EsMEJBQTBCLGlGQUFhO0FBQ3ZDLHlCQUF5QixXQUFXLFlBQVksa0JBQWtCLDRCQUE0QixHQUFHO0FBQ2pHLGFBQWE7QUFDYjtBQUNBO0FBQ0Esb0JBQW9CLG9FQUFPO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2Qiw0Q0FBNEMsNERBQU07QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3RUFBVztBQUMzQjtBQUNBO0FBQ0EsdUVBQXVFLDREQUFNO0FBQzdFO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLDREQUFNO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0VBQStFLDREQUFNO0FBQ3JGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw0REFBTTtBQUMvRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxxREFBcUQsNERBQU07QUFDM0Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtDQUErQyx3REFBd0QsNERBQU07QUFDN0c7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLDJEQUFZO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0ZBQWM7QUFDdEIsUUFBUSxnRkFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsSUFBSSxHQUFHLE1BQU07QUFDMUM7QUFDQTtBQUNBLFNBQVM7QUFDVCxtREFBbUQsWUFBWTtBQUMvRCxrQkFBa0IsYUFBYSxjQUFjLE9BQU8sRUFBRSxNQUFNLEVBQUUsT0FBTztBQUNyRTtBQUNBO0FBQ0Esa0JBQWtCLGFBQWE7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0VBQW1CO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxvREFBb0Q7QUFDMUY7QUFDQSw4QkFBOEIsSUFBSSxHQUFHLGFBQWE7QUFDbEQsaUJBQWlCO0FBQ2pCO0FBQ0EsaUNBQWlDLG9FQUFTO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQiwwRUFBUTtBQUNsQztBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCw0QkFBNEI7QUFDNUU7QUFDQSxnREFBZ0QseUJBQXlCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsNERBQU0sZ0NBQWdDLCtCQUErQjtBQUM5STtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw0REFBTSxnQ0FBZ0MsaUJBQWlCO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQ0FBbUMsaUJBQWlCO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxxQkFBcUI7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEM7Ozs7Ozs7Ozs7OztBQ2xhQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBYTtBQUNiLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QiwyQkFBMkIsK0RBQStELGdCQUFnQixFQUFFLEVBQUU7QUFDOUc7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IscUZBQXFGO0FBQ3BIO0FBQ0EsS0FBSztBQUNMO0FBQzREO0FBQ1A7QUFDRjtBQUMrQjtBQUNqQztBQUNQO0FBQ0s7QUFDRztBQUNIO0FBQ1Y7QUFDckMsbUJBQW1CLDREQUFNLENBQUMsZ0RBQU87QUFDakMsZ0JBQWdCLCtCQUErQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxrRUFBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLGdCQUFnQjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLElBQUksNERBQU07QUFDVixJQUFJLDREQUFNO0FBQ1YsSUFBSSw0REFBTTtBQUNWLElBQUksNERBQU07QUFDVixJQUFJLDREQUFNO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw2QkFBNkI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSx1QkFBdUIsaUJBQWlCO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDZFQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0Qiw2RUFBVztBQUN2QztBQUNBLDZCQUE2Qiw2RUFBVztBQUN4QztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsK0RBQUk7QUFDbkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiLFNBQVMsR0FBRyxxQkFBcUI7QUFDakMsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdFQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdFQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLHdFQUFXO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsd0VBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5Qyx3RUFBVywwQ0FBMEMsd0VBQVc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw0REFBTTtBQUMvRDtBQUNBO0FBQ0EsU0FBUztBQUNULEtBQUs7QUFDTDtBQUNPLCtCQUErQiwyREFBWTtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IseUVBQVE7QUFDeEIscUNBQXFDLHNFQUFtQjtBQUN4RDtBQUNBLHNDQUFzQyxnRUFBZ0U7QUFDdEc7QUFDQSwyQkFBMkIsNkVBQVc7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0Msc0VBQW1CO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBEQUEwRCw0Q0FBNEMsTUFBTTtBQUM1RztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdGQUFjO0FBQ3RCLFFBQVEsZ0ZBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQSwrQkFBK0Isb0JBQW9CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBLDRCQUE0QixzRUFBUSwwQkFBMEIscUVBQVc7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLHVCQUF1QixFQUFFO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUJBQXlCLDBFQUFRLFVBQVU7QUFDckY7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMseUJBQXlCLDBFQUFRLFVBQVU7QUFDckY7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyx5QkFBeUIsMEVBQVEsVUFBVTtBQUNqRjtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSw0REFBNEQ7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsS0FBSztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0EsaUJBQWlCO0FBQ2pCLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLDhEQUE4RCw0REFBTTtBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSw2Qzs7Ozs7Ozs7Ozs7O0FDcmtCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFhO0FBQzJEO0FBQ25CO0FBQ2lEO0FBQy9DO0FBQ0M7QUFDK0I7QUFDeEM7QUFDVjtBQUNyQyxtQkFBbUIsNERBQU0sQ0FBQyxnREFBTztBQUMxQjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQywyQkFBMkI7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDZFQUFXO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpRkFBYTtBQUM1QjtBQUNBLDZFQUE2RTtBQUM3RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrRUFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxrRUFBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtFQUFTO0FBQ3hCO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0VBQVc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHlFQUFVO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhLHdFQUFXO0FBQ3hCO0FBQ0E7QUFDQSx3QkFBd0IseUVBQVUsQ0FBQyx5RUFBWTtBQUMvQyw0QkFBNEIsb0VBQVc7QUFDdkM7QUFDQTtBQUNBLGVBQWUsaUZBQWtCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qyx3RUFBVztBQUN6RCxtQkFBbUIscUVBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxZQUFZLDBFQUFhO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrRUFBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0EsYUFBYSx3RUFBVztBQUN4QjtBQUNBO0FBQ0EsZUFBZSx1RUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELGtFQUFTO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQiw4QkFBOEIsa0VBQVM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isd0VBQVc7QUFDM0IsMEJBQTBCLGtFQUFTO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQix3RUFBVztBQUMzQiwwQkFBMEIsa0VBQVM7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUseUVBQWdCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLGtFQUFTO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLCtGQUErRiwyQ0FBMkM7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQzs7Ozs7Ozs7Ozs7O0FDMWJBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBYTtBQUMrQztBQUNQO0FBQ0k7QUFDc0I7QUFDcEI7QUFDRjtBQUNGO0FBQ1Y7QUFDK0I7QUFDUDtBQUNKO0FBQ1I7QUFDTjtBQUNpQztBQUNyQztBQUNVO0FBQ2lEO0FBQzNEO0FBQ1Y7QUFDckMsbUJBQW1CLDZEQUFNLENBQUMsaURBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLGtFQUFlO0FBQzlDO0FBQ0EsK0JBQStCLHNFQUFpQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYywwRUFBVTtBQUN4QjtBQUNBLG9FQUFvRSw2REFBTTtBQUMxRTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRLHFGQUFnQjtBQUN4QixRQUFRLGtGQUFlO0FBQ3ZCLFFBQVEsMkZBQWtCO0FBQzFCLFFBQVEsd0ZBQWlCO0FBQ3pCLFFBQVEsK0VBQWM7QUFDdEIsUUFBUSxtRkFBZTtBQUN2QixRQUFRLHlGQUFpQjtBQUN6QixRQUFRLGdGQUFjO0FBQ3RCLFFBQVEsMEVBQVk7QUFDcEIsUUFBUSxzRUFBVztBQUNuQixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBZVk7QUFDWixpQzs7Ozs7Ozs7Ozs7O0FDaEZBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFhO0FBQzhDO0FBQ0Y7QUFDUDtBQUNIO0FBQ1Y7QUFDckMsbUJBQW1CLDREQUFNLENBQUMsZ0RBQU87QUFDNEI7QUFDN0Q7QUFDTyxzQ0FBc0MscUVBQWlCO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEVBQThFLDREQUFNO0FBQ3BGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0ZBQWM7QUFDdEIsUUFBUSxnRkFBYztBQUN0QixRQUFRLGdGQUFjO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTyw2QkFBNkIseUVBQWtCO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDREQUFNO0FBQy9EO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHNFQUFtQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkM7Ozs7Ozs7Ozs7OztBQ3RIQTtBQUFBO0FBQWE7QUFDYjtBQUN1QjtBQUN2Qix3Qzs7Ozs7Ozs7Ozs7O0FDSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFxRDtBQUNOO0FBQ087QUFDdEQ7QUFDTyxtQ0FBbUMsa0VBQWU7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLDBFQUFRO0FBQ3JDO0FBQ0EsaUJBQWlCO0FBQ2pCLHVCQUF1QixvRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckIsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EOzs7Ozs7Ozs7Ozs7QUN6RUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFhO0FBQ2IsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDd0Q7QUFDSDtBQUNpQjtBQUNkO0FBQ3lFO0FBQzVFO0FBQ087QUFDUDtBQUNOO0FBQ1Y7QUFDckMsbUJBQW1CLDREQUFNLENBQUMsZ0RBQU87QUFDYztBQUMvQztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNENBQTRDLDREQUFNO0FBQ2xEO0FBQ0EsZ0RBQWdELHdFQUFXO0FBQzNEO0FBQ0E7QUFDQSxtRUFBbUUsNERBQU07QUFDekU7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLHVCQUF1Qiw0REFBTTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0UsNERBQU07QUFDckY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EseURBQXlELDREQUFNO0FBQy9EO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCw0REFBTTtBQUMzRDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsNERBQU07QUFDakY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLCtDQUErQyx3REFBd0QsNERBQU07QUFDN0c7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLDRCQUE0QixxRUFBTTtBQUN6QztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdGQUFnRjtBQUNoRjtBQUNBLFFBQVEsZ0ZBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGdGQUFjO0FBQzFCLFlBQVksZ0ZBQWM7QUFDMUI7QUFDQTtBQUNBLFlBQVksZ0ZBQWM7QUFDMUIsWUFBWSxnRkFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0RUFBNEUsNERBQU07QUFDbEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxRUFBcUUsNERBQU07QUFDM0U7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0Esc0JBQXNCLDZFQUFXO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2RUFBVztBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGVBQWUsbUZBQWlCO0FBQ2hDLGdCQUFnQixtRkFBaUI7QUFDakM7QUFDQSxTQUFTLFNBQVMsYUFBYTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLGFBQWE7QUFDekY7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLHdFQUF3RSw0REFBTTtBQUM5RTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQiw2QkFBNkIsK0RBQUk7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJLDBCQUEwQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLDREQUE0RCwwRUFBVztBQUN2RTtBQUNBLDhEQUE4RCxvRUFBTztBQUNyRSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsNERBQTRELDBFQUFXO0FBQ3ZFO0FBQ0E7QUFDQSxnRkFBZ0Ysb0VBQU87QUFDdkYsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLHFFQUFpQjtBQUNyRDtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IscUVBQWlCO0FBQ2hEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEMsOERBQThEO0FBQ3hHO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sOEJBQThCLDREQUFZO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLDJFQUFTO0FBQzNCO0FBQ0E7QUFDQSxZQUFZLGdGQUFjO0FBQzFCO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxZQUFZLGdGQUFjLG1DQUFtQyw2RUFBVztBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0EsbUNBQW1DLDJFQUFTO0FBQzVDO0FBQ0Esc0NBQXNDLGtFQUFTO0FBQy9DO0FBQ0E7QUFDQSx5RUFBeUUsNERBQU07QUFDL0U7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxpRUFBaUUsNERBQU07QUFDdkU7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBFQUFRO0FBQzdCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixvRUFBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLDJFQUFTO0FBQ3BELDZFQUE2RSxhQUFhO0FBQzFGO0FBQ0E7QUFDQSwyQ0FBMkMsMkVBQVM7QUFDcEQsb0ZBQW9GLGFBQWE7QUFDakc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxrRUFBUztBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLDZFQUFXO0FBQ2hELGlEQUFpRCw2RUFBVztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtEQUErRCw0REFBTSwwQkFBMEIsb0JBQW9CO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLHlCQUF5QjtBQUN6QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUSxFQUFFO0FBQ3REO0FBQ0EsaUJBQWlCLG9CQUFvQixFQUFFO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLFNBQVMsb0JBQW9CLEVBQUU7QUFDL0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLDZFQUFXO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxpRkFBZTtBQUN2QjtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixxRUFBUTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixvRUFBTztBQUNqQyxTQUFTO0FBQ1Q7QUFDQSxtQ0FBbUMsaUZBQWE7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Qzs7Ozs7Ozs7Ozs7O0FDN2tCQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDYTtBQUNnRDtBQUNkO0FBQ1Y7QUFDckMsbUJBQW1CLDREQUFNLENBQUMsZ0RBQU87QUFDakM7QUFDQTtBQUNPLGdDQUFnQyx5RUFBa0I7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDOzs7Ozs7Ozs7Ozs7QUN4Q0E7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWE7QUFDeUM7QUFDUDtBQUNWO0FBQ3JDLG1CQUFtQiw0REFBTSxDQUFDLGdEQUFPO0FBQzRCO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sNkJBQTZCLHlFQUFrQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyRUFBUztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDREQUFNO0FBQy9EO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlEQUF5RCw0REFBTTtBQUMvRDtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixLQUFLLFNBQVMscUJBQXFCO0FBQ2pFO0FBQ0E7QUFDQSw4QkFBOEIsS0FBSyxNQUFNLHFCQUFxQjtBQUM5RDtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDOzs7Ozs7Ozs7Ozs7QUNqSEE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBYTtBQUNiLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3QiwyQkFBMkIsK0RBQStELGdCQUFnQixFQUFFLEVBQUU7QUFDOUc7QUFDQSxtQ0FBbUMsTUFBTSw2QkFBNkIsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNqRyxrQ0FBa0MsTUFBTSxpQ0FBaUMsRUFBRSxZQUFZLFdBQVcsRUFBRTtBQUNwRywrQkFBK0IscUZBQXFGO0FBQ3BIO0FBQ0EsS0FBSztBQUNMO0FBQ3NFO0FBQ3ZCO0FBQ1Y7QUFDckMsbUJBQW1CLDREQUFNLENBQUMsZ0RBQU87QUFDcUI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPLG9DQUFvQyxrRUFBZTtBQUMxRDtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDREQUFNLHlCQUF5QjtBQUM1RjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixnRkFBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsMkVBQVM7QUFDM0IsaUJBQWlCLDJFQUFTO0FBQzFCLDJCQUEyQiwyRUFBUztBQUNwQztBQUNBO0FBQ0EsWUFBWSxnRkFBYztBQUMxQjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsZ0ZBQWM7QUFDOUIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRSw0REFBTSxnQ0FBZ0MseUJBQXlCO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxvQ0FBb0MsNERBQU07QUFDNUY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLGlEOzs7Ozs7Ozs7Ozs7QUMzRkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWE7QUFDd0Q7QUFDdEI7QUFDVjtBQUNyQyxtQkFBbUIsNERBQU0sQ0FBQyxnREFBTztBQUNxQjtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLDBFQUFRO0FBQ2pDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLDBFQUFRO0FBQzdCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ08sMkJBQTJCLGtFQUFlO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLGdGQUFjO0FBQ3RCLFFBQVEsZ0ZBQWM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDOzs7Ozs7Ozs7Ozs7QUNuSUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFhO0FBQ2IsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDJCQUEyQiwrREFBK0QsZ0JBQWdCLEVBQUUsRUFBRTtBQUM5RztBQUNBLG1DQUFtQyxNQUFNLDZCQUE2QixFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ2pHLGtDQUFrQyxNQUFNLGlDQUFpQyxFQUFFLFlBQVksV0FBVyxFQUFFO0FBQ3BHLCtCQUErQixxRkFBcUY7QUFDcEg7QUFDQSxLQUFLO0FBQ0w7QUFDcUQ7QUFDTTtBQUNMO0FBQ3JCO0FBQ2M7QUFDVjtBQUNyQyxtQkFBbUIsNERBQU0sQ0FBQyxnREFBTztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ08sZ0NBQWdDLGtFQUFlO0FBQ3REO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0Esc0ZBQXNGLDREQUFNO0FBQzVGO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnRkFBYyx5QkFBeUIsNkNBQVM7QUFDeEQsUUFBUSxnRkFBYyxzQkFBc0I7QUFDNUMsUUFBUSxnRkFBYyxrQkFBa0I7QUFDeEMsUUFBUSxnRkFBYyxvQkFBb0I7QUFDMUMsUUFBUSxnRkFBYztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGdGQUFjO0FBQ3RDLHdCQUF3QixnRkFBYztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEVBQTRFLDREQUFNO0FBQ2xGO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSw4RUFBOEUsNERBQU07QUFDcEY7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFFQUFxRSw0REFBTTtBQUMzRTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0Msa0VBQVM7QUFDakQ7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsNkNBQVM7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDhDOzs7Ozs7Ozs7Ozs7QUM3UkE7QUFBQTtBQUFBO0FBQUE7QUFBYTtBQUNrQztBQUNWO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNERBQU0sQ0FBQyxnREFBTztBQUNyQztBQUNBLDBFQUEwRSw0REFBTTtBQUNoRjtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUMyQjtBQUMzQiw4Qjs7Ozs7Ozs7Ozs7O0FDckJBO0FBQUE7QUFBTztBQUNQLG9DOzs7Ozs7Ozs7Ozs7QUNEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFhO0FBQzBCO0FBQ0Y7QUFDckMsaUM7Ozs7Ozs7Ozs7OztBQ0hBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBYTtBQUNtQztBQUNEO0FBQ1Y7QUFDckMsbUJBQW1CLDREQUFNLENBQUMsZ0RBQU87QUFDakM7QUFDQSxrQkFBa0IsVUFBVSx5QkFBeUIsRUFBRSxFQUFFO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsNERBQU07QUFDaEY7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxxRUFBUTtBQUNuQjtBQUNBO0FBQ0Esa0M7Ozs7Ozs7Ozs7Ozs7QUM3Q0E7QUFBQTtBQUFhO0FBQ047QUFDUDtBQUNBLGtDQUFrQyxPQUFPO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUM7Ozs7Ozs7Ozs7OztBQ1hBO0FBQUE7QUFBTztBQUNQLG9DOzs7Ozs7Ozs7Ozs7QUNEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBYTtBQUNiO0FBQ3NFO0FBQ3ZCO0FBQ1Y7QUFDckMsbUJBQW1CLDREQUFNLENBQUMsZ0RBQU87QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsWUFBWTtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsd0VBQVc7QUFDcEI7QUFDQTtBQUNBLDRDQUE0QyxxRUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUCxXQUFXLG9FQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNERBQU0sMEJBQTBCO0FBQ3RGO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLDRDQUE0Qyw0REFBTSwwQkFBMEI7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhEQUE4RCw0REFBTSwwQkFBMEI7QUFDOUY7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELDREQUFNLDBCQUEwQjtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0QsNERBQU0sMEJBQTBCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCw0REFBTSwwQkFBMEI7QUFDdEY7QUFDQTtBQUNBO0FBQ0Esc0RBQXNELDREQUFNLDBCQUEwQjtBQUN0RjtBQUNBLHVCQUF1QixvRUFBTztBQUM5QixnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsNERBQU0sMEJBQTBCO0FBQ2hGO0FBQ0EsdUJBQXVCLG9FQUFPO0FBQzlCLGdCQUFnQjtBQUNoQjtBQUNBLFlBQVksc0JBQXNCLG9FQUFPO0FBQ3pDO0FBQ087QUFDUCxrQkFBa0IscUVBQVE7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUM7Ozs7Ozs7Ozs7OztBQ3ZIQTtBQUFBO0FBQU87QUFDUCxvQzs7Ozs7Ozs7Ozs7O0FDREE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBZ0U7QUFDbkI7QUFDeUI7QUFDdEUsaUM7Ozs7Ozs7Ozs7OztBQ0hBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBYTtBQUNjO0FBQzNCO0FBQ2dEO0FBQ0g7QUFDRTtBQUNWO0FBQ3JDLG1CQUFtQiw0REFBTSxDQUFDLGdEQUFPO0FBQzFCO0FBQ1AsbUJBQW1CLDhDQUFJLG9CQUFvQixxRUFBUTtBQUNuRDtBQUNPO0FBQ1AsbUJBQW1CLDhDQUFJLGlCQUFpQixxRUFBUTtBQUNoRDtBQUNPO0FBQ1AsbUJBQW1CLDhDQUFJLGlCQUFpQixxRUFBUTtBQUNoRDtBQUNPO0FBQ1AsU0FBUyx5REFBa0I7QUFDM0IsZ0VBQWdFLDREQUFNO0FBQ3RFO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxrQkFBa0IsOENBQUksTUFBTSw4Q0FBSSxhQUFhLHFFQUFRLGNBQWMscUVBQVE7QUFDM0U7QUFDQSxnQzs7Ozs7Ozs7Ozs7O0FDMUJBO0FBQUE7QUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLENBQUMsZ0RBQWdEO0FBQ2pEO0FBQ0EsaUM7Ozs7Ozs7Ozs7OztBQ05BO0FBQUE7QUFBTztBQUNQLG9DOzs7Ozs7Ozs7Ozs7QUNEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBdUI7QUFDSTs7QUFFM0I7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLGlCQUFpQixZQUFZO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQSxHQUFHO0FBQ0gsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxpQkFBaUIsZ0JBQWdCO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSw0Q0FBRTtBQUNmO0FBQ0E7QUFDQSxDQUFDOztBQUVEOzs7O0FBSUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlLDRDQUFFOztBQUVqQjtBQUNBLDBCQUEwQiw0Q0FBRSxtQkFBbUIsNENBQUU7O0FBRWpEO0FBQ0Esa0JBQWtCLDRDQUFFO0FBQ3BCLGlCQUFpQiw0Q0FBRTtBQUNuQixpQkFBaUIsNENBQUU7O0FBRW5CO0FBQ0EseUJBQXlCLDRDQUFFO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLGdCQUFnQjtBQUM3QjtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCLE9BQU87QUFDeEIsZUFBZSxpQkFBaUI7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEIsUUFBUTtBQUN0QztBQUNBLG1CQUFtQix3QkFBd0I7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEsU0FBUztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLFFBQVE7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCOztBQUVBO0FBQ0E7QUFDQSxpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxTQUFTO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FB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QUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVLDRDQUFFOztBQUVaO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBOzs7Ozs7QUFNQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhDQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhDQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhDQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOENBQUk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBSTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLDhDQUFJO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsOENBQUk7QUFDWjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSw4Q0FBSTs7QUFFWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELENBQUM7O0FBRUQ7Ozs7OztBQU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7O0FBRUE7QUFDQSxhQUFhLDhDQUFJO0FBQ2pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGtCQUFrQixzQkFBc0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTtBQUNaO0FBQ0EsWUFBWTs7QUFFWixVQUFVO0FBQ1Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtCQUFrQiw0Q0FBRTs7QUFFcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7Ozs7O0FBS0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxlQUFlLDRDQUFFO0FBQ2pCLGVBQWUsNENBQUU7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQ0FBZ0MsY0FBYztBQUM5QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7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QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixpQkFBaUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQiw0QkFBNEI7QUFDN0M7QUFDQTs7QUFFQSxpQkFBaUIsYUFBYTtBQUM5QjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsaUJBQWlCLGFBQWE7QUFDOUI7QUFDQTs7QUFFQTtBQUNBOztBQUVBLFlBQVksZUFBZTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxxQkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixpQkFBaUI7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsbUJBQW1CLGdCQUFnQjtBQUNuQztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBOztBQUVBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsaUJBQWlCO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsY0FBYztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsNkJBQTZCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLGNBQWM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDZCQUE2QjtBQUN2QztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsWUFBWSxjQUFjO0FBQzFCO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxtQkFBbUIsU0FBUztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELFdBQVc7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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QTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkIsbUNBQW1DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsNkJBQTZCLG1DQUFtQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDZCQUE2QixtQ0FBbUM7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUJBQXVCLDBCQUEwQjtBQUNqRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUIsZ0NBQWdDO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsUUFBUTtBQUN6QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixZQUFZO0FBQy9CO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG1CQUFtQixnQkFBZ0I7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsb0JBQW9CO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCLFFBQVE7QUFDcEM7QUFDQSw2QkFBNkIsUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxFQUFFLE1BQTZCOzs7Ozs7Ozs7Ozs7OztBQ3IzR2hDO0FBQUE7QUFBTztBQUNQLG9DOzs7Ozs7Ozs7Ozs7QUNEQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQWE7QUFDc0U7QUFDakI7QUFDRTtBQUNyQjtBQUNPO0FBQ0E7QUFDUTtBQUNDO0FBQzlCO0FBQ21DO0FBQ3BFO0FBQ0E7QUFDQTtBQUNxQztBQUNyQyxtQkFBbUIsNERBQU0sQ0FBQyxnREFBTztBQUNqQztBQUNBO0FBSW9CO0FBQ3BCLGtDOzs7Ozs7Ozs7Ozs7QUN0QkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBYTtBQUNiO0FBQ21DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixvQ0FBTTtBQUNsQztBQUNBO0FBQ0EsZUFBZTtBQUNHO0FBSWtCO0FBQ3BDLGlDOzs7Ozs7Ozs7Ozs7QUNmQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsUUFBUTtBQUN6QjtBQUNBLFFBQVEsY0FBYztBQUN0Qiw4Q0FBOEM7QUFDOUM7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQSwwQkFBMEI7QUFDMUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQkFBaUIsY0FBYztBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQzs7QUFFbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLG1DQUFtQzs7QUFFbkM7QUFD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QTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQ3JSQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUMxQkE7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsWUFBWSxLQUE0QixJQUFJLHFKQUFVO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUJBQW1CLHlCQUF5QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLG9DQUFvQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDaUYsUUFBcEIsQ0FBaEIsR0FBZ0RsSCxTQVAzQjtBQVEvQm1ILG1CQUFpQixFQUFFbEYsSUFBSSxDQUFDa0YsaUJBQUwsR0FDZnpCLGdEQUFTLENBQUNDLElBQVYsQ0FBZTFELElBQUksQ0FBQ2tGLGlCQUFwQixDQURlLEdBRWZuSCxTQVYyQjtBQVcvQm9ILDJCQUF5QixFQUFFbkYsSUFBSSxDQUFDbUYseUJBQUwsR0FDdkIxQixnREFBUyxDQUFDQyxJQUFWLENBQWUxRCxJQUFJLENBQUNtRix5QkFBcEIsQ0FEdUIsR0FFdkJwSCxTQWIyQjtBQWMvQnFILGNBQVksRUFBRXBGLElBQUksQ0FBQ29GLFlBQUwsR0FDVjNCLGdEQUFTLENBQUNDLElBQVYsQ0FBZTFELElBQUksQ0FBQ29GLFlBQXBCLENBRFUsR0FFVnJILFNBaEIyQjtBQWlCL0JpRyxXQUFTLEVBQUVoRSxJQUFJLENBQUNnRSxTQUFMLEdBQWlCQyxRQUFRLENBQUNqRSxJQUFJLENBQUNnRSxTQUFOLENBQXpCLEdBQTRDakc7QUFqQnhCLEVBQTFCLEM7Ozs7Ozs7Ozs7O0FDbkJQLGUiLCJmaWxlIjoid29ya2VyLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZ2V0dGVyIH0pO1xuIFx0XHR9XG4gXHR9O1xuXG4gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSBmdW5jdGlvbihleHBvcnRzKSB7XG4gXHRcdGlmKHR5cGVvZiBTeW1ib2wgIT09ICd1bmRlZmluZWQnICYmIFN5bWJvbC50b1N0cmluZ1RhZykge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuIFx0XHR9XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG4gXHR9O1xuXG4gXHQvLyBjcmVhdGUgYSBmYWtlIG5hbWVzcGFjZSBvYmplY3RcbiBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuIFx0Ly8gbW9kZSAmIDI6IG1lcmdlIGFsbCBwcm9wZXJ0aWVzIG9mIHZhbHVlIGludG8gdGhlIG5zXG4gXHQvLyBtb2RlICYgNDogcmV0dXJuIHZhbHVlIHdoZW4gYWxyZWFkeSBucyBvYmplY3RcbiBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbiBcdF9fd2VicGFja19yZXF1aXJlX18udCA9IGZ1bmN0aW9uKHZhbHVlLCBtb2RlKSB7XG4gXHRcdGlmKG1vZGUgJiAxKSB2YWx1ZSA9IF9fd2VicGFja19yZXF1aXJlX18odmFsdWUpO1xuIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuIFx0XHRpZigobW9kZSAmIDQpICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgJiYgdmFsdWUuX19lc01vZHVsZSkgcmV0dXJuIHZhbHVlO1xuIFx0XHR2YXIgbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkobnMsICdkZWZhdWx0JywgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdmFsdWUgfSk7XG4gXHRcdGlmKG1vZGUgJiAyICYmIHR5cGVvZiB2YWx1ZSAhPSAnc3RyaW5nJykgZm9yKHZhciBrZXkgaW4gdmFsdWUpIF9fd2VicGFja19yZXF1aXJlX18uZChucywga2V5LCBmdW5jdGlvbihrZXkpIHsgcmV0dXJuIHZhbHVlW2tleV07IH0uYmluZChudWxsLCBrZXkpKTtcbiBcdFx0cmV0dXJuIG5zO1xuIFx0fTtcblxuIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubiA9IGZ1bmN0aW9uKG1vZHVsZSkge1xuIFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbiBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuIFx0XHRcdGZ1bmN0aW9uIGdldE1vZHVsZUV4cG9ydHMoKSB7IHJldHVybiBtb2R1bGU7IH07XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsICdhJywgZ2V0dGVyKTtcbiBcdFx0cmV0dXJuIGdldHRlcjtcbiBcdH07XG5cbiBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSkgeyByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwgcHJvcGVydHkpOyB9O1xuXG4gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5wID0gXCJcIjtcblxuXG4gXHQvLyBMb2FkIGVudHJ5IG1vZHVsZSBhbmQgcmV0dXJuIGV4cG9ydHNcbiBcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKF9fd2VicGFja19yZXF1aXJlX18ucyA9IFwiLi9zcmMvaW5kZXgudHNcIik7XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuIiwidmFyIHNjb3BlID0gKHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgJiYgZ2xvYmFsKSB8fFxuICAgICAgICAgICAgKHR5cGVvZiBzZWxmICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYpIHx8XG4gICAgICAgICAgICB3aW5kb3c7XG52YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJUaW1lb3V0KTtcbn07XG5leHBvcnRzLnNldEludGVydmFsID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiBuZXcgVGltZW91dChhcHBseS5jYWxsKHNldEludGVydmFsLCBzY29wZSwgYXJndW1lbnRzKSwgY2xlYXJJbnRlcnZhbCk7XG59O1xuZXhwb3J0cy5jbGVhclRpbWVvdXQgPVxuZXhwb3J0cy5jbGVhckludGVydmFsID0gZnVuY3Rpb24odGltZW91dCkge1xuICBpZiAodGltZW91dCkge1xuICAgIHRpbWVvdXQuY2xvc2UoKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gVGltZW91dChpZCwgY2xlYXJGbikge1xuICB0aGlzLl9pZCA9IGlkO1xuICB0aGlzLl9jbGVhckZuID0gY2xlYXJGbjtcbn1cblRpbWVvdXQucHJvdG90eXBlLnVucmVmID0gVGltZW91dC5wcm90b3R5cGUucmVmID0gZnVuY3Rpb24oKSB7fTtcblRpbWVvdXQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2NsZWFyRm4uY2FsbChzY29wZSwgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG4vLyBPbiBzb21lIGV4b3RpYyBlbnZpcm9ubWVudHMsIGl0J3Mgbm90IGNsZWFyIHdoaWNoIG9iamVjdCBgc2V0aW1tZWRpYXRlYCB3YXNcbi8vIGFibGUgdG8gaW5zdGFsbCBvbnRvLiAgU2VhcmNoIGVhY2ggcG9zc2liaWxpdHkgaW4gdGhlIHNhbWUgb3JkZXIgYXMgdGhlXG4vLyBgc2V0aW1tZWRpYXRlYCBsaWJyYXJ5LlxuZXhwb3J0cy5zZXRJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiICYmIGdsb2JhbC5zZXRJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICh0aGlzICYmIHRoaXMuc2V0SW1tZWRpYXRlKTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSAodHlwZW9mIHNlbGYgIT09IFwidW5kZWZpbmVkXCIgJiYgc2VsZi5jbGVhckltbWVkaWF0ZSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBnbG9iYWwuY2xlYXJJbW1lZGlhdGUpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgKHRoaXMgJiYgdGhpcy5jbGVhckltbWVkaWF0ZSk7XG4iLCIvKiBnbG9iYWxzIF9fd2VicGFja19hbWRfb3B0aW9uc19fICovXG5tb2R1bGUuZXhwb3J0cyA9IF9fd2VicGFja19hbWRfb3B0aW9uc19fO1xuIiwidmFyIGc7XG5cbi8vIFRoaXMgd29ya3MgaW4gbm9uLXN0cmljdCBtb2RlXG5nID0gKGZ1bmN0aW9uKCkge1xuXHRyZXR1cm4gdGhpcztcbn0pKCk7XG5cbnRyeSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgZXZhbCBpcyBhbGxvd2VkIChzZWUgQ1NQKVxuXHRnID0gZyB8fCBuZXcgRnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpO1xufSBjYXRjaCAoZSkge1xuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIikgZyA9IHdpbmRvdztcbn1cblxuLy8gZyBjYW4gc3RpbGwgYmUgdW5kZWZpbmVkLCBidXQgbm90aGluZyB0byBkbyBhYm91dCBpdC4uLlxuLy8gV2UgcmV0dXJuIHVuZGVmaW5lZCwgaW5zdGVhZCBvZiBub3RoaW5nIGhlcmUsIHNvIGl0J3Ncbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cblxubW9kdWxlLmV4cG9ydHMgPSBnO1xuIiwibW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihtb2R1bGUpIHtcblx0aWYgKCFtb2R1bGUud2VicGFja1BvbHlmaWxsKSB7XG5cdFx0bW9kdWxlLmRlcHJlY2F0ZSA9IGZ1bmN0aW9uKCkge307XG5cdFx0bW9kdWxlLnBhdGhzID0gW107XG5cdFx0Ly8gbW9kdWxlLnBhcmVudCA9IHVuZGVmaW5lZCBieSBkZWZhdWx0XG5cdFx0aWYgKCFtb2R1bGUuY2hpbGRyZW4pIG1vZHVsZS5jaGlsZHJlbiA9IFtdO1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShtb2R1bGUsIFwibG9hZGVkXCIsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gbW9kdWxlLmw7XG5cdFx0XHR9XG5cdFx0fSk7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KG1vZHVsZSwgXCJpZFwiLCB7XG5cdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIG1vZHVsZS5pO1xuXHRcdFx0fVxuXHRcdH0pO1xuXHRcdG1vZHVsZS53ZWJwYWNrUG9seWZpbGwgPSAxO1xuXHR9XG5cdHJldHVybiBtb2R1bGU7XG59O1xuIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImFiaS81LjUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvRXRoZXJldW0tQ29udHJhY3QtQUJJXG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgUmVhZGVyLCBXcml0ZXIgfSBmcm9tIFwiLi9jb2RlcnMvYWJzdHJhY3QtY29kZXJcIjtcbmltcG9ydCB7IEFkZHJlc3NDb2RlciB9IGZyb20gXCIuL2NvZGVycy9hZGRyZXNzXCI7XG5pbXBvcnQgeyBBcnJheUNvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2FycmF5XCI7XG5pbXBvcnQgeyBCb29sZWFuQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvYm9vbGVhblwiO1xuaW1wb3J0IHsgQnl0ZXNDb2RlciB9IGZyb20gXCIuL2NvZGVycy9ieXRlc1wiO1xuaW1wb3J0IHsgRml4ZWRCeXRlc0NvZGVyIH0gZnJvbSBcIi4vY29kZXJzL2ZpeGVkLWJ5dGVzXCI7XG5pbXBvcnQgeyBOdWxsQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVsbFwiO1xuaW1wb3J0IHsgTnVtYmVyQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvbnVtYmVyXCI7XG5pbXBvcnQgeyBTdHJpbmdDb2RlciB9IGZyb20gXCIuL2NvZGVycy9zdHJpbmdcIjtcbmltcG9ydCB7IFR1cGxlQ29kZXIgfSBmcm9tIFwiLi9jb2RlcnMvdHVwbGVcIjtcbmltcG9ydCB7IFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50c1wiO1xuY29uc3QgcGFyYW1UeXBlQnl0ZXMgPSBuZXcgUmVnRXhwKC9eYnl0ZXMoWzAtOV0qKSQvKTtcbmNvbnN0IHBhcmFtVHlwZU51bWJlciA9IG5ldyBSZWdFeHAoL14odT9pbnQpKFswLTldKikkLyk7XG5leHBvcnQgY2xhc3MgQWJpQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvZXJjZUZ1bmMpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KG5ldy50YXJnZXQsIEFiaUNvZGVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjb2VyY2VGdW5jXCIsIGNvZXJjZUZ1bmMgfHwgbnVsbCk7XG4gICAgfVxuICAgIF9nZXRDb2RlcihwYXJhbSkge1xuICAgICAgICBzd2l0Y2ggKHBhcmFtLmJhc2VUeXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQWRkcmVzc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEJvb2xlYW5Db2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJzdHJpbmdcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFN0cmluZ0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCeXRlc0NvZGVyKHBhcmFtLm5hbWUpO1xuICAgICAgICAgICAgY2FzZSBcImFycmF5XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBBcnJheUNvZGVyKHRoaXMuX2dldENvZGVyKHBhcmFtLmFycmF5Q2hpbGRyZW4pLCBwYXJhbS5hcnJheUxlbmd0aCwgcGFyYW0ubmFtZSk7XG4gICAgICAgICAgICBjYXNlIFwidHVwbGVcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IFR1cGxlQ29kZXIoKHBhcmFtLmNvbXBvbmVudHMgfHwgW10pLm1hcCgoY29tcG9uZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9nZXRDb2Rlcihjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIH0pLCBwYXJhbS5uYW1lKTtcbiAgICAgICAgICAgIGNhc2UgXCJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IE51bGxDb2RlcihwYXJhbS5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyB1P2ludFswLTldKlxuICAgICAgICBsZXQgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZU51bWJlcik7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgbGV0IHNpemUgPSBwYXJzZUludChtYXRjaFsyXSB8fCBcIjI1NlwiKTtcbiAgICAgICAgICAgIGlmIChzaXplID09PSAwIHx8IHNpemUgPiAyNTYgfHwgKHNpemUgJSA4KSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIFwiICsgbWF0Y2hbMV0gKyBcIiBiaXQgbGVuZ3RoXCIsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBOdW1iZXJDb2RlcihzaXplIC8gOCwgKG1hdGNoWzFdID09PSBcImludFwiKSwgcGFyYW0ubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYnl0ZXNbMC05XStcbiAgICAgICAgbWF0Y2ggPSBwYXJhbS50eXBlLm1hdGNoKHBhcmFtVHlwZUJ5dGVzKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBsZXQgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGlmIChzaXplID09PSAwIHx8IHNpemUgPiAzMikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVzIGxlbmd0aFwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgRml4ZWRCeXRlc0NvZGVyKHNpemUsIHBhcmFtLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0eXBlXCIsIFwidHlwZVwiLCBwYXJhbS50eXBlKTtcbiAgICB9XG4gICAgX2dldFdvcmRTaXplKCkgeyByZXR1cm4gMzI7IH1cbiAgICBfZ2V0UmVhZGVyKGRhdGEsIGFsbG93TG9vc2UpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWFkZXIoZGF0YSwgdGhpcy5fZ2V0V29yZFNpemUoKSwgdGhpcy5jb2VyY2VGdW5jLCBhbGxvd0xvb3NlKTtcbiAgICB9XG4gICAgX2dldFdyaXRlcigpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXcml0ZXIodGhpcy5fZ2V0V29yZFNpemUoKSk7XG4gICAgfVxuICAgIGdldERlZmF1bHRWYWx1ZSh0eXBlcykge1xuICAgICAgICBjb25zdCBjb2RlcnMgPSB0eXBlcy5tYXAoKHR5cGUpID0+IHRoaXMuX2dldENvZGVyKFBhcmFtVHlwZS5mcm9tKHR5cGUpKSk7XG4gICAgICAgIGNvbnN0IGNvZGVyID0gbmV3IFR1cGxlQ29kZXIoY29kZXJzLCBcIl9cIik7XG4gICAgICAgIHJldHVybiBjb2Rlci5kZWZhdWx0VmFsdWUoKTtcbiAgICB9XG4gICAgZW5jb2RlKHR5cGVzLCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVzLmxlbmd0aCAhPT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ0eXBlcy92YWx1ZXMgbGVuZ3RoIG1pc21hdGNoXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgIGNvdW50OiB7IHR5cGVzOiB0eXBlcy5sZW5ndGgsIHZhbHVlczogdmFsdWVzLmxlbmd0aCB9LFxuICAgICAgICAgICAgICAgIHZhbHVlOiB7IHR5cGVzOiB0eXBlcywgdmFsdWVzOiB2YWx1ZXMgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IChuZXcgVHVwbGVDb2Rlcihjb2RlcnMsIFwiX1wiKSk7XG4gICAgICAgIGNvbnN0IHdyaXRlciA9IHRoaXMuX2dldFdyaXRlcigpO1xuICAgICAgICBjb2Rlci5lbmNvZGUod3JpdGVyLCB2YWx1ZXMpO1xuICAgICAgICByZXR1cm4gd3JpdGVyLmRhdGE7XG4gICAgfVxuICAgIGRlY29kZSh0eXBlcywgZGF0YSwgbG9vc2UpIHtcbiAgICAgICAgY29uc3QgY29kZXJzID0gdHlwZXMubWFwKCh0eXBlKSA9PiB0aGlzLl9nZXRDb2RlcihQYXJhbVR5cGUuZnJvbSh0eXBlKSkpO1xuICAgICAgICBjb25zdCBjb2RlciA9IG5ldyBUdXBsZUNvZGVyKGNvZGVycywgXCJfXCIpO1xuICAgICAgICByZXR1cm4gY29kZXIuZGVjb2RlKHRoaXMuX2dldFJlYWRlcihhcnJheWlmeShkYXRhKSwgbG9vc2UpKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgZGVmYXVsdEFiaUNvZGVyID0gbmV3IEFiaUNvZGVyKCk7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYmktY29kZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhDb25jYXQsIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgZnVuY3Rpb24gY2hlY2tSZXN1bHRFcnJvcnMocmVzdWx0KSB7XG4gICAgLy8gRmluZCB0aGUgZmlyc3QgZXJyb3IgKGlmIGFueSlcbiAgICBjb25zdCBlcnJvcnMgPSBbXTtcbiAgICBjb25zdCBjaGVja0Vycm9ycyA9IGZ1bmN0aW9uIChwYXRoLCBvYmplY3QpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGxldCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCBjaGlsZFBhdGggPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICBjaGlsZFBhdGgucHVzaChrZXkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGVja0Vycm9ycyhjaGlsZFBhdGgsIG9iamVjdFtrZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGVycm9ycy5wdXNoKHsgcGF0aDogY2hpbGRQYXRoLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNoZWNrRXJyb3JzKFtdLCByZXN1bHQpO1xuICAgIHJldHVybiBlcnJvcnM7XG59XG5leHBvcnQgY2xhc3MgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKG5hbWUsIHR5cGUsIGxvY2FsTmFtZSwgZHluYW1pYykge1xuICAgICAgICAvLyBAVE9ETzogZGVmaW5lUmVhZE9ubHkgdGhlc2VcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgICAgdGhpcy5sb2NhbE5hbWUgPSBsb2NhbE5hbWU7XG4gICAgICAgIHRoaXMuZHluYW1pYyA9IGR5bmFtaWM7XG4gICAgfVxuICAgIF90aHJvd0Vycm9yKG1lc3NhZ2UsIHZhbHVlKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgdGhpcy5sb2NhbE5hbWUsIHZhbHVlKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgV3JpdGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih3b3JkU2l6ZSkge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIndvcmRTaXplXCIsIHdvcmRTaXplIHx8IDMyKTtcbiAgICAgICAgdGhpcy5fZGF0YSA9IFtdO1xuICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoID0gMDtcbiAgICAgICAgdGhpcy5fcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KHdvcmRTaXplKTtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7XG4gICAgICAgIHJldHVybiBoZXhDb25jYXQodGhpcy5fZGF0YSk7XG4gICAgfVxuICAgIGdldCBsZW5ndGgoKSB7IHJldHVybiB0aGlzLl9kYXRhTGVuZ3RoOyB9XG4gICAgX3dyaXRlRGF0YShkYXRhKSB7XG4gICAgICAgIHRoaXMuX2RhdGEucHVzaChkYXRhKTtcbiAgICAgICAgdGhpcy5fZGF0YUxlbmd0aCArPSBkYXRhLmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIGRhdGEubGVuZ3RoO1xuICAgIH1cbiAgICBhcHBlbmRXcml0ZXIod3JpdGVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEoY29uY2F0KHdyaXRlci5fZGF0YSkpO1xuICAgIH1cbiAgICAvLyBBcnJheWlzaCBpdGVtczsgcGFkZGVkIG9uIHRoZSByaWdodCB0byB3b3JkU2l6ZVxuICAgIHdyaXRlQnl0ZXModmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICBjb25zdCBwYWRkaW5nT2Zmc2V0ID0gYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZTtcbiAgICAgICAgaWYgKHBhZGRpbmdPZmZzZXQpIHtcbiAgICAgICAgICAgIGJ5dGVzID0gY29uY2F0KFtieXRlcywgdGhpcy5fcGFkZGluZy5zbGljZShwYWRkaW5nT2Zmc2V0KV0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl93cml0ZURhdGEoYnl0ZXMpO1xuICAgIH1cbiAgICBfZ2V0VmFsdWUodmFsdWUpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gYXJyYXlpZnkoQmlnTnVtYmVyLmZyb20odmFsdWUpKTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCA+IHRoaXMud29yZFNpemUpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoOiB0aGlzLndvcmRTaXplLFxuICAgICAgICAgICAgICAgIG9mZnNldDogYnl0ZXMubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSkge1xuICAgICAgICAgICAgYnl0ZXMgPSBjb25jYXQoW3RoaXMuX3BhZGRpbmcuc2xpY2UoYnl0ZXMubGVuZ3RoICUgdGhpcy53b3JkU2l6ZSksIGJ5dGVzXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGJ5dGVzO1xuICAgIH1cbiAgICAvLyBCaWdOdW1iZXJpc2ggaXRlbXM7IHBhZGRlZCBvbiB0aGUgbGVmdCB0byB3b3JkU2l6ZVxuICAgIHdyaXRlVmFsdWUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3dyaXRlRGF0YSh0aGlzLl9nZXRWYWx1ZSh2YWx1ZSkpO1xuICAgIH1cbiAgICB3cml0ZVVwZGF0YWJsZVZhbHVlKCkge1xuICAgICAgICBjb25zdCBvZmZzZXQgPSB0aGlzLl9kYXRhLmxlbmd0aDtcbiAgICAgICAgdGhpcy5fZGF0YS5wdXNoKHRoaXMuX3BhZGRpbmcpO1xuICAgICAgICB0aGlzLl9kYXRhTGVuZ3RoICs9IHRoaXMud29yZFNpemU7XG4gICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFbb2Zmc2V0XSA9IHRoaXMuX2dldFZhbHVlKHZhbHVlKTtcbiAgICAgICAgfTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgUmVhZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihkYXRhLCB3b3JkU2l6ZSwgY29lcmNlRnVuYywgYWxsb3dMb29zZSkge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9kYXRhXCIsIGFycmF5aWZ5KGRhdGEpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ3b3JkU2l6ZVwiLCB3b3JkU2l6ZSB8fCAzMik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2NvZXJjZUZ1bmNcIiwgY29lcmNlRnVuYyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWxsb3dMb29zZVwiLCBhbGxvd0xvb3NlKTtcbiAgICAgICAgdGhpcy5fb2Zmc2V0ID0gMDtcbiAgICB9XG4gICAgZ2V0IGRhdGEoKSB7IHJldHVybiBoZXhsaWZ5KHRoaXMuX2RhdGEpOyB9XG4gICAgZ2V0IGNvbnN1bWVkKCkgeyByZXR1cm4gdGhpcy5fb2Zmc2V0OyB9XG4gICAgLy8gVGhlIGRlZmF1bHQgQ29lcmNlIGZ1bmN0aW9uXG4gICAgc3RhdGljIGNvZXJjZShuYW1lLCB2YWx1ZSkge1xuICAgICAgICBsZXQgbWF0Y2ggPSBuYW1lLm1hdGNoKFwiXnU/aW50KFswLTldKykkXCIpO1xuICAgICAgICBpZiAobWF0Y2ggJiYgcGFyc2VJbnQobWF0Y2hbMV0pIDw9IDQ4KSB7XG4gICAgICAgICAgICB2YWx1ZSA9IHZhbHVlLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb2VyY2UobmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuX2NvZXJjZUZ1bmMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9jb2VyY2VGdW5jKG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUmVhZGVyLmNvZXJjZShuYW1lLCB2YWx1ZSk7XG4gICAgfVxuICAgIF9wZWVrQnl0ZXMob2Zmc2V0LCBsZW5ndGgsIGxvb3NlKSB7XG4gICAgICAgIGxldCBhbGlnbmVkTGVuZ3RoID0gTWF0aC5jZWlsKGxlbmd0aCAvIHRoaXMud29yZFNpemUpICogdGhpcy53b3JkU2l6ZTtcbiAgICAgICAgaWYgKHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGggPiB0aGlzLl9kYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuYWxsb3dMb29zZSAmJiBsb29zZSAmJiB0aGlzLl9vZmZzZXQgKyBsZW5ndGggPD0gdGhpcy5fZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBhbGlnbmVkTGVuZ3RoID0gbGVuZ3RoO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIG91dC1vZi1ib3VuZHNcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge1xuICAgICAgICAgICAgICAgICAgICBsZW5ndGg6IHRoaXMuX2RhdGEubGVuZ3RoLFxuICAgICAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGhcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YS5zbGljZSh0aGlzLl9vZmZzZXQsIHRoaXMuX29mZnNldCArIGFsaWduZWRMZW5ndGgpO1xuICAgIH1cbiAgICBzdWJSZWFkZXIob2Zmc2V0KSB7XG4gICAgICAgIHJldHVybiBuZXcgUmVhZGVyKHRoaXMuX2RhdGEuc2xpY2UodGhpcy5fb2Zmc2V0ICsgb2Zmc2V0KSwgdGhpcy53b3JkU2l6ZSwgdGhpcy5fY29lcmNlRnVuYywgdGhpcy5hbGxvd0xvb3NlKTtcbiAgICB9XG4gICAgcmVhZEJ5dGVzKGxlbmd0aCwgbG9vc2UpIHtcbiAgICAgICAgbGV0IGJ5dGVzID0gdGhpcy5fcGVla0J5dGVzKDAsIGxlbmd0aCwgISFsb29zZSk7XG4gICAgICAgIHRoaXMuX29mZnNldCArPSBieXRlcy5sZW5ndGg7XG4gICAgICAgIC8vIEBUT0RPOiBNYWtlIHN1cmUgdGhlIGxlbmd0aC4uZW5kIGJ5dGVzIGFyZSBhbGwgMD9cbiAgICAgICAgcmV0dXJuIGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCk7XG4gICAgfVxuICAgIHJlYWRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHRoaXMucmVhZEJ5dGVzKHRoaXMud29yZFNpemUpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hYnN0cmFjdC1jb2Rlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgaGV4WmVyb1BhZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuZXhwb3J0IGNsYXNzIEFkZHJlc3NDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhbHVlID0gZ2V0QWRkcmVzcyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKGVycm9yLm1lc3NhZ2UsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUpO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJldHVybiBnZXRBZGRyZXNzKGhleFplcm9QYWQocmVhZGVyLnJlYWRWYWx1ZSgpLnRvSGV4U3RyaW5nKCksIDIwKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbi8vIENsb25lcyB0aGUgZnVuY3Rpb25hbGl0eSBvZiBhbiBleGlzdGluZyBDb2RlciwgYnV0IHdpdGhvdXQgYSBsb2NhbE5hbWVcbmV4cG9ydCBjbGFzcyBBbm9ueW1vdXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihjb2Rlcikge1xuICAgICAgICBzdXBlcihjb2Rlci5uYW1lLCBjb2Rlci50eXBlLCB1bmRlZmluZWQsIGNvZGVyLmR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVyID0gY29kZXI7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvZGVyLmVuY29kZSh3cml0ZXIsIHZhbHVlKTtcbiAgICB9XG4gICAgZGVjb2RlKHJlYWRlcikge1xuICAgICAgICByZXR1cm4gdGhpcy5jb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbm9ueW1vdXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4uL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgQ29kZXIsIFdyaXRlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5pbXBvcnQgeyBBbm9ueW1vdXNDb2RlciB9IGZyb20gXCIuL2Fub255bW91c1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHBhY2sod3JpdGVyLCBjb2RlcnMsIHZhbHVlcykge1xuICAgIGxldCBhcnJheVZhbHVlcyA9IG51bGw7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWVzKSkge1xuICAgICAgICBhcnJheVZhbHVlcyA9IHZhbHVlcztcbiAgICB9XG4gICAgZWxzZSBpZiAodmFsdWVzICYmIHR5cGVvZiAodmFsdWVzKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBsZXQgdW5pcXVlID0ge307XG4gICAgICAgIGFycmF5VmFsdWVzID0gY29kZXJzLm1hcCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlbmNvZGUgb2JqZWN0IGZvciBzaWduYXR1cmUgd2l0aCBtaXNzaW5nIG5hbWVzXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJ2YWx1ZXNcIixcbiAgICAgICAgICAgICAgICAgICAgY29kZXI6IGNvZGVyLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodW5pcXVlW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgZW5jb2RlIG9iamVjdCBmb3Igc2lnbmF0dXJlIHdpdGggZHVwbGljYXRlIG5hbWVzXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJ2YWx1ZXNcIixcbiAgICAgICAgICAgICAgICAgICAgY29kZXI6IGNvZGVyLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmlxdWVbbmFtZV0gPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlc1tuYW1lXTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0dXBsZSB2YWx1ZVwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgfVxuICAgIGlmIChjb2RlcnMubGVuZ3RoICE9PSBhcnJheVZhbHVlcy5sZW5ndGgpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInR5cGVzL3ZhbHVlIGxlbmd0aCBtaXNtYXRjaFwiLCBcInR1cGxlXCIsIHZhbHVlcyk7XG4gICAgfVxuICAgIGxldCBzdGF0aWNXcml0ZXIgPSBuZXcgV3JpdGVyKHdyaXRlci53b3JkU2l6ZSk7XG4gICAgbGV0IGR5bmFtaWNXcml0ZXIgPSBuZXcgV3JpdGVyKHdyaXRlci53b3JkU2l6ZSk7XG4gICAgbGV0IHVwZGF0ZUZ1bmNzID0gW107XG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBhcnJheVZhbHVlc1tpbmRleF07XG4gICAgICAgIGlmIChjb2Rlci5keW5hbWljKSB7XG4gICAgICAgICAgICAvLyBHZXQgY3VycmVudCBkeW5hbWljIG9mZnNldCAoZm9yIHRoZSBmdXR1cmUgcG9pbnRlcilcbiAgICAgICAgICAgIGxldCBkeW5hbWljT2Zmc2V0ID0gZHluYW1pY1dyaXRlci5sZW5ndGg7XG4gICAgICAgICAgICAvLyBFbmNvZGUgdGhlIGR5bmFtaWMgdmFsdWUgaW50byB0aGUgZHluYW1pY1dyaXRlclxuICAgICAgICAgICAgY29kZXIuZW5jb2RlKGR5bmFtaWNXcml0ZXIsIHZhbHVlKTtcbiAgICAgICAgICAgIC8vIFByZXBhcmUgdG8gcG9wdWxhdGUgdGhlIGNvcnJlY3Qgb2Zmc2V0IG9uY2Ugd2UgYXJlIGRvbmVcbiAgICAgICAgICAgIGxldCB1cGRhdGVGdW5jID0gc3RhdGljV3JpdGVyLndyaXRlVXBkYXRhYmxlVmFsdWUoKTtcbiAgICAgICAgICAgIHVwZGF0ZUZ1bmNzLnB1c2goKGJhc2VPZmZzZXQpID0+IHtcbiAgICAgICAgICAgICAgICB1cGRhdGVGdW5jKGJhc2VPZmZzZXQgKyBkeW5hbWljT2Zmc2V0KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29kZXIuZW5jb2RlKHN0YXRpY1dyaXRlciwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQmFja2ZpbGwgYWxsIHRoZSBkeW5hbWljIG9mZnNldHMsIG5vdyB0aGF0IHdlIGtub3cgdGhlIHN0YXRpYyBsZW5ndGhcbiAgICB1cGRhdGVGdW5jcy5mb3JFYWNoKChmdW5jKSA9PiB7IGZ1bmMoc3RhdGljV3JpdGVyLmxlbmd0aCk7IH0pO1xuICAgIGxldCBsZW5ndGggPSB3cml0ZXIuYXBwZW5kV3JpdGVyKHN0YXRpY1dyaXRlcik7XG4gICAgbGVuZ3RoICs9IHdyaXRlci5hcHBlbmRXcml0ZXIoZHluYW1pY1dyaXRlcik7XG4gICAgcmV0dXJuIGxlbmd0aDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB1bnBhY2socmVhZGVyLCBjb2RlcnMpIHtcbiAgICBsZXQgdmFsdWVzID0gW107XG4gICAgLy8gQSByZWFkZXIgYW5jaG9yZWQgdG8gdGhpcyBiYXNlXG4gICAgbGV0IGJhc2VSZWFkZXIgPSByZWFkZXIuc3ViUmVhZGVyKDApO1xuICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICBsZXQgdmFsdWUgPSBudWxsO1xuICAgICAgICBpZiAoY29kZXIuZHluYW1pYykge1xuICAgICAgICAgICAgbGV0IG9mZnNldCA9IHJlYWRlci5yZWFkVmFsdWUoKTtcbiAgICAgICAgICAgIGxldCBvZmZzZXRSZWFkZXIgPSBiYXNlUmVhZGVyLnN1YlJlYWRlcihvZmZzZXQudG9OdW1iZXIoKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhbHVlID0gY29kZXIuZGVjb2RlKG9mZnNldFJlYWRlcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBDYW5ub3QgcmVjb3ZlciBmcm9tIHRoaXNcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBlcnJvcjtcbiAgICAgICAgICAgICAgICB2YWx1ZS5iYXNlVHlwZSA9IGNvZGVyLm5hbWU7XG4gICAgICAgICAgICAgICAgdmFsdWUubmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS50eXBlID0gY29kZXIudHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBjb2Rlci5kZWNvZGUocmVhZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIENhbm5vdCByZWNvdmVyIGZyb20gdGhpc1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YWx1ZSA9IGVycm9yO1xuICAgICAgICAgICAgICAgIHZhbHVlLmJhc2VUeXBlID0gY29kZXIubmFtZTtcbiAgICAgICAgICAgICAgICB2YWx1ZS5uYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgICAgIHZhbHVlLnR5cGUgPSBjb2Rlci50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIFdlIG9ubHkgb3V0cHV0IG5hbWVkIHByb3BlcnRpZXMgZm9yIHVuaXF1ZWx5IG5hbWVkIGNvZGVyc1xuICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0gY29kZXJzLnJlZHVjZSgoYWNjdW0sIGNvZGVyKSA9PiB7XG4gICAgICAgIGNvbnN0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgICAgICBpZiAoIWFjY3VtW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjdW1bbmFtZV0rKztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgfSwge30pO1xuICAgIC8vIEFkZCBhbnkgbmFtZWQgcGFyYW1ldGVycyAoaS5lLiB0dXBsZXMpXG4gICAgY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICBsZXQgbmFtZSA9IGNvZGVyLmxvY2FsTmFtZTtcbiAgICAgICAgaWYgKCFuYW1lIHx8IHVuaXF1ZU5hbWVzW25hbWVdICE9PSAxKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5hbWUgPT09IFwibGVuZ3RoXCIpIHtcbiAgICAgICAgICAgIG5hbWUgPSBcIl9sZW5ndGhcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzW25hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodmFsdWVzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBnZXQ6ICgpID0+IHsgdGhyb3cgdmFsdWU7IH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWVzW25hbWVdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHZhbHVlc1tpXTtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh2YWx1ZXMsIGksIHtcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgIGdldDogKCkgPT4geyB0aHJvdyB2YWx1ZTsgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC5mcmVlemUodmFsdWVzKTtcbn1cbmV4cG9ydCBjbGFzcyBBcnJheUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvZGVyLCBsZW5ndGgsIGxvY2FsTmFtZSkge1xuICAgICAgICBjb25zdCB0eXBlID0gKGNvZGVyLnR5cGUgKyBcIltcIiArIChsZW5ndGggPj0gMCA/IGxlbmd0aCA6IFwiXCIpICsgXCJdXCIpO1xuICAgICAgICBjb25zdCBkeW5hbWljID0gKGxlbmd0aCA9PT0gLTEgfHwgY29kZXIuZHluYW1pYyk7XG4gICAgICAgIHN1cGVyKFwiYXJyYXlcIiwgdHlwZSwgbG9jYWxOYW1lLCBkeW5hbWljKTtcbiAgICAgICAgdGhpcy5jb2RlciA9IGNvZGVyO1xuICAgICAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICAvLyBWZXJpZmllcyB0aGUgY2hpbGQgY29kZXIgaXMgdmFsaWQgKGV2ZW4gaWYgdGhlIGFycmF5IGlzIGR5bmFtaWMgb3IgMC1sZW5ndGgpXG4gICAgICAgIGNvbnN0IGRlZmF1bHRDaGlsZCA9IHRoaXMuY29kZXIuZGVmYXVsdFZhbHVlKCk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKGRlZmF1bHRDaGlsZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcImV4cGVjdGVkIGFycmF5IHZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgY291bnQgPSB0aGlzLmxlbmd0aDtcbiAgICAgICAgaWYgKGNvdW50ID09PSAtMSkge1xuICAgICAgICAgICAgY291bnQgPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgICAgICB3cml0ZXIud3JpdGVWYWx1ZSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5jaGVja0FyZ3VtZW50Q291bnQodmFsdWUubGVuZ3RoLCBjb3VudCwgXCJjb2RlciBhcnJheVwiICsgKHRoaXMubG9jYWxOYW1lID8gKFwiIFwiICsgdGhpcy5sb2NhbE5hbWUpIDogXCJcIikpO1xuICAgICAgICBsZXQgY29kZXJzID0gW107XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvZGVycy5wdXNoKHRoaXMuY29kZXIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwYWNrKHdyaXRlciwgY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IGNvdW50ID0gdGhpcy5sZW5ndGg7XG4gICAgICAgIGlmIChjb3VudCA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvdW50ID0gcmVhZGVyLnJlYWRWYWx1ZSgpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZXJlIGlzICpyb3VnaGx5KiBlbm91Z2ggZGF0YSB0byBlbnN1cmVcbiAgICAgICAgICAgIC8vIHN0cmF5IHJhbmRvbSBkYXRhIGlzIG5vdCBiZWluZyByZWFkIGFzIGEgbGVuZ3RoLiBFYWNoXG4gICAgICAgICAgICAvLyBzbG90IHJlcXVpcmVzIGF0IGxlYXN0IDMyIGJ5dGVzIGZvciB0aGVpciB2YWx1ZSAob3IgMzJcbiAgICAgICAgICAgIC8vIGJ5dGVzIGFzIGEgbGluayB0byB0aGUgZGF0YSkuIFRoaXMgY291bGQgdXNlIGEgbXVjaFxuICAgICAgICAgICAgLy8gdGlnaHRlciBib3VuZCwgYnV0IHdlIGFyZSBlcnJvcmluZyBvbiB0aGUgc2lkZSBvZiBzYWZldHkuXG4gICAgICAgICAgICBpZiAoY291bnQgKiAzMiA+IHJlYWRlci5fZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBkYXRhIGxlbmd0aFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aDogcmVhZGVyLl9kYXRhLmxlbmd0aCxcbiAgICAgICAgICAgICAgICAgICAgY291bnQ6IGNvdW50XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGNvZGVycyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcbiAgICAgICAgICAgIGNvZGVycy5wdXNoKG5ldyBBbm9ueW1vdXNDb2Rlcih0aGlzLmNvZGVyKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCB1bnBhY2socmVhZGVyLCBjb2RlcnMpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hcnJheS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbmV4cG9ydCBjbGFzcyBCb29sZWFuQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3IobG9jYWxOYW1lKSB7XG4gICAgICAgIHN1cGVyKFwiYm9vbFwiLCBcImJvb2xcIiwgbG9jYWxOYW1lLCBmYWxzZSk7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodmFsdWUgPyAxIDogMCk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy50eXBlLCAhcmVhZGVyLnJlYWRWYWx1ZSgpLmlzWmVybygpKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1ib29sZWFuLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IENvZGVyIH0gZnJvbSBcIi4vYWJzdHJhY3QtY29kZXJcIjtcbmV4cG9ydCBjbGFzcyBEeW5hbWljQnl0ZXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIodHlwZSwgdHlwZSwgbG9jYWxOYW1lLCB0cnVlKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCIweFwiO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICB2YWx1ZSA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgbGV0IGxlbmd0aCA9IHdyaXRlci53cml0ZVZhbHVlKHZhbHVlLmxlbmd0aCk7XG4gICAgICAgIGxlbmd0aCArPSB3cml0ZXIud3JpdGVCeXRlcyh2YWx1ZSk7XG4gICAgICAgIHJldHVybiBsZW5ndGg7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5yZWFkQnl0ZXMocmVhZGVyLnJlYWRWYWx1ZSgpLnRvTnVtYmVyKCksIHRydWUpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBCeXRlc0NvZGVyIGV4dGVuZHMgRHluYW1pY0J5dGVzQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGxvY2FsTmFtZSkge1xuICAgICAgICBzdXBlcihcImJ5dGVzXCIsIGxvY2FsTmFtZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBoZXhsaWZ5KHN1cGVyLmRlY29kZShyZWFkZXIpKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Ynl0ZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4bGlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuLy8gQFRPRE86IE1lcmdlIHRoaXMgd2l0aCBieXRlc1xuZXhwb3J0IGNsYXNzIEZpeGVkQnl0ZXNDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihzaXplLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgbGV0IG5hbWUgPSBcImJ5dGVzXCIgKyBTdHJpbmcoc2l6ZSk7XG4gICAgICAgIHN1cGVyKG5hbWUsIG5hbWUsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgICAgICB0aGlzLnNpemUgPSBzaXplO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiAoXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIikuc3Vic3RyaW5nKDAsIDIgKyB0aGlzLnNpemUgKiAyKTtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgbGV0IGRhdGEgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gdGhpcy5zaXplKSB7XG4gICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwiaW5jb3JyZWN0IGRhdGEgbGVuZ3RoXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoZGF0YSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCBoZXhsaWZ5KHJlYWRlci5yZWFkQnl0ZXModGhpcy5zaXplKSkpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkLWJ5dGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuZXhwb3J0IGNsYXNzIE51bGxDb2RlciBleHRlbmRzIENvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJudWxsXCIsIFwiXCIsIGxvY2FsTmFtZSwgZmFsc2UpO1xuICAgIH1cbiAgICBkZWZhdWx0VmFsdWUoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcIm5vdCBudWxsXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlQnl0ZXMoW10pO1xuICAgIH1cbiAgICBkZWNvZGUocmVhZGVyKSB7XG4gICAgICAgIHJlYWRlci5yZWFkQnl0ZXMoMCk7XG4gICAgICAgIHJldHVybiByZWFkZXIuY29lcmNlKHRoaXMubmFtZSwgbnVsbCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bnVsbC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IE1heFVpbnQyNTYsIE5lZ2F0aXZlT25lLCBPbmUsIFplcm8gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBDb2RlciB9IGZyb20gXCIuL2Fic3RyYWN0LWNvZGVyXCI7XG5leHBvcnQgY2xhc3MgTnVtYmVyQ29kZXIgZXh0ZW5kcyBDb2RlciB7XG4gICAgY29uc3RydWN0b3Ioc2l6ZSwgc2lnbmVkLCBsb2NhbE5hbWUpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9ICgoc2lnbmVkID8gXCJpbnRcIiA6IFwidWludFwiKSArIChzaXplICogOCkpO1xuICAgICAgICBzdXBlcihuYW1lLCBuYW1lLCBsb2NhbE5hbWUsIGZhbHNlKTtcbiAgICAgICAgdGhpcy5zaXplID0gc2l6ZTtcbiAgICAgICAgdGhpcy5zaWduZWQgPSBzaWduZWQ7XG4gICAgfVxuICAgIGRlZmF1bHRWYWx1ZSgpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIGVuY29kZSh3cml0ZXIsIHZhbHVlKSB7XG4gICAgICAgIGxldCB2ID0gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgICAgICAvLyBDaGVjayBib3VuZHMgYXJlIHNhZmUgZm9yIGVuY29kaW5nXG4gICAgICAgIGxldCBtYXhVaW50VmFsdWUgPSBNYXhVaW50MjU2Lm1hc2sod3JpdGVyLndvcmRTaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgbGV0IGJvdW5kcyA9IG1heFVpbnRWYWx1ZS5tYXNrKHRoaXMuc2l6ZSAqIDggLSAxKTtcbiAgICAgICAgICAgIGlmICh2Lmd0KGJvdW5kcykgfHwgdi5sdChib3VuZHMuYWRkKE9uZSkubXVsKE5lZ2F0aXZlT25lKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl90aHJvd0Vycm9yKFwidmFsdWUgb3V0LW9mLWJvdW5kc1wiLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodi5sdChaZXJvKSB8fCB2Lmd0KG1heFVpbnRWYWx1ZS5tYXNrKHRoaXMuc2l6ZSAqIDgpKSkge1xuICAgICAgICAgICAgdGhpcy5fdGhyb3dFcnJvcihcInZhbHVlIG91dC1vZi1ib3VuZHNcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHYgPSB2LnRvVHdvcyh0aGlzLnNpemUgKiA4KS5tYXNrKHRoaXMuc2l6ZSAqIDgpO1xuICAgICAgICBpZiAodGhpcy5zaWduZWQpIHtcbiAgICAgICAgICAgIHYgPSB2LmZyb21Ud29zKHRoaXMuc2l6ZSAqIDgpLnRvVHdvcyg4ICogd3JpdGVyLndvcmRTaXplKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gd3JpdGVyLndyaXRlVmFsdWUodik7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gcmVhZGVyLnJlYWRWYWx1ZSgpLm1hc2sodGhpcy5zaXplICogOCk7XG4gICAgICAgIGlmICh0aGlzLnNpZ25lZCkge1xuICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5mcm9tVHdvcyh0aGlzLnNpemUgKiA4KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVhZGVyLmNvZXJjZSh0aGlzLm5hbWUsIHZhbHVlKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1udW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IER5bmFtaWNCeXRlc0NvZGVyIH0gZnJvbSBcIi4vYnl0ZXNcIjtcbmV4cG9ydCBjbGFzcyBTdHJpbmdDb2RlciBleHRlbmRzIER5bmFtaWNCeXRlc0NvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbE5hbWUpIHtcbiAgICAgICAgc3VwZXIoXCJzdHJpbmdcIiwgbG9jYWxOYW1lKTtcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICB9XG4gICAgZW5jb2RlKHdyaXRlciwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHN1cGVyLmVuY29kZSh3cml0ZXIsIHRvVXRmOEJ5dGVzKHZhbHVlKSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvVXRmOFN0cmluZyhzdXBlci5kZWNvZGUocmVhZGVyKSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c3RyaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQ29kZXIgfSBmcm9tIFwiLi9hYnN0cmFjdC1jb2RlclwiO1xuaW1wb3J0IHsgcGFjaywgdW5wYWNrIH0gZnJvbSBcIi4vYXJyYXlcIjtcbmV4cG9ydCBjbGFzcyBUdXBsZUNvZGVyIGV4dGVuZHMgQ29kZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvZGVycywgbG9jYWxOYW1lKSB7XG4gICAgICAgIGxldCBkeW5hbWljID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gW107XG4gICAgICAgIGNvZGVycy5mb3JFYWNoKChjb2RlcikgPT4ge1xuICAgICAgICAgICAgaWYgKGNvZGVyLmR5bmFtaWMpIHtcbiAgICAgICAgICAgICAgICBkeW5hbWljID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR5cGVzLnB1c2goY29kZXIudHlwZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB0eXBlID0gKFwidHVwbGUoXCIgKyB0eXBlcy5qb2luKFwiLFwiKSArIFwiKVwiKTtcbiAgICAgICAgc3VwZXIoXCJ0dXBsZVwiLCB0eXBlLCBsb2NhbE5hbWUsIGR5bmFtaWMpO1xuICAgICAgICB0aGlzLmNvZGVycyA9IGNvZGVycztcbiAgICB9XG4gICAgZGVmYXVsdFZhbHVlKCkge1xuICAgICAgICBjb25zdCB2YWx1ZXMgPSBbXTtcbiAgICAgICAgdGhpcy5jb2RlcnMuZm9yRWFjaCgoY29kZXIpID0+IHtcbiAgICAgICAgICAgIHZhbHVlcy5wdXNoKGNvZGVyLmRlZmF1bHRWYWx1ZSgpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFdlIG9ubHkgb3V0cHV0IG5hbWVkIHByb3BlcnRpZXMgZm9yIHVuaXF1ZWx5IG5hbWVkIGNvZGVyc1xuICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IHRoaXMuY29kZXJzLnJlZHVjZSgoYWNjdW0sIGNvZGVyKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gY29kZXIubG9jYWxOYW1lO1xuICAgICAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFjY3VtW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYWNjdW1bbmFtZV0rKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICAvLyBBZGQgbmFtZWQgdmFsdWVzXG4gICAgICAgIHRoaXMuY29kZXJzLmZvckVhY2goKGNvZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5hbWUgPSBjb2Rlci5sb2NhbE5hbWU7XG4gICAgICAgICAgICBpZiAoIW5hbWUgfHwgdW5pcXVlTmFtZXNbbmFtZV0gIT09IDEpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobmFtZSA9PT0gXCJsZW5ndGhcIikge1xuICAgICAgICAgICAgICAgIG5hbWUgPSBcIl9sZW5ndGhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZXNbbmFtZV0gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhbHVlc1tuYW1lXSA9IHZhbHVlc1tpbmRleF07XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZSh2YWx1ZXMpO1xuICAgIH1cbiAgICBlbmNvZGUod3JpdGVyLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gcGFjayh3cml0ZXIsIHRoaXMuY29kZXJzLCB2YWx1ZSk7XG4gICAgfVxuICAgIGRlY29kZShyZWFkZXIpIHtcbiAgICAgICAgcmV0dXJuIHJlYWRlci5jb2VyY2UodGhpcy5uYW1lLCB1bnBhY2socmVhZGVyLCB0aGlzLmNvZGVycykpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR1cGxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuO1xuY29uc3QgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcbmxldCBNb2RpZmllcnNCeXRlcyA9IHsgY2FsbGRhdGE6IHRydWUsIG1lbW9yeTogdHJ1ZSwgc3RvcmFnZTogdHJ1ZSB9O1xubGV0IE1vZGlmaWVyc05lc3QgPSB7IGNhbGxkYXRhOiB0cnVlLCBtZW1vcnk6IHRydWUgfTtcbmZ1bmN0aW9uIGNoZWNrTW9kaWZpZXIodHlwZSwgbmFtZSkge1xuICAgIGlmICh0eXBlID09PSBcImJ5dGVzXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBpZiAoTW9kaWZpZXJzQnl0ZXNbbmFtZV0pIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgIGlmIChuYW1lID09PSBcInBheWFibGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZS5pbmRleE9mKFwiW1wiKSA+PSAwIHx8IHR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICBpZiAoTW9kaWZpZXJzTmVzdFtuYW1lXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKE1vZGlmaWVyc0J5dGVzW25hbWVdIHx8IG5hbWUgPT09IFwicGF5YWJsZVwiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG1vZGlmaWVyXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gQFRPRE86IE1ha2Ugc3VyZSB0aGF0IGNoaWxkcmVuIG9mIGFuIGluZGV4ZWQgdHVwbGUgYXJlIG1hcmtlZCB3aXRoIGEgbnVsbCBpbmRleGVkXG5mdW5jdGlvbiBwYXJzZVBhcmFtVHlwZShwYXJhbSwgYWxsb3dJbmRleGVkKSB7XG4gICAgbGV0IG9yaWdpbmFsUGFyYW0gPSBwYXJhbTtcbiAgICBmdW5jdGlvbiB0aHJvd0Vycm9yKGkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgdW5leHBlY3RlZCBjaGFyYWN0ZXIgYXQgcG9zaXRpb24gJHtpfWAsIFwicGFyYW1cIiwgcGFyYW0pO1xuICAgIH1cbiAgICBwYXJhbSA9IHBhcmFtLnJlcGxhY2UoL1xccy9nLCBcIiBcIik7XG4gICAgZnVuY3Rpb24gbmV3Tm9kZShwYXJlbnQpIHtcbiAgICAgICAgbGV0IG5vZGUgPSB7IHR5cGU6IFwiXCIsIG5hbWU6IFwiXCIsIHBhcmVudDogcGFyZW50LCBzdGF0ZTogeyBhbGxvd1R5cGU6IHRydWUgfSB9O1xuICAgICAgICBpZiAoYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICBub2RlLmluZGV4ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9XG4gICAgbGV0IHBhcmVudCA9IHsgdHlwZTogXCJcIiwgbmFtZTogXCJcIiwgc3RhdGU6IHsgYWxsb3dUeXBlOiB0cnVlIH0gfTtcbiAgICBsZXQgbm9kZSA9IHBhcmVudDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcmFtLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGxldCBjID0gcGFyYW1baV07XG4gICAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICAgICAgY2FzZSBcIihcIjpcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5zdGF0ZS5hbGxvd1R5cGUgJiYgbm9kZS50eXBlID09PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IFwidHVwbGVcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIW5vZGUuc3RhdGUuYWxsb3dQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd1R5cGUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICAgICAgbm9kZS5jb21wb25lbnRzID0gW25ld05vZGUobm9kZSldO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNvbXBvbmVudHNbMF07XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiKVwiOlxuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlO1xuICAgICAgICAgICAgICAgIGlmIChub2RlLm5hbWUgPT09IFwiaW5kZXhlZFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKGkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG5vZGUuaW5kZXhlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUubmFtZSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBub2RlLnR5cGUgPSB2ZXJpZnlUeXBlKG5vZGUudHlwZSk7XG4gICAgICAgICAgICAgICAgbGV0IGNoaWxkID0gbm9kZTtcbiAgICAgICAgICAgICAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBjaGlsZC5wYXJlbnQ7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd1BhcmFtcyA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIixcIjpcbiAgICAgICAgICAgICAgICBkZWxldGUgbm9kZS5zdGF0ZTtcbiAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lID0gXCJcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlID0gdmVyaWZ5VHlwZShub2RlLnR5cGUpO1xuICAgICAgICAgICAgICAgIGxldCBzaWJsaW5nID0gbmV3Tm9kZShub2RlLnBhcmVudCk7XG4gICAgICAgICAgICAgICAgLy97IHR5cGU6IFwiXCIsIG5hbWU6IFwiXCIsIHBhcmVudDogbm9kZS5wYXJlbnQsIHN0YXRlOiB7IGFsbG93VHlwZTogdHJ1ZSB9IH07XG4gICAgICAgICAgICAgICAgbm9kZS5wYXJlbnQuY29tcG9uZW50cy5wdXNoKHNpYmxpbmcpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnBhcmVudDtcbiAgICAgICAgICAgICAgICBub2RlID0gc2libGluZztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIEhpdCBhIHNwYWNlLi4uXG4gICAgICAgICAgICBjYXNlIFwiIFwiOlxuICAgICAgICAgICAgICAgIC8vIElmIHJlYWRpbmcgdHlwZSwgdGhlIHR5cGUgaXMgZG9uZSBhbmQgbWF5IHJlYWQgYSBwYXJhbSBvciBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChub2RlLnR5cGUgIT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSA9IHZlcmlmeVR5cGUobm9kZS50eXBlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlLmFsbG93VHlwZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dQYXJhbXMgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHJlYWRpbmcgbmFtZSwgdGhlIG5hbWUgaXMgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChub2RlLnN0YXRlLmFsbG93TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lICE9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghYWxsb3dJbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93RXJyb3IoaSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub2RlLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5pbmRleGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY2hlY2tNb2RpZmllcihub2RlLnR5cGUsIG5vZGUubmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJbXCI6XG4gICAgICAgICAgICAgICAgaWYgKCFub2RlLnN0YXRlLmFsbG93QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd0FycmF5ID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd05hbWUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLnJlYWRBcnJheSA9IHRydWU7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiXVwiOlxuICAgICAgICAgICAgICAgIGlmICghbm9kZS5zdGF0ZS5yZWFkQXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbm9kZS50eXBlICs9IGM7XG4gICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5yZWFkQXJyYXkgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93QXJyYXkgPSB0cnVlO1xuICAgICAgICAgICAgICAgIG5vZGUuc3RhdGUuYWxsb3dOYW1lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgaWYgKG5vZGUuc3RhdGUuYWxsb3dUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuICAgICAgICAgICAgICAgICAgICBub2RlLnN0YXRlLmFsbG93UGFyYW1zID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5zdGF0ZS5hbGxvd0FycmF5ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAobm9kZS5zdGF0ZS5hbGxvd05hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5uYW1lICs9IGM7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBub2RlLnN0YXRlLmFsbG93QXJyYXk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5vZGUuc3RhdGUucmVhZEFycmF5KSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUudHlwZSArPSBjO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3dFcnJvcihpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUucGFyZW50KSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmV4cGVjdGVkIGVvZlwiLCBcInBhcmFtXCIsIHBhcmFtKTtcbiAgICB9XG4gICAgZGVsZXRlIHBhcmVudC5zdGF0ZTtcbiAgICBpZiAobm9kZS5uYW1lID09PSBcImluZGV4ZWRcIikge1xuICAgICAgICBpZiAoIWFsbG93SW5kZXhlZCkge1xuICAgICAgICAgICAgdGhyb3dFcnJvcihvcmlnaW5hbFBhcmFtLmxlbmd0aCAtIDcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmluZGV4ZWQpIHtcbiAgICAgICAgICAgIHRocm93RXJyb3Iob3JpZ2luYWxQYXJhbS5sZW5ndGggLSA3KTtcbiAgICAgICAgfVxuICAgICAgICBub2RlLmluZGV4ZWQgPSB0cnVlO1xuICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgIH1cbiAgICBlbHNlIGlmIChjaGVja01vZGlmaWVyKG5vZGUudHlwZSwgbm9kZS5uYW1lKSkge1xuICAgICAgICBub2RlLm5hbWUgPSBcIlwiO1xuICAgIH1cbiAgICBwYXJlbnQudHlwZSA9IHZlcmlmeVR5cGUocGFyZW50LnR5cGUpO1xuICAgIHJldHVybiBwYXJlbnQ7XG59XG5mdW5jdGlvbiBwb3B1bGF0ZShvYmplY3QsIHBhcmFtcykge1xuICAgIGZvciAobGV0IGtleSBpbiBwYXJhbXMpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkob2JqZWN0LCBrZXksIHBhcmFtc1trZXldKTtcbiAgICB9XG59XG5leHBvcnQgY29uc3QgRm9ybWF0VHlwZXMgPSBPYmplY3QuZnJlZXplKHtcbiAgICAvLyBCYXJlIGZvcm1hdHRpbmcsIGFzIGlzIG5lZWRlZCBmb3IgY29tcHV0aW5nIGEgc2lnaGFzaCBvZiBhbiBldmVudCBvciBmdW5jdGlvblxuICAgIHNpZ2hhc2g6IFwic2lnaGFzaFwiLFxuICAgIC8vIEh1bWFuLVJlYWRhYmxlIHdpdGggTWluaW1hbCBzcGFjaW5nIGFuZCB3aXRob3V0IG5hbWVzIChjb21wYWN0IGh1bWFuLXJlYWRhYmxlKVxuICAgIG1pbmltYWw6IFwibWluaW1hbFwiLFxuICAgIC8vIEh1bWFuLVJlYWRhYmxlIHdpdGggbmljZSBzcGFjaW5nLCBpbmNsdWRpbmcgYWxsIG5hbWVzXG4gICAgZnVsbDogXCJmdWxsXCIsXG4gICAgLy8gSlNPTi1mb3JtYXQgYSBsYSBTb2xpZGl0eVxuICAgIGpzb246IFwianNvblwiXG59KTtcbmNvbnN0IHBhcmFtVHlwZUFycmF5ID0gbmV3IFJlZ0V4cCgvXiguKilcXFsoWzAtOV0qKVxcXSQvKTtcbmV4cG9ydCBjbGFzcyBQYXJhbVR5cGUge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIHBhcmFtcykge1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidXNlIGZyb21TdHJpbmdcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IFBhcmFtVHlwZSgpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHBvcHVsYXRlKHRoaXMsIHBhcmFtcyk7XG4gICAgICAgIGxldCBtYXRjaCA9IHRoaXMudHlwZS5tYXRjaChwYXJhbVR5cGVBcnJheSk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgcG9wdWxhdGUodGhpcywge1xuICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoOiBwYXJzZUludChtYXRjaFsyXSB8fCBcIi0xXCIpLFxuICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW46IFBhcmFtVHlwZS5mcm9tT2JqZWN0KHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogbWF0Y2hbMV0sXG4gICAgICAgICAgICAgICAgICAgIGNvbXBvbmVudHM6IHRoaXMuY29tcG9uZW50c1xuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIGJhc2VUeXBlOiBcImFycmF5XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcG9wdWxhdGUodGhpcywge1xuICAgICAgICAgICAgICAgIGFycmF5TGVuZ3RoOiBudWxsLFxuICAgICAgICAgICAgICAgIGFycmF5Q2hpbGRyZW46IG51bGwsXG4gICAgICAgICAgICAgICAgYmFzZVR5cGU6ICgodGhpcy5jb21wb25lbnRzICE9IG51bGwpID8gXCJ0dXBsZVwiIDogdGhpcy50eXBlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5faXNQYXJhbVR5cGUgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICAvLyBGb3JtYXQgdGhlIHBhcmFtZXRlciBmcmFnbWVudFxuICAgIC8vICAgLSBzaWdoYXNoOiBcIih1aW50MjU2LGFkZHJlc3MpXCJcbiAgICAvLyAgIC0gbWluaW1hbDogXCJ0dXBsZSh1aW50MjU2LGFkZHJlc3MpIGluZGV4ZWRcIlxuICAgIC8vICAgLSBmdWxsOiAgICBcInR1cGxlKHVpbnQyNTYgZm9vLCBhZGRyZXNzIGJhcikgaW5kZXhlZCBiYXpcIlxuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLnNpZ2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIGxldCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogKCh0aGlzLmJhc2VUeXBlID09PSBcInR1cGxlXCIpID8gXCJ0dXBsZVwiIDogdGhpcy50eXBlKSxcbiAgICAgICAgICAgICAgICBuYW1lOiAodGhpcy5uYW1lIHx8IHVuZGVmaW5lZClcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodHlwZW9mICh0aGlzLmluZGV4ZWQpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5pbmRleGVkID0gdGhpcy5pbmRleGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY29tcG9uZW50cykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5jb21wb25lbnRzID0gdGhpcy5jb21wb25lbnRzLm1hcCgoY29tcCkgPT4gSlNPTi5wYXJzZShjb21wLmZvcm1hdChmb3JtYXQpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgLy8gQXJyYXlcbiAgICAgICAgaWYgKHRoaXMuYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgcmVzdWx0ICs9IHRoaXMuYXJyYXlDaGlsZHJlbi5mb3JtYXQoZm9ybWF0KTtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcIltcIiArICh0aGlzLmFycmF5TGVuZ3RoIDwgMCA/IFwiXCIgOiBTdHJpbmcodGhpcy5hcnJheUxlbmd0aCkpICsgXCJdXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodGhpcy5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50eXBlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIoXCIgKyB0aGlzLmNvbXBvbmVudHMubWFwKChjb21wKSA9PiBjb21wLmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gdGhpcy50eXBlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmluZGV4ZWQgPT09IHRydWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgaW5kZXhlZFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCAmJiB0aGlzLm5hbWUpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCIgXCIgKyB0aGlzLm5hbWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUsIGFsbG93SW5kZXhlZCkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBQYXJhbVR5cGUuZnJvbVN0cmluZyh2YWx1ZSwgYWxsb3dJbmRleGVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gUGFyYW1UeXBlLmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoUGFyYW1UeXBlLmlzUGFyYW1UeXBlKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgUGFyYW1UeXBlKF9jb25zdHJ1Y3Rvckd1YXJkLCB7XG4gICAgICAgICAgICBuYW1lOiAodmFsdWUubmFtZSB8fCBudWxsKSxcbiAgICAgICAgICAgIHR5cGU6IHZlcmlmeVR5cGUodmFsdWUudHlwZSksXG4gICAgICAgICAgICBpbmRleGVkOiAoKHZhbHVlLmluZGV4ZWQgPT0gbnVsbCkgPyBudWxsIDogISF2YWx1ZS5pbmRleGVkKSxcbiAgICAgICAgICAgIGNvbXBvbmVudHM6ICh2YWx1ZS5jb21wb25lbnRzID8gdmFsdWUuY29tcG9uZW50cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogbnVsbClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlLCBhbGxvd0luZGV4ZWQpIHtcbiAgICAgICAgZnVuY3Rpb24gUGFyYW1UeXBpZnkobm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuIFBhcmFtVHlwZS5mcm9tT2JqZWN0KHtcbiAgICAgICAgICAgICAgICBuYW1lOiBub2RlLm5hbWUsXG4gICAgICAgICAgICAgICAgdHlwZTogbm9kZS50eXBlLFxuICAgICAgICAgICAgICAgIGluZGV4ZWQ6IG5vZGUuaW5kZXhlZCxcbiAgICAgICAgICAgICAgICBjb21wb25lbnRzOiBub2RlLmNvbXBvbmVudHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQYXJhbVR5cGlmeShwYXJzZVBhcmFtVHlwZSh2YWx1ZSwgISFhbGxvd0luZGV4ZWQpKTtcbiAgICB9XG4gICAgc3RhdGljIGlzUGFyYW1UeXBlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLl9pc1BhcmFtVHlwZSk7XG4gICAgfVxufVxuO1xuZnVuY3Rpb24gcGFyc2VQYXJhbXModmFsdWUsIGFsbG93SW5kZXgpIHtcbiAgICByZXR1cm4gc3BsaXROZXN0aW5nKHZhbHVlKS5tYXAoKHBhcmFtKSA9PiBQYXJhbVR5cGUuZnJvbVN0cmluZyhwYXJhbSwgYWxsb3dJbmRleCkpO1xufVxuZXhwb3J0IGNsYXNzIEZyYWdtZW50IHtcbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVzZSBhIHN0YXRpYyBmcm9tIG1ldGhvZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRnJhZ21lbnQoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBwb3B1bGF0ZSh0aGlzLCBwYXJhbXMpO1xuICAgICAgICB0aGlzLl9pc0ZyYWdtZW50ID0gdHJ1ZTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKEZyYWdtZW50LmlzRnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoRnJhZ21lbnQuaXNGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKHZhbHVlLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcImV2ZW50XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgICAgICAgICBjYXNlIFwiY29uc3RydWN0b3JcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgICAgICAgICAgY2FzZSBcImZhbGxiYWNrXCI6XG4gICAgICAgICAgICBjYXNlIFwicmVjZWl2ZVwiOlxuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBTb21ldGhpbmc/IE1heWJlIHJldHVybiBhIEZ1bmN0aW9uRnJhZ21lbnQ/IEEgY3VzdG9tIERlZmF1bHRGdW5jdGlvbkZyYWdtZW50P1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmcmFnbWVudCBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU3RyaW5nKHZhbHVlKSB7XG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgXCJyZXR1cm5zXCIgaXMgc3Vycm91bmRlZCBieSBhIHNwYWNlIGFuZCBhbGwgd2hpdGVzcGFjZSBpcyBleGFjdGx5IG9uZSBzcGFjZVxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnJlcGxhY2UoL1xccy9nLCBcIiBcIik7XG4gICAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFwoL2csIFwiIChcIikucmVwbGFjZSgvXFwpL2csIFwiKSBcIikucmVwbGFjZSgvXFxzKy9nLCBcIiBcIik7XG4gICAgICAgIHZhbHVlID0gdmFsdWUudHJpbSgpO1xuICAgICAgICBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFdmVudEZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUuc3Vic3RyaW5nKDUpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUuc3Vic3RyaW5nKDgpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIoXCIpWzBdLnRyaW0oKSA9PT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUuc3BsaXQoXCIgXCIpWzBdID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUuc3Vic3RyaW5nKDUpLnRyaW0oKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBmcmFnbWVudFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRnJhZ21lbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50KTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRXZlbnRGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5zaWdoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXZlbnRcIixcbiAgICAgICAgICAgICAgICBhbm9ueW1vdXM6IHRoaXMuYW5vbnltb3VzLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBcImV2ZW50IFwiO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSB0aGlzLm5hbWUgKyBcIihcIiArIHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IGlucHV0LmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuICAgICAgICBpZiAoZm9ybWF0ICE9PSBGb3JtYXRUeXBlcy5zaWdoYXNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgKz0gXCJhbm9ueW1vdXMgXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdC50cmltKCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbVN0cmluZyh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tT2JqZWN0KHZhbHVlKSB7XG4gICAgICAgIGlmIChFdmVudEZyYWdtZW50LmlzRXZlbnRGcmFnbWVudCh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWUudHlwZSAhPT0gXCJldmVudFwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBldmVudCBvYmplY3RcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgbmFtZTogdmVyaWZ5SWRlbnRpZmllcih2YWx1ZS5uYW1lKSxcbiAgICAgICAgICAgIGFub255bW91czogdmFsdWUuYW5vbnltb3VzLFxuICAgICAgICAgICAgaW5wdXRzOiAodmFsdWUuaW5wdXRzID8gdmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSksXG4gICAgICAgICAgICB0eXBlOiBcImV2ZW50XCJcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIG5ldyBFdmVudEZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSkge1xuICAgICAgICBsZXQgbWF0Y2ggPSB2YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgaWYgKCFtYXRjaCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXZlbnQgc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBhbm9ueW1vdXMgPSBmYWxzZTtcbiAgICAgICAgbWF0Y2hbM10uc3BsaXQoXCIgXCIpLmZvckVhY2goKG1vZGlmaWVyKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKG1vZGlmaWVyLnRyaW0oKSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJhbm9ueW1vdXNcIjpcbiAgICAgICAgICAgICAgICAgICAgYW5vbnltb3VzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlwiOlxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihcInVua25vd24gbW9kaWZpZXI6IFwiICsgbW9kaWZpZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIEV2ZW50RnJhZ21lbnQuZnJvbU9iamVjdCh7XG4gICAgICAgICAgICBuYW1lOiBtYXRjaFsxXS50cmltKCksXG4gICAgICAgICAgICBhbm9ueW1vdXM6IGFub255bW91cyxcbiAgICAgICAgICAgIGlucHV0czogcGFyc2VQYXJhbXMobWF0Y2hbMl0sIHRydWUpLFxuICAgICAgICAgICAgdHlwZTogXCJldmVudFwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgaXNFdmVudEZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJldmVudFwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiBwYXJzZUdhcyh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcGFyYW1zLmdhcyA9IG51bGw7XG4gICAgbGV0IGNvbXBzID0gdmFsdWUuc3BsaXQoXCJAXCIpO1xuICAgIGlmIChjb21wcy5sZW5ndGggIT09IDEpIHtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGh1bWFuLXJlYWRhYmxlIEFCSSBzaWduYXR1cmVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjb21wc1sxXS5tYXRjaCgvXlswLTldKyQvKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaHVtYW4tcmVhZGFibGUgQUJJIHNpZ25hdHVyZSBnYXNcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmdhcyA9IEJpZ051bWJlci5mcm9tKGNvbXBzWzFdKTtcbiAgICAgICAgcmV0dXJuIGNvbXBzWzBdO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5mdW5jdGlvbiBwYXJzZU1vZGlmaWVycyh2YWx1ZSwgcGFyYW1zKSB7XG4gICAgcGFyYW1zLmNvbnN0YW50ID0gZmFsc2U7XG4gICAgcGFyYW1zLnBheWFibGUgPSBmYWxzZTtcbiAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJub25wYXlhYmxlXCI7XG4gICAgdmFsdWUuc3BsaXQoXCIgXCIpLmZvckVhY2goKG1vZGlmaWVyKSA9PiB7XG4gICAgICAgIHN3aXRjaCAobW9kaWZpZXIudHJpbSgpKSB7XG4gICAgICAgICAgICBjYXNlIFwiY29uc3RhbnRcIjpcbiAgICAgICAgICAgICAgICBwYXJhbXMuY29uc3RhbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInBheWFibGVcIjpcbiAgICAgICAgICAgICAgICBwYXJhbXMucGF5YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwicGF5YWJsZVwiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm5vbnBheWFibGVcIjpcbiAgICAgICAgICAgICAgICBwYXJhbXMucGF5YWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5zdGF0ZU11dGFiaWxpdHkgPSBcIm5vbnBheWFibGVcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwdXJlXCI6XG4gICAgICAgICAgICAgICAgcGFyYW1zLmNvbnN0YW50ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBwYXJhbXMuc3RhdGVNdXRhYmlsaXR5ID0gXCJwdXJlXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidmlld1wiOlxuICAgICAgICAgICAgICAgIHBhcmFtcy5jb25zdGFudCA9IHRydWU7XG4gICAgICAgICAgICAgICAgcGFyYW1zLnN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImV4dGVybmFsXCI6XG4gICAgICAgICAgICBjYXNlIFwicHVibGljXCI6XG4gICAgICAgICAgICBjYXNlIFwiXCI6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwidW5rbm93biBtb2RpZmllcjogXCIgKyBtb2RpZmllcik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHZlcmlmeVN0YXRlKHZhbHVlKSB7XG4gICAgbGV0IHJlc3VsdCA9IHtcbiAgICAgICAgY29uc3RhbnQ6IGZhbHNlLFxuICAgICAgICBwYXlhYmxlOiB0cnVlLFxuICAgICAgICBzdGF0ZU11dGFiaWxpdHk6IFwicGF5YWJsZVwiXG4gICAgfTtcbiAgICBpZiAodmFsdWUuc3RhdGVNdXRhYmlsaXR5ICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IHZhbHVlLnN0YXRlTXV0YWJpbGl0eTtcbiAgICAgICAgLy8gU2V0IChhbmQgY2hlY2sgdGhpbmdzIGFyZSBjb25zaXN0ZW50KSB0aGUgY29uc3RhbnQgcHJvcGVydHlcbiAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gKHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPT09IFwidmlld1wiIHx8IHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPT09IFwicHVyZVwiKTtcbiAgICAgICAgaWYgKHZhbHVlLmNvbnN0YW50ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmICgoISF2YWx1ZS5jb25zdGFudCkgIT09IHJlc3VsdC5jb25zdGFudCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBjb25zdGFudCBmdW5jdGlvbiB3aXRoIG11dGFiaWxpdHkgXCIgKyByZXN1bHQuc3RhdGVNdXRhYmlsaXR5LCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgKGFuZCBjaGVjayB0aGluZ3MgYXJlIGNvbnNpc3RlbnQpIHRoZSBwYXlhYmxlIHByb3BlcnR5XG4gICAgICAgIHJlc3VsdC5wYXlhYmxlID0gKHJlc3VsdC5zdGF0ZU11dGFiaWxpdHkgPT09IFwicGF5YWJsZVwiKTtcbiAgICAgICAgaWYgKHZhbHVlLnBheWFibGUgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKCghIXZhbHVlLnBheWFibGUpICE9PSByZXN1bHQucGF5YWJsZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBwYXlhYmxlIGZ1bmN0aW9uIHdpdGggbXV0YWJpbGl0eSBcIiArIHJlc3VsdC5zdGF0ZU11dGFiaWxpdHksIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLnBheWFibGUgIT0gbnVsbCkge1xuICAgICAgICByZXN1bHQucGF5YWJsZSA9ICEhdmFsdWUucGF5YWJsZTtcbiAgICAgICAgLy8gSWYgcGF5YWJsZSB3ZSBjYW4gYXNzdW1lIG5vbi1jb25zdGFudDsgb3RoZXJ3aXNlIHdlIGNhbid0IGFzc3VtZVxuICAgICAgICBpZiAodmFsdWUuY29uc3RhbnQgPT0gbnVsbCAmJiAhcmVzdWx0LnBheWFibGUgJiYgdmFsdWUudHlwZSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5hYmxlIHRvIGRldGVybWluZSBzdGF0ZU11dGFiaWxpdHlcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gISF2YWx1ZS5jb25zdGFudDtcbiAgICAgICAgaWYgKHJlc3VsdC5jb25zdGFudCkge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IFwidmlld1wiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnN0YXRlTXV0YWJpbGl0eSA9IChyZXN1bHQucGF5YWJsZSA/IFwicGF5YWJsZVwiIDogXCJub25wYXlhYmxlXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQucGF5YWJsZSAmJiByZXN1bHQuY29uc3RhbnQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjYW5ub3QgaGF2ZSBjb25zdGFudCBwYXlhYmxlIGZ1bmN0aW9uXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHZhbHVlLmNvbnN0YW50ICE9IG51bGwpIHtcbiAgICAgICAgcmVzdWx0LmNvbnN0YW50ID0gISF2YWx1ZS5jb25zdGFudDtcbiAgICAgICAgcmVzdWx0LnBheWFibGUgPSAhcmVzdWx0LmNvbnN0YW50O1xuICAgICAgICByZXN1bHQuc3RhdGVNdXRhYmlsaXR5ID0gKHJlc3VsdC5jb25zdGFudCA/IFwidmlld1wiIDogXCJwYXlhYmxlXCIpO1xuICAgIH1cbiAgICBlbHNlIGlmICh2YWx1ZS50eXBlICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuYWJsZSB0byBkZXRlcm1pbmUgc3RhdGVNdXRhYmlsaXR5XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGNsYXNzIENvbnN0cnVjdG9yRnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4gICAgZm9ybWF0KGZvcm1hdCkge1xuICAgICAgICBpZiAoIWZvcm1hdCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gRm9ybWF0VHlwZXMuc2lnaGFzaDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIUZvcm1hdFR5cGVzW2Zvcm1hdF0pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZvcm1hdCB0eXBlXCIsIFwiZm9ybWF0XCIsIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuanNvbikge1xuICAgICAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImNvbnN0cnVjdG9yXCIsXG4gICAgICAgICAgICAgICAgc3RhdGVNdXRhYmlsaXR5OiAoKHRoaXMuc3RhdGVNdXRhYmlsaXR5ICE9PSBcIm5vbnBheWFibGVcIikgPyB0aGlzLnN0YXRlTXV0YWJpbGl0eSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgcGF5YWJsZTogdGhpcy5wYXlhYmxlLFxuICAgICAgICAgICAgICAgIGdhczogKHRoaXMuZ2FzID8gdGhpcy5nYXMudG9OdW1iZXIoKSA6IHVuZGVmaW5lZCksXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IGZvcm1hdCBhIGNvbnN0cnVjdG9yIGZvciBzaWdoYXNoXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImZvcm1hdChzaWdoYXNoKVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJjb25zdHJ1Y3RvcihcIiArIHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IGlucHV0LmZvcm1hdChmb3JtYXQpKS5qb2luKChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmZ1bGwpID8gXCIsIFwiIDogXCIsXCIpICsgXCIpIFwiO1xuICAgICAgICBpZiAodGhpcy5zdGF0ZU11dGFiaWxpdHkgJiYgdGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gdGhpcy5zdGF0ZU11dGFiaWxpdHkgKyBcIiBcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0LnRyaW0oKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tU3RyaW5nKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQ29uc3RydWN0b3JGcmFnbWVudC5mcm9tT2JqZWN0KHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21PYmplY3QodmFsdWUpIHtcbiAgICAgICAgaWYgKENvbnN0cnVjdG9yRnJhZ21lbnQuaXNDb25zdHJ1Y3RvckZyYWdtZW50KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZS50eXBlICE9PSBcImNvbnN0cnVjdG9yXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbnN0cnVjdG9yIG9iamVjdFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc3RhdGUgPSB2ZXJpZnlTdGF0ZSh2YWx1ZSk7XG4gICAgICAgIGlmIChzdGF0ZS5jb25zdGFudCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImNvbnN0cnVjdG9yIGNhbm5vdCBiZSBjb25zdGFudFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICBuYW1lOiBudWxsLFxuICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgICAgICAgIGlucHV0czogKHZhbHVlLmlucHV0cyA/IHZhbHVlLmlucHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuICAgICAgICAgICAgcGF5YWJsZTogc3RhdGUucGF5YWJsZSxcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogc3RhdGUuc3RhdGVNdXRhYmlsaXR5LFxuICAgICAgICAgICAgZ2FzOiAodmFsdWUuZ2FzID8gQmlnTnVtYmVyLmZyb20odmFsdWUuZ2FzKSA6IG51bGwpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3JGcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgbGV0IHBhcmFtcyA9IHsgdHlwZTogXCJjb25zdHJ1Y3RvclwiIH07XG4gICAgICAgIHZhbHVlID0gcGFyc2VHYXModmFsdWUsIHBhcmFtcyk7XG4gICAgICAgIGxldCBwYXJlbnMgPSB2YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgaWYgKCFwYXJlbnMgfHwgcGFyZW5zWzFdLnRyaW0oKSAhPT0gXCJjb25zdHJ1Y3RvclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb25zdHJ1Y3RvciBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmlucHV0cyA9IHBhcnNlUGFyYW1zKHBhcmVuc1syXS50cmltKCksIGZhbHNlKTtcbiAgICAgICAgcGFyc2VNb2RpZmllcnMocGFyZW5zWzNdLnRyaW0oKSwgcGFyYW1zKTtcbiAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yRnJhZ21lbnQuZnJvbU9iamVjdChwYXJhbXMpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNDb25zdHJ1Y3RvckZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJjb25zdHJ1Y3RvclwiKTtcbiAgICB9XG59XG5leHBvcnQgY2xhc3MgRnVuY3Rpb25GcmFnbWVudCBleHRlbmRzIENvbnN0cnVjdG9yRnJhZ21lbnQge1xuICAgIGZvcm1hdChmb3JtYXQpIHtcbiAgICAgICAgaWYgKCFmb3JtYXQpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IEZvcm1hdFR5cGVzLnNpZ2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFGb3JtYXRUeXBlc1tmb3JtYXRdKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmb3JtYXQgdHlwZVwiLCBcImZvcm1hdFwiLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLmpzb24pIHtcbiAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgICAgICAgICAgICBjb25zdGFudDogdGhpcy5jb25zdGFudCxcbiAgICAgICAgICAgICAgICBzdGF0ZU11dGFiaWxpdHk6ICgodGhpcy5zdGF0ZU11dGFiaWxpdHkgIT09IFwibm9ucGF5YWJsZVwiKSA/IHRoaXMuc3RhdGVNdXRhYmlsaXR5IDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBwYXlhYmxlOiB0aGlzLnBheWFibGUsXG4gICAgICAgICAgICAgICAgZ2FzOiAodGhpcy5nYXMgPyB0aGlzLmdhcy50b051bWJlcigpIDogdW5kZWZpbmVkKSxcbiAgICAgICAgICAgICAgICBpbnB1dHM6IHRoaXMuaW5wdXRzLm1hcCgoaW5wdXQpID0+IEpTT04ucGFyc2UoaW5wdXQuZm9ybWF0KGZvcm1hdCkpKSxcbiAgICAgICAgICAgICAgICBvdXRwdXRzOiB0aGlzLm91dHB1dHMubWFwKChvdXRwdXQpID0+IEpTT04ucGFyc2Uob3V0cHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiZnVuY3Rpb24gXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIikgXCI7XG4gICAgICAgIGlmIChmb3JtYXQgIT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlTXV0YWJpbGl0eSAhPT0gXCJub25wYXlhYmxlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0ICs9ICh0aGlzLnN0YXRlTXV0YWJpbGl0eSArIFwiIFwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0aGlzLmNvbnN0YW50KSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwidmlldyBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm91dHB1dHMgJiYgdGhpcy5vdXRwdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSBcInJldHVybnMgKFwiICsgdGhpcy5vdXRwdXRzLm1hcCgob3V0cHV0KSA9PiBvdXRwdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oXCIsIFwiKSArIFwiKSBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmdhcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9IFwiQFwiICsgdGhpcy5nYXMudG9TdHJpbmcoKSArIFwiIFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoRnVuY3Rpb25GcmFnbWVudC5pc0Z1bmN0aW9uRnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBzdGF0ZSA9IHZlcmlmeVN0YXRlKHZhbHVlKTtcbiAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgdHlwZTogdmFsdWUudHlwZSxcbiAgICAgICAgICAgIG5hbWU6IHZlcmlmeUlkZW50aWZpZXIodmFsdWUubmFtZSksXG4gICAgICAgICAgICBjb25zdGFudDogc3RhdGUuY29uc3RhbnQsXG4gICAgICAgICAgICBpbnB1dHM6ICh2YWx1ZS5pbnB1dHMgPyB2YWx1ZS5pbnB1dHMubWFwKFBhcmFtVHlwZS5mcm9tT2JqZWN0KSA6IFtdKSxcbiAgICAgICAgICAgIG91dHB1dHM6ICh2YWx1ZS5vdXRwdXRzID8gdmFsdWUub3V0cHV0cy5tYXAoUGFyYW1UeXBlLmZyb21PYmplY3QpIDogW10pLFxuICAgICAgICAgICAgcGF5YWJsZTogc3RhdGUucGF5YWJsZSxcbiAgICAgICAgICAgIHN0YXRlTXV0YWJpbGl0eTogc3RhdGUuc3RhdGVNdXRhYmlsaXR5LFxuICAgICAgICAgICAgZ2FzOiAodmFsdWUuZ2FzID8gQmlnTnVtYmVyLmZyb20odmFsdWUuZ2FzKSA6IG51bGwpXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBuZXcgRnVuY3Rpb25GcmFnbWVudChfY29uc3RydWN0b3JHdWFyZCwgcGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgbGV0IHBhcmFtcyA9IHsgdHlwZTogXCJmdW5jdGlvblwiIH07XG4gICAgICAgIHZhbHVlID0gcGFyc2VHYXModmFsdWUsIHBhcmFtcyk7XG4gICAgICAgIGxldCBjb21wcyA9IHZhbHVlLnNwbGl0KFwiIHJldHVybnMgXCIpO1xuICAgICAgICBpZiAoY29tcHMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZnVuY3Rpb24gc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBwYXJlbnMgPSBjb21wc1swXS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgaWYgKCFwYXJlbnMpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZ1bmN0aW9uIHNpZ25hdHVyZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMubmFtZSA9IHBhcmVuc1sxXS50cmltKCk7XG4gICAgICAgIGlmIChwYXJhbXMubmFtZSkge1xuICAgICAgICAgICAgdmVyaWZ5SWRlbnRpZmllcihwYXJhbXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmlucHV0cyA9IHBhcnNlUGFyYW1zKHBhcmVuc1syXSwgZmFsc2UpO1xuICAgICAgICBwYXJzZU1vZGlmaWVycyhwYXJlbnNbM10udHJpbSgpLCBwYXJhbXMpO1xuICAgICAgICAvLyBXZSBoYXZlIG91dHB1dHNcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxldCByZXR1cm5zID0gY29tcHNbMV0ubWF0Y2gocmVnZXhQYXJlbik7XG4gICAgICAgICAgICBpZiAocmV0dXJuc1sxXS50cmltKCkgIT0gXCJcIiB8fCByZXR1cm5zWzNdLnRyaW0oKSAhPSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuZXhwZWN0ZWQgdG9rZW5zXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGFyYW1zLm91dHB1dHMgPSBwYXJzZVBhcmFtcyhyZXR1cm5zWzJdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYXJhbXMub3V0cHV0cyA9IFtdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBGdW5jdGlvbkZyYWdtZW50LmZyb21PYmplY3QocGFyYW1zKTtcbiAgICB9XG4gICAgc3RhdGljIGlzRnVuY3Rpb25GcmFnbWVudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHZhbHVlICYmIHZhbHVlLl9pc0ZyYWdtZW50ICYmIHZhbHVlLnR5cGUgPT09IFwiZnVuY3Rpb25cIik7XG4gICAgfVxufVxuLy9leHBvcnQgY2xhc3MgU3RydWN0RnJhZ21lbnQgZXh0ZW5kcyBGcmFnbWVudCB7XG4vL31cbmZ1bmN0aW9uIGNoZWNrRm9yYmlkZGVuKGZyYWdtZW50KSB7XG4gICAgY29uc3Qgc2lnID0gZnJhZ21lbnQuZm9ybWF0KCk7XG4gICAgaWYgKHNpZyA9PT0gXCJFcnJvcihzdHJpbmcpXCIgfHwgc2lnID09PSBcIlBhbmljKHVpbnQyNTYpXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgY2Fubm90IHNwZWNpZnkgdXNlciBkZWZpbmVkICR7c2lnfSBlcnJvcmAsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgIH1cbiAgICByZXR1cm4gZnJhZ21lbnQ7XG59XG5leHBvcnQgY2xhc3MgRXJyb3JGcmFnbWVudCBleHRlbmRzIEZyYWdtZW50IHtcbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5zaWdoYXNoO1xuICAgICAgICB9XG4gICAgICAgIGlmICghRm9ybWF0VHlwZXNbZm9ybWF0XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZm9ybWF0IHR5cGVcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICAgICAgaW5wdXRzOiB0aGlzLmlucHV0cy5tYXAoKGlucHV0KSA9PiBKU09OLnBhcnNlKGlucHV0LmZvcm1hdChmb3JtYXQpKSksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICAgICAgaWYgKGZvcm1hdCAhPT0gRm9ybWF0VHlwZXMuc2lnaGFzaCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9IFwiZXJyb3IgXCI7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ICs9IHRoaXMubmFtZSArIFwiKFwiICsgdGhpcy5pbnB1dHMubWFwKChpbnB1dCkgPT4gaW5wdXQuZm9ybWF0KGZvcm1hdCkpLmpvaW4oKGZvcm1hdCA9PT0gRm9ybWF0VHlwZXMuZnVsbCkgPyBcIiwgXCIgOiBcIixcIikgKyBcIikgXCI7XG4gICAgICAgIHJldHVybiByZXN1bHQudHJpbSgpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb21TdHJpbmcodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBFcnJvckZyYWdtZW50LmZyb21PYmplY3QodmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbU9iamVjdCh2YWx1ZSkge1xuICAgICAgICBpZiAoRXJyb3JGcmFnbWVudC5pc0Vycm9yRnJhZ21lbnQodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlLnR5cGUgIT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZXJyb3Igb2JqZWN0XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgIHR5cGU6IHZhbHVlLnR5cGUsXG4gICAgICAgICAgICBuYW1lOiB2ZXJpZnlJZGVudGlmaWVyKHZhbHVlLm5hbWUpLFxuICAgICAgICAgICAgaW5wdXRzOiAodmFsdWUuaW5wdXRzID8gdmFsdWUuaW5wdXRzLm1hcChQYXJhbVR5cGUuZnJvbU9iamVjdCkgOiBbXSlcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNoZWNrRm9yYmlkZGVuKG5ldyBFcnJvckZyYWdtZW50KF9jb25zdHJ1Y3Rvckd1YXJkLCBwYXJhbXMpKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21TdHJpbmcodmFsdWUpIHtcbiAgICAgICAgbGV0IHBhcmFtcyA9IHsgdHlwZTogXCJlcnJvclwiIH07XG4gICAgICAgIGxldCBwYXJlbnMgPSB2YWx1ZS5tYXRjaChyZWdleFBhcmVuKTtcbiAgICAgICAgaWYgKCFwYXJlbnMpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGVycm9yIHNpZ25hdHVyZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBwYXJhbXMubmFtZSA9IHBhcmVuc1sxXS50cmltKCk7XG4gICAgICAgIGlmIChwYXJhbXMubmFtZSkge1xuICAgICAgICAgICAgdmVyaWZ5SWRlbnRpZmllcihwYXJhbXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcGFyYW1zLmlucHV0cyA9IHBhcnNlUGFyYW1zKHBhcmVuc1syXSwgZmFsc2UpO1xuICAgICAgICByZXR1cm4gY2hlY2tGb3JiaWRkZW4oRXJyb3JGcmFnbWVudC5mcm9tT2JqZWN0KHBhcmFtcykpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNFcnJvckZyYWdtZW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAodmFsdWUgJiYgdmFsdWUuX2lzRnJhZ21lbnQgJiYgdmFsdWUudHlwZSA9PT0gXCJlcnJvclwiKTtcbiAgICB9XG59XG5mdW5jdGlvbiB2ZXJpZnlUeXBlKHR5cGUpIHtcbiAgICAvLyBUaGVzZSBuZWVkIHRvIGJlIHRyYW5zZm9ybWVkIHRvIHRoZWlyIGZ1bGwgZGVzY3JpcHRpb25cbiAgICBpZiAodHlwZS5tYXRjaCgvXnVpbnQoJHxbXjEtOV0pLykpIHtcbiAgICAgICAgdHlwZSA9IFwidWludDI1NlwiICsgdHlwZS5zdWJzdHJpbmcoNCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGUubWF0Y2goL15pbnQoJHxbXjEtOV0pLykpIHtcbiAgICAgICAgdHlwZSA9IFwiaW50MjU2XCIgKyB0eXBlLnN1YnN0cmluZygzKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IG1vcmUgdmVyaWZpY2F0aW9uXG4gICAgcmV0dXJuIHR5cGU7XG59XG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS9zb2xpZGl0eS9ibG9iLzFmOGYxYTNkYjkzYTU0OGQwNTU1ZTNlMTRjZmM1NWExMGUyNWI2MGUvZG9jcy9ncmFtbWFyL1NvbGlkaXR5TGV4ZXIuZzQjTDIzNFxuY29uc3QgcmVnZXhJZGVudGlmaWVyID0gbmV3IFJlZ0V4cChcIl5bYS16QS1aJF9dW2EtekEtWjAtOSRfXSokXCIpO1xuZnVuY3Rpb24gdmVyaWZ5SWRlbnRpZmllcih2YWx1ZSkge1xuICAgIGlmICghdmFsdWUgfHwgIXZhbHVlLm1hdGNoKHJlZ2V4SWRlbnRpZmllcikpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBpZGVudGlmaWVyIFwiJHt2YWx1ZX1cImAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCByZWdleFBhcmVuID0gbmV3IFJlZ0V4cChcIl4oW14pKF0qKVxcXFwoKC4qKVxcXFwpKFteKShdKikkXCIpO1xuZnVuY3Rpb24gc3BsaXROZXN0aW5nKHZhbHVlKSB7XG4gICAgdmFsdWUgPSB2YWx1ZS50cmltKCk7XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGxldCBhY2N1bSA9IFwiXCI7XG4gICAgbGV0IGRlcHRoID0gMDtcbiAgICBmb3IgKGxldCBvZmZzZXQgPSAwOyBvZmZzZXQgPCB2YWx1ZS5sZW5ndGg7IG9mZnNldCsrKSB7XG4gICAgICAgIGxldCBjID0gdmFsdWVbb2Zmc2V0XTtcbiAgICAgICAgaWYgKGMgPT09IFwiLFwiICYmIGRlcHRoID09PSAwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChhY2N1bSk7XG4gICAgICAgICAgICBhY2N1bSA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhY2N1bSArPSBjO1xuICAgICAgICAgICAgaWYgKGMgPT09IFwiKFwiKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGMgPT09IFwiKVwiKSB7XG4gICAgICAgICAgICAgICAgZGVwdGgtLTtcbiAgICAgICAgICAgICAgICBpZiAoZGVwdGggPT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bmJhbGFuY2VkIHBhcmVudGhlc2lzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoYWNjdW0pIHtcbiAgICAgICAgcmVzdWx0LnB1c2goYWNjdW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZnJhZ21lbnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQ29uc3RydWN0b3JGcmFnbWVudCwgRXJyb3JGcmFnbWVudCwgRXZlbnRGcmFnbWVudCwgRm9ybWF0VHlwZXMsIEZyYWdtZW50LCBGdW5jdGlvbkZyYWdtZW50LCBQYXJhbVR5cGUgfSBmcm9tIFwiLi9mcmFnbWVudHNcIjtcbmltcG9ydCB7IEFiaUNvZGVyLCBkZWZhdWx0QWJpQ29kZXIgfSBmcm9tIFwiLi9hYmktY29kZXJcIjtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBJbmRleGVkLCBJbnRlcmZhY2UsIExvZ0Rlc2NyaXB0aW9uLCBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIH0gZnJvbSBcIi4vaW50ZXJmYWNlXCI7XG5leHBvcnQgeyBDb25zdHJ1Y3RvckZyYWdtZW50LCBFcnJvckZyYWdtZW50LCBFdmVudEZyYWdtZW50LCBGcmFnbWVudCwgRnVuY3Rpb25GcmFnbWVudCwgUGFyYW1UeXBlLCBGb3JtYXRUeXBlcywgQWJpQ29kZXIsIGRlZmF1bHRBYmlDb2RlciwgSW50ZXJmYWNlLCBJbmRleGVkLCBjaGVja1Jlc3VsdEVycm9ycywgTG9nRGVzY3JpcHRpb24sIFRyYW5zYWN0aW9uRGVzY3JpcHRpb24gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhEYXRhU2xpY2UsIGhleGxpZnksIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oYXNoXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgRGVzY3JpcHRpb24sIGdldFN0YXRpYyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBkZWZhdWx0QWJpQ29kZXIgfSBmcm9tIFwiLi9hYmktY29kZXJcIjtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzIH0gZnJvbSBcIi4vY29kZXJzL2Fic3RyYWN0LWNvZGVyXCI7XG5pbXBvcnQgeyBDb25zdHJ1Y3RvckZyYWdtZW50LCBFdmVudEZyYWdtZW50LCBGb3JtYXRUeXBlcywgRnJhZ21lbnQsIEZ1bmN0aW9uRnJhZ21lbnQsIFBhcmFtVHlwZSB9IGZyb20gXCIuL2ZyYWdtZW50c1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IHsgY2hlY2tSZXN1bHRFcnJvcnMgfTtcbmV4cG9ydCBjbGFzcyBMb2dEZXNjcmlwdGlvbiBleHRlbmRzIERlc2NyaXB0aW9uIHtcbn1cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIGV4dGVuZHMgRGVzY3JpcHRpb24ge1xufVxuZXhwb3J0IGNsYXNzIEVycm9yRGVzY3JpcHRpb24gZXh0ZW5kcyBEZXNjcmlwdGlvbiB7XG59XG5leHBvcnQgY2xhc3MgSW5kZXhlZCBleHRlbmRzIERlc2NyaXB0aW9uIHtcbiAgICBzdGF0aWMgaXNJbmRleGVkKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbmRleGVkKTtcbiAgICB9XG59XG5jb25zdCBCdWlsdGluRXJyb3JzID0ge1xuICAgIFwiMHgwOGMzNzlhMFwiOiB7IHNpZ25hdHVyZTogXCJFcnJvcihzdHJpbmcpXCIsIG5hbWU6IFwiRXJyb3JcIiwgaW5wdXRzOiBbXCJzdHJpbmdcIl0sIHJlYXNvbjogdHJ1ZSB9LFxuICAgIFwiMHg0ZTQ4N2I3MVwiOiB7IHNpZ25hdHVyZTogXCJQYW5pYyh1aW50MjU2KVwiLCBuYW1lOiBcIlBhbmljXCIsIGlucHV0czogW1widWludDI1NlwiXSB9XG59O1xuZnVuY3Rpb24gd3JhcEFjY2Vzc0Vycm9yKHByb3BlcnR5LCBlcnJvcikge1xuICAgIGNvbnN0IHdyYXAgPSBuZXcgRXJyb3IoYGRlZmVycmVkIGVycm9yIGR1cmluZyBBQkkgZGVjb2RpbmcgdHJpZ2dlcmVkIGFjY2Vzc2luZyAke3Byb3BlcnR5fWApO1xuICAgIHdyYXAuZXJyb3IgPSBlcnJvcjtcbiAgICByZXR1cm4gd3JhcDtcbn1cbi8qXG5mdW5jdGlvbiBjaGVja05hbWVzKGZyYWdtZW50OiBGcmFnbWVudCwgdHlwZTogXCJpbnB1dFwiIHwgXCJvdXRwdXRcIiwgcGFyYW1zOiBBcnJheTxQYXJhbVR5cGU+KTogdm9pZCB7XG4gICAgcGFyYW1zLnJlZHVjZSgoYWNjdW0sIHBhcmFtKSA9PiB7XG4gICAgICAgIGlmIChwYXJhbS5uYW1lKSB7XG4gICAgICAgICAgICBpZiAoYWNjdW1bcGFyYW0ubmFtZV0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBkdXBsaWNhdGUgJHsgdHlwZSB9IHBhcmFtZXRlciAkeyBKU09OLnN0cmluZ2lmeShwYXJhbS5uYW1lKSB9IGluICR7IGZyYWdtZW50LmZvcm1hdChcImZ1bGxcIikgfWAsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjdW1bcGFyYW0ubmFtZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCA8eyBbIG5hbWU6IHN0cmluZyBdOiBib29sZWFuIH0+eyB9KTtcbn1cbiovXG5leHBvcnQgY2xhc3MgSW50ZXJmYWNlIHtcbiAgICBjb25zdHJ1Y3RvcihmcmFnbWVudHMpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KG5ldy50YXJnZXQsIEludGVyZmFjZSk7XG4gICAgICAgIGxldCBhYmkgPSBbXTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJhZ21lbnRzKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYWJpID0gSlNPTi5wYXJzZShmcmFnbWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWJpID0gZnJhZ21lbnRzO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZnJhZ21lbnRzXCIsIGFiaS5tYXAoKGZyYWdtZW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gRnJhZ21lbnQuZnJvbShmcmFnbWVudCk7XG4gICAgICAgIH0pLmZpbHRlcigoZnJhZ21lbnQpID0+IChmcmFnbWVudCAhPSBudWxsKSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9hYmlDb2RlclwiLCBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXRBYmlDb2RlclwiKSgpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmdW5jdGlvbnNcIiwge30pO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImVycm9yc1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZXZlbnRzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJzdHJ1Y3RzXCIsIHt9KTtcbiAgICAgICAgLy8gQWRkIGFsbCBmcmFnbWVudHMgYnkgdGhlaXIgc2lnbmF0dXJlXG4gICAgICAgIHRoaXMuZnJhZ21lbnRzLmZvckVhY2goKGZyYWdtZW50KSA9PiB7XG4gICAgICAgICAgICBsZXQgYnVja2V0ID0gbnVsbDtcbiAgICAgICAgICAgIHN3aXRjaCAoZnJhZ21lbnQudHlwZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJjb25zdHJ1Y3RvclwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5kZXBsb3kpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwiaW5wdXRcIiwgZnJhZ21lbnQuaW5wdXRzKTtcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJkZXBsb3lcIiwgZnJhZ21lbnQpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgY2FzZSBcImZ1bmN0aW9uXCI6XG4gICAgICAgICAgICAgICAgICAgIC8vY2hlY2tOYW1lcyhmcmFnbWVudCwgXCJpbnB1dFwiLCBmcmFnbWVudC5pbnB1dHMpO1xuICAgICAgICAgICAgICAgICAgICAvL2NoZWNrTmFtZXMoZnJhZ21lbnQsIFwib3V0cHV0XCIsICg8RnVuY3Rpb25GcmFnbWVudD5mcmFnbWVudCkub3V0cHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuZnVuY3Rpb25zO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXZlbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgLy9jaGVja05hbWVzKGZyYWdtZW50LCBcImlucHV0XCIsIGZyYWdtZW50LmlucHV0cyk7XG4gICAgICAgICAgICAgICAgICAgIGJ1Y2tldCA9IHRoaXMuZXZlbnRzO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICAgICAgYnVja2V0ID0gdGhpcy5lcnJvcnM7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzaWduYXR1cmUgPSBmcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgICAgIGlmIChidWNrZXRbc2lnbmF0dXJlXSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKFwiZHVwbGljYXRlIGRlZmluaXRpb24gLSBcIiArIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnVja2V0W3NpZ25hdHVyZV0gPSBmcmFnbWVudDtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIElmIHdlIGRvIG5vdCBoYXZlIGEgY29uc3RydWN0b3IgYWRkIGEgZGVmYXVsdFxuICAgICAgICBpZiAoIXRoaXMuZGVwbG95KSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImRlcGxveVwiLCBDb25zdHJ1Y3RvckZyYWdtZW50LmZyb20oe1xuICAgICAgICAgICAgICAgIHBheWFibGU6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHR5cGU6IFwiY29uc3RydWN0b3JcIlxuICAgICAgICAgICAgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2lzSW50ZXJmYWNlXCIsIHRydWUpO1xuICAgIH1cbiAgICBmb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIGlmICghZm9ybWF0KSB7XG4gICAgICAgICAgICBmb3JtYXQgPSBGb3JtYXRUeXBlcy5mdWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChmb3JtYXQgPT09IEZvcm1hdFR5cGVzLnNpZ2hhc2gpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnRlcmZhY2UgZG9lcyBub3Qgc3VwcG9ydCBmb3JtYXR0aW5nIHNpZ2hhc2hcIiwgXCJmb3JtYXRcIiwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhYmkgPSB0aGlzLmZyYWdtZW50cy5tYXAoKGZyYWdtZW50KSA9PiBmcmFnbWVudC5mb3JtYXQoZm9ybWF0KSk7XG4gICAgICAgIC8vIFdlIG5lZWQgdG8gcmUtYnVuZGxlIHRoZSBKU09OIGZyYWdtZW50cyBhIGJpdFxuICAgICAgICBpZiAoZm9ybWF0ID09PSBGb3JtYXRUeXBlcy5qc29uKSB7XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYWJpLm1hcCgoaikgPT4gSlNPTi5wYXJzZShqKSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhYmk7XG4gICAgfVxuICAgIC8vIFN1Yi1jbGFzc2VzIGNhbiBvdmVycmlkZSB0aGVzZSB0byBoYW5kbGUgb3RoZXIgYmxvY2tjaGFpbnNcbiAgICBzdGF0aWMgZ2V0QWJpQ29kZXIoKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0QWJpQ29kZXI7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIGdldEFkZHJlc3MoYWRkcmVzcyk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRTaWdoYXNoKGZyYWdtZW50KSB7XG4gICAgICAgIHJldHVybiBoZXhEYXRhU2xpY2UoaWQoZnJhZ21lbnQuZm9ybWF0KCkpLCAwLCA0KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkge1xuICAgICAgICByZXR1cm4gaWQoZXZlbnRGcmFnbWVudC5mb3JtYXQoKSk7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgZ2V0RnVuY3Rpb24obmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5mdW5jdGlvbnMpIHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoID09PSB0aGlzLmdldFNpZ2hhc2gobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZnVuY3Rpb25zW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcInNpZ2hhc2hcIiwgbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZnVuY3Rpb25zKS5maWx0ZXIoKGYpID0+IChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGZ1bmN0aW9uc1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mdW5jdGlvbnNbbWF0Y2hpbmdbMF1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZnVuY3Rpb25zW0Z1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpLmZvcm1hdCgpXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBmdW5jdGlvblwiLCBcInNpZ25hdHVyZVwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZpbmQgYW4gZXZlbnQgZGVmaW5pdGlvbiBieSBhbnkgbWVhbnMgbmVjZXNzYXJ5ICh1bmxlc3MgaXQgaXMgYW1iaWd1b3VzKVxuICAgIGdldEV2ZW50KG5hbWVPclNpZ25hdHVyZU9yVG9waWMpIHtcbiAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWVPclNpZ25hdHVyZU9yVG9waWMpKSB7XG4gICAgICAgICAgICBjb25zdCB0b3BpY2hhc2ggPSBuYW1lT3JTaWduYXR1cmVPclRvcGljLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gdGhpcy5ldmVudHMpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9waWNoYXNoID09PSB0aGlzLmdldEV2ZW50VG9waWMobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBldmVudFwiLCBcInRvcGljaGFzaFwiLCB0b3BpY2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEl0IGlzIGEgYmFyZSBuYW1lLCBsb29rIHVwIHRoZSBmdW5jdGlvbiAod2lsbCByZXR1cm4gbnVsbCBpZiBhbWJpZ3VvdXMpXG4gICAgICAgIGlmIChuYW1lT3JTaWduYXR1cmVPclRvcGljLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclNpZ25hdHVyZU9yVG9waWMudHJpbSgpO1xuICAgICAgICAgICAgY29uc3QgbWF0Y2hpbmcgPSBPYmplY3Qua2V5cyh0aGlzLmV2ZW50cykuZmlsdGVyKChmKSA9PiAoZi5zcGxpdChcIihcIiAvKiBmaXg6KSAqLylbMF0gPT09IG5hbWUpKTtcbiAgICAgICAgICAgIGlmIChtYXRjaGluZy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibm8gbWF0Y2hpbmcgZXZlbnRcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAobWF0Y2hpbmcubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtdWx0aXBsZSBtYXRjaGluZyBldmVudHNcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXZlbnRzW21hdGNoaW5nWzBdXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3JtYWxpemUgdGhlIHNpZ25hdHVyZSBhbmQgbG9va3VwIHRoZSBmdW5jdGlvblxuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmV2ZW50c1tFdmVudEZyYWdtZW50LmZyb21TdHJpbmcobmFtZU9yU2lnbmF0dXJlT3JUb3BpYykuZm9ybWF0KCldO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5vIG1hdGNoaW5nIGV2ZW50XCIsIFwic2lnbmF0dXJlXCIsIG5hbWVPclNpZ25hdHVyZU9yVG9waWMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEZpbmQgYSBmdW5jdGlvbiBkZWZpbml0aW9uIGJ5IGFueSBtZWFucyBuZWNlc3NhcnkgKHVubGVzcyBpdCBpcyBhbWJpZ3VvdXMpXG4gICAgZ2V0RXJyb3IobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKSB7XG4gICAgICAgIGlmIChpc0hleFN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpKSB7XG4gICAgICAgICAgICBjb25zdCBnZXRTaWdoYXNoID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0U2lnaGFzaFwiKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiB0aGlzLmVycm9ycykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gdGhpcy5lcnJvcnNbbmFtZV07XG4gICAgICAgICAgICAgICAgaWYgKG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaCA9PT0gZ2V0U2lnaGFzaChlcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZXJyb3JzW25hbWVdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcInNpZ2hhc2hcIiwgbmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJdCBpcyBhIGJhcmUgbmFtZSwgbG9vayB1cCB0aGUgZnVuY3Rpb24gKHdpbGwgcmV0dXJuIG51bGwgaWYgYW1iaWd1b3VzKVxuICAgICAgICBpZiAobmFtZU9yU2lnbmF0dXJlT3JTaWdoYXNoLmluZGV4T2YoXCIoXCIpID09PSAtMSkge1xuICAgICAgICAgICAgY29uc3QgbmFtZSA9IG5hbWVPclNpZ25hdHVyZU9yU2lnaGFzaC50cmltKCk7XG4gICAgICAgICAgICBjb25zdCBtYXRjaGluZyA9IE9iamVjdC5rZXlzKHRoaXMuZXJyb3JzKS5maWx0ZXIoKGYpID0+IChmLnNwbGl0KFwiKFwiIC8qIGZpeDopICovKVswXSA9PT0gbmFtZSkpO1xuICAgICAgICAgICAgaWYgKG1hdGNoaW5nLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChtYXRjaGluZy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm11bHRpcGxlIG1hdGNoaW5nIGVycm9yc1wiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5lcnJvcnNbbWF0Y2hpbmdbMF1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgc2lnbmF0dXJlIGFuZCBsb29rdXAgdGhlIGZ1bmN0aW9uXG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuZXJyb3JzW0Z1bmN0aW9uRnJhZ21lbnQuZnJvbVN0cmluZyhuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpLmZvcm1hdCgpXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJubyBtYXRjaGluZyBlcnJvclwiLCBcInNpZ25hdHVyZVwiLCBuYW1lT3JTaWduYXR1cmVPclNpZ2hhc2gpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgc2lnaGFzaCAodGhlIGJ5dGVzNCBzZWxlY3RvcikgdXNlZCBieSBTb2xpZGl0eSB0byBpZGVudGlmeSBhIGZ1bmN0aW9uXG4gICAgZ2V0U2lnaGFzaChmcmFnbWVudCkge1xuICAgICAgICBpZiAodHlwZW9mIChmcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZyYWdtZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIGZyYWdtZW50ID0gdGhpcy5nZXRFcnJvcihmcmFnbWVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0U2lnaGFzaFwiKShmcmFnbWVudCk7XG4gICAgfVxuICAgIC8vIEdldCB0aGUgdG9waWMgKHRoZSBieXRlczMyIGhhc2gpIHVzZWQgYnkgU29saWRpdHkgdG8gaWRlbnRpZnkgYW4gZXZlbnRcbiAgICBnZXRFdmVudFRvcGljKGV2ZW50RnJhZ21lbnQpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJnZXRFdmVudFRvcGljXCIpKGV2ZW50RnJhZ21lbnQpO1xuICAgIH1cbiAgICBfZGVjb2RlUGFyYW1zKHBhcmFtcywgZGF0YSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKHBhcmFtcywgZGF0YSk7XG4gICAgfVxuICAgIF9lbmNvZGVQYXJhbXMocGFyYW1zLCB2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FiaUNvZGVyLmVuY29kZShwYXJhbXMsIHZhbHVlcyk7XG4gICAgfVxuICAgIGVuY29kZURlcGxveSh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VuY29kZVBhcmFtcyh0aGlzLmRlcGxveS5pbnB1dHMsIHZhbHVlcyB8fCBbXSk7XG4gICAgfVxuICAgIGRlY29kZUVycm9yUmVzdWx0KGZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgICAgICBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgIT09IHRoaXMuZ2V0U2lnaGFzaChmcmFnbWVudCkpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGRhdGEgc2lnbmF0dXJlIGRvZXMgbm90IG1hdGNoIGVycm9yICR7ZnJhZ21lbnQubmFtZX0uYCwgXCJkYXRhXCIsIGhleGxpZnkoYnl0ZXMpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZGVjb2RlUGFyYW1zKGZyYWdtZW50LmlucHV0cywgYnl0ZXMuc2xpY2UoNCkpO1xuICAgIH1cbiAgICBlbmNvZGVFcnJvclJlc3VsdChmcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZnJhZ21lbnQgPSB0aGlzLmdldEVycm9yKGZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICAgICAgdGhpcy5nZXRTaWdoYXNoKGZyYWdtZW50KSxcbiAgICAgICAgICAgIHRoaXMuX2VuY29kZVBhcmFtcyhmcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvLyBEZWNvZGUgdGhlIGRhdGEgZm9yIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiB0eC5kYXRhKVxuICAgIGRlY29kZUZ1bmN0aW9uRGF0YShmdW5jdGlvbkZyYWdtZW50LCBkYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZ1bmN0aW9uRnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgICAgICBpZiAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkgIT09IHRoaXMuZ2V0U2lnaGFzaChmdW5jdGlvbkZyYWdtZW50KSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgZGF0YSBzaWduYXR1cmUgZG9lcyBub3QgbWF0Y2ggZnVuY3Rpb24gJHtmdW5jdGlvbkZyYWdtZW50Lm5hbWV9LmAsIFwiZGF0YVwiLCBoZXhsaWZ5KGJ5dGVzKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlY29kZVBhcmFtcyhmdW5jdGlvbkZyYWdtZW50LmlucHV0cywgYnl0ZXMuc2xpY2UoNCkpO1xuICAgIH1cbiAgICAvLyBFbmNvZGUgdGhlIGRhdGEgZm9yIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiB0eC5kYXRhKVxuICAgIGVuY29kZUZ1bmN0aW9uRGF0YShmdW5jdGlvbkZyYWdtZW50LCB2YWx1ZXMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChbXG4gICAgICAgICAgICB0aGlzLmdldFNpZ2hhc2goZnVuY3Rpb25GcmFnbWVudCksXG4gICAgICAgICAgICB0aGlzLl9lbmNvZGVQYXJhbXMoZnVuY3Rpb25GcmFnbWVudC5pbnB1dHMsIHZhbHVlcyB8fCBbXSlcbiAgICAgICAgXSkpO1xuICAgIH1cbiAgICAvLyBEZWNvZGUgdGhlIHJlc3VsdCBmcm9tIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiBmcm9tIGV0aF9jYWxsKVxuICAgIGRlY29kZUZ1bmN0aW9uUmVzdWx0KGZ1bmN0aW9uRnJhZ21lbnQsIGRhdGEpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnVuY3Rpb25GcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQgPSB0aGlzLmdldEZ1bmN0aW9uKGZ1bmN0aW9uRnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBieXRlcyA9IGFycmF5aWZ5KGRhdGEpO1xuICAgICAgICBsZXQgcmVhc29uID0gbnVsbDtcbiAgICAgICAgbGV0IGVycm9yQXJncyA9IG51bGw7XG4gICAgICAgIGxldCBlcnJvck5hbWUgPSBudWxsO1xuICAgICAgICBsZXQgZXJyb3JTaWduYXR1cmUgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKGJ5dGVzLmxlbmd0aCAlIHRoaXMuX2FiaUNvZGVyLl9nZXRXb3JkU2l6ZSgpKSB7XG4gICAgICAgICAgICBjYXNlIDA6XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2FiaUNvZGVyLmRlY29kZShmdW5jdGlvbkZyYWdtZW50Lm91dHB1dHMsIGJ5dGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgNDoge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdG9yID0gaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSk7XG4gICAgICAgICAgICAgICAgY29uc3QgYnVpbHRpbiA9IEJ1aWx0aW5FcnJvcnNbc2VsZWN0b3JdO1xuICAgICAgICAgICAgICAgIGlmIChidWlsdGluKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yQXJncyA9IHRoaXMuX2FiaUNvZGVyLmRlY29kZShidWlsdGluLmlucHV0cywgYnl0ZXMuc2xpY2UoNCkpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvck5hbWUgPSBidWlsdGluLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yU2lnbmF0dXJlID0gYnVpbHRpbi5zaWduYXR1cmU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChidWlsdGluLnJlYXNvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gZXJyb3JBcmdzWzBdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLmdldEVycm9yKHNlbGVjdG9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yQXJncyA9IHRoaXMuX2FiaUNvZGVyLmRlY29kZShlcnJvci5pbnB1dHMsIGJ5dGVzLnNsaWNlKDQpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yTmFtZSA9IGVycm9yLm5hbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclNpZ25hdHVyZSA9IGVycm9yLmZvcm1hdCgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNhbGwgcmV2ZXJ0IGV4Y2VwdGlvblwiLCBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OLCB7XG4gICAgICAgICAgICBtZXRob2Q6IGZ1bmN0aW9uRnJhZ21lbnQuZm9ybWF0KCksXG4gICAgICAgICAgICBlcnJvckFyZ3MsIGVycm9yTmFtZSwgZXJyb3JTaWduYXR1cmUsIHJlYXNvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gRW5jb2RlIHRoZSByZXN1bHQgZm9yIGEgZnVuY3Rpb24gY2FsbCAoZS5nLiBmb3IgZXRoX2NhbGwpXG4gICAgZW5jb2RlRnVuY3Rpb25SZXN1bHQoZnVuY3Rpb25GcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGZ1bmN0aW9uRnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBmdW5jdGlvbkZyYWdtZW50ID0gdGhpcy5nZXRGdW5jdGlvbihmdW5jdGlvbkZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh0aGlzLl9hYmlDb2Rlci5lbmNvZGUoZnVuY3Rpb25GcmFnbWVudC5vdXRwdXRzLCB2YWx1ZXMgfHwgW10pKTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIHRoZSBmaWx0ZXIgZm9yIHRoZSBldmVudCB3aXRoIHNlYXJjaCBjcml0ZXJpYSAoZS5nLiBmb3IgZXRoX2ZpbHRlckxvZylcbiAgICBlbmNvZGVGaWx0ZXJUb3BpY3MoZXZlbnRGcmFnbWVudCwgdmFsdWVzKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKGV2ZW50RnJhZ21lbnQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBldmVudEZyYWdtZW50ID0gdGhpcy5nZXRFdmVudChldmVudEZyYWdtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodmFsdWVzLmxlbmd0aCA+IGV2ZW50RnJhZ21lbnQuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ0b28gbWFueSBhcmd1bWVudHMgZm9yIFwiICsgZXZlbnRGcmFnbWVudC5mb3JtYXQoKSwgTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7XG4gICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVzXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHRvcGljcyA9IFtdO1xuICAgICAgICBpZiAoIWV2ZW50RnJhZ21lbnQuYW5vbnltb3VzKSB7XG4gICAgICAgICAgICB0b3BpY3MucHVzaCh0aGlzLmdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGVuY29kZVRvcGljID0gKHBhcmFtLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaWQodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1NihoZXhsaWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDaGVjayBhZGRyZXNzZXMgYXJlIHZhbGlkXG4gICAgICAgICAgICBpZiAocGFyYW0udHlwZSA9PT0gXCJhZGRyZXNzXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9hYmlDb2Rlci5lbmNvZGUoW1wiYWRkcmVzc1wiXSwgW3ZhbHVlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gaGV4WmVyb1BhZChoZXhsaWZ5KHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICB2YWx1ZXMuZm9yRWFjaCgodmFsdWUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBsZXQgcGFyYW0gPSBldmVudEZyYWdtZW50LmlucHV0c1tpbmRleF07XG4gICAgICAgICAgICBpZiAoIXBhcmFtLmluZGV4ZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IGZpbHRlciBub24taW5kZXhlZCBwYXJhbWV0ZXJzOyBtdXN0IGJlIG51bGxcIiwgKFwiY29udHJhY3QuXCIgKyBwYXJhbS5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIiB8fCBwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImZpbHRlcmluZyB3aXRoIHR1cGxlcyBvciBhcnJheXMgbm90IHN1cHBvcnRlZFwiLCAoXCJjb250cmFjdC5cIiArIHBhcmFtLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKHZhbHVlLm1hcCgodmFsdWUpID0+IGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGVuY29kZVRvcGljKHBhcmFtLCB2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVHJpbSBvZmYgdHJhaWxpbmcgbnVsbHNcbiAgICAgICAgd2hpbGUgKHRvcGljcy5sZW5ndGggJiYgdG9waWNzW3RvcGljcy5sZW5ndGggLSAxXSA9PT0gbnVsbCkge1xuICAgICAgICAgICAgdG9waWNzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b3BpY3M7XG4gICAgfVxuICAgIGVuY29kZUV2ZW50TG9nKGV2ZW50RnJhZ21lbnQsIHZhbHVlcykge1xuICAgICAgICBpZiAodHlwZW9mIChldmVudEZyYWdtZW50KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZXZlbnRGcmFnbWVudCA9IHRoaXMuZ2V0RXZlbnQoZXZlbnRGcmFnbWVudCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdG9waWNzID0gW107XG4gICAgICAgIGNvbnN0IGRhdGFUeXBlcyA9IFtdO1xuICAgICAgICBjb25zdCBkYXRhVmFsdWVzID0gW107XG4gICAgICAgIGlmICghZXZlbnRGcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIHRvcGljcy5wdXNoKHRoaXMuZ2V0RXZlbnRUb3BpYyhldmVudEZyYWdtZW50KSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlcy5sZW5ndGggIT09IGV2ZW50RnJhZ21lbnQuaW5wdXRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImV2ZW50IGFyZ3VtZW50cy92YWx1ZXMgbWlzbWF0Y2hcIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcbiAgICAgICAgfVxuICAgICAgICBldmVudEZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gdmFsdWVzW2luZGV4XTtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2goaWQodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocGFyYW0udHlwZSA9PT0gXCJieXRlc1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRvcGljcy5wdXNoKGtlY2NhazI1Nih2YWx1ZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbS5iYXNlVHlwZSA9PT0gXCJ0dXBsZVwiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcImFycmF5XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE9cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdG9waWNzLnB1c2godGhpcy5fYWJpQ29kZXIuZW5jb2RlKFtwYXJhbS50eXBlXSwgW3ZhbHVlXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGRhdGFUeXBlcy5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICBkYXRhVmFsdWVzLnB1c2godmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRhdGE6IHRoaXMuX2FiaUNvZGVyLmVuY29kZShkYXRhVHlwZXMsIGRhdGFWYWx1ZXMpLFxuICAgICAgICAgICAgdG9waWNzOiB0b3BpY3NcbiAgICAgICAgfTtcbiAgICB9XG4gICAgLy8gRGVjb2RlIGEgZmlsdGVyIGZvciB0aGUgZXZlbnQgYW5kIHRoZSBzZWFyY2ggY3JpdGVyaWFcbiAgICBkZWNvZGVFdmVudExvZyhldmVudEZyYWdtZW50LCBkYXRhLCB0b3BpY3MpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnRGcmFnbWVudCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGV2ZW50RnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGV2ZW50RnJhZ21lbnQpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b3BpY3MgIT0gbnVsbCAmJiAhZXZlbnRGcmFnbWVudC5hbm9ueW1vdXMpIHtcbiAgICAgICAgICAgIGxldCB0b3BpY0hhc2ggPSB0aGlzLmdldEV2ZW50VG9waWMoZXZlbnRGcmFnbWVudCk7XG4gICAgICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKHRvcGljc1swXSwgMzIpIHx8IHRvcGljc1swXS50b0xvd2VyQ2FzZSgpICE9PSB0b3BpY0hhc2gpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImZyYWdtZW50L3RvcGljIG1pc21hdGNoXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwgeyBhcmd1bWVudDogXCJ0b3BpY3NbMF1cIiwgZXhwZWN0ZWQ6IHRvcGljSGFzaCwgdmFsdWU6IHRvcGljc1swXSB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRvcGljcyA9IHRvcGljcy5zbGljZSgxKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgaW5kZXhlZCA9IFtdO1xuICAgICAgICBsZXQgbm9uSW5kZXhlZCA9IFtdO1xuICAgICAgICBsZXQgZHluYW1pYyA9IFtdO1xuICAgICAgICBldmVudEZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtLnR5cGUgPT09IFwic3RyaW5nXCIgfHwgcGFyYW0udHlwZSA9PT0gXCJieXRlc1wiIHx8IHBhcmFtLmJhc2VUeXBlID09PSBcInR1cGxlXCIgfHwgcGFyYW0uYmFzZVR5cGUgPT09IFwiYXJyYXlcIikge1xuICAgICAgICAgICAgICAgICAgICBpbmRleGVkLnB1c2goUGFyYW1UeXBlLmZyb21PYmplY3QoeyB0eXBlOiBcImJ5dGVzMzJcIiwgbmFtZTogcGFyYW0ubmFtZSB9KSk7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ZWQucHVzaChwYXJhbSk7XG4gICAgICAgICAgICAgICAgICAgIGR5bmFtaWMucHVzaChmYWxzZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbm9uSW5kZXhlZC5wdXNoKHBhcmFtKTtcbiAgICAgICAgICAgICAgICBkeW5hbWljLnB1c2goZmFsc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbGV0IHJlc3VsdEluZGV4ZWQgPSAodG9waWNzICE9IG51bGwpID8gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGluZGV4ZWQsIGNvbmNhdCh0b3BpY3MpKSA6IG51bGw7XG4gICAgICAgIGxldCByZXN1bHROb25JbmRleGVkID0gdGhpcy5fYWJpQ29kZXIuZGVjb2RlKG5vbkluZGV4ZWQsIGRhdGEsIHRydWUpO1xuICAgICAgICBsZXQgcmVzdWx0ID0gW107XG4gICAgICAgIGxldCBub25JbmRleGVkSW5kZXggPSAwLCBpbmRleGVkSW5kZXggPSAwO1xuICAgICAgICBldmVudEZyYWdtZW50LmlucHV0cy5mb3JFYWNoKChwYXJhbSwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgIGlmIChwYXJhbS5pbmRleGVkKSB7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdEluZGV4ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gbmV3IEluZGV4ZWQoeyBfaXNJbmRleGVkOiB0cnVlLCBoYXNoOiBudWxsIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChkeW5hbWljW2luZGV4XSkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gbmV3IEluZGV4ZWQoeyBfaXNJbmRleGVkOiB0cnVlLCBoYXNoOiByZXN1bHRJbmRleGVkW2luZGV4ZWRJbmRleCsrXSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gcmVzdWx0SW5kZXhlZFtpbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gcmVzdWx0Tm9uSW5kZXhlZFtub25JbmRleGVkSW5kZXgrK107XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQWRkIHRoZSBrZXl3b3JkIGFyZ3VtZW50IGlmIG5hbWVkIGFuZCBzYWZlXG4gICAgICAgICAgICBpZiAocGFyYW0ubmFtZSAmJiByZXN1bHRbcGFyYW0ubmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdWx0W2luZGV4XTtcbiAgICAgICAgICAgICAgICAvLyBNYWtlIGVycm9yIG5hbWVkIHZhbHVlcyB0aHJvdyBvbiBhY2Nlc3NcbiAgICAgICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBwYXJhbS5uYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0OiAoKSA9PiB7IHRocm93IHdyYXBBY2Nlc3NFcnJvcihgcHJvcGVydHkgJHtKU09OLnN0cmluZ2lmeShwYXJhbS5uYW1lKX1gLCB2YWx1ZSk7IH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHRbcGFyYW0ubmFtZV0gPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBNYWtlIGFsbCBlcnJvciBpbmRleGVkIHZhbHVlcyB0aHJvdyBvbiBhY2Nlc3NcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVzdWx0W2ldO1xuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBpLCB7XG4gICAgICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgIGdldDogKCkgPT4geyB0aHJvdyB3cmFwQWNjZXNzRXJyb3IoYGluZGV4ICR7aX1gLCB2YWx1ZSk7IH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShyZXN1bHQpO1xuICAgIH1cbiAgICAvLyBHaXZlbiBhIHRyYW5zYWN0aW9uLCBmaW5kIHRoZSBtYXRjaGluZyBmdW5jdGlvbiBmcmFnbWVudCAoaWYgYW55KSBhbmRcbiAgICAvLyBkZXRlcm1pbmUgYWxsIGl0cyBwcm9wZXJ0aWVzIGFuZCBjYWxsIHBhcmFtZXRlcnNcbiAgICBwYXJzZVRyYW5zYWN0aW9uKHR4KSB7XG4gICAgICAgIGxldCBmcmFnbWVudCA9IHRoaXMuZ2V0RnVuY3Rpb24odHguZGF0YS5zdWJzdHJpbmcoMCwgMTApLnRvTG93ZXJDYXNlKCkpO1xuICAgICAgICBpZiAoIWZyYWdtZW50KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IFRyYW5zYWN0aW9uRGVzY3JpcHRpb24oe1xuICAgICAgICAgICAgYXJnczogdGhpcy5fYWJpQ29kZXIuZGVjb2RlKGZyYWdtZW50LmlucHV0cywgXCIweFwiICsgdHguZGF0YS5zdWJzdHJpbmcoMTApKSxcbiAgICAgICAgICAgIGZ1bmN0aW9uRnJhZ21lbnQ6IGZyYWdtZW50LFxuICAgICAgICAgICAgbmFtZTogZnJhZ21lbnQubmFtZSxcbiAgICAgICAgICAgIHNpZ25hdHVyZTogZnJhZ21lbnQuZm9ybWF0KCksXG4gICAgICAgICAgICBzaWdoYXNoOiB0aGlzLmdldFNpZ2hhc2goZnJhZ21lbnQpLFxuICAgICAgICAgICAgdmFsdWU6IEJpZ051bWJlci5mcm9tKHR4LnZhbHVlIHx8IFwiMFwiKSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEBUT0RPXG4gICAgLy9wYXJzZUNhbGxSZXN1bHQoZGF0YTogQnl0ZXNMaWtlKTogPz9cbiAgICAvLyBHaXZlbiBhbiBldmVudCBsb2csIGZpbmQgdGhlIG1hdGNoaW5nIGV2ZW50IGZyYWdtZW50IChpZiBhbnkpIGFuZFxuICAgIC8vIGRldGVybWluZSBhbGwgaXRzIHByb3BlcnRpZXMgYW5kIHZhbHVlc1xuICAgIHBhcnNlTG9nKGxvZykge1xuICAgICAgICBsZXQgZnJhZ21lbnQgPSB0aGlzLmdldEV2ZW50KGxvZy50b3BpY3NbMF0pO1xuICAgICAgICBpZiAoIWZyYWdtZW50IHx8IGZyYWdtZW50LmFub255bW91cykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IElmIGFub255bW91cywgYW5kIHRoZSBvbmx5IG1ldGhvZCwgYW5kIHRoZSBpbnB1dCBjb3VudCBtYXRjaGVzLCBzaG91bGQgd2UgcGFyc2U/XG4gICAgICAgIC8vICAgICAgICBQcm9iYWJseSBub3QsIGJlY2F1c2UganVzdCBiZWNhdXNlIGl0IGlzIHRoZSBvbmx5IGV2ZW50IGluIHRoZSBBQkkgZG9lc1xuICAgICAgICAvLyAgICAgICAgbm90IG1lYW4gd2UgaGF2ZSB0aGUgZnVsbCBBQkk7IG1heWJlIGp1c3QgYSBmcmFnbWVudD9cbiAgICAgICAgcmV0dXJuIG5ldyBMb2dEZXNjcmlwdGlvbih7XG4gICAgICAgICAgICBldmVudEZyYWdtZW50OiBmcmFnbWVudCxcbiAgICAgICAgICAgIG5hbWU6IGZyYWdtZW50Lm5hbWUsXG4gICAgICAgICAgICBzaWduYXR1cmU6IGZyYWdtZW50LmZvcm1hdCgpLFxuICAgICAgICAgICAgdG9waWM6IHRoaXMuZ2V0RXZlbnRUb3BpYyhmcmFnbWVudCksXG4gICAgICAgICAgICBhcmdzOiB0aGlzLmRlY29kZUV2ZW50TG9nKGZyYWdtZW50LCBsb2cuZGF0YSwgbG9nLnRvcGljcylcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBhcnNlRXJyb3IoZGF0YSkge1xuICAgICAgICBjb25zdCBoZXhEYXRhID0gaGV4bGlmeShkYXRhKTtcbiAgICAgICAgbGV0IGZyYWdtZW50ID0gdGhpcy5nZXRFcnJvcihoZXhEYXRhLnN1YnN0cmluZygwLCAxMCkudG9Mb3dlckNhc2UoKSk7XG4gICAgICAgIGlmICghZnJhZ21lbnQpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgRXJyb3JEZXNjcmlwdGlvbih7XG4gICAgICAgICAgICBhcmdzOiB0aGlzLl9hYmlDb2Rlci5kZWNvZGUoZnJhZ21lbnQuaW5wdXRzLCBcIjB4XCIgKyBoZXhEYXRhLnN1YnN0cmluZygxMCkpLFxuICAgICAgICAgICAgZXJyb3JGcmFnbWVudDogZnJhZ21lbnQsXG4gICAgICAgICAgICBuYW1lOiBmcmFnbWVudC5uYW1lLFxuICAgICAgICAgICAgc2lnbmF0dXJlOiBmcmFnbWVudC5mb3JtYXQoKSxcbiAgICAgICAgICAgIHNpZ2hhc2g6IHRoaXMuZ2V0U2lnaGFzaChmcmFnbWVudCksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKlxuICAgIHN0YXRpYyBmcm9tKHZhbHVlOiBBcnJheTxGcmFnbWVudCB8IHN0cmluZyB8IEpzb25BYmk+IHwgc3RyaW5nIHwgSW50ZXJmYWNlKSB7XG4gICAgICAgIGlmIChJbnRlcmZhY2UuaXNJbnRlcmZhY2UodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKEpTT04ucGFyc2UodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbmV3IEludGVyZmFjZSh2YWx1ZSk7XG4gICAgfVxuICAgICovXG4gICAgc3RhdGljIGlzSW50ZXJmYWNlKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNJbnRlcmZhY2UpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWludGVyZmFjZS5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYWJzdHJhY3QtcHJvdmlkZXIvNS41LjFcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgRGVzY3JpcHRpb24sIGRlZmluZVJlYWRPbmx5LCByZXNvbHZlUHJvcGVydGllcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG47XG47XG4vL2V4cG9ydCB0eXBlIENhbGxUcmFuc2FjdGlvbmFibGUgPSB7XG4vLyAgICBjYWxsKHRyYW5zYWN0aW9uOiBUcmFuc2FjdGlvblJlcXVlc3QpOiBQcm9taXNlPFRyYW5zYWN0aW9uUmVzcG9uc2U+O1xuLy99O1xuZXhwb3J0IGNsYXNzIEZvcmtFdmVudCBleHRlbmRzIERlc2NyaXB0aW9uIHtcbiAgICBzdGF0aWMgaXNGb3JrRXZlbnQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0ZvcmtFdmVudCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEJsb2NrRm9ya0V2ZW50IGV4dGVuZHMgRm9ya0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihibG9ja0hhc2gsIGV4cGlyeSkge1xuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKGJsb2NrSGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBibG9ja0hhc2hcIiwgXCJibG9ja0hhc2hcIiwgYmxvY2tIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBfaXNCbG9ja0ZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcbiAgICAgICAgICAgIGJsb2NrSGFzaDogYmxvY2tIYXNoXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBUcmFuc2FjdGlvbkZvcmtFdmVudCBleHRlbmRzIEZvcmtFdmVudCB7XG4gICAgY29uc3RydWN0b3IoaGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoaGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiaGFzaFwiLCBoYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih7XG4gICAgICAgICAgICBfaXNGb3JrRXZlbnQ6IHRydWUsXG4gICAgICAgICAgICBfaXNUcmFuc2FjdGlvbkZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcbiAgICAgICAgICAgIGhhc2g6IGhhc2hcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFRyYW5zYWN0aW9uT3JkZXJGb3JrRXZlbnQgZXh0ZW5kcyBGb3JrRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGJlZm9yZUhhc2gsIGFmdGVySGFzaCwgZXhwaXJ5KSB7XG4gICAgICAgIGlmICghaXNIZXhTdHJpbmcoYmVmb3JlSGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiYmVmb3JlSGFzaFwiLCBiZWZvcmVIYXNoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKGFmdGVySGFzaCwgMzIpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBoYXNoXCIsIFwiYWZ0ZXJIYXNoXCIsIGFmdGVySGFzaCk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoe1xuICAgICAgICAgICAgX2lzRm9ya0V2ZW50OiB0cnVlLFxuICAgICAgICAgICAgX2lzVHJhbnNhY3Rpb25PcmRlckZvcmtFdmVudDogdHJ1ZSxcbiAgICAgICAgICAgIGV4cGlyeTogKGV4cGlyeSB8fCAwKSxcbiAgICAgICAgICAgIGJlZm9yZUhhc2g6IGJlZm9yZUhhc2gsXG4gICAgICAgICAgICBhZnRlckhhc2g6IGFmdGVySGFzaFxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFeHBvcnRlZCBBYnN0cmFjdHNcbmV4cG9ydCBjbGFzcyBQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KG5ldy50YXJnZXQsIFByb3ZpZGVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNQcm92aWRlclwiLCB0cnVlKTtcbiAgICB9XG4gICAgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgYmxvY2ssIGdhc1ByaWNlIH0gPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYmxvY2s6IHRoaXMuZ2V0QmxvY2soXCJsYXRlc3RcIiksXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IHRoaXMuZ2V0R2FzUHJpY2UoKS5jYXRjaCgoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFdoeSBpcyB0aGlzIG5vdyBmYWlsaW5nIG9uIENhbGF2ZXJhcz9cbiAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGxldCBtYXhGZWVQZXJHYXMgPSBudWxsLCBtYXhQcmlvcml0eUZlZVBlckdhcyA9IG51bGw7XG4gICAgICAgICAgICBpZiAoYmxvY2sgJiYgYmxvY2suYmFzZUZlZVBlckdhcykge1xuICAgICAgICAgICAgICAgIC8vIFdlIG1heSB3YW50IHRvIGNvbXB1dGUgdGhpcyBtb3JlIGFjY3VyYXRlbHkgaW4gdGhlIGZ1dHVyZSxcbiAgICAgICAgICAgICAgICAvLyB1c2luZyB0aGUgZm9ybXVsYSBcImNoZWNrIGlmIHRoZSBiYXNlIGZlZSBpcyBjb3JyZWN0XCIuXG4gICAgICAgICAgICAgICAgLy8gU2VlOiBodHRwczovL2VpcHMuZXRoZXJldW0ub3JnL0VJUFMvZWlwLTE1NTlcbiAgICAgICAgICAgICAgICBtYXhQcmlvcml0eUZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKFwiMjUwMDAwMDAwMFwiKTtcbiAgICAgICAgICAgICAgICBtYXhGZWVQZXJHYXMgPSBibG9jay5iYXNlRmVlUGVyR2FzLm11bCgyKS5hZGQobWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHsgbWF4RmVlUGVyR2FzLCBtYXhQcmlvcml0eUZlZVBlckdhcywgZ2FzUHJpY2UgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEFsaWFzIGZvciBcIm9uXCJcbiAgICBhZGRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLm9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICAvLyBBbGlhcyBmb3IgXCJvZmZcIlxuICAgIHJlbW92ZUxpc3RlbmVyKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMub2ZmKGV2ZW50TmFtZSwgbGlzdGVuZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNQcm92aWRlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzUHJvdmlkZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJhYnN0cmFjdC1zaWduZXIvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgcmVzb2x2ZVByb3BlcnRpZXMsIHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSBbXG4gICAgXCJhY2Nlc3NMaXN0XCIsIFwiY2hhaW5JZFwiLCBcImN1c3RvbURhdGFcIiwgXCJkYXRhXCIsIFwiZnJvbVwiLCBcImdhc0xpbWl0XCIsIFwiZ2FzUHJpY2VcIiwgXCJtYXhGZWVQZXJHYXNcIiwgXCJtYXhQcmlvcml0eUZlZVBlckdhc1wiLCBcIm5vbmNlXCIsIFwidG9cIiwgXCJ0eXBlXCIsIFwidmFsdWVcIlxuXTtcbmNvbnN0IGZvcndhcmRFcnJvcnMgPSBbXG4gICAgTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsXG4gICAgTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELFxuICAgIExvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsXG5dO1xuO1xuO1xuZXhwb3J0IGNsYXNzIFNpZ25lciB7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN1Yi1jbGFzc2VzIE1VU1QgY2FsbCBzdXBlclxuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBsb2dnZXIuY2hlY2tBYnN0cmFjdChuZXcudGFyZ2V0LCBTaWduZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pc1NpZ25lclwiLCB0cnVlKTtcbiAgICB9XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN1Yi1jbGFzc2VzIE1BWSBvdmVycmlkZSB0aGVzZVxuICAgIGdldEJhbGFuY2UoYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRCYWxhbmNlXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0QmFsYW5jZSh0aGlzLmdldEFkZHJlc3MoKSwgYmxvY2tUYWcpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb25Db3VudChibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldFRyYW5zYWN0aW9uQ291bnRcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRUcmFuc2FjdGlvbkNvdW50KHRoaXMuZ2V0QWRkcmVzcygpLCBibG9ja1RhZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgXCJmcm9tXCIgaWYgdW5zcGVjaWZpZWQsIGFuZCBlc3RpbWF0ZXMgdGhlIGdhcyBmb3IgdGhlIHRyYW5zYWN0aW9uXG4gICAgZXN0aW1hdGVHYXModHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJlc3RpbWF0ZUdhc1wiKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyh0eCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgXCJmcm9tXCIgaWYgdW5zcGVjaWZpZWQsIGFuZCBjYWxscyB3aXRoIHRoZSB0cmFuc2FjdGlvblxuICAgIGNhbGwodHJhbnNhY3Rpb24sIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiY2FsbFwiKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModGhpcy5jaGVja1RyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSk7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHR4LCBibG9ja1RhZyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBQb3B1bGF0ZXMgYWxsIGZpZWxkcyBpbiBhIHRyYW5zYWN0aW9uLCBzaWducyBpdCBhbmQgc2VuZHMgaXQgdG8gdGhlIG5ldHdvcmtcbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJzZW5kVHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbih0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjb25zdCBzaWduZWRUeCA9IHlpZWxkIHRoaXMuc2lnblRyYW5zYWN0aW9uKHR4KTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihzaWduZWRUeCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDaGFpbklkKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcImdldENoYWluSWRcIik7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0geWllbGQgdGhpcy5wcm92aWRlci5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yay5jaGFpbklkO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0R2FzUHJpY2UoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1Byb3ZpZGVyKFwiZ2V0R2FzUHJpY2VcIik7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5wcm92aWRlci5nZXRHYXNQcmljZSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0RmVlRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRoaXMuX2NoZWNrUHJvdmlkZXIoXCJnZXRGZWVEYXRhXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0RmVlRGF0YSgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgdGhpcy5fY2hlY2tQcm92aWRlcihcInJlc29sdmVOYW1lXCIpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBDaGVja3MgYSB0cmFuc2FjdGlvbiBkb2VzIG5vdCBjb250YWluIGludmFsaWQga2V5cyBhbmQgaWZcbiAgICAvLyBubyBcImZyb21cIiBpcyBwcm92aWRlZCwgcG9wdWxhdGVzIGl0LlxuICAgIC8vIC0gZG9lcyBOT1QgcmVxdWlyZSBhIHByb3ZpZGVyXG4gICAgLy8gLSBhZGRzIFwiZnJvbVwiIGlzIG5vdCBwcmVzZW50XG4gICAgLy8gLSByZXR1cm5zIGEgQ09QWSAoc2FmZSB0byBtdXRhdGUgdGhlIHJlc3VsdClcbiAgICAvLyBCeSBkZWZhdWx0IGNhbGxlZCBmcm9tOiAob3ZlcnJpZGluZyB0aGVzZSBwcmV2ZW50cyBpdClcbiAgICAvLyAgIC0gY2FsbFxuICAgIC8vICAgLSBlc3RpbWF0ZUdhc1xuICAgIC8vICAgLSBwb3B1bGF0ZVRyYW5zYWN0aW9uIChhbmQgdGhlcmVmb3Igc2VuZFRyYW5zYWN0aW9uKVxuICAgIGNoZWNrVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGlmIChhbGxvd2VkVHJhbnNhY3Rpb25LZXlzLmluZGV4T2Yoa2V5KSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB0cmFuc2FjdGlvbiBrZXk6IFwiICsga2V5LCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0eCA9IHNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcbiAgICAgICAgaWYgKHR4LmZyb20gPT0gbnVsbCkge1xuICAgICAgICAgICAgdHguZnJvbSA9IHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIGFueSBwcm92aWRlZCBhZGRyZXNzIG1hdGNoZXMgdGhpcyBzaWduZXJcbiAgICAgICAgICAgIHR4LmZyb20gPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgUHJvbWlzZS5yZXNvbHZlKHR4LmZyb20pLFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0QWRkcmVzcygpXG4gICAgICAgICAgICBdKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0WzBdLnRvTG93ZXJDYXNlKCkgIT09IHJlc3VsdFsxXS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHRbMF07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIC8vIFBvcHVsYXRlcyBBTEwga2V5cyBmb3IgYSB0cmFuc2FjdGlvbiBhbmQgY2hlY2tzIHRoYXQgXCJmcm9tXCIgbWF0Y2hlc1xuICAgIC8vIHRoaXMgU2lnbmVyLiBTaG91bGQgYmUgdXNlZCBieSBzZW5kVHJhbnNhY3Rpb24gYnV0IE5PVCBieSBzaWduVHJhbnNhY3Rpb24uXG4gICAgLy8gQnkgZGVmYXVsdCBjYWxsZWQgZnJvbTogKG92ZXJyaWRpbmcgdGhlc2UgcHJldmVudHMgaXQpXG4gICAgLy8gICAtIHNlbmRUcmFuc2FjdGlvblxuICAgIC8vXG4gICAgLy8gTm90ZXM6XG4gICAgLy8gIC0gV2UgYWxsb3cgZ2FzUHJpY2UgZm9yIEVJUC0xNTU5IGFzIGxvbmcgYXMgaXQgbWF0Y2hlcyBtYXhGZWVQZXJHYXNcbiAgICBwb3B1bGF0ZVRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHRoaXMuY2hlY2tUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikpO1xuICAgICAgICAgICAgaWYgKHR4LnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0eC50byA9IFByb21pc2UucmVzb2x2ZSh0eC50bykudGhlbigodG8pID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRvID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLnJlc29sdmVOYW1lKHRvKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInByb3ZpZGVkIEVOUyBuYW1lIHJlc29sdmVzIHRvIG51bGxcIiwgXCJ0eC50b1wiLCB0byk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIFByZXZlbnQgdGhpcyBlcnJvciBmcm9tIGNhdXNpbmcgYW4gVW5oYW5kbGVkUHJvbWlzZUV4Y2VwdGlvblxuICAgICAgICAgICAgICAgIHR4LnRvLmNhdGNoKChlcnJvcikgPT4geyB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERvIG5vdCBhbGxvdyBtaXhpbmcgcHJlLWVpcC0xNTU5IGFuZCBlaXAtMTU1OSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICBjb25zdCBoYXNFaXAxNTU5ID0gKHR4Lm1heEZlZVBlckdhcyAhPSBudWxsIHx8IHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpO1xuICAgICAgICAgICAgaWYgKHR4Lmdhc1ByaWNlICE9IG51bGwgJiYgKHR4LnR5cGUgPT09IDIgfHwgaGFzRWlwMTU1OSkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiZWlwLTE1NTkgdHJhbnNhY3Rpb24gZG8gbm90IHN1cHBvcnQgZ2FzUHJpY2VcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICgodHgudHlwZSA9PT0gMCB8fCB0eC50eXBlID09PSAxKSAmJiBoYXNFaXAxNTU5KSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInByZS1laXAtMTU1OSB0cmFuc2FjdGlvbiBkbyBub3Qgc3VwcG9ydCBtYXhGZWVQZXJHYXMvbWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKHR4LnR5cGUgPT09IDIgfHwgdHgudHlwZSA9PSBudWxsKSAmJiAodHgubWF4RmVlUGVyR2FzICE9IG51bGwgJiYgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkpIHtcbiAgICAgICAgICAgICAgICAvLyBGdWxseS1mb3JtZWQgRUlQLTE1NTkgdHJhbnNhY3Rpb24gKHNraXAgZ2V0RmVlRGF0YSlcbiAgICAgICAgICAgICAgICB0eC50eXBlID0gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHR4LnR5cGUgPT09IDAgfHwgdHgudHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0IExlZ2FjeSBvciBFSVAtMjkzMCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZ2FzUHJpY2VcbiAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0eC5nYXNQcmljZSA9IHRoaXMuZ2V0R2FzUHJpY2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGdldCBmZWUgZGF0YSB0byBkZXRlcm1pbmUgdGhpbmdzXG4gICAgICAgICAgICAgICAgY29uc3QgZmVlRGF0YSA9IHlpZWxkIHRoaXMuZ2V0RmVlRGF0YSgpO1xuICAgICAgICAgICAgICAgIGlmICh0eC50eXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gV2UgbmVlZCB0byBhdXRvLWRldGVjdCB0aGUgaW50ZW5kZWQgdHlwZSBvZiB0aGlzIHRyYW5zYWN0aW9uLi4uXG4gICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyAhPSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG5ldHdvcmsgc3VwcG9ydHMgRUlQLTE1NTkhXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBVcGdyYWRlIHRyYW5zYWN0aW9uIGZyb20gbnVsbCB0byBlaXAtMTU1OVxuICAgICAgICAgICAgICAgICAgICAgICAgdHgudHlwZSA9IDI7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFVzaW5nIGxlZ2FjeSBnYXNQcmljZSBwcm9wZXJ0eSBvbiBhbiBlaXAtMTU1OSBuZXR3b3JrLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNvIHVzZSBnYXNQcmljZSBhcyBib3RoIGZlZSBwcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSB0eC5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHguZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZ2FzUHJpY2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4UHJpb3JpdHlGZWVQZXJHYXMgPSBnYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFBvcHVsYXRlIG1pc3NpbmcgZmVlIGRhdGFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHgubWF4RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhQcmlvcml0eUZlZVBlckdhcyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoZmVlRGF0YS5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBOZXR3b3JrIGRvZXNuJ3Qgc3VwcG9ydCBFSVAtMTU1OS4uLlxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gLi4uYnV0IHRoZXkgYXJlIHRyeWluZyB0byB1c2UgRUlQLTE1NTkgcHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhc0VpcDE1NTkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5ldHdvcmsgZG9lcyBub3Qgc3VwcG9ydCBFSVAtMTU1OVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicG9wdWxhdGVUcmFuc2FjdGlvblwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZ2FzUHJpY2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4Lmdhc1ByaWNlID0gZmVlRGF0YS5nYXNQcmljZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cGxpY2l0bHkgc2V0IHVudHlwZWQgdHJhbnNhY3Rpb24gdG8gbGVnYWN5XG4gICAgICAgICAgICAgICAgICAgICAgICB0eC50eXBlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGdldEZlZURhdGEgaGFzIGZhaWxlZCB1cy5cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZmFpbGVkIHRvIGdldCBjb25zaXN0ZW50IGZlZSBkYXRhXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25lci5nZXRGZWVEYXRhXCJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LnR5cGUgPT09IDIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gRXhwbGljaXRseSB1c2luZyBFSVAtMTU1OVxuICAgICAgICAgICAgICAgICAgICAvLyBQb3B1bGF0ZSBtaXNzaW5nIGZlZSBkYXRhXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eC5tYXhGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHgubWF4RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhGZWVQZXJHYXM7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gZmVlRGF0YS5tYXhQcmlvcml0eUZlZVBlckdhcztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eC5ub25jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdHgubm9uY2UgPSB0aGlzLmdldFRyYW5zYWN0aW9uQ291bnQoXCJwZW5kaW5nXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4Lmdhc0xpbWl0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICB0eC5nYXNMaW1pdCA9IHRoaXMuZXN0aW1hdGVHYXModHgpLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZm9yd2FyZEVycm9ycy5pbmRleE9mKGVycm9yLmNvZGUpID49IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIiwgTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgdHg6IHR4XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR4LmNoYWluSWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4LmNoYWluSWQgPSB0aGlzLmdldENoYWluSWQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHR4LmNoYWluSWQgPSBQcm9taXNlLmFsbChbXG4gICAgICAgICAgICAgICAgICAgIFByb21pc2UucmVzb2x2ZSh0eC5jaGFpbklkKSxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRDaGFpbklkKClcbiAgICAgICAgICAgICAgICBdKS50aGVuKChyZXN1bHRzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHRzWzFdICE9PSAwICYmIHJlc3VsdHNbMF0gIT09IHJlc3VsdHNbMV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJjaGFpbklkIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdHNbMF07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzb2x2ZVByb3BlcnRpZXModHgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIFN1Yi1jbGFzc2VzIFNIT1VMRCBsZWF2ZSB0aGVzZSBhbG9uZVxuICAgIF9jaGVja1Byb3ZpZGVyKG9wZXJhdGlvbikge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyBwcm92aWRlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogKG9wZXJhdGlvbiB8fCBcIl9jaGVja1Byb3ZpZGVyXCIpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBzdGF0aWMgaXNTaWduZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc1NpZ25lcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFZvaWRTaWduZXIgZXh0ZW5kcyBTaWduZXIge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIHByb3ZpZGVyKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja05ldyhuZXcudGFyZ2V0LCBWb2lkU2lnbmVyKTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyIHx8IG51bGwpO1xuICAgIH1cbiAgICBnZXRBZGRyZXNzKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuYWRkcmVzcyk7XG4gICAgfVxuICAgIF9mYWlsKG1lc3NhZ2UsIG9wZXJhdGlvbikge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKCkudGhlbigoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyBvcGVyYXRpb246IG9wZXJhdGlvbiB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZhaWwoXCJWb2lkU2lnbmVyIGNhbm5vdCBzaWduIG1lc3NhZ2VzXCIsIFwic2lnbk1lc3NhZ2VcIik7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gdHJhbnNhY3Rpb25zXCIsIFwic2lnblRyYW5zYWN0aW9uXCIpO1xuICAgIH1cbiAgICBfc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZmFpbChcIlZvaWRTaWduZXIgY2Fubm90IHNpZ24gdHlwZWQgZGF0YVwiLCBcInNpZ25UeXBlZERhdGFcIik7XG4gICAgfVxuICAgIGNvbm5lY3QocHJvdmlkZXIpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBWb2lkU2lnbmVyKHRoaXMuYWRkcmVzcywgcHJvdmlkZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJhZGRyZXNzLzUuNS4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaXNIZXhTdHJpbmcsIHN0cmlwWmVyb3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEJpZ051bWJlciwgX2Jhc2UxNlRvMzYsIF9iYXNlMzZUbzE2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgZW5jb2RlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3JscFwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZnVuY3Rpb24gZ2V0Q2hlY2tzdW1BZGRyZXNzKGFkZHJlc3MpIHtcbiAgICBpZiAoIWlzSGV4U3RyaW5nKGFkZHJlc3MsIDIwKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICB9XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICBjb25zdCBjaGFycyA9IGFkZHJlc3Muc3Vic3RyaW5nKDIpLnNwbGl0KFwiXCIpO1xuICAgIGNvbnN0IGV4cGFuZGVkID0gbmV3IFVpbnQ4QXJyYXkoNDApO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkrKykge1xuICAgICAgICBleHBhbmRlZFtpXSA9IGNoYXJzW2ldLmNoYXJDb2RlQXQoMCk7XG4gICAgfVxuICAgIGNvbnN0IGhhc2hlZCA9IGFycmF5aWZ5KGtlY2NhazI1NihleHBhbmRlZCkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgNDA7IGkgKz0gMikge1xuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdID4+IDQpID49IDgpIHtcbiAgICAgICAgICAgIGNoYXJzW2ldID0gY2hhcnNbaV0udG9VcHBlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKGhhc2hlZFtpID4+IDFdICYgMHgwZikgPj0gOCkge1xuICAgICAgICAgICAgY2hhcnNbaSArIDFdID0gY2hhcnNbaSArIDFdLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFwiMHhcIiArIGNoYXJzLmpvaW4oXCJcIik7XG59XG4vLyBTaGltcyBmb3IgZW52aXJvbm1lbnRzIHRoYXQgYXJlIG1pc3Npbmcgc29tZSByZXF1aXJlZCBjb25zdGFudHMgYW5kIGZ1bmN0aW9uc1xuY29uc3QgTUFYX1NBRkVfSU5URUdFUiA9IDB4MWZmZmZmZmZmZmZmZmY7XG5mdW5jdGlvbiBsb2cxMCh4KSB7XG4gICAgaWYgKE1hdGgubG9nMTApIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubG9nMTAoeCk7XG4gICAgfVxuICAgIHJldHVybiBNYXRoLmxvZyh4KSAvIE1hdGguTE4xMDtcbn1cbi8vIFNlZTogaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSW50ZXJuYXRpb25hbF9CYW5rX0FjY291bnRfTnVtYmVyXG4vLyBDcmVhdGUgbG9va3VwIHRhYmxlXG5jb25zdCBpYmFuTG9va3VwID0ge307XG5mb3IgKGxldCBpID0gMDsgaSA8IDEwOyBpKyspIHtcbiAgICBpYmFuTG9va3VwW1N0cmluZyhpKV0gPSBTdHJpbmcoaSk7XG59XG5mb3IgKGxldCBpID0gMDsgaSA8IDI2OyBpKyspIHtcbiAgICBpYmFuTG9va3VwW1N0cmluZy5mcm9tQ2hhckNvZGUoNjUgKyBpKV0gPSBTdHJpbmcoMTAgKyBpKTtcbn1cbi8vIEhvdyBtYW55IGRlY2ltYWwgZGlnaXRzIGNhbiB3ZSBwcm9jZXNzPyAoZm9yIDY0LWJpdCBmbG9hdCwgdGhpcyBpcyAxNSlcbmNvbnN0IHNhZmVEaWdpdHMgPSBNYXRoLmZsb29yKGxvZzEwKE1BWF9TQUZFX0lOVEVHRVIpKTtcbmZ1bmN0aW9uIGliYW5DaGVja3N1bShhZGRyZXNzKSB7XG4gICAgYWRkcmVzcyA9IGFkZHJlc3MudG9VcHBlckNhc2UoKTtcbiAgICBhZGRyZXNzID0gYWRkcmVzcy5zdWJzdHJpbmcoNCkgKyBhZGRyZXNzLnN1YnN0cmluZygwLCAyKSArIFwiMDBcIjtcbiAgICBsZXQgZXhwYW5kZWQgPSBhZGRyZXNzLnNwbGl0KFwiXCIpLm1hcCgoYykgPT4geyByZXR1cm4gaWJhbkxvb2t1cFtjXTsgfSkuam9pbihcIlwiKTtcbiAgICAvLyBKYXZhc2NyaXB0IGNhbiBoYW5kbGUgaW50ZWdlcnMgc2FmZWx5IHVwIHRvIDE1IChkZWNpbWFsKSBkaWdpdHNcbiAgICB3aGlsZSAoZXhwYW5kZWQubGVuZ3RoID49IHNhZmVEaWdpdHMpIHtcbiAgICAgICAgbGV0IGJsb2NrID0gZXhwYW5kZWQuc3Vic3RyaW5nKDAsIHNhZmVEaWdpdHMpO1xuICAgICAgICBleHBhbmRlZCA9IHBhcnNlSW50KGJsb2NrLCAxMCkgJSA5NyArIGV4cGFuZGVkLnN1YnN0cmluZyhibG9jay5sZW5ndGgpO1xuICAgIH1cbiAgICBsZXQgY2hlY2tzdW0gPSBTdHJpbmcoOTggLSAocGFyc2VJbnQoZXhwYW5kZWQsIDEwKSAlIDk3KSk7XG4gICAgd2hpbGUgKGNoZWNrc3VtLmxlbmd0aCA8IDIpIHtcbiAgICAgICAgY2hlY2tzdW0gPSBcIjBcIiArIGNoZWNrc3VtO1xuICAgIH1cbiAgICByZXR1cm4gY2hlY2tzdW07XG59XG47XG5leHBvcnQgZnVuY3Rpb24gZ2V0QWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgbGV0IHJlc3VsdCA9IG51bGw7XG4gICAgaWYgKHR5cGVvZiAoYWRkcmVzcykgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgfVxuICAgIGlmIChhZGRyZXNzLm1hdGNoKC9eKDB4KT9bMC05YS1mQS1GXXs0MH0kLykpIHtcbiAgICAgICAgLy8gTWlzc2luZyB0aGUgMHggcHJlZml4XG4gICAgICAgIGlmIChhZGRyZXNzLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0gXCIweFwiICsgYWRkcmVzcztcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBnZXRDaGVja3N1bUFkZHJlc3MoYWRkcmVzcyk7XG4gICAgICAgIC8vIEl0IGlzIGEgY2hlY2tzdW1tZWQgYWRkcmVzcyB3aXRoIGEgYmFkIGNoZWNrc3VtXG4gICAgICAgIGlmIChhZGRyZXNzLm1hdGNoKC8oW0EtRl0uKlthLWZdKXwoW2EtZl0uKltBLUZdKS8pICYmIHJlc3VsdCAhPT0gYWRkcmVzcykge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBhZGRyZXNzIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYXliZSBJQ0FQPyAod2Ugb25seSBzdXBwb3J0IGRpcmVjdCBtb2RlKVxuICAgIH1cbiAgICBlbHNlIGlmIChhZGRyZXNzLm1hdGNoKC9eWEVbMC05XXsyfVswLTlBLVphLXpdezMwLDMxfSQvKSkge1xuICAgICAgICAvLyBJdCBpcyBhbiBJQ0FQIGFkZHJlc3Mgd2l0aCBhIGJhZCBjaGVja3N1bVxuICAgICAgICBpZiAoYWRkcmVzcy5zdWJzdHJpbmcoMiwgNCkgIT09IGliYW5DaGVja3N1bShhZGRyZXNzKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBpY2FwIGNoZWNrc3VtXCIsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgPSBfYmFzZTM2VG8xNihhZGRyZXNzLnN1YnN0cmluZyg0KSk7XG4gICAgICAgIHdoaWxlIChyZXN1bHQubGVuZ3RoIDwgNDApIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IFwiMFwiICsgcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCA9IGdldENoZWNrc3VtQWRkcmVzcyhcIjB4XCIgKyByZXN1bHQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzc1wiLCBcImFkZHJlc3NcIiwgYWRkcmVzcyk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNBZGRyZXNzKGFkZHJlc3MpIHtcbiAgICB0cnkge1xuICAgICAgICBnZXRBZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gZ2V0SWNhcEFkZHJlc3MoYWRkcmVzcykge1xuICAgIGxldCBiYXNlMzYgPSBfYmFzZTE2VG8zNihnZXRBZGRyZXNzKGFkZHJlc3MpLnN1YnN0cmluZygyKSkudG9VcHBlckNhc2UoKTtcbiAgICB3aGlsZSAoYmFzZTM2Lmxlbmd0aCA8IDMwKSB7XG4gICAgICAgIGJhc2UzNiA9IFwiMFwiICsgYmFzZTM2O1xuICAgIH1cbiAgICByZXR1cm4gXCJYRVwiICsgaWJhbkNoZWNrc3VtKFwiWEUwMFwiICsgYmFzZTM2KSArIGJhc2UzNjtcbn1cbi8vIGh0dHA6Ly9ldGhlcmV1bS5zdGFja2V4Y2hhbmdlLmNvbS9xdWVzdGlvbnMvNzYwL2hvdy1pcy10aGUtYWRkcmVzcy1vZi1hbi1ldGhlcmV1bS1jb250cmFjdC1jb21wdXRlZFxuZXhwb3J0IGZ1bmN0aW9uIGdldENvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbikge1xuICAgIGxldCBmcm9tID0gbnVsbDtcbiAgICB0cnkge1xuICAgICAgICBmcm9tID0gZ2V0QWRkcmVzcyh0cmFuc2FjdGlvbi5mcm9tKTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIGZyb20gYWRkcmVzc1wiLCBcInRyYW5zYWN0aW9uXCIsIHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgY29uc3Qgbm9uY2UgPSBzdHJpcFplcm9zKGFycmF5aWZ5KEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLm5vbmNlKS50b0hleFN0cmluZygpKSk7XG4gICAgcmV0dXJuIGdldEFkZHJlc3MoaGV4RGF0YVNsaWNlKGtlY2NhazI1NihlbmNvZGUoW2Zyb20sIG5vbmNlXSkpLCAxMikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldENyZWF0ZTJBZGRyZXNzKGZyb20sIHNhbHQsIGluaXRDb2RlSGFzaCkge1xuICAgIGlmIChoZXhEYXRhTGVuZ3RoKHNhbHQpICE9PSAzMikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2FsdCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwic2FsdFwiLCBzYWx0KTtcbiAgICB9XG4gICAgaWYgKGhleERhdGFMZW5ndGgoaW5pdENvZGVIYXNoKSAhPT0gMzIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImluaXRDb2RlSGFzaCBtdXN0IGJlIDMyIGJ5dGVzXCIsIFwiaW5pdENvZGVIYXNoXCIsIGluaXRDb2RlSGFzaCk7XG4gICAgfVxuICAgIHJldHVybiBnZXRBZGRyZXNzKGhleERhdGFTbGljZShrZWNjYWsyNTYoY29uY2F0KFtcIjB4ZmZcIiwgZ2V0QWRkcmVzcyhmcm9tKSwgc2FsdCwgaW5pdENvZGVIYXNoXSkpLCAxMikpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZSh0ZXh0RGF0YSkge1xuICAgIHRleHREYXRhID0gYXRvYih0ZXh0RGF0YSk7XG4gICAgY29uc3QgZGF0YSA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGV4dERhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgZGF0YS5wdXNoKHRleHREYXRhLmNoYXJDb2RlQXQoaSkpO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlpZnkoZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gZW5jb2RlKGRhdGEpIHtcbiAgICBkYXRhID0gYXJyYXlpZnkoZGF0YSk7XG4gICAgbGV0IHRleHREYXRhID0gXCJcIjtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGRhdGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGV4dERhdGEgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShkYXRhW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIGJ0b2EodGV4dERhdGEpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZTY0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0IHsgZGVjb2RlLCBlbmNvZGUgfSBmcm9tIFwiLi9iYXNlNjRcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIi8qKlxuICogdmFyIGJhc2V4ID0gcmVxdWlyZShcImJhc2UteFwiKTtcbiAqXG4gKiBUaGlzIGltcGxlbWVudGF0aW9uIGlzIGhlYXZpbHkgYmFzZWQgb24gYmFzZS14LiBUaGUgbWFpbiByZWFzb24gdG9cbiAqIGRldmlhdGUgd2FzIHRvIHByZXZlbnQgdGhlIGRlcGVuZGVuY3kgb2YgQnVmZmVyLlxuICpcbiAqIENvbnRyaWJ1dG9yczpcbiAqXG4gKiBiYXNlLXggZW5jb2RpbmdcbiAqIEZvcmtlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9jcnlwdG9jb2luanMvYnM1OFxuICogT3JpZ2luYWxseSB3cml0dGVuIGJ5IE1pa2UgSGVhcm4gZm9yIEJpdGNvaW5KXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEgR29vZ2xlIEluY1xuICogUG9ydGVkIHRvIEphdmFTY3JpcHQgYnkgU3RlZmFuIFRob21hc1xuICogTWVyZ2VkIEJ1ZmZlciByZWZhY3RvcmluZ3MgZnJvbSBiYXNlNTgtbmF0aXZlIGJ5IFN0ZXBoZW4gUGFpclxuICogQ29weXJpZ2h0IChjKSAyMDEzIEJpdFBheSBJbmNcbiAqXG4gKiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcbiAqXG4gKiBDb3B5cmlnaHQgYmFzZS14IGNvbnRyaWJ1dG9ycyAoYykgMjAxNlxuICpcbiAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4gKiBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksXG4gKiB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uXG4gKiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSxcbiAqIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZVxuICogU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcbiAqXG4gKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpblxuICogYWxsIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiAqIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1MgT1JcbiAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gKiBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLCBEQU1BR0VTIE9SIE9USEVSXG4gKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lOR1xuICogRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HU1xuICogSU4gVEhFIFNPRlRXQVJFLlxuICpcbiAqL1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmV4cG9ydCBjbGFzcyBCYXNlWCB7XG4gICAgY29uc3RydWN0b3IoYWxwaGFiZXQpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhbHBoYWJldFwiLCBhbHBoYWJldCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYmFzZVwiLCBhbHBoYWJldC5sZW5ndGgpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9hbHBoYWJldE1hcFwiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2xlYWRlclwiLCBhbHBoYWJldC5jaGFyQXQoMCkpO1xuICAgICAgICAvLyBwcmUtY29tcHV0ZSBsb29rdXAgdGFibGVcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBhbHBoYWJldC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGhpcy5fYWxwaGFiZXRNYXBbYWxwaGFiZXQuY2hhckF0KGkpXSA9IGk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZW5jb2RlKHZhbHVlKSB7XG4gICAgICAgIGxldCBzb3VyY2UgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgICAgIGlmIChzb3VyY2UubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGlnaXRzID0gWzBdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZS5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgbGV0IGNhcnJ5ID0gc291cmNlW2ldO1xuICAgICAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBkaWdpdHMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjYXJyeSArPSBkaWdpdHNbal0gPDwgODtcbiAgICAgICAgICAgICAgICBkaWdpdHNbal0gPSBjYXJyeSAlIHRoaXMuYmFzZTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIHRoaXMuYmFzZSkgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd2hpbGUgKGNhcnJ5ID4gMCkge1xuICAgICAgICAgICAgICAgIGRpZ2l0cy5wdXNoKGNhcnJ5ICUgdGhpcy5iYXNlKTtcbiAgICAgICAgICAgICAgICBjYXJyeSA9IChjYXJyeSAvIHRoaXMuYmFzZSkgfCAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBzdHJpbmcgPSBcIlwiO1xuICAgICAgICAvLyBkZWFsIHdpdGggbGVhZGluZyB6ZXJvc1xuICAgICAgICBmb3IgKGxldCBrID0gMDsgc291cmNlW2tdID09PSAwICYmIGsgPCBzb3VyY2UubGVuZ3RoIC0gMTsgKytrKSB7XG4gICAgICAgICAgICBzdHJpbmcgKz0gdGhpcy5fbGVhZGVyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnZlcnQgZGlnaXRzIHRvIGEgc3RyaW5nXG4gICAgICAgIGZvciAobGV0IHEgPSBkaWdpdHMubGVuZ3RoIC0gMTsgcSA+PSAwOyAtLXEpIHtcbiAgICAgICAgICAgIHN0cmluZyArPSB0aGlzLmFscGhhYmV0W2RpZ2l0c1txXV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICB9XG4gICAgZGVjb2RlKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIFN0cmluZ1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYnl0ZXMgPSBbXTtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBieXRlcy5wdXNoKDApO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBsZXQgYnl0ZSA9IHRoaXMuX2FscGhhYmV0TWFwW3ZhbHVlW2ldXTtcbiAgICAgICAgICAgIGlmIChieXRlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJOb24tYmFzZVwiICsgdGhpcy5iYXNlICsgXCIgY2hhcmFjdGVyXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IGNhcnJ5ID0gYnl0ZTtcbiAgICAgICAgICAgIGZvciAobGV0IGogPSAwOyBqIDwgYnl0ZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICAgICAgICBjYXJyeSArPSBieXRlc1tqXSAqIHRoaXMuYmFzZTtcbiAgICAgICAgICAgICAgICBieXRlc1tqXSA9IGNhcnJ5ICYgMHhmZjtcbiAgICAgICAgICAgICAgICBjYXJyeSA+Pj0gODtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHdoaWxlIChjYXJyeSA+IDApIHtcbiAgICAgICAgICAgICAgICBieXRlcy5wdXNoKGNhcnJ5ICYgMHhmZik7XG4gICAgICAgICAgICAgICAgY2FycnkgPj49IDg7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gZGVhbCB3aXRoIGxlYWRpbmcgemVyb3NcbiAgICAgICAgZm9yIChsZXQgayA9IDA7IHZhbHVlW2tdID09PSB0aGlzLl9sZWFkZXIgJiYgayA8IHZhbHVlLmxlbmd0aCAtIDE7ICsraykge1xuICAgICAgICAgICAgYnl0ZXMucHVzaCgwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXlpZnkobmV3IFVpbnQ4QXJyYXkoYnl0ZXMucmV2ZXJzZSgpKSk7XG4gICAgfVxufVxuY29uc3QgQmFzZTMyID0gbmV3IEJhc2VYKFwiYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXoyMzQ1NjdcIik7XG5jb25zdCBCYXNlNTggPSBuZXcgQmFzZVgoXCIxMjM0NTY3ODlBQkNERUZHSEpLTE1OUFFSU1RVVldYWVphYmNkZWZnaGlqa21ub3BxcnN0dXZ3eHl6XCIpO1xuZXhwb3J0IHsgQmFzZTMyLCBCYXNlNTggfTtcbi8vY29uc29sZS5sb2coQmFzZTU4LmRlY29kZShcIlFtZDJWNzc3bzVYdkpiWU1lTWI4azJuVTVmOGQzY2lVUTVZcFl1V2h6djhpRGpcIikpXG4vL2NvbnNvbGUubG9nKEJhc2U1OC5lbmNvZGUoQmFzZTU4LmRlY29kZShcIlFtZDJWNzc3bzVYdkpiWU1lTWI4azJuVTVmOGQzY2lVUTVZcFl1V2h6djhpRGpcIikpKVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImJpZ251bWJlci81LjUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vKipcbiAqICBCaWdOdW1iZXJcbiAqXG4gKiAgQSB3cmFwcGVyIGFyb3VuZCB0aGUgQk4uanMgb2JqZWN0LiBXZSB1c2UgdGhlIEJOLmpzIGxpYnJhcnlcbiAqICBiZWNhdXNlIGl0IGlzIHVzZWQgYnkgZWxsaXB0aWMsIHNvIGl0IGlzIHJlcXVpcmVkIHJlZ2FyZGxlc3MuXG4gKlxuICovXG5pbXBvcnQgX0JOIGZyb20gXCJibi5qc1wiO1xudmFyIEJOID0gX0JOLkJOO1xuaW1wb3J0IHsgaGV4bGlmeSwgaXNCeXRlcywgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmNvbnN0IF9jb25zdHJ1Y3Rvckd1YXJkID0ge307XG5jb25zdCBNQVhfU0FGRSA9IDB4MWZmZmZmZmZmZmZmZmY7XG5leHBvcnQgZnVuY3Rpb24gaXNCaWdOdW1iZXJpc2godmFsdWUpIHtcbiAgICByZXR1cm4gKHZhbHVlICE9IG51bGwpICYmIChCaWdOdW1iZXIuaXNCaWdOdW1iZXIodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJudW1iZXJcIiAmJiAodmFsdWUgJSAxKSA9PT0gMCkgfHxcbiAgICAgICAgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiICYmICEhdmFsdWUubWF0Y2goL14tP1swLTldKyQvKSkgfHxcbiAgICAgICAgaXNIZXhTdHJpbmcodmFsdWUpIHx8XG4gICAgICAgICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJiaWdpbnRcIikgfHxcbiAgICAgICAgaXNCeXRlcyh2YWx1ZSkpO1xufVxuLy8gT25seSB3YXJuIGFib3V0IHBhc3NpbmcgMTAgaW50byByYWRpeCBvbmNlXG5sZXQgX3dhcm5lZFRvU3RyaW5nUmFkaXggPSBmYWxzZTtcbmV4cG9ydCBjbGFzcyBCaWdOdW1iZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIGhleCkge1xuICAgICAgICBsb2dnZXIuY2hlY2tOZXcobmV3LnRhcmdldCwgQmlnTnVtYmVyKTtcbiAgICAgICAgaWYgKGNvbnN0cnVjdG9yR3VhcmQgIT09IF9jb25zdHJ1Y3Rvckd1YXJkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBjYWxsIGNvbnN0cnVjdG9yIGRpcmVjdGx5OyB1c2UgQmlnTnVtYmVyLmZyb21cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwibmV3IChCaWdOdW1iZXIpXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2hleCA9IGhleDtcbiAgICAgICAgdGhpcy5faXNCaWdOdW1iZXIgPSB0cnVlO1xuICAgICAgICBPYmplY3QuZnJlZXplKHRoaXMpO1xuICAgIH1cbiAgICBmcm9tVHdvcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5mcm9tVHdvcyh2YWx1ZSkpO1xuICAgIH1cbiAgICB0b1R3b3ModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudG9Ud29zKHZhbHVlKSk7XG4gICAgfVxuICAgIGFicygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2hleFswXSA9PT0gXCItXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh0aGlzLl9oZXguc3Vic3RyaW5nKDEpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgYWRkKG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFkZCh0b0JOKG90aGVyKSkpO1xuICAgIH1cbiAgICBzdWIob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuc3ViKHRvQk4ob3RoZXIpKSk7XG4gICAgfVxuICAgIGRpdihvdGhlcikge1xuICAgICAgICBjb25zdCBvID0gQmlnTnVtYmVyLmZyb20ob3RoZXIpO1xuICAgICAgICBpZiAoby5pc1plcm8oKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcImRpdmlzaW9uIGJ5IHplcm9cIiwgXCJkaXZcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykuZGl2KHRvQk4ob3RoZXIpKSk7XG4gICAgfVxuICAgIG11bChvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CaWdOdW1iZXIodG9CTih0aGlzKS5tdWwodG9CTihvdGhlcikpKTtcbiAgICB9XG4gICAgbW9kKG90aGVyKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gdG9CTihvdGhlcik7XG4gICAgICAgIGlmICh2YWx1ZS5pc05lZygpKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwiY2Fubm90IG1vZHVsbyBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJtb2RcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykudW1vZCh2YWx1ZSkpO1xuICAgIH1cbiAgICBwb3cob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3QgcmFpc2UgdG8gbmVnYXRpdmUgdmFsdWVzXCIsIFwicG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnBvdyh2YWx1ZSkpO1xuICAgIH1cbiAgICBhbmQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgdmFsdWUgPSB0b0JOKG90aGVyKTtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlLmlzTmVnKCkpIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3QgJ2FuZCcgbmVnYXRpdmUgdmFsdWVzXCIsIFwiYW5kXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLmFuZCh2YWx1ZSkpO1xuICAgIH1cbiAgICBvcihvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCAnb3InIG5lZ2F0aXZlIHZhbHVlc1wiLCBcIm9yXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLm9yKHZhbHVlKSk7XG4gICAgfVxuICAgIHhvcihvdGhlcikge1xuICAgICAgICBjb25zdCB2YWx1ZSA9IHRvQk4ob3RoZXIpO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgfHwgdmFsdWUuaXNOZWcoKSkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCAneG9yJyBuZWdhdGl2ZSB2YWx1ZXNcIiwgXCJ4b3JcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykueG9yKHZhbHVlKSk7XG4gICAgfVxuICAgIG1hc2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNOZWdhdGl2ZSgpIHx8IHZhbHVlIDwgMCkge1xuICAgICAgICAgICAgdGhyb3dGYXVsdChcImNhbm5vdCBtYXNrIG5lZ2F0aXZlIHZhbHVlc1wiLCBcIm1hc2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQmlnTnVtYmVyKHRvQk4odGhpcykubWFza24odmFsdWUpKTtcbiAgICB9XG4gICAgc2hsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3Qgc2hpZnQgbmVnYXRpdmUgdmFsdWVzXCIsIFwic2hsXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnNobG4odmFsdWUpKTtcbiAgICB9XG4gICAgc2hyKHZhbHVlKSB7XG4gICAgICAgIGlmICh0aGlzLmlzTmVnYXRpdmUoKSB8fCB2YWx1ZSA8IDApIHtcbiAgICAgICAgICAgIHRocm93RmF1bHQoXCJjYW5ub3Qgc2hpZnQgbmVnYXRpdmUgdmFsdWVzXCIsIFwic2hyXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0b0JpZ051bWJlcih0b0JOKHRoaXMpLnNocm4odmFsdWUpKTtcbiAgICB9XG4gICAgZXEob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykuZXEodG9CTihvdGhlcikpO1xuICAgIH1cbiAgICBsdChvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5sdCh0b0JOKG90aGVyKSk7XG4gICAgfVxuICAgIGx0ZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5sdGUodG9CTihvdGhlcikpO1xuICAgIH1cbiAgICBndChvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5ndCh0b0JOKG90aGVyKSk7XG4gICAgfVxuICAgIGd0ZShvdGhlcikge1xuICAgICAgICByZXR1cm4gdG9CTih0aGlzKS5ndGUodG9CTihvdGhlcikpO1xuICAgIH1cbiAgICBpc05lZ2F0aXZlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX2hleFswXSA9PT0gXCItXCIpO1xuICAgIH1cbiAgICBpc1plcm8oKSB7XG4gICAgICAgIHJldHVybiB0b0JOKHRoaXMpLmlzWmVybygpO1xuICAgIH1cbiAgICB0b051bWJlcigpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0b0JOKHRoaXMpLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwib3ZlcmZsb3dcIiwgXCJ0b051bWJlclwiLCB0aGlzLnRvU3RyaW5nKCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB0b0JpZ0ludCgpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBCaWdJbnQodGhpcy50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkgeyB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcInRoaXMgcGxhdGZvcm0gZG9lcyBub3Qgc3VwcG9ydCBCaWdJbnRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgIHZhbHVlOiB0aGlzLnRvU3RyaW5nKClcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICAvLyBMb3RzIG9mIHBlb3BsZSBleHBlY3QgdGhpcywgd2hpY2ggd2UgZG8gbm90IHN1cHBvcnQsIHNvIGNoZWNrIChTZWU6ICM4ODkpXG4gICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50c1swXSA9PT0gMTApIHtcbiAgICAgICAgICAgICAgICBpZiAoIV93YXJuZWRUb1N0cmluZ1JhZGl4KSB7XG4gICAgICAgICAgICAgICAgICAgIF93YXJuZWRUb1N0cmluZ1JhZGl4ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oXCJCaWdOdW1iZXIudG9TdHJpbmcgZG9lcyBub3QgYWNjZXB0IGFueSBwYXJhbWV0ZXJzOyBiYXNlLTEwIGlzIGFzc3VtZWRcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoYXJndW1lbnRzWzBdID09PSAxNikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiQmlnTnVtYmVyLnRvU3RyaW5nIGRvZXMgbm90IGFjY2VwdCBhbnkgcGFyYW1ldGVyczsgdXNlIGJpZ051bWJlci50b0hleFN0cmluZygpXCIsIExvZ2dlci5lcnJvcnMuVU5FWFBFQ1RFRF9BUkdVTUVOVCwge30pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJCaWdOdW1iZXIudG9TdHJpbmcgZG9lcyBub3QgYWNjZXB0IHBhcmFtZXRlcnNcIiwgTG9nZ2VyLmVycm9ycy5VTkVYUEVDVEVEX0FSR1VNRU5ULCB7fSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvQk4odGhpcykudG9TdHJpbmcoMTApO1xuICAgIH1cbiAgICB0b0hleFN0cmluZygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hleDtcbiAgICB9XG4gICAgdG9KU09OKGtleSkge1xuICAgICAgICByZXR1cm4geyB0eXBlOiBcIkJpZ051bWJlclwiLCBoZXg6IHRoaXMudG9IZXhTdHJpbmcoKSB9O1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh2YWx1ZSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBCaWdOdW1iZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5tYXRjaCgvXi0/MHhbMC05YS1mXSskL2kpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBCaWdOdW1iZXIoX2NvbnN0cnVjdG9yR3VhcmQsIHRvSGV4KHZhbHVlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodmFsdWUubWF0Y2goL14tP1swLTldKyQvKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQmlnTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0b0hleChuZXcgQk4odmFsdWUpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmlnTnVtYmVyIHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAlIDEpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0ZhdWx0KFwidW5kZXJmbG93XCIsIFwiQmlnTnVtYmVyLmZyb21cIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZhbHVlID49IE1BWF9TQUZFIHx8IHZhbHVlIDw9IC1NQVhfU0FGRSkge1xuICAgICAgICAgICAgICAgIHRocm93RmF1bHQoXCJvdmVyZmxvd1wiLCBcIkJpZ051bWJlci5mcm9tXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShTdHJpbmcodmFsdWUpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhbnlWYWx1ZSA9IHZhbHVlO1xuICAgICAgICBpZiAodHlwZW9mIChhbnlWYWx1ZSkgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShhbnlWYWx1ZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNCeXRlcyhhbnlWYWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbShoZXhsaWZ5KGFueVZhbHVlKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFueVZhbHVlKSB7XG4gICAgICAgICAgICAvLyBIZXhhYmxlIGludGVyZmFjZSAodGFrZXMgcHJpb3JpdHkpXG4gICAgICAgICAgICBpZiAoYW55VmFsdWUudG9IZXhTdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXggPSBhbnlWYWx1ZS50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGhleCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKGhleCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLy8gRm9yIG5vdywgaGFuZGxlIGxlZ2FjeSBKU09OLWlmaWVkIHZhbHVlcyAoZ29lcyBhd2F5IGluIHY2KVxuICAgICAgICAgICAgICAgIGxldCBoZXggPSBhbnlWYWx1ZS5faGV4O1xuICAgICAgICAgICAgICAgIC8vIE5ldy1mb3JtIEpTT05cbiAgICAgICAgICAgICAgICBpZiAoaGV4ID09IG51bGwgJiYgYW55VmFsdWUudHlwZSA9PT0gXCJCaWdOdW1iZXJcIikge1xuICAgICAgICAgICAgICAgICAgICBoZXggPSBhbnlWYWx1ZS5oZXg7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKGhleCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGhleCkgfHwgKGhleFswXSA9PT0gXCItXCIgJiYgaXNIZXhTdHJpbmcoaGV4LnN1YnN0cmluZygxKSkpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20oaGV4KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgQmlnTnVtYmVyIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNCaWdOdW1iZXIodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9pc0JpZ051bWJlcik7XG4gICAgfVxufVxuLy8gTm9ybWFsaXplIHRoZSBoZXggc3RyaW5nXG5mdW5jdGlvbiB0b0hleCh2YWx1ZSkge1xuICAgIC8vIEZvciBCTiwgY2FsbCBvbiB0aGUgaGV4IHN0cmluZ1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdG9IZXgodmFsdWUudG9TdHJpbmcoMTYpKTtcbiAgICB9XG4gICAgLy8gSWYgbmVnYXRpdmUsIHByZXBlbmQgdGhlIG5lZ2F0aXZlIHNpZ24gdG8gdGhlIG5vcm1hbGl6ZWQgcG9zaXRpdmUgdmFsdWVcbiAgICBpZiAodmFsdWVbMF0gPT09IFwiLVwiKSB7XG4gICAgICAgIC8vIFN0cmlwIG9mZiB0aGUgbmVnYXRpdmUgc2lnblxuICAgICAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygxKTtcbiAgICAgICAgLy8gQ2Fubm90IGhhdmUgbXVsdGlwbGUgbmVnYXRpdmUgc2lnbnMgKGUuZy4gXCItLTB4MDRcIilcbiAgICAgICAgaWYgKHZhbHVlWzBdID09PSBcIi1cIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbGwgdG9IZXggb24gdGhlIHBvc2l0aXZlIGNvbXBvbmVudFxuICAgICAgICB2YWx1ZSA9IHRvSGV4KHZhbHVlKTtcbiAgICAgICAgLy8gRG8gbm90IGFsbG93IFwiLTB4MDBcIlxuICAgICAgICBpZiAodmFsdWUgPT09IFwiMHgwMFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTmVnYXRlIHRoZSB2YWx1ZVxuICAgICAgICByZXR1cm4gXCItXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgLy8gQWRkIGEgXCIweFwiIHByZWZpeCBpZiBtaXNzaW5nXG4gICAgaWYgKHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgIHZhbHVlID0gXCIweFwiICsgdmFsdWU7XG4gICAgfVxuICAgIC8vIE5vcm1hbGl6ZSB6ZXJvXG4gICAgaWYgKHZhbHVlID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiMHgwMFwiO1xuICAgIH1cbiAgICAvLyBNYWtlIHRoZSBzdHJpbmcgZXZlbiBsZW5ndGhcbiAgICBpZiAodmFsdWUubGVuZ3RoICUgMikge1xuICAgICAgICB2YWx1ZSA9IFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgfVxuICAgIC8vIFRyaW0gdG8gc21hbGxlc3QgZXZlbi1sZW5ndGggc3RyaW5nXG4gICAgd2hpbGUgKHZhbHVlLmxlbmd0aCA+IDQgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDQpID09PSBcIjB4MDBcIikge1xuICAgICAgICB2YWx1ZSA9IFwiMHhcIiArIHZhbHVlLnN1YnN0cmluZyg0KTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZnVuY3Rpb24gdG9CaWdOdW1iZXIodmFsdWUpIHtcbiAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20odG9IZXgodmFsdWUpKTtcbn1cbmZ1bmN0aW9uIHRvQk4odmFsdWUpIHtcbiAgICBjb25zdCBoZXggPSBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKTtcbiAgICBpZiAoaGV4WzBdID09PSBcIi1cIikge1xuICAgICAgICByZXR1cm4gKG5ldyBCTihcIi1cIiArIGhleC5zdWJzdHJpbmcoMyksIDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBuZXcgQk4oaGV4LnN1YnN0cmluZygyKSwgMTYpO1xufVxuZnVuY3Rpb24gdGhyb3dGYXVsdChmYXVsdCwgb3BlcmF0aW9uLCB2YWx1ZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgZmF1bHQ6IGZhdWx0LCBvcGVyYXRpb246IG9wZXJhdGlvbiB9O1xuICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgIHBhcmFtcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoZmF1bHQsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwgcGFyYW1zKTtcbn1cbi8vIHZhbHVlIHNob3VsZCBoYXZlIG5vIHByZWZpeFxuZXhwb3J0IGZ1bmN0aW9uIF9iYXNlMzZUbzE2KHZhbHVlKSB7XG4gICAgcmV0dXJuIChuZXcgQk4odmFsdWUsIDM2KSkudG9TdHJpbmcoMTYpO1xufVxuLy8gdmFsdWUgc2hvdWxkIGhhdmUgbm8gcHJlZml4XG5leHBvcnQgZnVuY3Rpb24gX2Jhc2UxNlRvMzYodmFsdWUpIHtcbiAgICByZXR1cm4gKG5ldyBCTih2YWx1ZSwgMTYpKS50b1N0cmluZygzNik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1iaWdudW1iZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4WmVyb1BhZCwgaXNCeXRlcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgQmlnTnVtYmVyLCBpc0JpZ051bWJlcmlzaCB9IGZyb20gXCIuL2JpZ251bWJlclwiO1xuY29uc3QgX2NvbnN0cnVjdG9yR3VhcmQgPSB7fTtcbmNvbnN0IFplcm8gPSBCaWdOdW1iZXIuZnJvbSgwKTtcbmNvbnN0IE5lZ2F0aXZlT25lID0gQmlnTnVtYmVyLmZyb20oLTEpO1xuZnVuY3Rpb24gdGhyb3dGYXVsdChtZXNzYWdlLCBmYXVsdCwgb3BlcmF0aW9uLCB2YWx1ZSkge1xuICAgIGNvbnN0IHBhcmFtcyA9IHsgZmF1bHQ6IGZhdWx0LCBvcGVyYXRpb246IG9wZXJhdGlvbiB9O1xuICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHBhcmFtcy52YWx1ZSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCBwYXJhbXMpO1xufVxuLy8gQ29uc3RhbnQgdG8gcHVsbCB6ZXJvcyBmcm9tIGZvciBtdWx0aXBsaWVyc1xubGV0IHplcm9zID0gXCIwXCI7XG53aGlsZSAoemVyb3MubGVuZ3RoIDwgMjU2KSB7XG4gICAgemVyb3MgKz0gemVyb3M7XG59XG4vLyBSZXR1cm5zIGEgc3RyaW5nIFwiMVwiIGZvbGxvd2VkIGJ5IGRlY2ltYWwgXCIwXCJzXG5mdW5jdGlvbiBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKSB7XG4gICAgaWYgKHR5cGVvZiAoZGVjaW1hbHMpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBkZWNpbWFscyA9IEJpZ051bWJlci5mcm9tKGRlY2ltYWxzKS50b051bWJlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiAoZGVjaW1hbHMpID09PSBcIm51bWJlclwiICYmIGRlY2ltYWxzID49IDAgJiYgZGVjaW1hbHMgPD0gMjU2ICYmICEoZGVjaW1hbHMgJSAxKSkge1xuICAgICAgICByZXR1cm4gKFwiMVwiICsgemVyb3Muc3Vic3RyaW5nKDAsIGRlY2ltYWxzKSk7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIHNpemVcIiwgXCJkZWNpbWFsc1wiLCBkZWNpbWFscyk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Rml4ZWQodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgIH1cbiAgICBjb25zdCBtdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG4gICAgLy8gTWFrZSBzdXJlIHdlaSBpcyBhIGJpZyBudW1iZXIgKGNvbnZlcnQgYXMgbmVjZXNzYXJ5KVxuICAgIHZhbHVlID0gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgIGNvbnN0IG5lZ2F0aXZlID0gdmFsdWUubHQoWmVybyk7XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUubXVsKE5lZ2F0aXZlT25lKTtcbiAgICB9XG4gICAgbGV0IGZyYWN0aW9uID0gdmFsdWUubW9kKG11bHRpcGxpZXIpLnRvU3RyaW5nKCk7XG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IG11bHRpcGxpZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICBmcmFjdGlvbiA9IFwiMFwiICsgZnJhY3Rpb247XG4gICAgfVxuICAgIC8vIFN0cmlwIHRyYWluaW5nIDBcbiAgICBmcmFjdGlvbiA9IGZyYWN0aW9uLm1hdGNoKC9eKFswLTldKlsxLTldfDApKDAqKS8pWzFdO1xuICAgIGNvbnN0IHdob2xlID0gdmFsdWUuZGl2KG11bHRpcGxpZXIpLnRvU3RyaW5nKCk7XG4gICAgaWYgKG11bHRpcGxpZXIubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIHZhbHVlID0gd2hvbGU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YWx1ZSA9IHdob2xlICsgXCIuXCIgKyBmcmFjdGlvbjtcbiAgICB9XG4gICAgaWYgKG5lZ2F0aXZlKSB7XG4gICAgICAgIHZhbHVlID0gXCItXCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRml4ZWQodmFsdWUsIGRlY2ltYWxzKSB7XG4gICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgIH1cbiAgICBjb25zdCBtdWx0aXBsaWVyID0gZ2V0TXVsdGlwbGllcihkZWNpbWFscyk7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiIHx8ICF2YWx1ZS5tYXRjaCgvXi0/WzAtOS5dKyQvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBJcyBpdCBuZWdhdGl2ZT9cbiAgICBjb25zdCBuZWdhdGl2ZSA9ICh2YWx1ZS5zdWJzdHJpbmcoMCwgMSkgPT09IFwiLVwiKTtcbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA9PT0gXCIuXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFNwbGl0IGl0IGludG8gYSB3aG9sZSBhbmQgZnJhY3Rpb25hbCBwYXJ0XG4gICAgY29uc3QgY29tcHMgPSB2YWx1ZS5zcGxpdChcIi5cIik7XG4gICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInRvbyBtYW55IGRlY2ltYWwgcG9pbnRzXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBsZXQgd2hvbGUgPSBjb21wc1swXSwgZnJhY3Rpb24gPSBjb21wc1sxXTtcbiAgICBpZiAoIXdob2xlKSB7XG4gICAgICAgIHdob2xlID0gXCIwXCI7XG4gICAgfVxuICAgIGlmICghZnJhY3Rpb24pIHtcbiAgICAgICAgZnJhY3Rpb24gPSBcIjBcIjtcbiAgICB9XG4gICAgLy8gVHJpbSB0cmFpbGluZyB6ZXJvc1xuICAgIHdoaWxlIChmcmFjdGlvbltmcmFjdGlvbi5sZW5ndGggLSAxXSA9PT0gXCIwXCIpIHtcbiAgICAgICAgZnJhY3Rpb24gPSBmcmFjdGlvbi5zdWJzdHJpbmcoMCwgZnJhY3Rpb24ubGVuZ3RoIC0gMSk7XG4gICAgfVxuICAgIC8vIENoZWNrIHRoZSBmcmFjdGlvbiBkb2Vzbid0IGV4Y2VlZCBvdXIgZGVjaW1hbHMgc2l6ZVxuICAgIGlmIChmcmFjdGlvbi5sZW5ndGggPiBtdWx0aXBsaWVyLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgdGhyb3dGYXVsdChcImZyYWN0aW9uYWwgY29tcG9uZW50IGV4Y2VlZHMgZGVjaW1hbHNcIiwgXCJ1bmRlcmZsb3dcIiwgXCJwYXJzZUZpeGVkXCIpO1xuICAgIH1cbiAgICAvLyBJZiBkZWNpbWFscyBpcyAwLCB3ZSBoYXZlIGFuIGVtcHR5IHN0cmluZyBmb3IgZnJhY3Rpb25cbiAgICBpZiAoZnJhY3Rpb24gPT09IFwiXCIpIHtcbiAgICAgICAgZnJhY3Rpb24gPSBcIjBcIjtcbiAgICB9XG4gICAgLy8gRnVsbHkgcGFkIHRoZSBzdHJpbmcgd2l0aCB6ZXJvcyB0byBnZXQgdG8gd2VpXG4gICAgd2hpbGUgKGZyYWN0aW9uLmxlbmd0aCA8IG11bHRpcGxpZXIubGVuZ3RoIC0gMSkge1xuICAgICAgICBmcmFjdGlvbiArPSBcIjBcIjtcbiAgICB9XG4gICAgY29uc3Qgd2hvbGVWYWx1ZSA9IEJpZ051bWJlci5mcm9tKHdob2xlKTtcbiAgICBjb25zdCBmcmFjdGlvblZhbHVlID0gQmlnTnVtYmVyLmZyb20oZnJhY3Rpb24pO1xuICAgIGxldCB3ZWkgPSAod2hvbGVWYWx1ZS5tdWwobXVsdGlwbGllcikpLmFkZChmcmFjdGlvblZhbHVlKTtcbiAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgd2VpID0gd2VpLm11bChOZWdhdGl2ZU9uZSk7XG4gICAgfVxuICAgIHJldHVybiB3ZWk7XG59XG5leHBvcnQgY2xhc3MgRml4ZWRGb3JtYXQge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIHNpZ25lZCwgd2lkdGgsIGRlY2ltYWxzKSB7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgdXNlIEZpeGVkRm9ybWF0IGNvbnN0cnVjdG9yOyB1c2UgRml4ZWRGb3JtYXQuZnJvbVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRml4ZWRGb3JtYXRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zaWduZWQgPSBzaWduZWQ7XG4gICAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICAgICAgdGhpcy5kZWNpbWFscyA9IGRlY2ltYWxzO1xuICAgICAgICB0aGlzLm5hbWUgPSAoc2lnbmVkID8gXCJcIiA6IFwidVwiKSArIFwiZml4ZWRcIiArIFN0cmluZyh3aWR0aCkgKyBcInhcIiArIFN0cmluZyhkZWNpbWFscyk7XG4gICAgICAgIHRoaXMuX211bHRpcGxpZXIgPSBnZXRNdWx0aXBsaWVyKGRlY2ltYWxzKTtcbiAgICAgICAgT2JqZWN0LmZyZWV6ZSh0aGlzKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgRml4ZWRGb3JtYXQpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gYGZpeGVkMTI4eCR7dmFsdWV9YDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgc2lnbmVkID0gdHJ1ZTtcbiAgICAgICAgbGV0IHdpZHRoID0gMTI4O1xuICAgICAgICBsZXQgZGVjaW1hbHMgPSAxODtcbiAgICAgICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT09IFwiZml4ZWRcIikge1xuICAgICAgICAgICAgICAgIC8vIGRlZmF1bHRzLi4uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh2YWx1ZSA9PT0gXCJ1Zml4ZWRcIikge1xuICAgICAgICAgICAgICAgIHNpZ25lZCA9IGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbWF0Y2ggPSB2YWx1ZS5tYXRjaCgvXih1PylmaXhlZChbMC05XSspeChbMC05XSspJC8pO1xuICAgICAgICAgICAgICAgIGlmICghbWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0XCIsIFwiZm9ybWF0XCIsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2lnbmVkID0gKG1hdGNoWzFdICE9PSBcInVcIik7XG4gICAgICAgICAgICAgICAgd2lkdGggPSBwYXJzZUludChtYXRjaFsyXSk7XG4gICAgICAgICAgICAgICAgZGVjaW1hbHMgPSBwYXJzZUludChtYXRjaFszXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGNvbnN0IGNoZWNrID0gKGtleSwgdHlwZSwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZGVmYXVsdFZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZVtrZXldKSAhPT0gdHlwZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBmaXhlZCBmb3JtYXQgKFwiICsga2V5ICsgXCIgbm90IFwiICsgdHlwZSArIFwiKVwiLCBcImZvcm1hdC5cIiArIGtleSwgdmFsdWVba2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNpZ25lZCA9IGNoZWNrKFwic2lnbmVkXCIsIFwiYm9vbGVhblwiLCBzaWduZWQpO1xuICAgICAgICAgICAgd2lkdGggPSBjaGVjayhcIndpZHRoXCIsIFwibnVtYmVyXCIsIHdpZHRoKTtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gY2hlY2soXCJkZWNpbWFsc1wiLCBcIm51bWJlclwiLCBkZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHdpZHRoICUgOCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZml4ZWQgZm9ybWF0IHdpZHRoIChub3QgYnl0ZSBhbGlnbmVkKVwiLCBcImZvcm1hdC53aWR0aFwiLCB3aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2ltYWxzID4gODApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGZpeGVkIGZvcm1hdCAoZGVjaW1hbHMgdG9vIGxhcmdlKVwiLCBcImZvcm1hdC5kZWNpbWFsc1wiLCBkZWNpbWFscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZEZvcm1hdChfY29uc3RydWN0b3JHdWFyZCwgc2lnbmVkLCB3aWR0aCwgZGVjaW1hbHMpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBGaXhlZE51bWJlciB7XG4gICAgY29uc3RydWN0b3IoY29uc3RydWN0b3JHdWFyZCwgaGV4LCB2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGxvZ2dlci5jaGVja05ldyhuZXcudGFyZ2V0LCBGaXhlZE51bWJlcik7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgdXNlIEZpeGVkTnVtYmVyIGNvbnN0cnVjdG9yOyB1c2UgRml4ZWROdW1iZXIuZnJvbVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgRml4ZWRGb3JtYXRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mb3JtYXQgPSBmb3JtYXQ7XG4gICAgICAgIHRoaXMuX2hleCA9IGhleDtcbiAgICAgICAgdGhpcy5fdmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgdGhpcy5faXNGaXhlZE51bWJlciA9IHRydWU7XG4gICAgICAgIE9iamVjdC5mcmVlemUodGhpcyk7XG4gICAgfVxuICAgIF9jaGVja0Zvcm1hdChvdGhlcikge1xuICAgICAgICBpZiAodGhpcy5mb3JtYXQubmFtZSAhPT0gb3RoZXIuZm9ybWF0Lm5hbWUpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbmNvbXBhdGlibGUgZm9ybWF0OyB1c2UgZml4ZWROdW1iZXIudG9Gb3JtYXRcIiwgXCJvdGhlclwiLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYWRkVW5zYWZlKG90aGVyKSB7XG4gICAgICAgIHRoaXMuX2NoZWNrRm9ybWF0KG90aGVyKTtcbiAgICAgICAgY29uc3QgYSA9IHBhcnNlRml4ZWQodGhpcy5fdmFsdWUsIHRoaXMuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgY29uc3QgYiA9IHBhcnNlRml4ZWQob3RoZXIuX3ZhbHVlLCBvdGhlci5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVZhbHVlKGEuYWRkKGIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuICAgIH1cbiAgICBzdWJVbnNhZmUob3RoZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5zdWIoYiksIHRoaXMuZm9ybWF0LmRlY2ltYWxzLCB0aGlzLmZvcm1hdCk7XG4gICAgfVxuICAgIG11bFVuc2FmZShvdGhlcikge1xuICAgICAgICB0aGlzLl9jaGVja0Zvcm1hdChvdGhlcik7XG4gICAgICAgIGNvbnN0IGEgPSBwYXJzZUZpeGVkKHRoaXMuX3ZhbHVlLCB0aGlzLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIGNvbnN0IGIgPSBwYXJzZUZpeGVkKG90aGVyLl92YWx1ZSwgb3RoZXIuZm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZShhLm11bChiKS5kaXYodGhpcy5mb3JtYXQuX211bHRpcGxpZXIpLCB0aGlzLmZvcm1hdC5kZWNpbWFscywgdGhpcy5mb3JtYXQpO1xuICAgIH1cbiAgICBkaXZVbnNhZmUob3RoZXIpIHtcbiAgICAgICAgdGhpcy5fY2hlY2tGb3JtYXQob3RoZXIpO1xuICAgICAgICBjb25zdCBhID0gcGFyc2VGaXhlZCh0aGlzLl92YWx1ZSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBjb25zdCBiID0gcGFyc2VGaXhlZChvdGhlci5fdmFsdWUsIG90aGVyLmZvcm1hdC5kZWNpbWFscyk7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tVmFsdWUoYS5tdWwodGhpcy5mb3JtYXQuX211bHRpcGxpZXIpLmRpdihiKSwgdGhpcy5mb3JtYXQuZGVjaW1hbHMsIHRoaXMuZm9ybWF0KTtcbiAgICB9XG4gICAgZmxvb3IoKSB7XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlc3VsdCA9IEZpeGVkTnVtYmVyLmZyb20oY29tcHNbMF0sIHRoaXMuZm9ybWF0KTtcbiAgICAgICAgY29uc3QgaGFzRnJhY3Rpb24gPSAhY29tcHNbMV0ubWF0Y2goL14oMCopJC8pO1xuICAgICAgICBpZiAodGhpcy5pc05lZ2F0aXZlKCkgJiYgaGFzRnJhY3Rpb24pIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5zdWJVbnNhZmUoT05FLnRvRm9ybWF0KHJlc3VsdC5mb3JtYXQpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBjZWlsaW5nKCkge1xuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudG9TdHJpbmcoKS5zcGxpdChcIi5cIik7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbXBzLnB1c2goXCIwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSBGaXhlZE51bWJlci5mcm9tKGNvbXBzWzBdLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGhhc0ZyYWN0aW9uID0gIWNvbXBzWzFdLm1hdGNoKC9eKDAqKSQvKTtcbiAgICAgICAgaWYgKCF0aGlzLmlzTmVnYXRpdmUoKSAmJiBoYXNGcmFjdGlvbikge1xuICAgICAgICAgICAgcmVzdWx0ID0gcmVzdWx0LmFkZFVuc2FmZShPTkUudG9Gb3JtYXQocmVzdWx0LmZvcm1hdCkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBTdXBwb3J0IG90aGVyIHJvdW5kaW5nIGFsZ29yaXRobXNcbiAgICByb3VuZChkZWNpbWFscykge1xuICAgICAgICBpZiAoZGVjaW1hbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVjaW1hbHMgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGFyZSBhbHJlYWR5IGluIHJhbmdlLCB3ZSdyZSBkb25lXG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50b1N0cmluZygpLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgY29tcHMucHVzaChcIjBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2ltYWxzIDwgMCB8fCBkZWNpbWFscyA+IDgwIHx8IChkZWNpbWFscyAlIDEpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBkZWNpbWFsIGNvdW50XCIsIFwiZGVjaW1hbHNcIiwgZGVjaW1hbHMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wc1sxXS5sZW5ndGggPD0gZGVjaW1hbHMpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZhY3RvciA9IEZpeGVkTnVtYmVyLmZyb20oXCIxXCIgKyB6ZXJvcy5zdWJzdHJpbmcoMCwgZGVjaW1hbHMpLCB0aGlzLmZvcm1hdCk7XG4gICAgICAgIGNvbnN0IGJ1bXAgPSBCVU1QLnRvRm9ybWF0KHRoaXMuZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIHRoaXMubXVsVW5zYWZlKGZhY3RvcikuYWRkVW5zYWZlKGJ1bXApLmZsb29yKCkuZGl2VW5zYWZlKGZhY3Rvcik7XG4gICAgfVxuICAgIGlzWmVybygpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl92YWx1ZSA9PT0gXCIwLjBcIiB8fCB0aGlzLl92YWx1ZSA9PT0gXCIwXCIpO1xuICAgIH1cbiAgICBpc05lZ2F0aXZlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3ZhbHVlWzBdID09PSBcIi1cIik7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkgeyByZXR1cm4gdGhpcy5fdmFsdWU7IH1cbiAgICB0b0hleFN0cmluZyh3aWR0aCkge1xuICAgICAgICBpZiAod2lkdGggPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hleDtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2lkdGggJSA4KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBieXRlIHdpZHRoXCIsIFwid2lkdGhcIiwgd2lkdGgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGhleCA9IEJpZ051bWJlci5mcm9tKHRoaXMuX2hleCkuZnJvbVR3b3ModGhpcy5mb3JtYXQud2lkdGgpLnRvVHdvcyh3aWR0aCkudG9IZXhTdHJpbmcoKTtcbiAgICAgICAgcmV0dXJuIGhleFplcm9QYWQoaGV4LCB3aWR0aCAvIDgpO1xuICAgIH1cbiAgICB0b1Vuc2FmZUZsb2F0KCkgeyByZXR1cm4gcGFyc2VGbG9hdCh0aGlzLnRvU3RyaW5nKCkpOyB9XG4gICAgdG9Gb3JtYXQoZm9ybWF0KSB7XG4gICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHRoaXMuX3ZhbHVlLCBmb3JtYXQpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVZhbHVlKHZhbHVlLCBkZWNpbWFscywgZm9ybWF0KSB7XG4gICAgICAgIC8vIElmIGRlY2ltYWxzIGxvb2tzIG1vcmUgbGlrZSBhIGZvcm1hdCwgYW5kIHRoZXJlIGlzIG5vIGZvcm1hdCwgc2hpZnQgdGhlIHBhcmFtZXRlcnNcbiAgICAgICAgaWYgKGZvcm1hdCA9PSBudWxsICYmIGRlY2ltYWxzICE9IG51bGwgJiYgIWlzQmlnTnVtYmVyaXNoKGRlY2ltYWxzKSkge1xuICAgICAgICAgICAgZm9ybWF0ID0gZGVjaW1hbHM7XG4gICAgICAgICAgICBkZWNpbWFscyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGRlY2ltYWxzID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlY2ltYWxzID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRml4ZWROdW1iZXIuZnJvbVN0cmluZyhmb3JtYXRGaXhlZCh2YWx1ZSwgZGVjaW1hbHMpLCBGaXhlZEZvcm1hdC5mcm9tKGZvcm1hdCkpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVN0cmluZyh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9ybWF0ID0gXCJmaXhlZFwiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpeGVkRm9ybWF0ID0gRml4ZWRGb3JtYXQuZnJvbShmb3JtYXQpO1xuICAgICAgICBjb25zdCBudW1lcmljID0gcGFyc2VGaXhlZCh2YWx1ZSwgZml4ZWRGb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICBpZiAoIWZpeGVkRm9ybWF0LnNpZ25lZCAmJiBudW1lcmljLmx0KFplcm8pKSB7XG4gICAgICAgICAgICB0aHJvd0ZhdWx0KFwidW5zaWduZWQgdmFsdWUgY2Fubm90IGJlIG5lZ2F0aXZlXCIsIFwib3ZlcmZsb3dcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGhleCA9IG51bGw7XG4gICAgICAgIGlmIChmaXhlZEZvcm1hdC5zaWduZWQpIHtcbiAgICAgICAgICAgIGhleCA9IG51bWVyaWMudG9Ud29zKGZpeGVkRm9ybWF0LndpZHRoKS50b0hleFN0cmluZygpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGV4ID0gbnVtZXJpYy50b0hleFN0cmluZygpO1xuICAgICAgICAgICAgaGV4ID0gaGV4WmVyb1BhZChoZXgsIGZpeGVkRm9ybWF0LndpZHRoIC8gOCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVjaW1hbCA9IGZvcm1hdEZpeGVkKG51bWVyaWMsIGZpeGVkRm9ybWF0LmRlY2ltYWxzKTtcbiAgICAgICAgcmV0dXJuIG5ldyBGaXhlZE51bWJlcihfY29uc3RydWN0b3JHdWFyZCwgaGV4LCBkZWNpbWFsLCBmaXhlZEZvcm1hdCk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tQnl0ZXModmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAoZm9ybWF0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGZvcm1hdCA9IFwiZml4ZWRcIjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmaXhlZEZvcm1hdCA9IEZpeGVkRm9ybWF0LmZyb20oZm9ybWF0KTtcbiAgICAgICAgaWYgKGFycmF5aWZ5KHZhbHVlKS5sZW5ndGggPiBmaXhlZEZvcm1hdC53aWR0aCAvIDgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm92ZXJmbG93XCIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBudW1lcmljID0gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgICAgICBpZiAoZml4ZWRGb3JtYXQuc2lnbmVkKSB7XG4gICAgICAgICAgICBudW1lcmljID0gbnVtZXJpYy5mcm9tVHdvcyhmaXhlZEZvcm1hdC53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaGV4ID0gbnVtZXJpYy50b1R3b3MoKGZpeGVkRm9ybWF0LnNpZ25lZCA/IDAgOiAxKSArIGZpeGVkRm9ybWF0LndpZHRoKS50b0hleFN0cmluZygpO1xuICAgICAgICBjb25zdCBkZWNpbWFsID0gZm9ybWF0Rml4ZWQobnVtZXJpYywgZml4ZWRGb3JtYXQuZGVjaW1hbHMpO1xuICAgICAgICByZXR1cm4gbmV3IEZpeGVkTnVtYmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCBoZXgsIGRlY2ltYWwsIGZpeGVkRm9ybWF0KTtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmFsdWUsIGZvcm1hdCkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBGaXhlZE51bWJlci5mcm9tU3RyaW5nKHZhbHVlLCBmb3JtYXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0J5dGVzKHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21CeXRlcyh2YWx1ZSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIEZpeGVkTnVtYmVyLmZyb21WYWx1ZSh2YWx1ZSwgMCwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IE5VTUVSSUNfRkFVTFQgdG8gYnViYmxlIHVwXG4gICAgICAgICAgICBpZiAoZXJyb3IuY29kZSAhPT0gTG9nZ2VyLmVycm9ycy5JTlZBTElEX0FSR1VNRU5UKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEZpeGVkTnVtYmVyIHZhbHVlXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICBzdGF0aWMgaXNGaXhlZE51bWJlcih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzRml4ZWROdW1iZXIpO1xuICAgIH1cbn1cbmNvbnN0IE9ORSA9IEZpeGVkTnVtYmVyLmZyb20oMSk7XG5jb25zdCBCVU1QID0gRml4ZWROdW1iZXIuZnJvbShcIjAuNVwiKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZpeGVkbnVtYmVyLmpzLm1hcCIsImV4cG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCIuL2JpZ251bWJlclwiO1xuZXhwb3J0IHsgZm9ybWF0Rml4ZWQsIEZpeGVkRm9ybWF0LCBGaXhlZE51bWJlciwgcGFyc2VGaXhlZCB9IGZyb20gXCIuL2ZpeGVkbnVtYmVyXCI7XG4vLyBJbnRlcm5hbCBtZXRob2RzIHVzZWQgYnkgYWRkcmVzc1xuZXhwb3J0IHsgX2Jhc2UxNlRvMzYsIF9iYXNlMzZUbzE2IH0gZnJvbSBcIi4vYmlnbnVtYmVyXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiYnl0ZXMvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gaXNIZXhhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICEhKHZhbHVlLnRvSGV4U3RyaW5nKTtcbn1cbmZ1bmN0aW9uIGFkZFNsaWNlKGFycmF5KSB7XG4gICAgaWYgKGFycmF5LnNsaWNlKSB7XG4gICAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG4gICAgYXJyYXkuc2xpY2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IGFyZ3MgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gYWRkU2xpY2UobmV3IFVpbnQ4QXJyYXkoQXJyYXkucHJvdG90eXBlLnNsaWNlLmFwcGx5KGFycmF5LCBhcmdzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGFycmF5O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXNMaWtlKHZhbHVlKSB7XG4gICAgcmV0dXJuICgoaXNIZXhTdHJpbmcodmFsdWUpICYmICEodmFsdWUubGVuZ3RoICUgMikpIHx8IGlzQnl0ZXModmFsdWUpKTtcbn1cbmZ1bmN0aW9uIGlzSW50ZWdlcih2YWx1ZSkge1xuICAgIHJldHVybiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIgJiYgdmFsdWUgPT0gdmFsdWUgJiYgKHZhbHVlICUgMSkgPT09IDApO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQnl0ZXModmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmICh2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gVWludDhBcnJheSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0ludGVnZXIodmFsdWUubGVuZ3RoKSB8fCB2YWx1ZS5sZW5ndGggPCAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB2YWx1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCB2ID0gdmFsdWVbaV07XG4gICAgICAgIGlmICghaXNJbnRlZ2VyKHYpIHx8IHYgPCAwIHx8IHYgPj0gMjU2KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnQgZnVuY3Rpb24gYXJyYXlpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgXCJpbnZhbGlkIGFycmF5aWZ5IHZhbHVlXCIpO1xuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgICAgICByZXN1bHQudW5zaGlmdCh2YWx1ZSAmIDB4ZmYpO1xuICAgICAgICAgICAgdmFsdWUgPSBwYXJzZUludChTdHJpbmcodmFsdWUgLyAyNTYpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KHJlc3VsdCkpO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGxvd01pc3NpbmdQcmVmaXggJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzSGV4YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b0hleFN0cmluZygpO1xuICAgIH1cbiAgICBpZiAoaXNIZXhTdHJpbmcodmFsdWUpKSB7XG4gICAgICAgIGxldCBoZXggPSB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgICAgIGlmIChoZXgubGVuZ3RoICUgMikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMuaGV4UGFkID09PSBcImxlZnRcIikge1xuICAgICAgICAgICAgICAgIGhleCA9IFwiMHgwXCIgKyBoZXguc3Vic3RyaW5nKDIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAob3B0aW9ucy5oZXhQYWQgPT09IFwicmlnaHRcIikge1xuICAgICAgICAgICAgICAgIGhleCArPSBcIjBcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJoZXggZGF0YSBpcyBvZGQtbGVuZ3RoXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGhleC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2gocGFyc2VJbnQoaGV4LnN1YnN0cmluZyhpLCBpICsgMiksIDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KHJlc3VsdCkpO1xuICAgIH1cbiAgICBpZiAoaXNCeXRlcyh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGFkZFNsaWNlKG5ldyBVaW50OEFycmF5KHZhbHVlKSk7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhcnJheWlmeSB2YWx1ZVwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25jYXQoaXRlbXMpIHtcbiAgICBjb25zdCBvYmplY3RzID0gaXRlbXMubWFwKGl0ZW0gPT4gYXJyYXlpZnkoaXRlbSkpO1xuICAgIGNvbnN0IGxlbmd0aCA9IG9iamVjdHMucmVkdWNlKChhY2N1bSwgaXRlbSkgPT4gKGFjY3VtICsgaXRlbS5sZW5ndGgpLCAwKTtcbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIG9iamVjdHMucmVkdWNlKChvZmZzZXQsIG9iamVjdCkgPT4ge1xuICAgICAgICByZXN1bHQuc2V0KG9iamVjdCwgb2Zmc2V0KTtcbiAgICAgICAgcmV0dXJuIG9mZnNldCArIG9iamVjdC5sZW5ndGg7XG4gICAgfSwgMCk7XG4gICAgcmV0dXJuIGFkZFNsaWNlKHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gc3RyaXBaZXJvcyh2YWx1ZSkge1xuICAgIGxldCByZXN1bHQgPSBhcnJheWlmeSh2YWx1ZSk7XG4gICAgaWYgKHJlc3VsdC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gRmluZCB0aGUgZmlyc3Qgbm9uLXplcm8gZW50cnlcbiAgICBsZXQgc3RhcnQgPSAwO1xuICAgIHdoaWxlIChzdGFydCA8IHJlc3VsdC5sZW5ndGggJiYgcmVzdWx0W3N0YXJ0XSA9PT0gMCkge1xuICAgICAgICBzdGFydCsrO1xuICAgIH1cbiAgICAvLyBJZiB3ZSBzdGFydGVkIHdpdGggemVyb3MsIHN0cmlwIHRoZW1cbiAgICBpZiAoc3RhcnQpIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnNsaWNlKHN0YXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiB6ZXJvUGFkKHZhbHVlLCBsZW5ndGgpIHtcbiAgICB2YWx1ZSA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICBpZiAodmFsdWUubGVuZ3RoID4gbGVuZ3RoKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ2YWx1ZSBvdXQgb2YgcmFuZ2VcIiwgXCJ2YWx1ZVwiLCBhcmd1bWVudHNbMF0pO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICAgIHJlc3VsdC5zZXQodmFsdWUsIGxlbmd0aCAtIHZhbHVlLmxlbmd0aCk7XG4gICAgcmV0dXJuIGFkZFNsaWNlKHJlc3VsdCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNIZXhTdHJpbmcodmFsdWUsIGxlbmd0aCkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIiB8fCAhdmFsdWUubWF0Y2goL14weFswLTlBLUZhLWZdKiQvKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChsZW5ndGggJiYgdmFsdWUubGVuZ3RoICE9PSAyICsgMiAqIGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuY29uc3QgSGV4Q2hhcmFjdGVycyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuZXhwb3J0IGZ1bmN0aW9uIGhleGxpZnkodmFsdWUsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrU2FmZVVpbnQ1Myh2YWx1ZSwgXCJpbnZhbGlkIGhleGxpZnkgdmFsdWVcIik7XG4gICAgICAgIGxldCBoZXggPSBcIlwiO1xuICAgICAgICB3aGlsZSAodmFsdWUpIHtcbiAgICAgICAgICAgIGhleCA9IEhleENoYXJhY3RlcnNbdmFsdWUgJiAweGZdICsgaGV4O1xuICAgICAgICAgICAgdmFsdWUgPSBNYXRoLmZsb29yKHZhbHVlIC8gMTYpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZXgubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGV4Lmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgICAgICBoZXggPSBcIjBcIiArIGhleDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBcIjB4XCIgKyBoZXg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiMHgwMFwiO1xuICAgIH1cbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwiYmlnaW50XCIpIHtcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS50b1N0cmluZygxNik7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggJSAyKSB7XG4gICAgICAgICAgICByZXR1cm4gKFwiMHgwXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIHZhbHVlO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5hbGxvd01pc3NpbmdQcmVmaXggJiYgdHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUuc3Vic3RyaW5nKDAsIDIpICE9PSBcIjB4XCIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzSGV4YWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvSGV4U3RyaW5nKCk7XG4gICAgfVxuICAgIGlmIChpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmxlbmd0aCAlIDIpIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJsZWZ0XCIpIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IFwiMHgwXCIgKyB2YWx1ZS5zdWJzdHJpbmcoMik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLmhleFBhZCA9PT0gXCJyaWdodFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgKz0gXCIwXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaGV4IGRhdGEgaXMgb2RkLWxlbmd0aFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXModmFsdWUpKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGxldCB2ID0gdmFsdWVbaV07XG4gICAgICAgICAgICByZXN1bHQgKz0gSGV4Q2hhcmFjdGVyc1sodiAmIDB4ZjApID4+IDRdICsgSGV4Q2hhcmFjdGVyc1t2ICYgMHgwZl07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGhleGxpZnkgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG59XG4vKlxuZnVuY3Rpb24gdW5vZGRpZnkodmFsdWU6IEJ5dGVzTGlrZSB8IEhleGFibGUgfCBudW1iZXIpOiBCeXRlc0xpa2UgfCBIZXhhYmxlIHwgbnVtYmVyIHtcbiAgICBpZiAodHlwZW9mKHZhbHVlKSA9PT0gXCJzdHJpbmdcIiAmJiB2YWx1ZS5sZW5ndGggJSAyICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG4qL1xuZXhwb3J0IGZ1bmN0aW9uIGhleERhdGFMZW5ndGgoZGF0YSkge1xuICAgIGlmICh0eXBlb2YgKGRhdGEpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGRhdGEgPSBoZXhsaWZ5KGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNIZXhTdHJpbmcoZGF0YSkgfHwgKGRhdGEubGVuZ3RoICUgMikpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoZGF0YS5sZW5ndGggLSAyKSAvIDI7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4RGF0YVNsaWNlKGRhdGEsIG9mZnNldCwgZW5kT2Zmc2V0KSB7XG4gICAgaWYgKHR5cGVvZiAoZGF0YSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YSA9IGhleGxpZnkoZGF0YSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc0hleFN0cmluZyhkYXRhKSB8fCAoZGF0YS5sZW5ndGggJSAyKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXhEYXRhXCIsIFwidmFsdWVcIiwgZGF0YSk7XG4gICAgfVxuICAgIG9mZnNldCA9IDIgKyAyICogb2Zmc2V0O1xuICAgIGlmIChlbmRPZmZzZXQgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCIweFwiICsgZGF0YS5zdWJzdHJpbmcob2Zmc2V0LCAyICsgMiAqIGVuZE9mZnNldCk7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBkYXRhLnN1YnN0cmluZyhvZmZzZXQpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGhleENvbmNhdChpdGVtcykge1xuICAgIGxldCByZXN1bHQgPSBcIjB4XCI7XG4gICAgaXRlbXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICByZXN1bHQgKz0gaGV4bGlmeShpdGVtKS5zdWJzdHJpbmcoMik7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBoZXhWYWx1ZSh2YWx1ZSkge1xuICAgIGNvbnN0IHRyaW1tZWQgPSBoZXhTdHJpcFplcm9zKGhleGxpZnkodmFsdWUsIHsgaGV4UGFkOiBcImxlZnRcIiB9KSk7XG4gICAgaWYgKHRyaW1tZWQgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gXCIweDBcIjtcbiAgICB9XG4gICAgcmV0dXJuIHRyaW1tZWQ7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4U3RyaXBaZXJvcyh2YWx1ZSkge1xuICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB2YWx1ZSA9IGhleGxpZnkodmFsdWUpO1xuICAgIH1cbiAgICBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBoZXggc3RyaW5nXCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgIH1cbiAgICB2YWx1ZSA9IHZhbHVlLnN1YnN0cmluZygyKTtcbiAgICBsZXQgb2Zmc2V0ID0gMDtcbiAgICB3aGlsZSAob2Zmc2V0IDwgdmFsdWUubGVuZ3RoICYmIHZhbHVlW29mZnNldF0gPT09IFwiMFwiKSB7XG4gICAgICAgIG9mZnNldCsrO1xuICAgIH1cbiAgICByZXR1cm4gXCIweFwiICsgdmFsdWUuc3Vic3RyaW5nKG9mZnNldCk7XG59XG5leHBvcnQgZnVuY3Rpb24gaGV4WmVyb1BhZCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHZhbHVlID0gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGV4IHN0cmluZ1wiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlLmxlbmd0aCA+IDIgKiBsZW5ndGggKyAyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ2YWx1ZSBvdXQgb2YgcmFuZ2VcIiwgXCJ2YWx1ZVwiLCBhcmd1bWVudHNbMV0pO1xuICAgIH1cbiAgICB3aGlsZSAodmFsdWUubGVuZ3RoIDwgMiAqIGxlbmd0aCArIDIpIHtcbiAgICAgICAgdmFsdWUgPSBcIjB4MFwiICsgdmFsdWUuc3Vic3RyaW5nKDIpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnQgZnVuY3Rpb24gc3BsaXRTaWduYXR1cmUoc2lnbmF0dXJlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICByOiBcIjB4XCIsXG4gICAgICAgIHM6IFwiMHhcIixcbiAgICAgICAgX3ZzOiBcIjB4XCIsXG4gICAgICAgIHJlY292ZXJ5UGFyYW06IDAsXG4gICAgICAgIHY6IDBcbiAgICB9O1xuICAgIGlmIChpc0J5dGVzTGlrZShzaWduYXR1cmUpKSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkoc2lnbmF0dXJlKTtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gNjUpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHNpZ25hdHVyZSBzdHJpbmc7IG11c3QgYmUgNjUgYnl0ZXNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBHZXQgdGhlIHIsIHMgYW5kIHZcbiAgICAgICAgcmVzdWx0LnIgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDAsIDMyKSk7XG4gICAgICAgIHJlc3VsdC5zID0gaGV4bGlmeShieXRlcy5zbGljZSgzMiwgNjQpKTtcbiAgICAgICAgcmVzdWx0LnYgPSBieXRlc1s2NF07XG4gICAgICAgIC8vIEFsbG93IGEgcmVjaWQgdG8gYmUgdXNlZCBhcyB0aGUgdlxuICAgICAgICBpZiAocmVzdWx0LnYgPCAyNykge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC52ID09PSAwIHx8IHJlc3VsdC52ID09PSAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnYgKz0gMjc7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIGludmFsaWQgdiBieXRlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ29tcHV0ZSByZWNvdmVyeVBhcmFtIGZyb20gdlxuICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IDEgLSAocmVzdWx0LnYgJSAyKTtcbiAgICAgICAgLy8gQ29tcHV0ZSBfdnMgZnJvbSByZWNvdmVyeVBhcmFtIGFuZCBzXG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSkge1xuICAgICAgICAgICAgYnl0ZXNbMzJdIHw9IDB4ODA7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0Ll92cyA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMzIsIDY0KSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXN1bHQuciA9IHNpZ25hdHVyZS5yO1xuICAgICAgICByZXN1bHQucyA9IHNpZ25hdHVyZS5zO1xuICAgICAgICByZXN1bHQudiA9IHNpZ25hdHVyZS52O1xuICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtO1xuICAgICAgICByZXN1bHQuX3ZzID0gc2lnbmF0dXJlLl92cztcbiAgICAgICAgLy8gSWYgdGhlIF92cyBpcyBhdmFpbGFibGUsIHVzZSBpdCB0byBwb3B1bGF0ZSBtaXNzaW5nIHMsIHYgYW5kIHJlY292ZXJ5UGFyYW1cbiAgICAgICAgLy8gYW5kIHZlcmlmeSBub24tbWlzc2luZyBzLCB2IGFuZCByZWNvdmVyeVBhcmFtXG4gICAgICAgIGlmIChyZXN1bHQuX3ZzICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHZzID0gemVyb1BhZChhcnJheWlmeShyZXN1bHQuX3ZzKSwgMzIpO1xuICAgICAgICAgICAgcmVzdWx0Ll92cyA9IGhleGxpZnkodnMpO1xuICAgICAgICAgICAgLy8gU2V0IG9yIGNoZWNrIHRoZSByZWNpZFxuICAgICAgICAgICAgY29uc3QgcmVjb3ZlcnlQYXJhbSA9ICgodnNbMF0gPj0gMTI4KSA/IDEgOiAwKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnJlY292ZXJ5UGFyYW0gPSByZWNvdmVyeVBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY292ZXJ5UGFyYW0pIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHJlY292ZXJ5UGFyYW0gbWlzbWF0Y2ggX3ZzXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIHNcbiAgICAgICAgICAgIHZzWzBdICY9IDB4N2Y7XG4gICAgICAgICAgICBjb25zdCBzID0gaGV4bGlmeSh2cyk7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5zID0gcztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5zICE9PSBzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSB2IG1pc21hdGNoIF92c1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFVzZSByZWNpZCBhbmQgdiB0byBwb3B1bGF0ZSBlYWNoIG90aGVyXG4gICAgICAgIGlmIChyZXN1bHQucmVjb3ZlcnlQYXJhbSA9PSBudWxsKSB7XG4gICAgICAgICAgICBpZiAocmVzdWx0LnYgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyB2IGFuZCByZWNvdmVyeVBhcmFtXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQudiA9PT0gMCB8fCByZXN1bHQudiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5yZWNvdmVyeVBhcmFtID0gcmVzdWx0LnY7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucmVjb3ZlcnlQYXJhbSA9IDEgLSAocmVzdWx0LnYgJSAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChyZXN1bHQudiA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnYgPSAyNyArIHJlc3VsdC5yZWNvdmVyeVBhcmFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjSWQgPSAocmVzdWx0LnYgPT09IDAgfHwgcmVzdWx0LnYgPT09IDEpID8gcmVzdWx0LnYgOiAoMSAtIChyZXN1bHQudiAlIDIpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0LnJlY292ZXJ5UGFyYW0gIT09IHJlY0lkKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgcmVjb3ZlcnlQYXJhbSBtaXNtYXRjaCB2XCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuciA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHJcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5yID0gaGV4WmVyb1BhZChyZXN1bHQuciwgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQucyA9PSBudWxsIHx8ICFpc0hleFN0cmluZyhyZXN1bHQucykpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgbWlzc2luZyBvciBpbnZhbGlkIHNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5zID0gaGV4WmVyb1BhZChyZXN1bHQucywgMzIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHZzID0gYXJyYXlpZnkocmVzdWx0LnMpO1xuICAgICAgICBpZiAodnNbMF0gPj0gMTI4KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwic2lnbmF0dXJlIHMgb3V0IG9mIHJhbmdlXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5yZWNvdmVyeVBhcmFtKSB7XG4gICAgICAgICAgICB2c1swXSB8PSAweDgwO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IF92cyA9IGhleGxpZnkodnMpO1xuICAgICAgICBpZiAocmVzdWx0Ll92cykge1xuICAgICAgICAgICAgaWYgKCFpc0hleFN0cmluZyhyZXN1bHQuX3ZzKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJzaWduYXR1cmUgaW52YWxpZCBfdnNcIiwgXCJzaWduYXR1cmVcIiwgc2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5fdnMgPSBoZXhaZXJvUGFkKHJlc3VsdC5fdnMsIDMyKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTZXQgb3IgY2hlY2sgdGhlIF92c1xuICAgICAgICBpZiAocmVzdWx0Ll92cyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQuX3ZzID0gX3ZzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHJlc3VsdC5fdnMgIT09IF92cykge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInNpZ25hdHVyZSBfdnMgbWlzbWF0Y2ggdiBhbmQgc1wiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnQgZnVuY3Rpb24gam9pblNpZ25hdHVyZShzaWduYXR1cmUpIHtcbiAgICBzaWduYXR1cmUgPSBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIHJldHVybiBoZXhsaWZ5KGNvbmNhdChbXG4gICAgICAgIHNpZ25hdHVyZS5yLFxuICAgICAgICBzaWduYXR1cmUucyxcbiAgICAgICAgKHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtID8gXCIweDFjXCIgOiBcIjB4MWJcIilcbiAgICBdKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgQWRkcmVzc1plcm8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YWRkcmVzc2VzLmpzLm1hcCIsImltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmNvbnN0IE5lZ2F0aXZlT25lID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oLTEpKTtcbmNvbnN0IFplcm8gPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgwKSk7XG5jb25zdCBPbmUgPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgxKSk7XG5jb25zdCBUd28gPSAoIC8qI19fUFVSRV9fKi9CaWdOdW1iZXIuZnJvbSgyKSk7XG5jb25zdCBXZWlQZXJFdGhlciA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKFwiMTAwMDAwMDAwMDAwMDAwMDAwMFwiKSk7XG5jb25zdCBNYXhVaW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIikpO1xuY29uc3QgTWluSW50MjU2ID0gKCAvKiNfX1BVUkVfXyovQmlnTnVtYmVyLmZyb20oXCItMHg4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIpKTtcbmNvbnN0IE1heEludDI1NiA9ICggLyojX19QVVJFX18qL0JpZ051bWJlci5mcm9tKFwiMHg3ZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmXCIpKTtcbmV4cG9ydCB7IE5lZ2F0aXZlT25lLCBaZXJvLCBPbmUsIFR3bywgV2VpUGVyRXRoZXIsIE1heFVpbnQyNTYsIE1pbkludDI1NiwgTWF4SW50MjU2LCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmlnbnVtYmVycy5qcy5tYXAiLCJleHBvcnQgY29uc3QgSGFzaFplcm8gPSBcIjB4MDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aGFzaGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuZXhwb3J0IHsgQWRkcmVzc1plcm8gfSBmcm9tIFwiLi9hZGRyZXNzZXNcIjtcbmV4cG9ydCB7IE5lZ2F0aXZlT25lLCBaZXJvLCBPbmUsIFR3bywgV2VpUGVyRXRoZXIsIE1heFVpbnQyNTYsIE1pbkludDI1NiwgTWF4SW50MjU2IH0gZnJvbSBcIi4vYmlnbnVtYmVyc1wiO1xuZXhwb3J0IHsgSGFzaFplcm8gfSBmcm9tIFwiLi9oYXNoZXNcIjtcbmV4cG9ydCB7IEV0aGVyU3ltYm9sIH0gZnJvbSBcIi4vc3RyaW5nc1wiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiLy8gTkZLQyAoY29tcG9zZWQpICAgICAgICAgICAgIC8vIChkZWNvbXBvc2VkKVxuZXhwb3J0IGNvbnN0IEV0aGVyU3ltYm9sID0gXCJcXHUwMzllXCI7IC8vIFwiXFx1RDgzNVxcdURGNjNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZ3MuanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImNvbnRyYWN0cy81LjUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGNoZWNrUmVzdWx0RXJyb3JzLCBJbmRleGVkLCBJbnRlcmZhY2UgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJpXCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlclwiO1xuaW1wb3J0IHsgU2lnbmVyLCBWb2lkU2lnbmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lclwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q29udHJhY3RBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleGxpZnksIGlzQnl0ZXMsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSwgZGVlcENvcHksIGdldFN0YXRpYywgcmVzb2x2ZVByb3BlcnRpZXMsIHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG47XG47XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5jb25zdCBhbGxvd2VkVHJhbnNhY3Rpb25LZXlzID0ge1xuICAgIGNoYWluSWQ6IHRydWUsIGRhdGE6IHRydWUsIGZyb206IHRydWUsIGdhc0xpbWl0OiB0cnVlLCBnYXNQcmljZTogdHJ1ZSwgbm9uY2U6IHRydWUsIHRvOiB0cnVlLCB2YWx1ZTogdHJ1ZSxcbiAgICB0eXBlOiB0cnVlLCBhY2Nlc3NMaXN0OiB0cnVlLFxuICAgIG1heEZlZVBlckdhczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWUsXG4gICAgY3VzdG9tRGF0YTogdHJ1ZVxufTtcbmZ1bmN0aW9uIHJlc29sdmVOYW1lKHJlc29sdmVyLCBuYW1lT3JQcm9taXNlKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY29uc3QgbmFtZSA9IHlpZWxkIG5hbWVPclByb21pc2U7XG4gICAgICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIEVOUyBuYW1lXCIsIFwibmFtZVwiLCBuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBpdCBpcyBhbHJlYWR5IGFuIGFkZHJlc3MsIGp1c3QgdXNlIGl0IChhZnRlciBhZGRpbmcgY2hlY2tzdW0pXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhuYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImEgcHJvdmlkZXIgb3Igc2lnbmVyIGlzIG5lZWRlZCB0byByZXNvbHZlIEVOUyBuYW1lc1wiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJyZXNvbHZlTmFtZVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgcmVzb2x2ZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJyZXNvbHZlciBvciBhZGRyIGlzIG5vdCBjb25maWd1cmVkIGZvciBFTlMgbmFtZVwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgfSk7XG59XG4vLyBSZWN1cnNpdmVseSByZXBsYWNlcyBFTlMgbmFtZXMgd2l0aCBwcm9taXNlcyB0byByZXNvbHZlIHRoZSBuYW1lIGFuZCByZXNvbHZlcyBhbGwgcHJvcGVydGllc1xuZnVuY3Rpb24gcmVzb2x2ZUFkZHJlc3NlcyhyZXNvbHZlciwgdmFsdWUsIHBhcmFtVHlwZSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHBhcmFtVHlwZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCBQcm9taXNlLmFsbChwYXJhbVR5cGUubWFwKChwYXJhbVR5cGUsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsICgoQXJyYXkuaXNBcnJheSh2YWx1ZSkpID8gdmFsdWVbaW5kZXhdIDogdmFsdWVbcGFyYW1UeXBlLm5hbWVdKSwgcGFyYW1UeXBlKTtcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1UeXBlLnR5cGUgPT09IFwiYWRkcmVzc1wiKSB7XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzb2x2ZU5hbWUocmVzb2x2ZXIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFyYW1UeXBlLnR5cGUgPT09IFwidHVwbGVcIikge1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHJlc29sdmVBZGRyZXNzZXMocmVzb2x2ZXIsIHZhbHVlLCBwYXJhbVR5cGUuY29tcG9uZW50cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtVHlwZS5iYXNlVHlwZSA9PT0gXCJhcnJheVwiKSB7XG4gICAgICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGxvZ2dlci5tYWtlRXJyb3IoXCJpbnZhbGlkIHZhbHVlIGZvciBhcnJheVwiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwidmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgUHJvbWlzZS5hbGwodmFsdWUubWFwKCh2KSA9PiByZXNvbHZlQWRkcmVzc2VzKHJlc29sdmVyLCB2LCBwYXJhbVR5cGUuYXJyYXlDaGlsZHJlbikpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBwb3B1bGF0ZVRyYW5zYWN0aW9uKGNvbnRyYWN0LCBmcmFnbWVudCwgYXJncykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIC8vIElmIGFuIGV4dHJhIGFyZ3VtZW50IGlzIGdpdmVuLCBpdCBpcyBvdmVycmlkZXNcbiAgICAgICAgbGV0IG92ZXJyaWRlcyA9IHt9O1xuICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxICYmIHR5cGVvZiAoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgb3ZlcnJpZGVzID0gc2hhbGxvd0NvcHkoYXJncy5wb3AoKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBwYXJhbWV0ZXIgY291bnQgbWF0Y2hlc1xuICAgICAgICBsb2dnZXIuY2hlY2tBcmd1bWVudENvdW50KGFyZ3MubGVuZ3RoLCBmcmFnbWVudC5pbnB1dHMubGVuZ3RoLCBcInBhc3NlZCB0byBjb250cmFjdFwiKTtcbiAgICAgICAgLy8gUG9wdWxhdGUgXCJmcm9tXCIgb3ZlcnJpZGUgKGFsbG93IHByb21pc2VzKVxuICAgICAgICBpZiAoY29udHJhY3Quc2lnbmVyKSB7XG4gICAgICAgICAgICBpZiAob3ZlcnJpZGVzLmZyb20pIHtcbiAgICAgICAgICAgICAgICAvLyBDb250cmFjdHMgd2l0aCBhIFNpZ25lciBhcmUgZnJvbSB0aGUgU2lnbmVyJ3MgZnJhbWUtb2YtcmVmZXJlbmNlO1xuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBhbGxvdyBvdmVycmlkaW5nIFwiZnJvbVwiIGlmIGl0IG1hdGNoZXMgdGhlIHNpZ25lclxuICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gcmVzb2x2ZVByb3BlcnRpZXMoe1xuICAgICAgICAgICAgICAgICAgICBvdmVycmlkZTogcmVzb2x2ZU5hbWUoY29udHJhY3Quc2lnbmVyLCBvdmVycmlkZXMuZnJvbSksXG4gICAgICAgICAgICAgICAgICAgIHNpZ25lcjogY29udHJhY3Quc2lnbmVyLmdldEFkZHJlc3MoKVxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKGNoZWNrKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnZXRBZGRyZXNzKGNoZWNrLnNpZ25lcikgIT09IGNoZWNrLm92ZXJyaWRlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIkNvbnRyYWN0IHdpdGggYSBTaWduZXIgY2Fubm90IG92ZXJyaWRlIGZyb21cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwib3ZlcnJpZGVzLmZyb21cIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrLm92ZXJyaWRlO1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG92ZXJyaWRlcy5mcm9tID0gY29udHJhY3Quc2lnbmVyLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChvdmVycmlkZXMuZnJvbSkge1xuICAgICAgICAgICAgb3ZlcnJpZGVzLmZyb20gPSByZXNvbHZlTmFtZShjb250cmFjdC5wcm92aWRlciwgb3ZlcnJpZGVzLmZyb20pO1xuICAgICAgICAgICAgLy99IGVsc2Uge1xuICAgICAgICAgICAgLy8gQ29udHJhY3RzIHdpdGhvdXQgYSBzaWduZXIgY2FuIG92ZXJyaWRlIFwiZnJvbVwiLCBhbmQgaWZcbiAgICAgICAgICAgIC8vIHVuc3BlY2lmaWVkIHRoZSB6ZXJvIGFkZHJlc3MgaXMgdXNlZFxuICAgICAgICAgICAgLy9vdmVycmlkZXMuZnJvbSA9IEFkZHJlc3NaZXJvO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdhaXQgZm9yIGFsbCBkZXBlbmRlbmNpZXMgdG8gYmUgcmVzb2x2ZWQgKHByZWZlciB0aGUgc2lnbmVyIG92ZXIgdGhlIHByb3ZpZGVyKVxuICAgICAgICBjb25zdCByZXNvbHZlZCA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIGFyZ3M6IHJlc29sdmVBZGRyZXNzZXMoY29udHJhY3Quc2lnbmVyIHx8IGNvbnRyYWN0LnByb3ZpZGVyLCBhcmdzLCBmcmFnbWVudC5pbnB1dHMpLFxuICAgICAgICAgICAgYWRkcmVzczogY29udHJhY3QucmVzb2x2ZWRBZGRyZXNzLFxuICAgICAgICAgICAgb3ZlcnJpZGVzOiAocmVzb2x2ZVByb3BlcnRpZXMob3ZlcnJpZGVzKSB8fCB7fSlcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBBQkkgY29kZWQgdHJhbnNhY3Rpb25cbiAgICAgICAgY29uc3QgZGF0YSA9IGNvbnRyYWN0LmludGVyZmFjZS5lbmNvZGVGdW5jdGlvbkRhdGEoZnJhZ21lbnQsIHJlc29sdmVkLmFyZ3MpO1xuICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICB0bzogcmVzb2x2ZWQuYWRkcmVzc1xuICAgICAgICB9O1xuICAgICAgICAvLyBSZXNvbHZlZCBPdmVycmlkZXNcbiAgICAgICAgY29uc3Qgcm8gPSByZXNvbHZlZC5vdmVycmlkZXM7XG4gICAgICAgIC8vIFBvcHVsYXRlIHNpbXBsZSBvdmVycmlkZXNcbiAgICAgICAgaWYgKHJvLm5vbmNlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4Lm5vbmNlID0gQmlnTnVtYmVyLmZyb20ocm8ubm9uY2UpLnRvTnVtYmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvLmdhc0xpbWl0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gQmlnTnVtYmVyLmZyb20ocm8uZ2FzTGltaXQpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5nYXNQcmljZSAhPSBudWxsKSB7XG4gICAgICAgICAgICB0eC5nYXNQcmljZSA9IEJpZ051bWJlci5mcm9tKHJvLmdhc1ByaWNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocm8ubWF4RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4Lm1heEZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKHJvLm1heEZlZVBlckdhcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJvLm1heFByaW9yaXR5RmVlUGVyR2FzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID0gQmlnTnVtYmVyLmZyb20ocm8ubWF4UHJpb3JpdHlGZWVQZXJHYXMpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5mcm9tICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LmZyb20gPSByby5mcm9tO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby50eXBlICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LnR5cGUgPSByby50eXBlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5hY2Nlc3NMaXN0ICE9IG51bGwpIHtcbiAgICAgICAgICAgIHR4LmFjY2Vzc0xpc3QgPSBhY2Nlc3NMaXN0aWZ5KHJvLmFjY2Vzc0xpc3QpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBubyBcImdhc0xpbWl0XCIgb3ZlcnJpZGUsIGJ1dCB0aGUgQUJJIHNwZWNpZmllcyBhIGRlZmF1bHQsIHVzZSBpdFxuICAgICAgICBpZiAodHguZ2FzTGltaXQgPT0gbnVsbCAmJiBmcmFnbWVudC5nYXMgIT0gbnVsbCkge1xuICAgICAgICAgICAgLy8gQ29tcHV0ZSB0aGUgaW50cmluc2ljIGdhcyBjb3N0IGZvciB0aGlzIHRyYW5zYWN0aW9uXG4gICAgICAgICAgICAvLyBAVE9ETzogVGhpcyBpcyBiYXNlZCBvbiB0aGUgeWVsbG93IHBhcGVyIGFzIG9mIFBldGVyc2J1cmc7IHRoaXMgaXMgc29tZXRoaW5nXG4gICAgICAgICAgICAvLyB3ZSBtYXkgd2lzaCB0byBwYXJhbWV0ZXJpemUgaW4gdjYgYXMgcGFydCBvZiB0aGUgTmV0d29yayBvYmplY3QuIFNpbmNlIHRoaXNcbiAgICAgICAgICAgIC8vIGlzIGFsd2F5cyBhIG5vbi1uaWwgdG8gYWRkcmVzcywgd2UgY2FuIGlnbm9yZSBHX2NyZWF0ZSwgYnV0IG1heSB3aXNoIHRvIGFkZFxuICAgICAgICAgICAgLy8gc2ltaWxhciBsb2dpYyB0byB0aGUgQ29udHJhY3RGYWN0b3J5LlxuICAgICAgICAgICAgbGV0IGludHJpbnNpYyA9IDIxMDAwO1xuICAgICAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShkYXRhKTtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYnl0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBpbnRyaW5zaWMgKz0gNDtcbiAgICAgICAgICAgICAgICBpZiAoYnl0ZXNbaV0pIHtcbiAgICAgICAgICAgICAgICAgICAgaW50cmluc2ljICs9IDY0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHR4Lmdhc0xpbWl0ID0gQmlnTnVtYmVyLmZyb20oZnJhZ21lbnQuZ2FzKS5hZGQoaW50cmluc2ljKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBQb3B1bGF0ZSBcInZhbHVlXCIgb3ZlcnJpZGVcbiAgICAgICAgaWYgKHJvLnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCByb1ZhbHVlID0gQmlnTnVtYmVyLmZyb20ocm8udmFsdWUpO1xuICAgICAgICAgICAgaWYgKCFyb1ZhbHVlLmlzWmVybygpICYmICFmcmFnbWVudC5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub24tcGF5YWJsZSBtZXRob2QgY2Fubm90IG92ZXJyaWRlIHZhbHVlXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJvdmVycmlkZXMudmFsdWVcIixcbiAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG92ZXJyaWRlcy52YWx1ZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHgudmFsdWUgPSByb1ZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyby5jdXN0b21EYXRhKSB7XG4gICAgICAgICAgICB0eC5jdXN0b21EYXRhID0gc2hhbGxvd0NvcHkocm8uY3VzdG9tRGF0YSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBvdmVycmlkZXNcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5ub25jZTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5nYXNMaW1pdDtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5nYXNQcmljZTtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5mcm9tO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLnZhbHVlO1xuICAgICAgICBkZWxldGUgb3ZlcnJpZGVzLnR5cGU7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuYWNjZXNzTGlzdDtcbiAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5tYXhGZWVQZXJHYXM7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMubWF4UHJpb3JpdHlGZWVQZXJHYXM7XG4gICAgICAgIGRlbGV0ZSBvdmVycmlkZXMuY3VzdG9tRGF0YTtcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZXJlIGFyZSBubyBzdHJheSBvdmVycmlkZXMsIHdoaWNoIG1heSBpbmRpY2F0ZSBhXG4gICAgICAgIC8vIHR5cG8gb3IgdXNpbmcgYW4gdW5zdXBwb3J0ZWQga2V5LlxuICAgICAgICBjb25zdCBsZWZ0b3ZlcnMgPSBPYmplY3Qua2V5cyhvdmVycmlkZXMpLmZpbHRlcigoa2V5KSA9PiAob3ZlcnJpZGVzW2tleV0gIT0gbnVsbCkpO1xuICAgICAgICBpZiAobGVmdG92ZXJzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoYGNhbm5vdCBvdmVycmlkZSAke2xlZnRvdmVycy5tYXAoKGwpID0+IEpTT04uc3RyaW5naWZ5KGwpKS5qb2luKFwiLFwiKX1gLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJvdmVycmlkZXNcIixcbiAgICAgICAgICAgICAgICBvdmVycmlkZXM6IGxlZnRvdmVyc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR4O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gYnVpbGRQb3B1bGF0ZShjb250cmFjdCwgZnJhZ21lbnQpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYnVpbGRFc3RpbWF0ZShjb250cmFjdCwgZnJhZ21lbnQpIHtcbiAgICBjb25zdCBzaWduZXJPclByb3ZpZGVyID0gKGNvbnRyYWN0LnNpZ25lciB8fCBjb250cmFjdC5wcm92aWRlcik7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIXNpZ25lck9yUHJvdmlkZXIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImVzdGltYXRlIHJlcXVpcmUgYSBwcm92aWRlciBvciBzaWduZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImVzdGltYXRlR2FzXCJcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHR4ID0geWllbGQgcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHNpZ25lck9yUHJvdmlkZXIuZXN0aW1hdGVHYXModHgpO1xuICAgICAgICB9KTtcbiAgICB9O1xufVxuZnVuY3Rpb24gYWRkQ29udHJhY3RXYWl0KGNvbnRyYWN0LCB0eCkge1xuICAgIGNvbnN0IHdhaXQgPSB0eC53YWl0LmJpbmQodHgpO1xuICAgIHR4LndhaXQgPSAoY29uZmlybWF0aW9ucykgPT4ge1xuICAgICAgICByZXR1cm4gd2FpdChjb25maXJtYXRpb25zKS50aGVuKChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICByZWNlaXB0LmV2ZW50cyA9IHJlY2VpcHQubG9ncy5tYXAoKGxvZykgPT4ge1xuICAgICAgICAgICAgICAgIGxldCBldmVudCA9IGRlZXBDb3B5KGxvZyk7XG4gICAgICAgICAgICAgICAgbGV0IHBhcnNlZCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkID0gY29udHJhY3QuaW50ZXJmYWNlLnBhcnNlTG9nKGxvZyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgICAgICAvLyBTdWNjZXNzZnVsbHkgcGFyc2VkIHRoZSBldmVudCBsb2c7IGluY2x1ZGUgaXRcbiAgICAgICAgICAgICAgICBpZiAocGFyc2VkKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50LmFyZ3MgPSBwYXJzZWQuYXJncztcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZGVjb2RlID0gKGRhdGEsIHRvcGljcykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LmludGVyZmFjZS5kZWNvZGVFdmVudExvZyhwYXJzZWQuZXZlbnRGcmFnbWVudCwgZGF0YSwgdG9waWNzKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZXZlbnQgPSBwYXJzZWQubmFtZTtcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQuZXZlbnRTaWduYXR1cmUgPSBwYXJzZWQuc2lnbmF0dXJlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBVc2VmdWwgb3BlcmF0aW9uc1xuICAgICAgICAgICAgICAgIGV2ZW50LnJlbW92ZUxpc3RlbmVyID0gKCkgPT4geyByZXR1cm4gY29udHJhY3QucHJvdmlkZXI7IH07XG4gICAgICAgICAgICAgICAgZXZlbnQuZ2V0QmxvY2sgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjb250cmFjdC5wcm92aWRlci5nZXRCbG9jayhyZWNlaXB0LmJsb2NrSGFzaCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvbiA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0LnByb3ZpZGVyLmdldFRyYW5zYWN0aW9uKHJlY2VpcHQudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uUmVjZWlwdCA9ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShyZWNlaXB0KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHJldHVybiBldmVudDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZENhbGwoY29udHJhY3QsIGZyYWdtZW50LCBjb2xsYXBzZVNpbXBsZSkge1xuICAgIGNvbnN0IHNpZ25lck9yUHJvdmlkZXIgPSAoY29udHJhY3Quc2lnbmVyIHx8IGNvbnRyYWN0LnByb3ZpZGVyKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIEV4dHJhY3QgdGhlIFwiYmxvY2tUYWdcIiBvdmVycmlkZSBpZiBwcmVzZW50XG4gICAgICAgICAgICBsZXQgYmxvY2tUYWcgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoYXJncy5sZW5ndGggPT09IGZyYWdtZW50LmlucHV0cy5sZW5ndGggKyAxICYmIHR5cGVvZiAoYXJnc1thcmdzLmxlbmd0aCAtIDFdKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IG92ZXJyaWRlcyA9IHNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO1xuICAgICAgICAgICAgICAgIGlmIChvdmVycmlkZXMuYmxvY2tUYWcgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBibG9ja1RhZyA9IHlpZWxkIG92ZXJyaWRlcy5ibG9ja1RhZztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIG92ZXJyaWRlcy5ibG9ja1RhZztcbiAgICAgICAgICAgICAgICBhcmdzLnB1c2gob3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIElmIHRoZSBjb250cmFjdCB3YXMganVzdCBkZXBsb3llZCwgd2FpdCB1bnRpbCBpdCBpcyBtaW5lZFxuICAgICAgICAgICAgaWYgKGNvbnRyYWN0LmRlcGxveVRyYW5zYWN0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjb250cmFjdC5fZGVwbG95ZWQoYmxvY2tUYWcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gQ2FsbCBhIG5vZGUgYW5kIGdldCB0aGUgcmVzdWx0XG4gICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHBvcHVsYXRlVHJhbnNhY3Rpb24oY29udHJhY3QsIGZyYWdtZW50LCBhcmdzKTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHNpZ25lck9yUHJvdmlkZXIuY2FsbCh0eCwgYmxvY2tUYWcpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBsZXQgdmFsdWUgPSBjb250cmFjdC5pbnRlcmZhY2UuZGVjb2RlRnVuY3Rpb25SZXN1bHQoZnJhZ21lbnQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbGxhcHNlU2ltcGxlICYmIGZyYWdtZW50Lm91dHB1dHMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gdmFsdWVbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yLmFkZHJlc3MgPSBjb250cmFjdC5hZGRyZXNzO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5hcmdzID0gYXJncztcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IudHJhbnNhY3Rpb24gPSB0eDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZFNlbmQoY29udHJhY3QsIGZyYWdtZW50KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAoIWNvbnRyYWN0LnNpZ25lcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwic2VuZGluZyBhIHRyYW5zYWN0aW9uIHJlcXVpcmVzIGEgc2lnbmVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb25cIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlIGNvbnRyYWN0IHdhcyBqdXN0IGRlcGxveWVkLCB3YWl0IHVudGlsIGl0IGlzIG1pbmVkXG4gICAgICAgICAgICBpZiAoY29udHJhY3QuZGVwbG95VHJhbnNhY3Rpb24gIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHlpZWxkIGNvbnRyYWN0Ll9kZXBsb3llZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgdHhSZXF1ZXN0ID0geWllbGQgcG9wdWxhdGVUcmFuc2FjdGlvbihjb250cmFjdCwgZnJhZ21lbnQsIGFyZ3MpO1xuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCBjb250cmFjdC5zaWduZXIuc2VuZFRyYW5zYWN0aW9uKHR4UmVxdWVzdCk7XG4gICAgICAgICAgICAvLyBUd2VhayB0aGUgdHgud2FpdCBzbyB0aGUgcmVjZWlwdCBoYXMgZXh0cmEgcHJvcGVydGllc1xuICAgICAgICAgICAgYWRkQ29udHJhY3RXYWl0KGNvbnRyYWN0LCB0eCk7XG4gICAgICAgICAgICByZXR1cm4gdHg7XG4gICAgICAgIH0pO1xuICAgIH07XG59XG5mdW5jdGlvbiBidWlsZERlZmF1bHQoY29udHJhY3QsIGZyYWdtZW50LCBjb2xsYXBzZVNpbXBsZSkge1xuICAgIGlmIChmcmFnbWVudC5jb25zdGFudCkge1xuICAgICAgICByZXR1cm4gYnVpbGRDYWxsKGNvbnRyYWN0LCBmcmFnbWVudCwgY29sbGFwc2VTaW1wbGUpO1xuICAgIH1cbiAgICByZXR1cm4gYnVpbGRTZW5kKGNvbnRyYWN0LCBmcmFnbWVudCk7XG59XG5mdW5jdGlvbiBnZXRFdmVudFRhZyhmaWx0ZXIpIHtcbiAgICBpZiAoZmlsdGVyLmFkZHJlc3MgJiYgKGZpbHRlci50b3BpY3MgPT0gbnVsbCB8fCBmaWx0ZXIudG9waWNzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgcmV0dXJuIFwiKlwiO1xuICAgIH1cbiAgICByZXR1cm4gKGZpbHRlci5hZGRyZXNzIHx8IFwiKlwiKSArIFwiQFwiICsgKGZpbHRlci50b3BpY3MgPyBmaWx0ZXIudG9waWNzLm1hcCgodG9waWMpID0+IHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodG9waWMpKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9waWMuam9pbihcInxcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRvcGljO1xuICAgIH0pLmpvaW4oXCI6XCIpIDogXCJcIik7XG59XG5jbGFzcyBSdW5uaW5nRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHRhZywgZmlsdGVyKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwidGFnXCIsIHRhZyk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZmlsdGVyXCIsIGZpbHRlcik7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IFtdO1xuICAgIH1cbiAgICBhZGRMaXN0ZW5lcihsaXN0ZW5lciwgb25jZSkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMucHVzaCh7IGxpc3RlbmVyOiBsaXN0ZW5lciwgb25jZTogb25jZSB9KTtcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIobGlzdGVuZXIpIHtcbiAgICAgICAgbGV0IGRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fbGlzdGVuZXJzID0gdGhpcy5fbGlzdGVuZXJzLmZpbHRlcigoaXRlbSkgPT4ge1xuICAgICAgICAgICAgaWYgKGRvbmUgfHwgaXRlbS5saXN0ZW5lciAhPT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKCkge1xuICAgICAgICB0aGlzLl9saXN0ZW5lcnMgPSBbXTtcbiAgICB9XG4gICAgbGlzdGVuZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbGlzdGVuZXJzLm1hcCgoaSkgPT4gaS5saXN0ZW5lcik7XG4gICAgfVxuICAgIGxpc3RlbmVyQ291bnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9saXN0ZW5lcnMubGVuZ3RoO1xuICAgIH1cbiAgICBydW4oYXJncykge1xuICAgICAgICBjb25zdCBsaXN0ZW5lckNvdW50ID0gdGhpcy5saXN0ZW5lckNvdW50KCk7XG4gICAgICAgIHRoaXMuX2xpc3RlbmVycyA9IHRoaXMuX2xpc3RlbmVycy5maWx0ZXIoKGl0ZW0pID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGFyZ3NDb3B5ID0gYXJncy5zbGljZSgpO1xuICAgICAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgaW4gdGhlIG5leHQgZXZlbnQgbG9vcFxuICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgaXRlbS5saXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzQ29weSk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIC8vIFJlc2NoZWR1bGUgaXQgaWYgaXQgbm90IFwib25jZVwiXG4gICAgICAgICAgICByZXR1cm4gIShpdGVtLm9uY2UpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVyQ291bnQ7XG4gICAgfVxuICAgIHByZXBhcmVFdmVudChldmVudCkge1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBhcnJheSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byBhbiBlbWl0XG4gICAgZ2V0RW1pdChldmVudCkge1xuICAgICAgICByZXR1cm4gW2V2ZW50XTtcbiAgICB9XG59XG5jbGFzcyBFcnJvclJ1bm5pbmdFdmVudCBleHRlbmRzIFJ1bm5pbmdFdmVudCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiZXJyb3JcIiwgbnVsbCk7XG4gICAgfVxufVxuLy8gQFRPRE8gRnJhZ21lbnQgc2hvdWxkIGluaGVyaXQgV2lsZGNhcmQ/IGFuZCBqdXN0IG92ZXJyaWRlIGdldEVtaXQ/XG4vLyAgICAgICBvciBoYXZlIGEgY29tbW9uIGFic3RyYWN0IHN1cGVyIGNsYXNzLCB3aXRoIGVub3VnaCBjb25zdHJ1Y3RvclxuLy8gICAgICAgb3B0aW9ucyB0byBjb25maWd1cmUgYm90aC5cbi8vIEEgRnJhZ21lbnQgRXZlbnQgd2lsbCBwb3B1bGF0ZSBhbGwgdGhlIHByb3BlcnRpZXMgdGhhdCBXaWxkY2FyZFxuLy8gd2lsbCwgYW5kIGFkZGl0aW9uYWxseSBkZXJlZmVyZW5jZSB0aGUgYXJndW1lbnRzIHdoZW4gZW1pdHRpbmdcbmNsYXNzIEZyYWdtZW50UnVubmluZ0V2ZW50IGV4dGVuZHMgUnVubmluZ0V2ZW50IHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzLCBjb250cmFjdEludGVyZmFjZSwgZnJhZ21lbnQsIHRvcGljcykge1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSB7XG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzXG4gICAgICAgIH07XG4gICAgICAgIGxldCB0b3BpYyA9IGNvbnRyYWN0SW50ZXJmYWNlLmdldEV2ZW50VG9waWMoZnJhZ21lbnQpO1xuICAgICAgICBpZiAodG9waWNzKSB7XG4gICAgICAgICAgICBpZiAodG9waWMgIT09IHRvcGljc1swXSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0b3BpYyBtaXNtYXRjaFwiLCBcInRvcGljc1wiLCB0b3BpY3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcy5zbGljZSgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IFt0b3BpY107XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIoZ2V0RXZlbnRUYWcoZmlsdGVyKSwgZmlsdGVyKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGFkZHJlc3MpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImludGVyZmFjZVwiLCBjb250cmFjdEludGVyZmFjZSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZnJhZ21lbnRcIiwgZnJhZ21lbnQpO1xuICAgIH1cbiAgICBwcmVwYXJlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgc3VwZXIucHJlcGFyZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgZXZlbnQuZXZlbnQgPSB0aGlzLmZyYWdtZW50Lm5hbWU7XG4gICAgICAgIGV2ZW50LmV2ZW50U2lnbmF0dXJlID0gdGhpcy5mcmFnbWVudC5mb3JtYXQoKTtcbiAgICAgICAgZXZlbnQuZGVjb2RlID0gKGRhdGEsIHRvcGljcykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKHRoaXMuZnJhZ21lbnQsIGRhdGEsIHRvcGljcyk7XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBldmVudC5hcmdzID0gdGhpcy5pbnRlcmZhY2UuZGVjb2RlRXZlbnRMb2codGhpcy5mcmFnbWVudCwgZXZlbnQuZGF0YSwgZXZlbnQudG9waWNzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGV2ZW50LmFyZ3MgPSBudWxsO1xuICAgICAgICAgICAgZXZlbnQuZGVjb2RlRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXRFbWl0KGV2ZW50KSB7XG4gICAgICAgIGNvbnN0IGVycm9ycyA9IGNoZWNrUmVzdWx0RXJyb3JzKGV2ZW50LmFyZ3MpO1xuICAgICAgICBpZiAoZXJyb3JzLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgZXJyb3JzWzBdLmVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFyZ3MgPSAoZXZlbnQuYXJncyB8fCBbXSkuc2xpY2UoKTtcbiAgICAgICAgYXJncy5wdXNoKGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIGFyZ3M7XG4gICAgfVxufVxuLy8gQSBXaWxkY2FyZCBFdmVudCB3aWxsIGF0dGVtcHQgdG8gcG9wdWxhdGU6XG4vLyAgLSBldmVudCAgICAgICAgICAgIFRoZSBuYW1lIG9mIHRoZSBldmVudCBuYW1lXG4vLyAgLSBldmVudFNpZ25hdHVyZSAgIFRoZSBmdWxsIHNpZ25hdHVyZSBvZiB0aGUgZXZlbnRcbi8vICAtIGRlY29kZSAgICAgICAgICAgQSBmdW5jdGlvbiB0byBkZWNvZGUgZGF0YSBhbmQgdG9waWNzXG4vLyAgLSBhcmdzICAgICAgICAgICAgIFRoZSBkZWNvZGVkIGRhdGEgYW5kIHRvcGljc1xuY2xhc3MgV2lsZGNhcmRSdW5uaW5nRXZlbnQgZXh0ZW5kcyBSdW5uaW5nRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKGFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlKSB7XG4gICAgICAgIHN1cGVyKFwiKlwiLCB7IGFkZHJlc3M6IGFkZHJlc3MgfSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWRkcmVzc1wiLCBhZGRyZXNzKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJpbnRlcmZhY2VcIiwgY29udHJhY3RJbnRlcmZhY2UpO1xuICAgIH1cbiAgICBwcmVwYXJlRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgc3VwZXIucHJlcGFyZUV2ZW50KGV2ZW50KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZCA9IHRoaXMuaW50ZXJmYWNlLnBhcnNlTG9nKGV2ZW50KTtcbiAgICAgICAgICAgIGV2ZW50LmV2ZW50ID0gcGFyc2VkLm5hbWU7XG4gICAgICAgICAgICBldmVudC5ldmVudFNpZ25hdHVyZSA9IHBhcnNlZC5zaWduYXR1cmU7XG4gICAgICAgICAgICBldmVudC5kZWNvZGUgPSAoZGF0YSwgdG9waWNzKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW50ZXJmYWNlLmRlY29kZUV2ZW50TG9nKHBhcnNlZC5ldmVudEZyYWdtZW50LCBkYXRhLCB0b3BpY3MpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGV2ZW50LmFyZ3MgPSBwYXJzZWQuYXJncztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5vIG1hdGNoaW5nIGV2ZW50XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnQgY2xhc3MgQmFzZUNvbnRyYWN0IHtcbiAgICBjb25zdHJ1Y3RvcihhZGRyZXNzT3JOYW1lLCBjb250cmFjdEludGVyZmFjZSwgc2lnbmVyT3JQcm92aWRlcikge1xuICAgICAgICBsb2dnZXIuY2hlY2tOZXcobmV3LnRhcmdldCwgQ29udHJhY3QpO1xuICAgICAgICAvLyBAVE9ETzogTWF5YmUgc3RpbGwgY2hlY2sgdGhlIGFkZHJlc3NPck5hbWUgbG9va3MgbGlrZSBhIHZhbGlkIGFkZHJlc3Mgb3IgbmFtZT9cbiAgICAgICAgLy9hZGRyZXNzID0gZ2V0QWRkcmVzcyhhZGRyZXNzKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJpbnRlcmZhY2VcIiwgZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0SW50ZXJmYWNlXCIpKGNvbnRyYWN0SW50ZXJmYWNlKSk7XG4gICAgICAgIGlmIChzaWduZXJPclByb3ZpZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgbnVsbCk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInNpZ25lclwiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChTaWduZXIuaXNTaWduZXIoc2lnbmVyT3JQcm92aWRlcikpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgc2lnbmVyT3JQcm92aWRlci5wcm92aWRlciB8fCBudWxsKTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwic2lnbmVyXCIsIHNpZ25lck9yUHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFByb3ZpZGVyLmlzUHJvdmlkZXIoc2lnbmVyT3JQcm92aWRlcikpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgc2lnbmVyT3JQcm92aWRlcik7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInNpZ25lclwiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHNpZ25lciBvciBwcm92aWRlclwiLCBcInNpZ25lck9yUHJvdmlkZXJcIiwgc2lnbmVyT3JQcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjYWxsU3RhdGljXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJlc3RpbWF0ZUdhc1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiZnVuY3Rpb25zXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwb3B1bGF0ZVRyYW5zYWN0aW9uXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJmaWx0ZXJzXCIsIHt9KTtcbiAgICAgICAge1xuICAgICAgICAgICAgY29uc3QgdW5pcXVlRmlsdGVycyA9IHt9O1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnRlcmZhY2UuZXZlbnRzKS5mb3JFYWNoKChldmVudFNpZ25hdHVyZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5pbnRlcmZhY2UuZXZlbnRzW2V2ZW50U2lnbmF0dXJlXTtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmZpbHRlcnMsIGV2ZW50U2lnbmF0dXJlLCAoLi4uYXJncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgdG9waWNzOiB0aGlzLmludGVyZmFjZS5lbmNvZGVGaWx0ZXJUb3BpY3MoZXZlbnQsIGFyZ3MpXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKCF1bmlxdWVGaWx0ZXJzW2V2ZW50Lm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHVuaXF1ZUZpbHRlcnNbZXZlbnQubmFtZV0gPSBbXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdW5pcXVlRmlsdGVyc1tldmVudC5uYW1lXS5wdXNoKGV2ZW50U2lnbmF0dXJlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModW5pcXVlRmlsdGVycykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpbHRlcnMgPSB1bmlxdWVGaWx0ZXJzW25hbWVdO1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmZpbHRlcnMsIG5hbWUsIHRoaXMuZmlsdGVyc1tmaWx0ZXJzWzBdXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIud2FybihgRHVwbGljYXRlIGRlZmluaXRpb24gb2YgJHtuYW1lfSAoJHtmaWx0ZXJzLmpvaW4oXCIsIFwiKX0pYCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfcnVubmluZ0V2ZW50c1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3dyYXBwZWRFbWl0c1wiLCB7fSk7XG4gICAgICAgIGlmIChhZGRyZXNzT3JOYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbnRyYWN0IGFkZHJlc3Mgb3IgRU5TIG5hbWVcIiwgXCJhZGRyZXNzT3JOYW1lXCIsIGFkZHJlc3NPck5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWRkcmVzc1wiLCBhZGRyZXNzT3JOYW1lKTtcbiAgICAgICAgaWYgKHRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicmVzb2x2ZWRBZGRyZXNzXCIsIHJlc29sdmVOYW1lKHRoaXMucHJvdmlkZXIsIGFkZHJlc3NPck5hbWUpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJyZXNvbHZlZEFkZHJlc3NcIiwgUHJvbWlzZS5yZXNvbHZlKGdldEFkZHJlc3MoYWRkcmVzc09yTmFtZSkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIC8vIFdpdGhvdXQgYSBwcm92aWRlciwgd2UgY2Fubm90IHVzZSBFTlMgbmFtZXNcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInByb3ZpZGVyIGlzIHJlcXVpcmVkIHRvIHVzZSBFTlMgbmFtZSBhcyBjb250cmFjdCBhZGRyZXNzXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXcgQ29udHJhY3RcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHVuaXF1ZU5hbWVzID0ge307XG4gICAgICAgIGNvbnN0IHVuaXF1ZVNpZ25hdHVyZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zKS5mb3JFYWNoKChzaWduYXR1cmUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZyYWdtZW50ID0gdGhpcy5pbnRlcmZhY2UuZnVuY3Rpb25zW3NpZ25hdHVyZV07XG4gICAgICAgICAgICAvLyBDaGVjayB0aGF0IHRoZSBzaWduYXR1cmUgaXMgdW5pcXVlOyBpZiBub3QgdGhlIEFCSSBnZW5lcmF0aW9uIGhhc1xuICAgICAgICAgICAgLy8gbm90IGJlZW4gY2xlYW5lZCBvciBtYXkgYmUgaW5jb3JyZWN0bHkgZ2VuZXJhdGVkXG4gICAgICAgICAgICBpZiAodW5pcXVlU2lnbmF0dXJlc1tzaWduYXR1cmVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYER1cGxpY2F0ZSBBQkkgZW50cnkgZm9yICR7SlNPTi5zdHJpbmdpZnkoc2lnbmF0dXJlKX1gKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1bmlxdWVTaWduYXR1cmVzW3NpZ25hdHVyZV0gPSB0cnVlO1xuICAgICAgICAgICAgLy8gVHJhY2sgdW5pcXVlIG5hbWVzOyB3ZSBvbmx5IGV4cG9zZSBiYXJlIG5hbWVkIGZ1bmN0aW9ucyBpZiB0aGV5XG4gICAgICAgICAgICAvLyBhcmUgYW1iaWd1b3VzXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgbmFtZSA9IGZyYWdtZW50Lm5hbWU7XG4gICAgICAgICAgICAgICAgaWYgKCF1bmlxdWVOYW1lc1tgJSR7bmFtZX1gXSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVOYW1lc1tgJSR7bmFtZX1gXSA9IFtdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB1bmlxdWVOYW1lc1tgJSR7bmFtZX1gXS5wdXNoKHNpZ25hdHVyZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpc1tzaWduYXR1cmVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBzaWduYXR1cmUsIGJ1aWxkRGVmYXVsdCh0aGlzLCBmcmFnbWVudCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gV2UgZG8gbm90IGNvbGxhcHNlIHNpbXBsZSBjYWxscyBvbiB0aGlzIGJ1Y2tldCwgd2hpY2ggYWxsb3dzXG4gICAgICAgICAgICAvLyBmcmFtZXdvcmtzIHRvIHNhZmVseSB1c2UgdGhpcyB3aXRob3V0IGludHJvc3BlY3Rpb24gYXMgd2VsbCBhc1xuICAgICAgICAgICAgLy8gYWxsb3dzIGRlY29kaW5nIGVycm9yIHJlY292ZXJ5LlxuICAgICAgICAgICAgaWYgKHRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMuZnVuY3Rpb25zLCBzaWduYXR1cmUsIGJ1aWxkRGVmYXVsdCh0aGlzLCBmcmFnbWVudCwgZmFsc2UpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5jYWxsU3RhdGljLCBzaWduYXR1cmUsIGJ1aWxkQ2FsbCh0aGlzLCBmcmFnbWVudCwgdHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIHNpZ25hdHVyZSwgYnVpbGRQb3B1bGF0ZSh0aGlzLCBmcmFnbWVudCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuZXN0aW1hdGVHYXNbc2lnbmF0dXJlXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5lc3RpbWF0ZUdhcywgc2lnbmF0dXJlLCBidWlsZEVzdGltYXRlKHRoaXMsIGZyYWdtZW50KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBPYmplY3Qua2V5cyh1bmlxdWVOYW1lcykuZm9yRWFjaCgobmFtZSkgPT4ge1xuICAgICAgICAgICAgLy8gQW1iaWd1b3VzIG5hbWVzIHRvIG5vdCBnZXQgYXR0YWNoZWQgYXMgYmFyZSBuYW1lc1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlcyA9IHVuaXF1ZU5hbWVzW25hbWVdO1xuICAgICAgICAgICAgaWYgKHNpZ25hdHVyZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFN0cmlwIG9mZiB0aGUgbGVhZGluZyBcIiVcIiB1c2VkIGZvciBwcm90b3R5cGUgcHJvdGVjdGlvblxuICAgICAgICAgICAgbmFtZSA9IG5hbWUuc3Vic3RyaW5nKDEpO1xuICAgICAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0gc2lnbmF0dXJlc1swXTtcbiAgICAgICAgICAgIC8vIElmIG92ZXJ3cml0aW5nIGEgbWVtYmVyIHByb3BlcnR5IHRoYXQgaXMgbnVsbCwgc3dhbGxvdyB0aGUgZXJyb3JcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXNbbmFtZV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBuYW1lLCB0aGlzW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIGlmICh0aGlzLmZ1bmN0aW9uc1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5mdW5jdGlvbnMsIG5hbWUsIHRoaXMuZnVuY3Rpb25zW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRoaXMuY2FsbFN0YXRpY1tuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcy5jYWxsU3RhdGljLCBuYW1lLCB0aGlzLmNhbGxTdGF0aWNbc2lnbmF0dXJlXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5wb3B1bGF0ZVRyYW5zYWN0aW9uW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLnBvcHVsYXRlVHJhbnNhY3Rpb24sIG5hbWUsIHRoaXMucG9wdWxhdGVUcmFuc2FjdGlvbltzaWduYXR1cmVdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLmVzdGltYXRlR2FzW25hbWVdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLmVzdGltYXRlR2FzLCBuYW1lLCB0aGlzLmVzdGltYXRlR2FzW3NpZ25hdHVyZV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldENvbnRyYWN0QWRkcmVzcyh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gZ2V0Q29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKTtcbiAgICB9XG4gICAgc3RhdGljIGdldEludGVyZmFjZShjb250cmFjdEludGVyZmFjZSkge1xuICAgICAgICBpZiAoSW50ZXJmYWNlLmlzSW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKSkge1xuICAgICAgICAgICAgcmV0dXJuIGNvbnRyYWN0SW50ZXJmYWNlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgSW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKTtcbiAgICB9XG4gICAgLy8gQFRPRE86IEFsbG93IHRpbWVvdXQ/XG4gICAgZGVwbG95ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZXBsb3llZCgpO1xuICAgIH1cbiAgICBfZGVwbG95ZWQoYmxvY2tUYWcpIHtcbiAgICAgICAgaWYgKCF0aGlzLl9kZXBsb3llZFByb21pc2UpIHtcbiAgICAgICAgICAgIC8vIElmIHdlIHdlcmUganVzdCBkZXBsb3llZCwgd2Uga25vdyB0aGUgdHJhbnNhY3Rpb24gd2Ugc2hvdWxkIG9jY3VyIGluXG4gICAgICAgICAgICBpZiAodGhpcy5kZXBsb3lUcmFuc2FjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2RlcGxveWVkUHJvbWlzZSA9IHRoaXMuZGVwbG95VHJhbnNhY3Rpb24ud2FpdCgpLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIEBUT0RPOiBPbmNlIHdlIGFsbG93IGEgdGltZW91dCB0byBiZSBwYXNzZWQgaW4sIHdlIHdpbGwgd2FpdFxuICAgICAgICAgICAgICAgIC8vIHVwIHRvIHRoYXQgbWFueSBibG9ja3MgZm9yIGdldENvZGVcbiAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIHBvbGwgZm9yIG91ciBjb2RlIHRvIGJlIGRlcGxveWVkXG4gICAgICAgICAgICAgICAgdGhpcy5fZGVwbG95ZWRQcm9taXNlID0gdGhpcy5wcm92aWRlci5nZXRDb2RlKHRoaXMuYWRkcmVzcywgYmxvY2tUYWcpLnRoZW4oKGNvZGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGUgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjb250cmFjdCBub3QgZGVwbG95ZWRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250cmFjdEFkZHJlc3M6IHRoaXMuYWRkcmVzcyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwiZ2V0RGVwbG95ZWRcIlxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2RlcGxveWVkUHJvbWlzZTtcbiAgICB9XG4gICAgLy8gQFRPRE86XG4gICAgLy8gZXN0aW1hdGVGYWxsYmFjayhvdmVycmlkZXM/OiBUcmFuc2FjdGlvblJlcXVlc3QpOiBQcm9taXNlPEJpZ051bWJlcj5cbiAgICAvLyBAVE9ETzpcbiAgICAvLyBlc3RpbWF0ZURlcGxveShieXRlY29kZTogc3RyaW5nLCAuLi5hcmdzKTogUHJvbWlzZTxCaWdOdW1iZXI+XG4gICAgZmFsbGJhY2sob3ZlcnJpZGVzKSB7XG4gICAgICAgIGlmICghdGhpcy5zaWduZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwic2VuZGluZyBhIHRyYW5zYWN0aW9ucyByZXF1aXJlIGEgc2lnbmVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJzZW5kVHJhbnNhY3Rpb24oZmFsbGJhY2spXCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHggPSBzaGFsbG93Q29weShvdmVycmlkZXMgfHwge30pO1xuICAgICAgICBbXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBrZXksIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjoga2V5IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgdHgudG8gPSB0aGlzLnJlc29sdmVkQWRkcmVzcztcbiAgICAgICAgcmV0dXJuIHRoaXMuZGVwbG95ZWQoKS50aGVuKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odHgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gUmVjb25uZWN0IHRvIGEgZGlmZmVyZW50IHNpZ25lciBvciBwcm92aWRlclxuICAgIGNvbm5lY3Qoc2lnbmVyT3JQcm92aWRlcikge1xuICAgICAgICBpZiAodHlwZW9mIChzaWduZXJPclByb3ZpZGVyKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgc2lnbmVyT3JQcm92aWRlciA9IG5ldyBWb2lkU2lnbmVyKHNpZ25lck9yUHJvdmlkZXIsIHRoaXMucHJvdmlkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKSh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBzaWduZXJPclByb3ZpZGVyKTtcbiAgICAgICAgaWYgKHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KGNvbnRyYWN0LCBcImRlcGxveVRyYW5zYWN0aW9uXCIsIHRoaXMuZGVwbG95VHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb250cmFjdDtcbiAgICB9XG4gICAgLy8gUmUtYXR0YWNoIHRvIGEgZGlmZmVyZW50IG9uLWNoYWluIGluc3RhbmNlIG9mIHRoaXMgY29udHJhY3RcbiAgICBhdHRhY2goYWRkcmVzc09yTmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3ICh0aGlzLmNvbnN0cnVjdG9yKShhZGRyZXNzT3JOYW1lLCB0aGlzLmludGVyZmFjZSwgdGhpcy5zaWduZXIgfHwgdGhpcy5wcm92aWRlcik7XG4gICAgfVxuICAgIHN0YXRpYyBpc0luZGV4ZWQodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEluZGV4ZWQuaXNJbmRleGVkKHZhbHVlKTtcbiAgICB9XG4gICAgX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChydW5uaW5nRXZlbnQpIHtcbiAgICAgICAgLy8gQWxyZWFkeSBoYXZlIGFuIGluc3RhbmNlIG9mIHRoaXMgZXZlbnQgcnVubmluZzsgd2UgY2FuIHJlLXVzZSBpdFxuICAgICAgICBpZiAodGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3J1bm5pbmdFdmVudHNbcnVubmluZ0V2ZW50LnRhZ107XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJ1bm5pbmdFdmVudDtcbiAgICB9XG4gICAgX2dldFJ1bm5pbmdFdmVudChldmVudE5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiAoZXZlbnROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBcImVycm9yXCIgZXZlbnRzIChpZiB5b3VyIGNvbnRyYWN0IGhhcyBhbiBlcnJvciBldmVudCwgaW5jbHVkZVxuICAgICAgICAgICAgLy8gdGhlIGZ1bGwgc2lnbmF0dXJlIHRvIGJ5cGFzcyB0aGlzIHNwZWNpYWwgZXZlbnQga2V5d29yZClcbiAgICAgICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiZXJyb3JcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IEVycm9yUnVubmluZ0V2ZW50KCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTGlzdGVuIGZvciBhbnkgZXZlbnQgdGhhdCBpcyByZWdpc3RlcmVkXG4gICAgICAgICAgICBpZiAoZXZlbnROYW1lID09PSBcImV2ZW50XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBSdW5uaW5nRXZlbnQoXCJldmVudFwiLCBudWxsKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBMaXN0ZW4gZm9yIGFueSBldmVudFxuICAgICAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCIqXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBXaWxkY2FyZFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGV2ZW50IEZyYWdtZW50ICh0aHJvd3MgaWYgYW1iaWd1b3VzL3Vua25vd24gZXZlbnQpXG4gICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBGcmFnbWVudFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBmcmFnbWVudCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFdlIGhhdmUgdG9waWNzIHRvIGZpbHRlciBieS4uLlxuICAgICAgICBpZiAoZXZlbnROYW1lLnRvcGljcyAmJiBldmVudE5hbWUudG9waWNzLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIC8vIElzIGl0IGEga25vd24gdG9waWNoYXNoPyAodGhyb3dzIGlmIG5vIG1hdGNoaW5nIHRvcGljaGFzaClcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdG9waWMgPSBldmVudE5hbWUudG9waWNzWzBdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHRvcGljKSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHRvcGljXCIpOyAvLyBAVE9ETzogTWF5IGhhcHBlbiBmb3IgYW5vbnltb3VzIGV2ZW50c1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBmcmFnbWVudCA9IHRoaXMuaW50ZXJmYWNlLmdldEV2ZW50KHRvcGljKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fbm9ybWFsaXplUnVubmluZ0V2ZW50KG5ldyBGcmFnbWVudFJ1bm5pbmdFdmVudCh0aGlzLmFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCBmcmFnbWVudCwgZXZlbnROYW1lLnRvcGljcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIC8vIEZpbHRlciBieSB0aGUgdW5rbm93biB0b3BpY2hhc2hcbiAgICAgICAgICAgIGNvbnN0IGZpbHRlciA9IHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgdG9waWNzOiBldmVudE5hbWUudG9waWNzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vcm1hbGl6ZVJ1bm5pbmdFdmVudChuZXcgUnVubmluZ0V2ZW50KGdldEV2ZW50VGFnKGZpbHRlciksIGZpbHRlcikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ub3JtYWxpemVSdW5uaW5nRXZlbnQobmV3IFdpbGRjYXJkUnVubmluZ0V2ZW50KHRoaXMuYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UpKTtcbiAgICB9XG4gICAgX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpIHtcbiAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5saXN0ZW5lckNvdW50KCkgPT09IDApIHtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9ydW5uaW5nRXZlbnRzW3J1bm5pbmdFdmVudC50YWddO1xuICAgICAgICAgICAgLy8gSWYgd2UgaGF2ZSBhIHBvbGxlciBmb3IgdGhpcywgcmVtb3ZlIGl0XG4gICAgICAgICAgICBjb25zdCBlbWl0ID0gdGhpcy5fd3JhcHBlZEVtaXRzW3J1bm5pbmdFdmVudC50YWddO1xuICAgICAgICAgICAgaWYgKGVtaXQgJiYgcnVubmluZ0V2ZW50LmZpbHRlcikge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub2ZmKHJ1bm5pbmdFdmVudC5maWx0ZXIsIGVtaXQpO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ107XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBncmFjZWZ1bGx5IHJlY292ZXJcbiAgICAvLyBmcm9tIHBhcnNlIGVycm9ycyBpZiB0aGV5IHdpc2hcbiAgICBfd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCwgbG9nLCBsaXN0ZW5lcikge1xuICAgICAgICBjb25zdCBldmVudCA9IGRlZXBDb3B5KGxvZyk7XG4gICAgICAgIGV2ZW50LnJlbW92ZUxpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFsaXN0ZW5lcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcbiAgICAgICAgfTtcbiAgICAgICAgZXZlbnQuZ2V0QmxvY2sgPSAoKSA9PiB7IHJldHVybiB0aGlzLnByb3ZpZGVyLmdldEJsb2NrKGxvZy5ibG9ja0hhc2gpOyB9O1xuICAgICAgICBldmVudC5nZXRUcmFuc2FjdGlvbiA9ICgpID0+IHsgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24obG9nLnRyYW5zYWN0aW9uSGFzaCk7IH07XG4gICAgICAgIGV2ZW50LmdldFRyYW5zYWN0aW9uUmVjZWlwdCA9ICgpID0+IHsgcmV0dXJuIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb25SZWNlaXB0KGxvZy50cmFuc2FjdGlvbkhhc2gpOyB9O1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdyBpZiB0aGUgdG9waWNzIGFuZCBkYXRhIG1pc21hdGNoIHRoZSBzaWduYXR1cmVcbiAgICAgICAgcnVubmluZ0V2ZW50LnByZXBhcmVFdmVudChldmVudCk7XG4gICAgICAgIHJldHVybiBldmVudDtcbiAgICB9XG4gICAgX2FkZEV2ZW50TGlzdGVuZXIocnVubmluZ0V2ZW50LCBsaXN0ZW5lciwgb25jZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZXZlbnRzIHJlcXVpcmUgYSBwcm92aWRlciBvciBhIHNpZ25lciB3aXRoIGEgcHJvdmlkZXJcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgb3BlcmF0aW9uOiBcIm9uY2VcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBydW5uaW5nRXZlbnQuYWRkTGlzdGVuZXIobGlzdGVuZXIsIG9uY2UpO1xuICAgICAgICAvLyBUcmFjayB0aGlzIHJ1bm5pbmcgZXZlbnQgYW5kIGl0cyBsaXN0ZW5lcnMgKG1heSBhbHJlYWR5IGJlIHRoZXJlOyBidXQgbm8gaGFyZCBpbiB1cGRhdGluZylcbiAgICAgICAgdGhpcy5fcnVubmluZ0V2ZW50c1tydW5uaW5nRXZlbnQudGFnXSA9IHJ1bm5pbmdFdmVudDtcbiAgICAgICAgLy8gSWYgd2UgYXJlIG5vdCBwb2xsaW5nIHRoZSBwcm92aWRlciwgc3RhcnQgcG9sbGluZ1xuICAgICAgICBpZiAoIXRoaXMuX3dyYXBwZWRFbWl0c1tydW5uaW5nRXZlbnQudGFnXSkge1xuICAgICAgICAgICAgY29uc3Qgd3JhcHBlZEVtaXQgPSAobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgbGV0IGV2ZW50ID0gdGhpcy5fd3JhcEV2ZW50KHJ1bm5pbmdFdmVudCwgbG9nLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRvIGVtaXQgdGhlIHJlc3VsdCBmb3IgdGhlIHBhcmFtZXRlcml6ZWQgZXZlbnQuLi5cbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVjb2RlRXJyb3IgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYXJncyA9IHJ1bm5pbmdFdmVudC5nZXRFbWl0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChydW5uaW5nRXZlbnQuZmlsdGVyLCAuLi5hcmdzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV2ZW50LmRlY29kZUVycm9yID0gZXJyb3IuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWx3YXlzIGVtaXQgXCJldmVudFwiIGZvciBmcmFnbWVudC1iYXNlIGV2ZW50c1xuICAgICAgICAgICAgICAgIGlmIChydW5uaW5nRXZlbnQuZmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZXZlbnRcIiwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBFbWl0IFwiZXJyb3JcIiBpZiB0aGVyZSB3YXMgYW4gZXJyb3JcbiAgICAgICAgICAgICAgICBpZiAoZXZlbnQuZGVjb2RlRXJyb3IgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBldmVudC5kZWNvZGVFcnJvciwgZXZlbnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl93cmFwcGVkRW1pdHNbcnVubmluZ0V2ZW50LnRhZ10gPSB3cmFwcGVkRW1pdDtcbiAgICAgICAgICAgIC8vIFNwZWNpYWwgZXZlbnRzLCBsaWtlIFwiZXJyb3JcIiBkbyBub3QgaGF2ZSBhIGZpbHRlclxuICAgICAgICAgICAgaWYgKHJ1bm5pbmdFdmVudC5maWx0ZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRoaXMucHJvdmlkZXIub24ocnVubmluZ0V2ZW50LmZpbHRlciwgd3JhcHBlZEVtaXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXJ5RmlsdGVyKGV2ZW50LCBmcm9tQmxvY2tPckJsb2NraGFzaCwgdG9CbG9jaykge1xuICAgICAgICBjb25zdCBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnQpO1xuICAgICAgICBjb25zdCBmaWx0ZXIgPSBzaGFsbG93Q29weShydW5uaW5nRXZlbnQuZmlsdGVyKTtcbiAgICAgICAgaWYgKHR5cGVvZiAoZnJvbUJsb2NrT3JCbG9ja2hhc2gpID09PSBcInN0cmluZ1wiICYmIGlzSGV4U3RyaW5nKGZyb21CbG9ja09yQmxvY2toYXNoLCAzMikpIHtcbiAgICAgICAgICAgIGlmICh0b0Jsb2NrICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiY2Fubm90IHNwZWNpZnkgdG9CbG9jayB3aXRoIGJsb2NraGFzaFwiLCBcInRvQmxvY2tcIiwgdG9CbG9jayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaWx0ZXIuYmxvY2tIYXNoID0gZnJvbUJsb2NrT3JCbG9ja2hhc2g7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaWx0ZXIuZnJvbUJsb2NrID0gKChmcm9tQmxvY2tPckJsb2NraGFzaCAhPSBudWxsKSA/IGZyb21CbG9ja09yQmxvY2toYXNoIDogMCk7XG4gICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9ICgodG9CbG9jayAhPSBudWxsKSA/IHRvQmxvY2sgOiBcImxhdGVzdFwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5nZXRMb2dzKGZpbHRlcikudGhlbigobG9ncykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ3MubWFwKChsb2cpID0+IHRoaXMuX3dyYXBFdmVudChydW5uaW5nRXZlbnQsIGxvZywgbnVsbCkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgb24oZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSwgbGlzdGVuZXIsIGZhbHNlKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uY2UoZXZlbnQsIGxpc3RlbmVyKSB7XG4gICAgICAgIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIodGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50KSwgbGlzdGVuZXIsIHRydWUpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgZW1pdChldmVudE5hbWUsIC4uLmFyZ3MpIHtcbiAgICAgICAgaWYgKCF0aGlzLnByb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmluZ0V2ZW50ID0gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IChydW5uaW5nRXZlbnQucnVuKGFyZ3MpID4gMCk7XG4gICAgICAgIC8vIE1heSBoYXZlIGRyYWluZWQgYWxsIHRoZSBcIm9uY2VcIiBldmVudHM7IGNoZWNrIGZvciBsaXZpbmcgZXZlbnRzXG4gICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBsaXN0ZW5lckNvdW50KGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiAwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX3J1bm5pbmdFdmVudHMpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bSArIHRoaXMuX3J1bm5pbmdFdmVudHNba2V5XS5saXN0ZW5lckNvdW50KCk7XG4gICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSkubGlzdGVuZXJDb3VudCgpO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIHRoaXMuX3J1bm5pbmdFdmVudHNbdGFnXS5saXN0ZW5lcnMoKS5mb3JFYWNoKChsaXN0ZW5lcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChsaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKS5saXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoIXRoaXMucHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGlmIChldmVudE5hbWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgZm9yIChjb25zdCB0YWcgaW4gdGhpcy5fcnVubmluZ0V2ZW50cykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJ1bm5pbmdFdmVudCA9IHRoaXMuX3J1bm5pbmdFdmVudHNbdGFnXTtcbiAgICAgICAgICAgICAgICBydW5uaW5nRXZlbnQucmVtb3ZlQWxsTGlzdGVuZXJzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fY2hlY2tSdW5uaW5nRXZlbnRzKHJ1bm5pbmdFdmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICAvLyBEZWxldGUgYW55IGxpc3RlbmVyc1xuICAgICAgICBjb25zdCBydW5uaW5nRXZlbnQgPSB0aGlzLl9nZXRSdW5uaW5nRXZlbnQoZXZlbnROYW1lKTtcbiAgICAgICAgcnVubmluZ0V2ZW50LnJlbW92ZUFsbExpc3RlbmVycygpO1xuICAgICAgICB0aGlzLl9jaGVja1J1bm5pbmdFdmVudHMocnVubmluZ0V2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9mZihldmVudE5hbWUsIGxpc3RlbmVyKSB7XG4gICAgICAgIGlmICghdGhpcy5wcm92aWRlcikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcnVubmluZ0V2ZW50ID0gdGhpcy5fZ2V0UnVubmluZ0V2ZW50KGV2ZW50TmFtZSk7XG4gICAgICAgIHJ1bm5pbmdFdmVudC5yZW1vdmVMaXN0ZW5lcihsaXN0ZW5lcik7XG4gICAgICAgIHRoaXMuX2NoZWNrUnVubmluZ0V2ZW50cyhydW5uaW5nRXZlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlTGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIENvbnRyYWN0IGV4dGVuZHMgQmFzZUNvbnRyYWN0IHtcbn1cbmV4cG9ydCBjbGFzcyBDb250cmFjdEZhY3Rvcnkge1xuICAgIGNvbnN0cnVjdG9yKGNvbnRyYWN0SW50ZXJmYWNlLCBieXRlY29kZSwgc2lnbmVyKSB7XG4gICAgICAgIGxldCBieXRlY29kZUhleCA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgKGJ5dGVjb2RlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBieXRlY29kZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc0J5dGVzKGJ5dGVjb2RlKSkge1xuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBoZXhsaWZ5KGJ5dGVjb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChieXRlY29kZSAmJiB0eXBlb2YgKGJ5dGVjb2RlLm9iamVjdCkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIC8vIEFsbG93IHRoZSBieXRlY29kZSBvYmplY3QgZnJvbSB0aGUgU29saWRpdHkgY29tcGlsZXJcbiAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gYnl0ZWNvZGUub2JqZWN0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gQ3Jhc2ggaW4gdGhlIG5leHQgdmVyaWZpY2F0aW9uIHN0ZXBcbiAgICAgICAgICAgIGJ5dGVjb2RlSGV4ID0gXCIhXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTWFrZSBzdXJlIGl0IGlzIDB4IHByZWZpeGVkXG4gICAgICAgIGlmIChieXRlY29kZUhleC5zdWJzdHJpbmcoMCwgMikgIT09IFwiMHhcIikge1xuICAgICAgICAgICAgYnl0ZWNvZGVIZXggPSBcIjB4XCIgKyBieXRlY29kZUhleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGZpbmFsIHJlc3VsdCBpcyB2YWxpZCBieXRlY29kZVxuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKGJ5dGVjb2RlSGV4KSB8fCAoYnl0ZWNvZGVIZXgubGVuZ3RoICUgMikpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVjb2RlXCIsIFwiYnl0ZWNvZGVcIiwgYnl0ZWNvZGUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBzaWduZXIsIG1ha2Ugc3VyZSBpdCBpcyB2YWxpZFxuICAgICAgICBpZiAoc2lnbmVyICYmICFTaWduZXIuaXNTaWduZXIoc2lnbmVyKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgc2lnbmVyXCIsIFwic2lnbmVyXCIsIHNpZ25lcik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJieXRlY29kZVwiLCBieXRlY29kZUhleCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW50ZXJmYWNlXCIsIGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldEludGVyZmFjZVwiKShjb250cmFjdEludGVyZmFjZSkpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInNpZ25lclwiLCBzaWduZXIgfHwgbnVsbCk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBGdXR1cmU7IHJlbmFtZSB0byBwb3B1bGF0ZVRyYW5zYWN0aW9uP1xuICAgIGdldERlcGxveVRyYW5zYWN0aW9uKC4uLmFyZ3MpIHtcbiAgICAgICAgbGV0IHR4ID0ge307XG4gICAgICAgIC8vIElmIHdlIGhhdmUgMSBhZGRpdGlvbmFsIGFyZ3VtZW50LCB3ZSBhbGxvdyB0cmFuc2FjdGlvbiBvdmVycmlkZXNcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCArIDEgJiYgdHlwZW9mIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICB0eCA9IHNoYWxsb3dDb3B5KGFyZ3MucG9wKCkpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWFsbG93ZWRUcmFuc2FjdGlvbktleXNba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bmtub3duIHRyYW5zYWN0aW9uIG92ZXJyaWRlIFwiICsga2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90IGFsbG93IHRoZXNlIHRvIGJlIG92ZXJyaWRkZW4gaW4gYSBkZXBsb3ltZW50IHRyYW5zYWN0aW9uXG4gICAgICAgIFtcImRhdGFcIiwgXCJmcm9tXCIsIFwidG9cIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICBpZiAodHhba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3Qgb3ZlcnJpZGUgXCIgKyBrZXksIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjoga2V5IH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHR4LnZhbHVlKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHR4LnZhbHVlKTtcbiAgICAgICAgICAgIGlmICghdmFsdWUuaXNaZXJvKCkgJiYgIXRoaXMuaW50ZXJmYWNlLmRlcGxveS5wYXlhYmxlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub24tcGF5YWJsZSBjb25zdHJ1Y3RvciBjYW5ub3Qgb3ZlcnJpZGUgdmFsdWVcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm92ZXJyaWRlcy52YWx1ZVwiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHgudmFsdWVcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBNYWtlIHN1cmUgdGhlIGNhbGwgbWF0Y2hlcyB0aGUgY29uc3RydWN0b3Igc2lnbmF0dXJlXG4gICAgICAgIGxvZ2dlci5jaGVja0FyZ3VtZW50Q291bnQoYXJncy5sZW5ndGgsIHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMubGVuZ3RoLCBcIiBpbiBDb250cmFjdCBjb25zdHJ1Y3RvclwiKTtcbiAgICAgICAgLy8gU2V0IHRoZSBkYXRhIHRvIHRoZSBieXRlY29kZSArIHRoZSBlbmNvZGVkIGNvbnN0cnVjdG9yIGFyZ3VtZW50c1xuICAgICAgICB0eC5kYXRhID0gaGV4bGlmeShjb25jYXQoW1xuICAgICAgICAgICAgdGhpcy5ieXRlY29kZSxcbiAgICAgICAgICAgIHRoaXMuaW50ZXJmYWNlLmVuY29kZURlcGxveShhcmdzKVxuICAgICAgICBdKSk7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgZGVwbG95KC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBvdmVycmlkZXMgPSB7fTtcbiAgICAgICAgICAgIC8vIElmIDEgZXh0cmEgcGFyYW1ldGVyIHdhcyBwYXNzZWQgaW4sIGl0IGNvbnRhaW5zIG92ZXJyaWRlc1xuICAgICAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSB0aGlzLmludGVyZmFjZS5kZXBsb3kuaW5wdXRzLmxlbmd0aCArIDEpIHtcbiAgICAgICAgICAgICAgICBvdmVycmlkZXMgPSBhcmdzLnBvcCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBjYWxsIG1hdGNoZXMgdGhlIGNvbnN0cnVjdG9yIHNpZ25hdHVyZVxuICAgICAgICAgICAgbG9nZ2VyLmNoZWNrQXJndW1lbnRDb3VudChhcmdzLmxlbmd0aCwgdGhpcy5pbnRlcmZhY2UuZGVwbG95LmlucHV0cy5sZW5ndGgsIFwiIGluIENvbnRyYWN0IGNvbnN0cnVjdG9yXCIpO1xuICAgICAgICAgICAgLy8gUmVzb2x2ZSBFTlMgbmFtZXMgYW5kIHByb21pc2VzIGluIHRoZSBhcmd1bWVudHNcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVBZGRyZXNzZXModGhpcy5zaWduZXIsIGFyZ3MsIHRoaXMuaW50ZXJmYWNlLmRlcGxveS5pbnB1dHMpO1xuICAgICAgICAgICAgcGFyYW1zLnB1c2gob3ZlcnJpZGVzKTtcbiAgICAgICAgICAgIC8vIEdldCB0aGUgZGVwbG95bWVudCB0cmFuc2FjdGlvbiAod2l0aCBvcHRpb25hbCBvdmVycmlkZXMpXG4gICAgICAgICAgICBjb25zdCB1bnNpZ25lZFR4ID0gdGhpcy5nZXREZXBsb3lUcmFuc2FjdGlvbiguLi5wYXJhbXMpO1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgZGVwbG95bWVudCB0cmFuc2FjdGlvblxuICAgICAgICAgICAgY29uc3QgdHggPSB5aWVsZCB0aGlzLnNpZ25lci5zZW5kVHJhbnNhY3Rpb24odW5zaWduZWRUeCk7XG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0Q29udHJhY3RBZGRyZXNzXCIpKHR4KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRyYWN0ID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0Q29udHJhY3RcIikoYWRkcmVzcywgdGhpcy5pbnRlcmZhY2UsIHRoaXMuc2lnbmVyKTtcbiAgICAgICAgICAgIC8vIEFkZCB0aGUgbW9kaWZpZWQgd2FpdCB0aGF0IHdyYXBzIGV2ZW50c1xuICAgICAgICAgICAgYWRkQ29udHJhY3RXYWl0KGNvbnRyYWN0LCB0eCk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seShjb250cmFjdCwgXCJkZXBsb3lUcmFuc2FjdGlvblwiLCB0eCk7XG4gICAgICAgICAgICByZXR1cm4gY29udHJhY3Q7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhdHRhY2goYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gKHRoaXMuY29uc3RydWN0b3IpLmdldENvbnRyYWN0KGFkZHJlc3MsIHRoaXMuaW50ZXJmYWNlLCB0aGlzLnNpZ25lcik7XG4gICAgfVxuICAgIGNvbm5lY3Qoc2lnbmVyKSB7XG4gICAgICAgIHJldHVybiBuZXcgKHRoaXMuY29uc3RydWN0b3IpKHRoaXMuaW50ZXJmYWNlLCB0aGlzLmJ5dGVjb2RlLCBzaWduZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbVNvbGlkaXR5KGNvbXBpbGVyT3V0cHV0LCBzaWduZXIpIHtcbiAgICAgICAgaWYgKGNvbXBpbGVyT3V0cHV0ID09IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibWlzc2luZyBjb21waWxlciBvdXRwdXRcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX0FSR1VNRU5ULCB7IGFyZ3VtZW50OiBcImNvbXBpbGVyT3V0cHV0XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoY29tcGlsZXJPdXRwdXQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb21waWxlck91dHB1dCA9IEpTT04ucGFyc2UoY29tcGlsZXJPdXRwdXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFiaSA9IGNvbXBpbGVyT3V0cHV0LmFiaTtcbiAgICAgICAgbGV0IGJ5dGVjb2RlID0gbnVsbDtcbiAgICAgICAgaWYgKGNvbXBpbGVyT3V0cHV0LmJ5dGVjb2RlKSB7XG4gICAgICAgICAgICBieXRlY29kZSA9IGNvbXBpbGVyT3V0cHV0LmJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNvbXBpbGVyT3V0cHV0LmV2bSAmJiBjb21waWxlck91dHB1dC5ldm0uYnl0ZWNvZGUpIHtcbiAgICAgICAgICAgIGJ5dGVjb2RlID0gY29tcGlsZXJPdXRwdXQuZXZtLmJ5dGVjb2RlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgdGhpcyhhYmksIGJ5dGVjb2RlLCBzaWduZXIpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0SW50ZXJmYWNlKGNvbnRyYWN0SW50ZXJmYWNlKSB7XG4gICAgICAgIHJldHVybiBDb250cmFjdC5nZXRJbnRlcmZhY2UoY29udHJhY3RJbnRlcmZhY2UpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q29udHJhY3RBZGRyZXNzKHR4KSB7XG4gICAgICAgIHJldHVybiBnZXRDb250cmFjdEFkZHJlc3ModHgpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0Q29udHJhY3QoYWRkcmVzcywgY29udHJhY3RJbnRlcmZhY2UsIHNpZ25lcikge1xuICAgICAgICByZXR1cm4gbmV3IENvbnRyYWN0KGFkZHJlc3MsIGNvbnRyYWN0SW50ZXJmYWNlLCBzaWduZXIpO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJoYXNoLzUuNS4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJpbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5leHBvcnQgZnVuY3Rpb24gaWQodGV4dCkge1xuICAgIHJldHVybiBrZWNjYWsyNTYodG9VdGY4Qnl0ZXModGV4dCkpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCIuL2lkXCI7XG5pbXBvcnQgeyBpc1ZhbGlkTmFtZSwgbmFtZWhhc2ggfSBmcm9tIFwiLi9uYW1laGFzaFwiO1xuaW1wb3J0IHsgaGFzaE1lc3NhZ2UsIG1lc3NhZ2VQcmVmaXggfSBmcm9tIFwiLi9tZXNzYWdlXCI7XG5pbXBvcnQgeyBUeXBlZERhdGFFbmNvZGVyIGFzIF9UeXBlZERhdGFFbmNvZGVyIH0gZnJvbSBcIi4vdHlwZWQtZGF0YVwiO1xuZXhwb3J0IHsgaWQsIG5hbWVoYXNoLCBpc1ZhbGlkTmFtZSwgbWVzc2FnZVByZWZpeCwgaGFzaE1lc3NhZ2UsIF9UeXBlZERhdGFFbmNvZGVyLCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiaW1wb3J0IHsgY29uY2F0IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5leHBvcnQgY29uc3QgbWVzc2FnZVByZWZpeCA9IFwiXFx4MTlFdGhlcmV1bSBTaWduZWQgTWVzc2FnZTpcXG5cIjtcbmV4cG9ydCBmdW5jdGlvbiBoYXNoTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgaWYgKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbWVzc2FnZSA9IHRvVXRmOEJ5dGVzKG1lc3NhZ2UpO1xuICAgIH1cbiAgICByZXR1cm4ga2VjY2FrMjU2KGNvbmNhdChbXG4gICAgICAgIHRvVXRmOEJ5dGVzKG1lc3NhZ2VQcmVmaXgpLFxuICAgICAgICB0b1V0ZjhCeXRlcyhTdHJpbmcobWVzc2FnZS5sZW5ndGgpKSxcbiAgICAgICAgbWVzc2FnZVxuICAgIF0pKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lc3NhZ2UuanMubWFwIiwiaW1wb3J0IHsgY29uY2F0LCBoZXhsaWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBuYW1lcHJlcCwgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuY29uc3QgWmVyb3MgPSBuZXcgVWludDhBcnJheSgzMik7XG5aZXJvcy5maWxsKDApO1xuY29uc3QgUGFydGl0aW9uID0gbmV3IFJlZ0V4cChcIl4oKC4qKVxcXFwuKT8oW14uXSspJFwiKTtcbmV4cG9ydCBmdW5jdGlvbiBpc1ZhbGlkTmFtZShuYW1lKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgY29tcHMgPSBuYW1lLnNwbGl0KFwiLlwiKTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjb21wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKG5hbWVwcmVwKGNvbXBzW2ldKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbXB0eVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICByZXR1cm4gZmFsc2U7XG59XG5leHBvcnQgZnVuY3Rpb24gbmFtZWhhc2gobmFtZSkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBuYW1lOyBub3QgYSBzdHJpbmdcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgIH1cbiAgICBsZXQgY3VycmVudCA9IG5hbWU7XG4gICAgbGV0IHJlc3VsdCA9IFplcm9zO1xuICAgIHdoaWxlIChjdXJyZW50Lmxlbmd0aCkge1xuICAgICAgICBjb25zdCBwYXJ0aXRpb24gPSBjdXJyZW50Lm1hdGNoKFBhcnRpdGlvbik7XG4gICAgICAgIGlmIChwYXJ0aXRpb24gPT0gbnVsbCB8fCBwYXJ0aXRpb25bMl0gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIEVOUyBhZGRyZXNzOyBtaXNzaW5nIGNvbXBvbmVudFwiLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFiZWwgPSB0b1V0ZjhCeXRlcyhuYW1lcHJlcChwYXJ0aXRpb25bM10pKTtcbiAgICAgICAgcmVzdWx0ID0ga2VjY2FrMjU2KGNvbmNhdChbcmVzdWx0LCBrZWNjYWsyNTYobGFiZWwpXSkpO1xuICAgICAgICBjdXJyZW50ID0gcGFydGl0aW9uWzJdIHx8IFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1uYW1laGFzaC5qcy5tYXAiLCJ2YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleENvbmNhdCwgaGV4bGlmeSwgaGV4WmVyb1BhZCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IGRlZXBDb3B5LCBkZWZpbmVSZWFkT25seSwgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgaWQgfSBmcm9tIFwiLi9pZFwiO1xuY29uc3QgcGFkZGluZyA9IG5ldyBVaW50OEFycmF5KDMyKTtcbnBhZGRpbmcuZmlsbCgwKTtcbmNvbnN0IE5lZ2F0aXZlT25lID0gQmlnTnVtYmVyLmZyb20oLTEpO1xuY29uc3QgWmVybyA9IEJpZ051bWJlci5mcm9tKDApO1xuY29uc3QgT25lID0gQmlnTnVtYmVyLmZyb20oMSk7XG5jb25zdCBNYXhVaW50MjU2ID0gQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZcIik7XG5mdW5jdGlvbiBoZXhQYWRSaWdodCh2YWx1ZSkge1xuICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkodmFsdWUpO1xuICAgIGNvbnN0IHBhZE9mZnNldCA9IGJ5dGVzLmxlbmd0aCAlIDMyO1xuICAgIGlmIChwYWRPZmZzZXQpIHtcbiAgICAgICAgcmV0dXJuIGhleENvbmNhdChbYnl0ZXMsIHBhZGRpbmcuc2xpY2UocGFkT2Zmc2V0KV0pO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG59XG5jb25zdCBoZXhUcnVlID0gaGV4WmVyb1BhZChPbmUudG9IZXhTdHJpbmcoKSwgMzIpO1xuY29uc3QgaGV4RmFsc2UgPSBoZXhaZXJvUGFkKFplcm8udG9IZXhTdHJpbmcoKSwgMzIpO1xuY29uc3QgZG9tYWluRmllbGRUeXBlcyA9IHtcbiAgICBuYW1lOiBcInN0cmluZ1wiLFxuICAgIHZlcnNpb246IFwic3RyaW5nXCIsXG4gICAgY2hhaW5JZDogXCJ1aW50MjU2XCIsXG4gICAgdmVyaWZ5aW5nQ29udHJhY3Q6IFwiYWRkcmVzc1wiLFxuICAgIHNhbHQ6IFwiYnl0ZXMzMlwiXG59O1xuY29uc3QgZG9tYWluRmllbGROYW1lcyA9IFtcbiAgICBcIm5hbWVcIiwgXCJ2ZXJzaW9uXCIsIFwiY2hhaW5JZFwiLCBcInZlcmlmeWluZ0NvbnRyYWN0XCIsIFwic2FsdFwiXG5dO1xuZnVuY3Rpb24gY2hlY2tTdHJpbmcoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgZG9tYWluIHZhbHVlIGZvciAke0pTT04uc3RyaW5naWZ5KGtleSl9YCwgYGRvbWFpbi4ke2tleX1gLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG59XG5jb25zdCBkb21haW5DaGVja3MgPSB7XG4gICAgbmFtZTogY2hlY2tTdHJpbmcoXCJuYW1lXCIpLFxuICAgIHZlcnNpb246IGNoZWNrU3RyaW5nKFwidmVyc2lvblwiKSxcbiAgICBjaGFpbklkOiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBkb21haW4gdmFsdWUgZm9yIFwiY2hhaW5JZFwiYCwgXCJkb21haW4uY2hhaW5JZFwiLCB2YWx1ZSk7XG4gICAgfSxcbiAgICB2ZXJpZnlpbmdDb250cmFjdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBkb21haW4gdmFsdWUgXCJ2ZXJpZnlpbmdDb250cmFjdFwiYCwgXCJkb21haW4udmVyaWZ5aW5nQ29udHJhY3RcIiwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2FsdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBieXRlcyA9IGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDMyKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmFkIGxlbmd0aFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGJ5dGVzKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBkb21haW4gdmFsdWUgXCJzYWx0XCJgLCBcImRvbWFpbi5zYWx0XCIsIHZhbHVlKTtcbiAgICB9XG59O1xuZnVuY3Rpb24gZ2V0QmFzZUVuY29kZXIodHlwZSkge1xuICAgIC8vIGludFhYIGFuZCB1aW50WFhcbiAgICB7XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXih1PylpbnQoXFxkKikkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc2lnbmVkID0gKG1hdGNoWzFdID09PSBcIlwiKTtcbiAgICAgICAgICAgIGNvbnN0IHdpZHRoID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgICAgICBpZiAod2lkdGggJSA4ICE9PSAwIHx8IHdpZHRoID4gMjU2IHx8IChtYXRjaFsyXSAmJiBtYXRjaFsyXSAhPT0gU3RyaW5nKHdpZHRoKSkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBudW1lcmljIHdpZHRoXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGJvdW5kc1VwcGVyID0gTWF4VWludDI1Ni5tYXNrKHNpZ25lZCA/ICh3aWR0aCAtIDEpIDogd2lkdGgpO1xuICAgICAgICAgICAgY29uc3QgYm91bmRzTG93ZXIgPSBzaWduZWQgPyBib3VuZHNVcHBlci5hZGQoT25lKS5tdWwoTmVnYXRpdmVPbmUpIDogWmVybztcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2ID0gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmICh2Lmx0KGJvdW5kc0xvd2VyKSB8fCB2Lmd0KGJvdW5kc1VwcGVyKSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGB2YWx1ZSBvdXQtb2YtYm91bmRzIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhaZXJvUGFkKHYudG9Ud29zKDI1NikudG9IZXhTdHJpbmcoKSwgMzIpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBieXRlc1hYXG4gICAge1xuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL15ieXRlcyhcXGQrKSQvKTtcbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICBjb25zdCB3aWR0aCA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgICAgIGlmICh3aWR0aCA9PT0gMCB8fCB3aWR0aCA+IDMyIHx8IG1hdGNoWzFdICE9PSBTdHJpbmcod2lkdGgpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYnl0ZXMgd2lkdGhcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IHdpZHRoKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgbGVuZ3RoIGZvciAke3R5cGV9YCwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBoZXhQYWRSaWdodCh2YWx1ZSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4WmVyb1BhZChnZXRBZGRyZXNzKHZhbHVlKSwgMzIpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiYm9vbFwiOiByZXR1cm4gZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICByZXR1cm4gKCghdmFsdWUpID8gaGV4RmFsc2UgOiBoZXhUcnVlKTtcbiAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImJ5dGVzXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYodmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBjYXNlIFwic3RyaW5nXCI6IHJldHVybiBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybiBpZCh2YWx1ZSk7XG4gICAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gZW5jb2RlVHlwZShuYW1lLCBmaWVsZHMpIHtcbiAgICByZXR1cm4gYCR7bmFtZX0oJHtmaWVsZHMubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4gKHR5cGUgKyBcIiBcIiArIG5hbWUpKS5qb2luKFwiLFwiKX0pYDtcbn1cbmV4cG9ydCBjbGFzcyBUeXBlZERhdGFFbmNvZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcih0eXBlcykge1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInR5cGVzXCIsIE9iamVjdC5mcmVlemUoZGVlcENvcHkodHlwZXMpKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2VuY29kZXJDYWNoZVwiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3R5cGVzXCIsIHt9KTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3QgdHlwZXMgdG8gdGhlaXIgZGlyZWN0IGNoaWxkIHN0cnVjdHNcbiAgICAgICAgY29uc3QgbGlua3MgPSB7fTtcbiAgICAgICAgLy8gTGluayBzdHJ1Y3RzIHRvIHN0cnVjdHMgd2hpY2ggY29udGFpbiB0aGVtIGFzIGEgY2hpbGRcbiAgICAgICAgY29uc3QgcGFyZW50cyA9IHt9O1xuICAgICAgICAvLyBMaW5rIGFsbCBzdWJ0eXBlcyB3aXRoaW4gYSBnaXZlbiBzdHJ1Y3RcbiAgICAgICAgY29uc3Qgc3VidHlwZXMgPSB7fTtcbiAgICAgICAgT2JqZWN0LmtleXModHlwZXMpLmZvckVhY2goKHR5cGUpID0+IHtcbiAgICAgICAgICAgIGxpbmtzW3R5cGVdID0ge307XG4gICAgICAgICAgICBwYXJlbnRzW3R5cGVdID0gW107XG4gICAgICAgICAgICBzdWJ0eXBlc1t0eXBlXSA9IHt9O1xuICAgICAgICB9KTtcbiAgICAgICAgZm9yIChjb25zdCBuYW1lIGluIHR5cGVzKSB7XG4gICAgICAgICAgICBjb25zdCB1bmlxdWVOYW1lcyA9IHt9O1xuICAgICAgICAgICAgdHlwZXNbbmFtZV0uZm9yRWFjaCgoZmllbGQpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBDaGVjayBlYWNoIGZpZWxkIGhhcyBhIHVuaXF1ZSBuYW1lXG4gICAgICAgICAgICAgICAgaWYgKHVuaXF1ZU5hbWVzW2ZpZWxkLm5hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGR1cGxpY2F0ZSB2YXJpYWJsZSBuYW1lICR7SlNPTi5zdHJpbmdpZnkoZmllbGQubmFtZSl9IGluICR7SlNPTi5zdHJpbmdpZnkobmFtZSl9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHVuaXF1ZU5hbWVzW2ZpZWxkLm5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIGJhc2UgdHlwZSAoZHJvcCBhbnkgYXJyYXkgc3BlY2lmaWVycylcbiAgICAgICAgICAgICAgICBjb25zdCBiYXNlVHlwZSA9IGZpZWxkLnR5cGUubWF0Y2goL14oW15cXHg1Yl0qKShcXHg1YnwkKS8pWzFdO1xuICAgICAgICAgICAgICAgIGlmIChiYXNlVHlwZSA9PT0gbmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZSB0byAke0pTT04uc3RyaW5naWZ5KGJhc2VUeXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gSXMgdGhpcyBhIGJhc2UgZW5jb2RpbmcgdHlwZT9cbiAgICAgICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIoYmFzZVR5cGUpO1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwYXJlbnRzW2Jhc2VUeXBlXSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGB1bmtub3duIHR5cGUgJHtKU09OLnN0cmluZ2lmeShiYXNlVHlwZSl9YCwgXCJ0eXBlc1wiLCB0eXBlcyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIEFkZCBsaW5rYWdlXG4gICAgICAgICAgICAgICAgcGFyZW50c1tiYXNlVHlwZV0ucHVzaChuYW1lKTtcbiAgICAgICAgICAgICAgICBsaW5rc1tuYW1lXVtiYXNlVHlwZV0gPSB0cnVlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRGVkdWNlIHRoZSBwcmltYXJ5IHR5cGVcbiAgICAgICAgY29uc3QgcHJpbWFyeVR5cGVzID0gT2JqZWN0LmtleXMocGFyZW50cykuZmlsdGVyKChuKSA9PiAocGFyZW50c1tuXS5sZW5ndGggPT09IDApKTtcbiAgICAgICAgaWYgKHByaW1hcnlUeXBlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtaXNzaW5nIHByaW1hcnkgdHlwZVwiLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChwcmltYXJ5VHlwZXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgYW1iaWd1b3VzIHByaW1hcnkgdHlwZXMgb3IgdW51c2VkIHR5cGVzOiAke3ByaW1hcnlUeXBlcy5tYXAoKHQpID0+IChKU09OLnN0cmluZ2lmeSh0KSkpLmpvaW4oXCIsIFwiKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByaW1hcnlUeXBlXCIsIHByaW1hcnlUeXBlc1swXSk7XG4gICAgICAgIC8vIENoZWNrIGZvciBjaXJjdWxhciB0eXBlIHJlZmVyZW5jZXNcbiAgICAgICAgZnVuY3Rpb24gY2hlY2tDaXJjdWxhcih0eXBlLCBmb3VuZCkge1xuICAgICAgICAgICAgaWYgKGZvdW5kW3R5cGVdKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgY2lyY3VsYXIgdHlwZSByZWZlcmVuY2UgdG8gJHtKU09OLnN0cmluZ2lmeSh0eXBlKX1gLCBcInR5cGVzXCIsIHR5cGVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kW3R5cGVdID0gdHJ1ZTtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGxpbmtzW3R5cGVdKS5mb3JFYWNoKChjaGlsZCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghcGFyZW50c1tjaGlsZF0pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBjaGVjayBjaGlsZHJlblxuICAgICAgICAgICAgICAgIGNoZWNrQ2lyY3VsYXIoY2hpbGQsIGZvdW5kKTtcbiAgICAgICAgICAgICAgICAvLyBNYXJrIGFsbCBhbmNlc3RvcnMgYXMgaGF2aW5nIHRoaXMgZGVjZW5kYW50XG4gICAgICAgICAgICAgICAgT2JqZWN0LmtleXMoZm91bmQpLmZvckVhY2goKHN1YnR5cGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZXNbc3VidHlwZV1bY2hpbGRdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgZGVsZXRlIGZvdW5kW3R5cGVdO1xuICAgICAgICB9XG4gICAgICAgIGNoZWNrQ2lyY3VsYXIodGhpcy5wcmltYXJ5VHlwZSwge30pO1xuICAgICAgICAvLyBDb21wdXRlIGVhY2ggZnVsbHkgZGVzY3JpYmUgdHlwZVxuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gc3VidHlwZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0ID0gT2JqZWN0LmtleXMoc3VidHlwZXNbbmFtZV0pO1xuICAgICAgICAgICAgc3Quc29ydCgpO1xuICAgICAgICAgICAgdGhpcy5fdHlwZXNbbmFtZV0gPSBlbmNvZGVUeXBlKG5hbWUsIHR5cGVzW25hbWVdKSArIHN0Lm1hcCgodCkgPT4gZW5jb2RlVHlwZSh0LCB0eXBlc1t0XSkpLmpvaW4oXCJcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIGxldCBlbmNvZGVyID0gdGhpcy5fZW5jb2RlckNhY2hlW3R5cGVdO1xuICAgICAgICBpZiAoIWVuY29kZXIpIHtcbiAgICAgICAgICAgIGVuY29kZXIgPSB0aGlzLl9lbmNvZGVyQ2FjaGVbdHlwZV0gPSB0aGlzLl9nZXRFbmNvZGVyKHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgIH1cbiAgICBfZ2V0RW5jb2Rlcih0eXBlKSB7XG4gICAgICAgIC8vIEJhc2ljIGVuY29kZXIgdHlwZSAoYWRkcmVzcywgYm9vbCwgdWludDI1NiwgZXRjKVxuICAgICAgICB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVyID0gZ2V0QmFzZUVuY29kZXIodHlwZSk7XG4gICAgICAgICAgICBpZiAoZW5jb2Rlcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBlbmNvZGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIEFycmF5XG4gICAgICAgIGNvbnN0IG1hdGNoID0gdHlwZS5tYXRjaCgvXiguKikoXFx4NWIoXFxkKilcXHg1ZCkkLyk7XG4gICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgY29uc3Qgc3VidHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgY29uc3Qgc3ViRW5jb2RlciA9IHRoaXMuZ2V0RW5jb2RlcihzdWJ0eXBlKTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzNdKTtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobGVuZ3RoID49IDAgJiYgdmFsdWUubGVuZ3RoICE9PSBsZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImFycmF5IGxlbmd0aCBtaXNtYXRjaDsgZXhwZWN0ZWQgbGVuZ3RoICR7IGFycmF5TGVuZ3RoIH1cIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCByZXN1bHQgPSB2YWx1ZS5tYXAoc3ViRW5jb2Rlcik7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX3R5cGVzW3N1YnR5cGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5tYXAoa2VjY2FrMjU2KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGtlY2NhazI1NihoZXhDb25jYXQocmVzdWx0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIC8vIFN0cnVjdFxuICAgICAgICBjb25zdCBmaWVsZHMgPSB0aGlzLnR5cGVzW3R5cGVdO1xuICAgICAgICBpZiAoZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBlbmNvZGVkVHlwZSA9IGlkKHRoaXMuX3R5cGVzW3R5cGVdKTtcbiAgICAgICAgICAgIHJldHVybiAodmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBmaWVsZHMubWFwKCh7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLmdldEVuY29kZXIodHlwZSkodmFsdWVbbmFtZV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fdHlwZXNbdHlwZV0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBrZWNjYWsyNTYocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHZhbHVlcy51bnNoaWZ0KGVuY29kZWRUeXBlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGV4Q29uY2F0KHZhbHVlcyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGB1bmtub3duIHR5cGU6ICR7dHlwZX1gLCBcInR5cGVcIiwgdHlwZSk7XG4gICAgfVxuICAgIGVuY29kZVR5cGUobmFtZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl90eXBlc1tuYW1lXTtcbiAgICAgICAgaWYgKCFyZXN1bHQpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZTogJHtKU09OLnN0cmluZ2lmeShuYW1lKX1gLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgZW5jb2RlRGF0YSh0eXBlLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRFbmNvZGVyKHR5cGUpKHZhbHVlKTtcbiAgICB9XG4gICAgaGFzaFN0cnVjdChuYW1lLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KHRoaXMuZW5jb2RlRGF0YShuYW1lLCB2YWx1ZSkpO1xuICAgIH1cbiAgICBlbmNvZGUodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZW5jb2RlRGF0YSh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIGhhc2godmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuaGFzaFN0cnVjdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSk7XG4gICAgfVxuICAgIF92aXNpdCh0eXBlLCB2YWx1ZSwgY2FsbGJhY2spIHtcbiAgICAgICAgLy8gQmFzaWMgZW5jb2RlciB0eXBlIChhZGRyZXNzLCBib29sLCB1aW50MjU2LCBldGMpXG4gICAgICAgIHtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kZXIgPSBnZXRCYXNlRW5jb2Rlcih0eXBlKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHR5cGUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBBcnJheVxuICAgICAgICBjb25zdCBtYXRjaCA9IHR5cGUubWF0Y2goL14oLiopKFxceDViKFxcZCopXFx4NWQpJC8pO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIGNvbnN0IHN1YnR5cGUgPSBtYXRjaFsxXTtcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IHBhcnNlSW50KG1hdGNoWzNdKTtcbiAgICAgICAgICAgIGlmIChsZW5ndGggPj0gMCAmJiB2YWx1ZS5sZW5ndGggIT09IGxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhcnJheSBsZW5ndGggbWlzbWF0Y2g7IGV4cGVjdGVkIGxlbmd0aCAkeyBhcnJheUxlbmd0aCB9XCIsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlLm1hcCgodikgPT4gdGhpcy5fdmlzaXQoc3VidHlwZSwgdiwgY2FsbGJhY2spKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBTdHJ1Y3RcbiAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy50eXBlc1t0eXBlXTtcbiAgICAgICAgaWYgKGZpZWxkcykge1xuICAgICAgICAgICAgcmV0dXJuIGZpZWxkcy5yZWR1Y2UoKGFjY3VtLCB7IG5hbWUsIHR5cGUgfSkgPT4ge1xuICAgICAgICAgICAgICAgIGFjY3VtW25hbWVdID0gdGhpcy5fdmlzaXQodHlwZSwgdmFsdWVbbmFtZV0sIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgICAgICB9LCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYHVua25vd24gdHlwZTogJHt0eXBlfWAsIFwidHlwZVwiLCB0eXBlKTtcbiAgICB9XG4gICAgdmlzaXQodmFsdWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl92aXNpdCh0aGlzLnByaW1hcnlUeXBlLCB2YWx1ZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbSh0eXBlcykge1xuICAgICAgICByZXR1cm4gbmV3IFR5cGVkRGF0YUVuY29kZXIodHlwZXMpO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0UHJpbWFyeVR5cGUodHlwZXMpIHtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcykucHJpbWFyeVR5cGU7XG4gICAgfVxuICAgIHN0YXRpYyBoYXNoU3RydWN0KG5hbWUsIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gVHlwZWREYXRhRW5jb2Rlci5mcm9tKHR5cGVzKS5oYXNoU3RydWN0KG5hbWUsIHZhbHVlKTtcbiAgICB9XG4gICAgc3RhdGljIGhhc2hEb21haW4oZG9tYWluKSB7XG4gICAgICAgIGNvbnN0IGRvbWFpbkZpZWxkcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZG9tYWluKSB7XG4gICAgICAgICAgICBjb25zdCB0eXBlID0gZG9tYWluRmllbGRUeXBlc1tuYW1lXTtcbiAgICAgICAgICAgIGlmICghdHlwZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgdHlwZWQtZGF0YSBkb21haW4ga2V5OiAke0pTT04uc3RyaW5naWZ5KG5hbWUpfWAsIFwiZG9tYWluXCIsIGRvbWFpbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkb21haW5GaWVsZHMucHVzaCh7IG5hbWUsIHR5cGUgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9tYWluRmllbGRzLnNvcnQoKGEsIGIpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBkb21haW5GaWVsZE5hbWVzLmluZGV4T2YoYS5uYW1lKSAtIGRvbWFpbkZpZWxkTmFtZXMuaW5kZXhPZihiLm5hbWUpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIFR5cGVkRGF0YUVuY29kZXIuaGFzaFN0cnVjdChcIkVJUDcxMkRvbWFpblwiLCB7IEVJUDcxMkRvbWFpbjogZG9tYWluRmllbGRzIH0sIGRvbWFpbik7XG4gICAgfVxuICAgIHN0YXRpYyBlbmNvZGUoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGhleENvbmNhdChbXG4gICAgICAgICAgICBcIjB4MTkwMVwiLFxuICAgICAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbiksXG4gICAgICAgICAgICBUeXBlZERhdGFFbmNvZGVyLmZyb20odHlwZXMpLmhhc2godmFsdWUpXG4gICAgICAgIF0pO1xuICAgIH1cbiAgICBzdGF0aWMgaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4ga2VjY2FrMjU2KFR5cGVkRGF0YUVuY29kZXIuZW5jb2RlKGRvbWFpbiwgdHlwZXMsIHZhbHVlKSk7XG4gICAgfVxuICAgIC8vIFJlcGxhY2VzIGFsbCBhZGRyZXNzIHR5cGVzIHdpdGggRU5TIG5hbWVzIHdpdGggdGhlaXIgbG9va2VkIHVwIGFkZHJlc3NcbiAgICBzdGF0aWMgcmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCByZXNvbHZlTmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gTWFrZSBhIGNvcHkgdG8gaXNvbGF0ZSBpdCBmcm9tIHRoZSBvYmplY3QgcGFzc2VkIGluXG4gICAgICAgICAgICBkb21haW4gPSBzaGFsbG93Q29weShkb21haW4pO1xuICAgICAgICAgICAgLy8gTG9vayB1cCBhbGwgRU5TIG5hbWVzXG4gICAgICAgICAgICBjb25zdCBlbnNDYWNoZSA9IHt9O1xuICAgICAgICAgICAgLy8gRG8gd2UgbmVlZCB0byBsb29rIHVwIHRoZSBkb21haW4ncyB2ZXJpZnlpbmdDb250cmFjdD9cbiAgICAgICAgICAgIGlmIChkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgJiYgIWlzSGV4U3RyaW5nKGRvbWFpbi52ZXJpZnlpbmdDb250cmFjdCwgMjApKSB7XG4gICAgICAgICAgICAgICAgZW5zQ2FjaGVbZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0XSA9IFwiMHhcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIGFyZSBnb2luZyB0byB1c2UgdGhlIGVuY29kZXIgdG8gdmlzaXQgYWxsIHRoZSBiYXNlIHZhbHVlc1xuICAgICAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgICAgICAvLyBHZXQgYSBsaXN0IG9mIGFsbCB0aGUgYWRkcmVzc2VzXG4gICAgICAgICAgICBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgIWlzSGV4U3RyaW5nKHZhbHVlLCAyMCkpIHtcbiAgICAgICAgICAgICAgICAgICAgZW5zQ2FjaGVbdmFsdWVdID0gXCIweFwiO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIExvb2t1cCBlYWNoIG5hbWVcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBpbiBlbnNDYWNoZSkge1xuICAgICAgICAgICAgICAgIGVuc0NhY2hlW25hbWVdID0geWllbGQgcmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBkb21haW4gdmVyaWZ5aW5nQ29udHJhY3QgaWYgbmVlZGVkXG4gICAgICAgICAgICBpZiAoZG9tYWluLnZlcmlmeWluZ0NvbnRyYWN0ICYmIGVuc0NhY2hlW2RvbWFpbi52ZXJpZnlpbmdDb250cmFjdF0pIHtcbiAgICAgICAgICAgICAgICBkb21haW4udmVyaWZ5aW5nQ29udHJhY3QgPSBlbnNDYWNoZVtkb21haW4udmVyaWZ5aW5nQ29udHJhY3RdO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gUmVwbGFjZSBhbGwgRU5TIG5hbWVzIHdpdGggdGhlaXIgYWRkcmVzc1xuICAgICAgICAgICAgdmFsdWUgPSBlbmNvZGVyLnZpc2l0KHZhbHVlLCAodHlwZSwgdmFsdWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodHlwZSA9PT0gXCJhZGRyZXNzXCIgJiYgZW5zQ2FjaGVbdmFsdWVdKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlbnNDYWNoZVt2YWx1ZV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHsgZG9tYWluLCB2YWx1ZSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgc3RhdGljIGdldFBheWxvYWQoZG9tYWluLCB0eXBlcywgdmFsdWUpIHtcbiAgICAgICAgLy8gVmFsaWRhdGUgdGhlIGRvbWFpbiBmaWVsZHNcbiAgICAgICAgVHlwZWREYXRhRW5jb2Rlci5oYXNoRG9tYWluKGRvbWFpbik7XG4gICAgICAgIC8vIERlcml2ZSB0aGUgRUlQNzEyRG9tYWluIFN0cnVjdCByZWZlcmVuY2UgdHlwZVxuICAgICAgICBjb25zdCBkb21haW5WYWx1ZXMgPSB7fTtcbiAgICAgICAgY29uc3QgZG9tYWluVHlwZXMgPSBbXTtcbiAgICAgICAgZG9tYWluRmllbGROYW1lcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGRvbWFpbltuYW1lXTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZG9tYWluVmFsdWVzW25hbWVdID0gZG9tYWluQ2hlY2tzW25hbWVdKHZhbHVlKTtcbiAgICAgICAgICAgIGRvbWFpblR5cGVzLnB1c2goeyBuYW1lLCB0eXBlOiBkb21haW5GaWVsZFR5cGVzW25hbWVdIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgZW5jb2RlciA9IFR5cGVkRGF0YUVuY29kZXIuZnJvbSh0eXBlcyk7XG4gICAgICAgIGNvbnN0IHR5cGVzV2l0aERvbWFpbiA9IHNoYWxsb3dDb3B5KHR5cGVzKTtcbiAgICAgICAgaWYgKHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4pIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0eXBlcyBtdXN0IG5vdCBjb250YWluIEVJUDcxMkRvbWFpbiB0eXBlXCIsIFwidHlwZXMuRUlQNzEyRG9tYWluXCIsIHR5cGVzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR5cGVzV2l0aERvbWFpbi5FSVA3MTJEb21haW4gPSBkb21haW5UeXBlcztcbiAgICAgICAgfVxuICAgICAgICAvLyBWYWxpZGF0ZSB0aGUgZGF0YSBzdHJ1Y3R1cmVzIGFuZCB0eXBlc1xuICAgICAgICBlbmNvZGVyLmVuY29kZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlczogdHlwZXNXaXRoRG9tYWluLFxuICAgICAgICAgICAgZG9tYWluOiBkb21haW5WYWx1ZXMsXG4gICAgICAgICAgICBwcmltYXJ5VHlwZTogZW5jb2Rlci5wcmltYXJ5VHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGVuY29kZXIudmlzaXQodmFsdWUsICh0eXBlLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIC8vIGJ5dGVzXG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL15ieXRlcyhcXGQqKS8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KGFycmF5aWZ5KHZhbHVlKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIHVpbnQgb3IgaW50XG4gICAgICAgICAgICAgICAgaWYgKHR5cGUubWF0Y2goL151P2ludC8pKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJhZGRyZXNzXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImJvb2xcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAhIXZhbHVlO1xuICAgICAgICAgICAgICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBpbnZhbGlkIHN0cmluZ2AsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD10eXBlZC1kYXRhLmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJoZG5vZGUvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQmFzZTU4IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Jhc2V4XCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhEYXRhU2xpY2UsIGhleFplcm9QYWQsIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuaW1wb3J0IHsgcGJrZGYyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Bia2RmMlwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgU2lnbmluZ0tleSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zaWduaW5nLWtleVwiO1xuaW1wb3J0IHsgY29tcHV0ZUhtYWMsIHJpcGVtZDE2MCwgc2hhMjU2LCBTdXBwb3J0ZWRBbGdvcml0aG0gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc2hhMlwiO1xuaW1wb3J0IHsgY29tcHV0ZUFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyB3b3JkbGlzdHMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvd29yZGxpc3RzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5jb25zdCBOID0gQmlnTnVtYmVyLmZyb20oXCIweGZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZmZlYmFhZWRjZTZhZjQ4YTAzYmJmZDI1ZThjZDAzNjQxNDFcIik7XG4vLyBcIkJpdGNvaW4gc2VlZFwiXG5jb25zdCBNYXN0ZXJTZWNyZXQgPSB0b1V0ZjhCeXRlcyhcIkJpdGNvaW4gc2VlZFwiKTtcbmNvbnN0IEhhcmRlbmVkQml0ID0gMHg4MDAwMDAwMDtcbi8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIE1TQiBiaXRzIHNldFxuZnVuY3Rpb24gZ2V0VXBwZXJNYXNrKGJpdHMpIHtcbiAgICByZXR1cm4gKCgxIDw8IGJpdHMpIC0gMSkgPDwgKDggLSBiaXRzKTtcbn1cbi8vIFJldHVybnMgYSBieXRlIHdpdGggdGhlIExTQiBiaXRzIHNldFxuZnVuY3Rpb24gZ2V0TG93ZXJNYXNrKGJpdHMpIHtcbiAgICByZXR1cm4gKDEgPDwgYml0cykgLSAxO1xufVxuZnVuY3Rpb24gYnl0ZXMzMih2YWx1ZSkge1xuICAgIHJldHVybiBoZXhaZXJvUGFkKGhleGxpZnkodmFsdWUpLCAzMik7XG59XG5mdW5jdGlvbiBiYXNlNThjaGVjayhkYXRhKSB7XG4gICAgcmV0dXJuIEJhc2U1OC5lbmNvZGUoY29uY2F0KFtkYXRhLCBoZXhEYXRhU2xpY2Uoc2hhMjU2KHNoYTI1NihkYXRhKSksIDAsIDQpXSkpO1xufVxuZnVuY3Rpb24gZ2V0V29yZGxpc3Qod29yZGxpc3QpIHtcbiAgICBpZiAod29yZGxpc3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gd29yZGxpc3RzW1wiZW5cIl07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHdvcmRsaXN0KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCB3b3JkcyA9IHdvcmRsaXN0c1t3b3JkbGlzdF07XG4gICAgICAgIGlmICh3b3JkcyA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5rbm93biBsb2NhbGVcIiwgXCJ3b3JkbGlzdFwiLCB3b3JkbGlzdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdvcmRzO1xuICAgIH1cbiAgICByZXR1cm4gd29yZGxpc3Q7XG59XG5jb25zdCBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuZXhwb3J0IGNvbnN0IGRlZmF1bHRQYXRoID0gXCJtLzQ0Jy82MCcvMCcvMC8wXCI7XG47XG5leHBvcnQgY2xhc3MgSEROb2RlIHtcbiAgICAvKipcbiAgICAgKiAgVGhpcyBjb25zdHJ1Y3RvciBzaG91bGQgbm90IGJlIGNhbGxlZCBkaXJlY3RseS5cbiAgICAgKlxuICAgICAqICBQbGVhc2UgdXNlOlxuICAgICAqICAgLSBmcm9tTW5lbW9uaWNcbiAgICAgKiAgIC0gZnJvbVNlZWRcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcihjb25zdHJ1Y3Rvckd1YXJkLCBwcml2YXRlS2V5LCBwdWJsaWNLZXksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIGluZGV4LCBkZXB0aCwgbW5lbW9uaWNPclBhdGgpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KG5ldy50YXJnZXQsIEhETm9kZSk7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICBpZiAoY29uc3RydWN0b3JHdWFyZCAhPT0gX2NvbnN0cnVjdG9yR3VhcmQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkhETm9kZSBjb25zdHJ1Y3RvciBjYW5ub3QgYmUgY2FsbGVkIGRpcmVjdGx5XCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcml2YXRlS2V5KSB7XG4gICAgICAgICAgICBjb25zdCBzaWduaW5nS2V5ID0gbmV3IFNpZ25pbmdLZXkocHJpdmF0ZUtleSk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByaXZhdGVLZXlcIiwgc2lnbmluZ0tleS5wcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHVibGljS2V5XCIsIHNpZ25pbmdLZXkuY29tcHJlc3NlZFB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByaXZhdGVLZXlcIiwgbnVsbCk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInB1YmxpY0tleVwiLCBoZXhsaWZ5KHB1YmxpY0tleSkpO1xuICAgICAgICB9XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicGFyZW50RmluZ2VycHJpbnRcIiwgcGFyZW50RmluZ2VycHJpbnQpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImZpbmdlcnByaW50XCIsIGhleERhdGFTbGljZShyaXBlbWQxNjAoc2hhMjU2KHRoaXMucHVibGljS2V5KSksIDAsIDQpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJhZGRyZXNzXCIsIGNvbXB1dGVBZGRyZXNzKHRoaXMucHVibGljS2V5KSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiY2hhaW5Db2RlXCIsIGNoYWluQ29kZSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiaW5kZXhcIiwgaW5kZXgpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImRlcHRoXCIsIGRlcHRoKTtcbiAgICAgICAgaWYgKG1uZW1vbmljT3JQYXRoID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIEZyb20gYSBzb3VyY2UgdGhhdCBkb2VzIG5vdCBwcmVzZXJ2ZSB0aGUgcGF0aCAoZS5nLiBleHRlbmRlZCBrZXlzKVxuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJtbmVtb25pY1wiLCBudWxsKTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicGF0aFwiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgKG1uZW1vbmljT3JQYXRoKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgLy8gRnJvbSBhIHNvdXJjZSB0aGF0IGRvZXMgbm90IHByZXNlcnZlIHRoZSBtbmVtb25pYyAoZS5nLiBuZXV0ZXJlZClcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwibW5lbW9uaWNcIiwgbnVsbCk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInBhdGhcIiwgbW5lbW9uaWNPclBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gRnJvbSBhIGZ1bGx5IHF1YWxpZmllZCBzb3VyY2VcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwibW5lbW9uaWNcIiwgbW5lbW9uaWNPclBhdGgpO1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwYXRoXCIsIG1uZW1vbmljT3JQYXRoLnBhdGgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBleHRlbmRlZEtleSgpIHtcbiAgICAgICAgLy8gV2Ugb25seSBzdXBwb3J0IHRoZSBtYWlubmV0IHZhbHVlcyBmb3Igbm93LCBidXQgaWYgYW55b25lIG5lZWRzXG4gICAgICAgIC8vIHRlc3RuZXQgdmFsdWVzLCBsZXQgbWUga25vdy4gSSBiZWxpZXZlIGN1cnJlbnQgc2VudGltZW50IGlzIHRoYXRcbiAgICAgICAgLy8gd2Ugc2hvdWxkIGFsd2F5cyB1c2UgbWFpbm5ldCwgYW5kIHVzZSBCSVAtNDQgdG8gZGVyaXZlIHRoZSBuZXR3b3JrXG4gICAgICAgIC8vICAgLSBNYWlubmV0OiBwdWJsaWM9MHgwNDg4QjIxRSwgcHJpdmF0ZT0weDA0ODhBREU0XG4gICAgICAgIC8vICAgLSBUZXN0bmV0OiBwdWJsaWM9MHgwNDM1ODdDRiwgcHJpdmF0ZT0weDA0MzU4Mzk0XG4gICAgICAgIGlmICh0aGlzLmRlcHRoID49IDI1Nikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGVwdGggdG9vIGxhcmdlIVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmFzZTU4Y2hlY2soY29uY2F0KFtcbiAgICAgICAgICAgICgodGhpcy5wcml2YXRlS2V5ICE9IG51bGwpID8gXCIweDA0ODhBREU0XCIgOiBcIjB4MDQ4OEIyMUVcIiksXG4gICAgICAgICAgICBoZXhsaWZ5KHRoaXMuZGVwdGgpLFxuICAgICAgICAgICAgdGhpcy5wYXJlbnRGaW5nZXJwcmludCxcbiAgICAgICAgICAgIGhleFplcm9QYWQoaGV4bGlmeSh0aGlzLmluZGV4KSwgNCksXG4gICAgICAgICAgICB0aGlzLmNoYWluQ29kZSxcbiAgICAgICAgICAgICgodGhpcy5wcml2YXRlS2V5ICE9IG51bGwpID8gY29uY2F0KFtcIjB4MDBcIiwgdGhpcy5wcml2YXRlS2V5XSkgOiB0aGlzLnB1YmxpY0tleSksXG4gICAgICAgIF0pKTtcbiAgICB9XG4gICAgbmV1dGVyKCkge1xuICAgICAgICByZXR1cm4gbmV3IEhETm9kZShfY29uc3RydWN0b3JHdWFyZCwgbnVsbCwgdGhpcy5wdWJsaWNLZXksIHRoaXMucGFyZW50RmluZ2VycHJpbnQsIHRoaXMuY2hhaW5Db2RlLCB0aGlzLmluZGV4LCB0aGlzLmRlcHRoLCB0aGlzLnBhdGgpO1xuICAgIH1cbiAgICBfZGVyaXZlKGluZGV4KSB7XG4gICAgICAgIGlmIChpbmRleCA+IDB4ZmZmZmZmZmYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaW5kZXggLSBcIiArIFN0cmluZyhpbmRleCkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEJhc2UgcGF0aFxuICAgICAgICBsZXQgcGF0aCA9IHRoaXMucGF0aDtcbiAgICAgICAgaWYgKHBhdGgpIHtcbiAgICAgICAgICAgIHBhdGggKz0gXCIvXCIgKyAoaW5kZXggJiB+SGFyZGVuZWRCaXQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheSgzNyk7XG4gICAgICAgIGlmIChpbmRleCAmIEhhcmRlbmVkQml0KSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImNhbm5vdCBkZXJpdmUgY2hpbGQgb2YgbmV1dGVyZWQgbm9kZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIERhdGEgPSAweDAwIHx8IHNlcl8yNTYoa19wYXIpXG4gICAgICAgICAgICBkYXRhLnNldChhcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpLCAxKTtcbiAgICAgICAgICAgIC8vIEhhcmRlbmVkIHBhdGhcbiAgICAgICAgICAgIGlmIChwYXRoKSB7XG4gICAgICAgICAgICAgICAgcGF0aCArPSBcIidcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIERhdGEgPSBzZXJfcChwb2ludChrX3BhcikpXG4gICAgICAgICAgICBkYXRhLnNldChhcnJheWlmeSh0aGlzLnB1YmxpY0tleSkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIERhdGEgKz0gc2VyXzMyKGkpXG4gICAgICAgIGZvciAobGV0IGkgPSAyNDsgaSA+PSAwOyBpIC09IDgpIHtcbiAgICAgICAgICAgIGRhdGFbMzMgKyAoaSA+PiAzKV0gPSAoKGluZGV4ID4+ICgyNCAtIGkpKSAmIDB4ZmYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IEkgPSBhcnJheWlmeShjb21wdXRlSG1hYyhTdXBwb3J0ZWRBbGdvcml0aG0uc2hhNTEyLCB0aGlzLmNoYWluQ29kZSwgZGF0YSkpO1xuICAgICAgICBjb25zdCBJTCA9IEkuc2xpY2UoMCwgMzIpO1xuICAgICAgICBjb25zdCBJUiA9IEkuc2xpY2UoMzIpO1xuICAgICAgICAvLyBUaGUgcHJpdmF0ZSBrZXlcbiAgICAgICAgbGV0IGtpID0gbnVsbDtcbiAgICAgICAgLy8gVGhlIHB1YmxpYyBrZXlcbiAgICAgICAgbGV0IEtpID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAga2kgPSBieXRlczMyKEJpZ051bWJlci5mcm9tKElMKS5hZGQodGhpcy5wcml2YXRlS2V5KS5tb2QoTikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgZWsgPSBuZXcgU2lnbmluZ0tleShoZXhsaWZ5KElMKSk7XG4gICAgICAgICAgICBLaSA9IGVrLl9hZGRQb2ludCh0aGlzLnB1YmxpY0tleSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IG1uZW1vbmljT3JQYXRoID0gcGF0aDtcbiAgICAgICAgY29uc3Qgc3JjTW5lbW9uaWMgPSB0aGlzLm1uZW1vbmljO1xuICAgICAgICBpZiAoc3JjTW5lbW9uaWMpIHtcbiAgICAgICAgICAgIG1uZW1vbmljT3JQYXRoID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgICAgICAgICAgICAgcGhyYXNlOiBzcmNNbmVtb25pYy5waHJhc2UsXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IChzcmNNbmVtb25pYy5sb2NhbGUgfHwgXCJlblwiKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGUoX2NvbnN0cnVjdG9yR3VhcmQsIGtpLCBLaSwgdGhpcy5maW5nZXJwcmludCwgYnl0ZXMzMihJUiksIGluZGV4LCB0aGlzLmRlcHRoICsgMSwgbW5lbW9uaWNPclBhdGgpO1xuICAgIH1cbiAgICBkZXJpdmVQYXRoKHBhdGgpIHtcbiAgICAgICAgY29uc3QgY29tcG9uZW50cyA9IHBhdGguc3BsaXQoXCIvXCIpO1xuICAgICAgICBpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDAgfHwgKGNvbXBvbmVudHNbMF0gPT09IFwibVwiICYmIHRoaXMuZGVwdGggIT09IDApKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggLSBcIiArIHBhdGgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21wb25lbnRzWzBdID09PSBcIm1cIikge1xuICAgICAgICAgICAgY29tcG9uZW50cy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXN1bHQgPSB0aGlzO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBvbmVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbXBvbmVudCA9IGNvbXBvbmVudHNbaV07XG4gICAgICAgICAgICBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJyQvKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gcGFyc2VJbnQoY29tcG9uZW50LnN1YnN0cmluZygwLCBjb21wb25lbnQubGVuZ3RoIC0gMSkpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBIYXJkZW5lZEJpdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggaW5kZXggLSBcIiArIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5fZGVyaXZlKEhhcmRlbmVkQml0ICsgaW5kZXgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoY29tcG9uZW50Lm1hdGNoKC9eWzAtOV0rJC8pKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChjb21wb25lbnQpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+PSBIYXJkZW5lZEJpdCkge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBhdGggaW5kZXggLSBcIiArIGNvbXBvbmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJlc3VsdCA9IHJlc3VsdC5fZGVyaXZlKGluZGV4KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgcGF0aCBjb21wb25lbnQgLSBcIiArIGNvbXBvbmVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RhdGljIF9mcm9tU2VlZChzZWVkLCBtbmVtb25pYykge1xuICAgICAgICBjb25zdCBzZWVkQXJyYXkgPSBhcnJheWlmeShzZWVkKTtcbiAgICAgICAgaWYgKHNlZWRBcnJheS5sZW5ndGggPCAxNiB8fCBzZWVkQXJyYXkubGVuZ3RoID4gNjQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgc2VlZFwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBJID0gYXJyYXlpZnkoY29tcHV0ZUhtYWMoU3VwcG9ydGVkQWxnb3JpdGhtLnNoYTUxMiwgTWFzdGVyU2VjcmV0LCBzZWVkQXJyYXkpKTtcbiAgICAgICAgcmV0dXJuIG5ldyBIRE5vZGUoX2NvbnN0cnVjdG9yR3VhcmQsIGJ5dGVzMzIoSS5zbGljZSgwLCAzMikpLCBudWxsLCBcIjB4MDAwMDAwMDBcIiwgYnl0ZXMzMihJLnNsaWNlKDMyKSksIDAsIDAsIG1uZW1vbmljKTtcbiAgICB9XG4gICAgc3RhdGljIGZyb21NbmVtb25pYyhtbmVtb25pYywgcGFzc3dvcmQsIHdvcmRsaXN0KSB7XG4gICAgICAgIC8vIElmIGEgbG9jYWxlIG5hbWUgd2FzIHBhc3NlZCBpbiwgZmluZCB0aGUgYXNzb2NpYXRlZCB3b3JkbGlzdFxuICAgICAgICB3b3JkbGlzdCA9IGdldFdvcmRsaXN0KHdvcmRsaXN0KTtcbiAgICAgICAgLy8gTm9ybWFsaXplIHRoZSBjYXNlIGFuZCBzcGFjaW5nIGluIHRoZSBtbmVtb25pYyAodGhyb3dzIGlmIHRoZSBtbmVtb25pYyBpcyBpbnZhbGlkKVxuICAgICAgICBtbmVtb25pYyA9IGVudHJvcHlUb01uZW1vbmljKG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLCB3b3JkbGlzdCksIHdvcmRsaXN0KTtcbiAgICAgICAgcmV0dXJuIEhETm9kZS5fZnJvbVNlZWQobW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3N3b3JkKSwge1xuICAgICAgICAgICAgcGhyYXNlOiBtbmVtb25pYyxcbiAgICAgICAgICAgIHBhdGg6IFwibVwiLFxuICAgICAgICAgICAgbG9jYWxlOiB3b3JkbGlzdC5sb2NhbGVcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tU2VlZChzZWVkKSB7XG4gICAgICAgIHJldHVybiBIRE5vZGUuX2Zyb21TZWVkKHNlZWQsIG51bGwpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUV4dGVuZGVkS2V5KGV4dGVuZGVkS2V5KSB7XG4gICAgICAgIGNvbnN0IGJ5dGVzID0gQmFzZTU4LmRlY29kZShleHRlbmRlZEtleSk7XG4gICAgICAgIGlmIChieXRlcy5sZW5ndGggIT09IDgyIHx8IGJhc2U1OGNoZWNrKGJ5dGVzLnNsaWNlKDAsIDc4KSkgIT09IGV4dGVuZGVkS2V5KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBleHRlbmRlZCBrZXlcIiwgXCJleHRlbmRlZEtleVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVwdGggPSBieXRlc1s0XTtcbiAgICAgICAgY29uc3QgcGFyZW50RmluZ2VycHJpbnQgPSBoZXhsaWZ5KGJ5dGVzLnNsaWNlKDUsIDkpKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZUludChoZXhsaWZ5KGJ5dGVzLnNsaWNlKDksIDEzKSkuc3Vic3RyaW5nKDIpLCAxNik7XG4gICAgICAgIGNvbnN0IGNoYWluQ29kZSA9IGhleGxpZnkoYnl0ZXMuc2xpY2UoMTMsIDQ1KSk7XG4gICAgICAgIGNvbnN0IGtleSA9IGJ5dGVzLnNsaWNlKDQ1LCA3OCk7XG4gICAgICAgIHN3aXRjaCAoaGV4bGlmeShieXRlcy5zbGljZSgwLCA0KSkpIHtcbiAgICAgICAgICAgIC8vIFB1YmxpYyBLZXlcbiAgICAgICAgICAgIGNhc2UgXCIweDA0ODhiMjFlXCI6XG4gICAgICAgICAgICBjYXNlIFwiMHgwNDM1ODdjZlwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkLCBudWxsLCBoZXhsaWZ5KGtleSksIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIGluZGV4LCBkZXB0aCwgbnVsbCk7XG4gICAgICAgICAgICAvLyBQcml2YXRlIEtleVxuICAgICAgICAgICAgY2FzZSBcIjB4MDQ4OGFkZTRcIjpcbiAgICAgICAgICAgIGNhc2UgXCIweDA0MzU4Mzk0IFwiOlxuICAgICAgICAgICAgICAgIGlmIChrZXlbMF0gIT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgSEROb2RlKF9jb25zdHJ1Y3Rvckd1YXJkLCBoZXhsaWZ5KGtleS5zbGljZSgxKSksIG51bGwsIHBhcmVudEZpbmdlcnByaW50LCBjaGFpbkNvZGUsIGluZGV4LCBkZXB0aCwgbnVsbCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGV4dGVuZGVkIGtleVwiLCBcImV4dGVuZGVkS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gbW5lbW9uaWNUb1NlZWQobW5lbW9uaWMsIHBhc3N3b3JkKSB7XG4gICAgaWYgKCFwYXNzd29yZCkge1xuICAgICAgICBwYXNzd29yZCA9IFwiXCI7XG4gICAgfVxuICAgIGNvbnN0IHNhbHQgPSB0b1V0ZjhCeXRlcyhcIm1uZW1vbmljXCIgKyBwYXNzd29yZCwgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0QpO1xuICAgIHJldHVybiBwYmtkZjIodG9VdGY4Qnl0ZXMobW5lbW9uaWMsIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktEKSwgc2FsdCwgMjA0OCwgNjQsIFwic2hhNTEyXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLCB3b3JkbGlzdCkge1xuICAgIHdvcmRsaXN0ID0gZ2V0V29yZGxpc3Qod29yZGxpc3QpO1xuICAgIGxvZ2dlci5jaGVja05vcm1hbGl6ZSgpO1xuICAgIGNvbnN0IHdvcmRzID0gd29yZGxpc3Quc3BsaXQobW5lbW9uaWMpO1xuICAgIGlmICgod29yZHMubGVuZ3RoICUgMykgIT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBtbmVtb25pY1wiKTtcbiAgICB9XG4gICAgY29uc3QgZW50cm9weSA9IGFycmF5aWZ5KG5ldyBVaW50OEFycmF5KE1hdGguY2VpbCgxMSAqIHdvcmRzLmxlbmd0aCAvIDgpKSk7XG4gICAgbGV0IG9mZnNldCA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCB3b3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBsZXQgaW5kZXggPSB3b3JkbGlzdC5nZXRXb3JkSW5kZXgod29yZHNbaV0ubm9ybWFsaXplKFwiTkZLRFwiKSk7XG4gICAgICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgbW5lbW9uaWNcIik7XG4gICAgICAgIH1cbiAgICAgICAgZm9yIChsZXQgYml0ID0gMDsgYml0IDwgMTE7IGJpdCsrKSB7XG4gICAgICAgICAgICBpZiAoaW5kZXggJiAoMSA8PCAoMTAgLSBiaXQpKSkge1xuICAgICAgICAgICAgICAgIGVudHJvcHlbb2Zmc2V0ID4+IDNdIHw9ICgxIDw8ICg3IC0gKG9mZnNldCAlIDgpKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBvZmZzZXQrKztcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlbnRyb3B5Qml0cyA9IDMyICogd29yZHMubGVuZ3RoIC8gMztcbiAgICBjb25zdCBjaGVja3N1bUJpdHMgPSB3b3Jkcy5sZW5ndGggLyAzO1xuICAgIGNvbnN0IGNoZWNrc3VtTWFzayA9IGdldFVwcGVyTWFzayhjaGVja3N1bUJpdHMpO1xuICAgIGNvbnN0IGNoZWNrc3VtID0gYXJyYXlpZnkoc2hhMjU2KGVudHJvcHkuc2xpY2UoMCwgZW50cm9weUJpdHMgLyA4KSkpWzBdICYgY2hlY2tzdW1NYXNrO1xuICAgIGlmIChjaGVja3N1bSAhPT0gKGVudHJvcHlbZW50cm9weS5sZW5ndGggLSAxXSAmIGNoZWNrc3VtTWFzaykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBjaGVja3N1bVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIGhleGxpZnkoZW50cm9weS5zbGljZSgwLCBlbnRyb3B5Qml0cyAvIDgpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBlbnRyb3B5VG9NbmVtb25pYyhlbnRyb3B5LCB3b3JkbGlzdCkge1xuICAgIHdvcmRsaXN0ID0gZ2V0V29yZGxpc3Qod29yZGxpc3QpO1xuICAgIGVudHJvcHkgPSBhcnJheWlmeShlbnRyb3B5KTtcbiAgICBpZiAoKGVudHJvcHkubGVuZ3RoICUgNCkgIT09IDAgfHwgZW50cm9weS5sZW5ndGggPCAxNiB8fCBlbnRyb3B5Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZW50cm9weVwiKTtcbiAgICB9XG4gICAgY29uc3QgaW5kaWNlcyA9IFswXTtcbiAgICBsZXQgcmVtYWluaW5nQml0cyA9IDExO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZW50cm9weS5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBDb25zdW1lIHRoZSB3aG9sZSBieXRlICh3aXRoIHN0aWxsIG1vcmUgdG8gZ28pXG4gICAgICAgIGlmIChyZW1haW5pbmdCaXRzID4gOCkge1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIDw8PSA4O1xuICAgICAgICAgICAgaW5kaWNlc1tpbmRpY2VzLmxlbmd0aCAtIDFdIHw9IGVudHJvcHlbaV07XG4gICAgICAgICAgICByZW1haW5pbmdCaXRzIC09IDg7XG4gICAgICAgICAgICAvLyBUaGlzIGJ5dGUgd2lsbCBjb21wbGV0ZSBhbiAxMS1iaXQgaW5kZXhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gcmVtYWluaW5nQml0cztcbiAgICAgICAgICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSBlbnRyb3B5W2ldID4+ICg4IC0gcmVtYWluaW5nQml0cyk7XG4gICAgICAgICAgICAvLyBTdGFydCB0aGUgbmV4dCB3b3JkXG4gICAgICAgICAgICBpbmRpY2VzLnB1c2goZW50cm9weVtpXSAmIGdldExvd2VyTWFzayg4IC0gcmVtYWluaW5nQml0cykpO1xuICAgICAgICAgICAgcmVtYWluaW5nQml0cyArPSAzO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIENvbXB1dGUgdGhlIGNoZWNrc3VtIGJpdHNcbiAgICBjb25zdCBjaGVja3N1bUJpdHMgPSBlbnRyb3B5Lmxlbmd0aCAvIDQ7XG4gICAgY29uc3QgY2hlY2tzdW0gPSBhcnJheWlmeShzaGEyNTYoZW50cm9weSkpWzBdICYgZ2V0VXBwZXJNYXNrKGNoZWNrc3VtQml0cyk7XG4gICAgLy8gU2hpZnQgdGhlIGNoZWNrc3VtIGludG8gdGhlIHdvcmQgaW5kaWNlc1xuICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSA8PD0gY2hlY2tzdW1CaXRzO1xuICAgIGluZGljZXNbaW5kaWNlcy5sZW5ndGggLSAxXSB8PSAoY2hlY2tzdW0gPj4gKDggLSBjaGVja3N1bUJpdHMpKTtcbiAgICByZXR1cm4gd29yZGxpc3Quam9pbihpbmRpY2VzLm1hcCgoaW5kZXgpID0+IHdvcmRsaXN0LmdldFdvcmQoaW5kZXgpKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNWYWxpZE1uZW1vbmljKG1uZW1vbmljLCB3b3JkbGlzdCkge1xuICAgIHRyeSB7XG4gICAgICAgIG1uZW1vbmljVG9FbnRyb3B5KG1uZW1vbmljLCB3b3JkbGlzdCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIHJldHVybiBmYWxzZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBnZXRBY2NvdW50UGF0aChpbmRleCkge1xuICAgIGlmICh0eXBlb2YgKGluZGV4KSAhPT0gXCJudW1iZXJcIiB8fCBpbmRleCA8IDAgfHwgaW5kZXggPj0gSGFyZGVuZWRCaXQgfHwgaW5kZXggJSAxKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFjY291bnQgaW5kZXhcIiwgXCJpbmRleFwiLCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiBgbS80NCcvNjAnLyR7aW5kZXh9Jy8wLzBgO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcImpzb24td2FsbGV0cy81LjUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgYWVzIGZyb20gXCJhZXMtanNcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IHBia2RmMiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wYmtkZjJcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IERlc2NyaXB0aW9uIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IGdldFBhc3N3b3JkLCBsb29zZUFycmF5aWZ5LCBzZWFyY2hQYXRoIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmV4cG9ydCBjbGFzcyBDcm93ZHNhbGVBY2NvdW50IGV4dGVuZHMgRGVzY3JpcHRpb24ge1xuICAgIGlzQ3Jvd2RzYWxlQWNjb3VudCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzQ3Jvd2RzYWxlQWNjb3VudCk7XG4gICAgfVxufVxuLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vcHlldGhzYWxldG9vbFxuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHQoanNvbiwgcGFzc3dvcmQpIHtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICBwYXNzd29yZCA9IGdldFBhc3N3b3JkKHBhc3N3b3JkKTtcbiAgICAvLyBFdGhlcmV1bSBBZGRyZXNzXG4gICAgY29uc3QgZXRoYWRkciA9IGdldEFkZHJlc3Moc2VhcmNoUGF0aChkYXRhLCBcImV0aGFkZHJcIikpO1xuICAgIC8vIEVuY3J5cHRlZCBTZWVkXG4gICAgY29uc3QgZW5jc2VlZCA9IGxvb3NlQXJyYXlpZnkoc2VhcmNoUGF0aChkYXRhLCBcImVuY3NlZWRcIikpO1xuICAgIGlmICghZW5jc2VlZCB8fCAoZW5jc2VlZC5sZW5ndGggJSAxNikgIT09IDApIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgZW5jc2VlZFwiLCBcImpzb25cIiwganNvbik7XG4gICAgfVxuICAgIGNvbnN0IGtleSA9IGFycmF5aWZ5KHBia2RmMihwYXNzd29yZCwgcGFzc3dvcmQsIDIwMDAsIDMyLCBcInNoYTI1NlwiKSkuc2xpY2UoMCwgMTYpO1xuICAgIGNvbnN0IGl2ID0gZW5jc2VlZC5zbGljZSgwLCAxNik7XG4gICAgY29uc3QgZW5jcnlwdGVkU2VlZCA9IGVuY3NlZWQuc2xpY2UoMTYpO1xuICAgIC8vIERlY3J5cHQgdGhlIHNlZWRcbiAgICBjb25zdCBhZXNDYmMgPSBuZXcgYWVzLk1vZGVPZk9wZXJhdGlvbi5jYmMoa2V5LCBpdik7XG4gICAgY29uc3Qgc2VlZCA9IGFlcy5wYWRkaW5nLnBrY3M3LnN0cmlwKGFycmF5aWZ5KGFlc0NiYy5kZWNyeXB0KGVuY3J5cHRlZFNlZWQpKSk7XG4gICAgLy8gVGhpcyB3YWxsZXQgZm9ybWF0IGlzIHdlaXJkLi4uIENvbnZlcnQgdGhlIGJpbmFyeSBlbmNvZGVkIGhleCB0byBhIHN0cmluZy5cbiAgICBsZXQgc2VlZEhleCA9IFwiXCI7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzZWVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHNlZWRIZXggKz0gU3RyaW5nLmZyb21DaGFyQ29kZShzZWVkW2ldKTtcbiAgICB9XG4gICAgY29uc3Qgc2VlZEhleEJ5dGVzID0gdG9VdGY4Qnl0ZXMoc2VlZEhleCk7XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IGtlY2NhazI1NihzZWVkSGV4Qnl0ZXMpO1xuICAgIHJldHVybiBuZXcgQ3Jvd2RzYWxlQWNjb3VudCh7XG4gICAgICAgIF9pc0Nyb3dkc2FsZUFjY291bnQ6IHRydWUsXG4gICAgICAgIGFkZHJlc3M6IGV0aGFkZHIsXG4gICAgICAgIHByaXZhdGVLZXk6IHByaXZhdGVLZXlcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNyb3dkc2FsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGRlY3J5cHQgYXMgZGVjcnlwdENyb3dkc2FsZSB9IGZyb20gXCIuL2Nyb3dkc2FsZVwiO1xuaW1wb3J0IHsgZ2V0SnNvbldhbGxldEFkZHJlc3MsIGlzQ3Jvd2RzYWxlV2FsbGV0LCBpc0tleXN0b3JlV2FsbGV0IH0gZnJvbSBcIi4vaW5zcGVjdFwiO1xuaW1wb3J0IHsgZGVjcnlwdCBhcyBkZWNyeXB0S2V5c3RvcmUsIGRlY3J5cHRTeW5jIGFzIGRlY3J5cHRLZXlzdG9yZVN5bmMsIGVuY3J5cHQgYXMgZW5jcnlwdEtleXN0b3JlIH0gZnJvbSBcIi4va2V5c3RvcmVcIjtcbmZ1bmN0aW9uIGRlY3J5cHRKc29uV2FsbGV0KGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgaWYgKGlzQ3Jvd2RzYWxlV2FsbGV0KGpzb24pKSB7XG4gICAgICAgIGlmIChwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKDApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFjY291bnQgPSBkZWNyeXB0Q3Jvd2RzYWxlKGpzb24sIHBhc3N3b3JkKTtcbiAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgICAgIHByb2dyZXNzQ2FsbGJhY2soMSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVzb2x2ZShhY2NvdW50KTtcbiAgICB9XG4gICAgaWYgKGlzS2V5c3RvcmVXYWxsZXQoanNvbikpIHtcbiAgICAgICAgcmV0dXJuIGRlY3J5cHRLZXlzdG9yZShqc29uLCBwYXNzd29yZCwgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgfVxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChuZXcgRXJyb3IoXCJpbnZhbGlkIEpTT04gd2FsbGV0XCIpKTtcbn1cbmZ1bmN0aW9uIGRlY3J5cHRKc29uV2FsbGV0U3luYyhqc29uLCBwYXNzd29yZCkge1xuICAgIGlmIChpc0Nyb3dkc2FsZVdhbGxldChqc29uKSkge1xuICAgICAgICByZXR1cm4gZGVjcnlwdENyb3dkc2FsZShqc29uLCBwYXNzd29yZCk7XG4gICAgfVxuICAgIGlmIChpc0tleXN0b3JlV2FsbGV0KGpzb24pKSB7XG4gICAgICAgIHJldHVybiBkZWNyeXB0S2V5c3RvcmVTeW5jKGpzb24sIHBhc3N3b3JkKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBKU09OIHdhbGxldFwiKTtcbn1cbmV4cG9ydCB7IGRlY3J5cHRDcm93ZHNhbGUsIGRlY3J5cHRLZXlzdG9yZSwgZGVjcnlwdEtleXN0b3JlU3luYywgZW5jcnlwdEtleXN0b3JlLCBpc0Nyb3dkc2FsZVdhbGxldCwgaXNLZXlzdG9yZVdhbGxldCwgZ2V0SnNvbldhbGxldEFkZHJlc3MsIGRlY3J5cHRKc29uV2FsbGV0LCBkZWNyeXB0SnNvbldhbGxldFN5bmMsIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIGlzQ3Jvd2RzYWxlV2FsbGV0KGpzb24pIHtcbiAgICBsZXQgZGF0YSA9IG51bGw7XG4gICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoanNvbik7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiAoZGF0YS5lbmNzZWVkICYmIGRhdGEuZXRoYWRkcik7XG59XG5leHBvcnQgZnVuY3Rpb24gaXNLZXlzdG9yZVdhbGxldChqc29uKSB7XG4gICAgbGV0IGRhdGEgPSBudWxsO1xuICAgIHRyeSB7XG4gICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGpzb24pO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIWRhdGEudmVyc2lvbiB8fCBwYXJzZUludChkYXRhLnZlcnNpb24pICE9PSBkYXRhLnZlcnNpb24gfHwgcGFyc2VJbnQoZGF0YS52ZXJzaW9uKSAhPT0gMykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBQdXQgbW9yZSBjaGVja3MgdG8gbWFrZSBzdXJlIGl0IGhhcyBrZGYsIGl2IGFuZCBhbGwgdGhhdCBnb29kIHN0dWZmXG4gICAgcmV0dXJuIHRydWU7XG59XG4vL2V4cG9ydCBmdW5jdGlvbiBpc0pzb25XYWxsZXQoanNvbjogc3RyaW5nKTogYm9vbGVhbiB7XG4vLyAgICByZXR1cm4gKGlzU2VjcmV0U3RvcmFnZVdhbGxldChqc29uKSB8fCBpc0Nyb3dkc2FsZVdhbGxldChqc29uKSk7XG4vL31cbmV4cG9ydCBmdW5jdGlvbiBnZXRKc29uV2FsbGV0QWRkcmVzcyhqc29uKSB7XG4gICAgaWYgKGlzQ3Jvd2RzYWxlV2FsbGV0KGpzb24pKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0QWRkcmVzcyhKU09OLnBhcnNlKGpzb24pLmV0aGFkZHIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzS2V5c3RvcmVXYWxsZXQoanNvbikpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRBZGRyZXNzKEpTT04ucGFyc2UoanNvbikuYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluc3BlY3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCBhZXMgZnJvbSBcImFlcy1qc1wiO1xuaW1wb3J0IHNjcnlwdCBmcm9tIFwic2NyeXB0LWpzXCI7XG5pbXBvcnQgeyBnZXRBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZmF1bHRQYXRoLCBlbnRyb3B5VG9NbmVtb25pYywgSEROb2RlLCBtbmVtb25pY1RvRW50cm9weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oZG5vZGVcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IHBia2RmMiBhcyBfcGJrZGYyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Bia2RmMlwiO1xuaW1wb3J0IHsgcmFuZG9tQnl0ZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcmFuZG9tXCI7XG5pbXBvcnQgeyBEZXNjcmlwdGlvbiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBjb21wdXRlQWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IGdldFBhc3N3b3JkLCBsb29zZUFycmF5aWZ5LCBzZWFyY2hQYXRoLCB1dWlkVjQsIHpwYWQgfSBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuLy8gRXhwb3J0ZWQgVHlwZXNcbmZ1bmN0aW9uIGhhc01uZW1vbmljKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmIHZhbHVlLm1uZW1vbmljICYmIHZhbHVlLm1uZW1vbmljLnBocmFzZSk7XG59XG5leHBvcnQgY2xhc3MgS2V5c3RvcmVBY2NvdW50IGV4dGVuZHMgRGVzY3JpcHRpb24ge1xuICAgIGlzS2V5c3RvcmVBY2NvdW50KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5faXNLZXlzdG9yZUFjY291bnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIF9kZWNyeXB0KGRhdGEsIGtleSwgY2lwaGVydGV4dCkge1xuICAgIGNvbnN0IGNpcGhlciA9IHNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8vY2lwaGVyXCIpO1xuICAgIGlmIChjaXBoZXIgPT09IFwiYWVzLTEyOC1jdHJcIikge1xuICAgICAgICBjb25zdCBpdiA9IGxvb3NlQXJyYXlpZnkoc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9jaXBoZXJwYXJhbXMvaXZcIikpO1xuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IGFlcy5Db3VudGVyKGl2KTtcbiAgICAgICAgY29uc3QgYWVzQ3RyID0gbmV3IGFlcy5Nb2RlT2ZPcGVyYXRpb24uY3RyKGtleSwgY291bnRlcik7XG4gICAgICAgIHJldHVybiBhcnJheWlmeShhZXNDdHIuZGVjcnlwdChjaXBoZXJ0ZXh0KSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZnVuY3Rpb24gX2dldEFjY291bnQoZGF0YSwga2V5KSB7XG4gICAgY29uc3QgY2lwaGVydGV4dCA9IGxvb3NlQXJyYXlpZnkoc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9jaXBoZXJ0ZXh0XCIpKTtcbiAgICBjb25zdCBjb21wdXRlZE1BQyA9IGhleGxpZnkoa2VjY2FrMjU2KGNvbmNhdChba2V5LnNsaWNlKDE2LCAzMiksIGNpcGhlcnRleHRdKSkpLnN1YnN0cmluZygyKTtcbiAgICBpZiAoY29tcHV0ZWRNQUMgIT09IHNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8vbWFjXCIpLnRvTG93ZXJDYXNlKCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBwYXNzd29yZFwiKTtcbiAgICB9XG4gICAgY29uc3QgcHJpdmF0ZUtleSA9IF9kZWNyeXB0KGRhdGEsIGtleS5zbGljZSgwLCAxNiksIGNpcGhlcnRleHQpO1xuICAgIGlmICghcHJpdmF0ZUtleSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIGNpcGhlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImRlY3J5cHRcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgbW5lbW9uaWNLZXkgPSBrZXkuc2xpY2UoMzIsIDY0KTtcbiAgICBjb25zdCBhZGRyZXNzID0gY29tcHV0ZUFkZHJlc3MocHJpdmF0ZUtleSk7XG4gICAgaWYgKGRhdGEuYWRkcmVzcykge1xuICAgICAgICBsZXQgY2hlY2sgPSBkYXRhLmFkZHJlc3MudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgaWYgKGNoZWNrLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgICAgICBjaGVjayA9IFwiMHhcIiArIGNoZWNrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZXRBZGRyZXNzKGNoZWNrKSAhPT0gYWRkcmVzcykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYWRkcmVzcyBtaXNtYXRjaFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBhY2NvdW50ID0ge1xuICAgICAgICBfaXNLZXlzdG9yZUFjY291bnQ6IHRydWUsXG4gICAgICAgIGFkZHJlc3M6IGFkZHJlc3MsXG4gICAgICAgIHByaXZhdGVLZXk6IGhleGxpZnkocHJpdmF0ZUtleSlcbiAgICB9O1xuICAgIC8vIFZlcnNpb24gMC4xIHgtZXRoZXJzIG1ldGFkYXRhIG11c3QgY29udGFpbiBhbiBlbmNyeXB0ZWQgbW5lbW9uaWMgcGhyYXNlXG4gICAgaWYgKHNlYXJjaFBhdGgoZGF0YSwgXCJ4LWV0aGVycy92ZXJzaW9uXCIpID09PSBcIjAuMVwiKSB7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljQ2lwaGVydGV4dCA9IGxvb3NlQXJyYXlpZnkoc2VhcmNoUGF0aChkYXRhLCBcIngtZXRoZXJzL21uZW1vbmljQ2lwaGVydGV4dFwiKSk7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljSXYgPSBsb29zZUFycmF5aWZ5KHNlYXJjaFBhdGgoZGF0YSwgXCJ4LWV0aGVycy9tbmVtb25pY0NvdW50ZXJcIikpO1xuICAgICAgICBjb25zdCBtbmVtb25pY0NvdW50ZXIgPSBuZXcgYWVzLkNvdW50ZXIobW5lbW9uaWNJdik7XG4gICAgICAgIGNvbnN0IG1uZW1vbmljQWVzQ3RyID0gbmV3IGFlcy5Nb2RlT2ZPcGVyYXRpb24uY3RyKG1uZW1vbmljS2V5LCBtbmVtb25pY0NvdW50ZXIpO1xuICAgICAgICBjb25zdCBwYXRoID0gc2VhcmNoUGF0aChkYXRhLCBcIngtZXRoZXJzL3BhdGhcIikgfHwgZGVmYXVsdFBhdGg7XG4gICAgICAgIGNvbnN0IGxvY2FsZSA9IHNlYXJjaFBhdGgoZGF0YSwgXCJ4LWV0aGVycy9sb2NhbGVcIikgfHwgXCJlblwiO1xuICAgICAgICBjb25zdCBlbnRyb3B5ID0gYXJyYXlpZnkobW5lbW9uaWNBZXNDdHIuZGVjcnlwdChtbmVtb25pY0NpcGhlcnRleHQpKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG1uZW1vbmljID0gZW50cm9weVRvTW5lbW9uaWMoZW50cm9weSwgbG9jYWxlKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBIRE5vZGUuZnJvbU1uZW1vbmljKG1uZW1vbmljLCBudWxsLCBsb2NhbGUpLmRlcml2ZVBhdGgocGF0aCk7XG4gICAgICAgICAgICBpZiAobm9kZS5wcml2YXRlS2V5ICE9IGFjY291bnQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1uZW1vbmljIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWNjb3VudC5tbmVtb25pYyA9IG5vZGUubW5lbW9uaWM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAvLyBJZiB3ZSBkb24ndCBoYXZlIHRoZSBsb2NhbGUgd29yZGxpc3QgaW5zdGFsbGVkIHRvXG4gICAgICAgICAgICAvLyByZWFkIHRoaXMgbW5lbW9uaWMsIGp1c3QgYmFpbCBhbmQgZG9uJ3Qgc2V0IHRoZVxuICAgICAgICAgICAgLy8gbW5lbW9uaWNcbiAgICAgICAgICAgIGlmIChlcnJvci5jb2RlICE9PSBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQgfHwgZXJyb3IuYXJndW1lbnQgIT09IFwid29yZGxpc3RcIikge1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZXcgS2V5c3RvcmVBY2NvdW50KGFjY291bnQpO1xufVxuZnVuY3Rpb24gcGJrZGYyU3luYyhwYXNzd29yZEJ5dGVzLCBzYWx0LCBjb3VudCwgZGtMZW4sIHByZkZ1bmMpIHtcbiAgICByZXR1cm4gYXJyYXlpZnkoX3Bia2RmMihwYXNzd29yZEJ5dGVzLCBzYWx0LCBjb3VudCwgZGtMZW4sIHByZkZ1bmMpKTtcbn1cbmZ1bmN0aW9uIHBia2RmMihwYXNzd29yZEJ5dGVzLCBzYWx0LCBjb3VudCwgZGtMZW4sIHByZkZ1bmMpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHBia2RmMlN5bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKSk7XG59XG5mdW5jdGlvbiBfY29tcHV0ZUtkZktleShkYXRhLCBwYXNzd29yZCwgcGJrZGYyRnVuYywgc2NyeXB0RnVuYywgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgIGNvbnN0IHBhc3N3b3JkQnl0ZXMgPSBnZXRQYXNzd29yZChwYXNzd29yZCk7XG4gICAgY29uc3Qga2RmID0gc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZcIik7XG4gICAgaWYgKGtkZiAmJiB0eXBlb2YgKGtkZikgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgY29uc3QgdGhyb3dFcnJvciA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSkge1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uIHBhcmFtZXRlcnNcIiwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9O1xuICAgICAgICBpZiAoa2RmLnRvTG93ZXJDYXNlKCkgPT09IFwic2NyeXB0XCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHNhbHQgPSBsb29zZUFycmF5aWZ5KHNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL3NhbHRcIikpO1xuICAgICAgICAgICAgY29uc3QgTiA9IHBhcnNlSW50KHNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL25cIikpO1xuICAgICAgICAgICAgY29uc3QgciA9IHBhcnNlSW50KHNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL3JcIikpO1xuICAgICAgICAgICAgY29uc3QgcCA9IHBhcnNlSW50KHNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL3BcIikpO1xuICAgICAgICAgICAgLy8gQ2hlY2sgZm9yIGFsbCByZXF1aXJlZCBwYXJhbWV0ZXJzXG4gICAgICAgICAgICBpZiAoIU4gfHwgIXIgfHwgIXApIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwia2RmXCIsIGtkZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgTiBpcyBhIHBvd2VyIG9mIDJcbiAgICAgICAgICAgIGlmICgoTiAmIChOIC0gMSkpICE9PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3dFcnJvcihcIk5cIiwgTik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBka0xlbiA9IHBhcnNlSW50KHNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL2RrbGVuXCIpKTtcbiAgICAgICAgICAgIGlmIChka0xlbiAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwiZGtsZW5cIiwgZGtMZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHNjcnlwdEZ1bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgTiwgciwgcCwgNjQsIHByb2dyZXNzQ2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtkZi50b0xvd2VyQ2FzZSgpID09PSBcInBia2RmMlwiKSB7XG4gICAgICAgICAgICBjb25zdCBzYWx0ID0gbG9vc2VBcnJheWlmeShzZWFyY2hQYXRoKGRhdGEsIFwiY3J5cHRvL2tkZnBhcmFtcy9zYWx0XCIpKTtcbiAgICAgICAgICAgIGxldCBwcmZGdW5jID0gbnVsbDtcbiAgICAgICAgICAgIGNvbnN0IHByZiA9IHNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL3ByZlwiKTtcbiAgICAgICAgICAgIGlmIChwcmYgPT09IFwiaG1hYy1zaGEyNTZcIikge1xuICAgICAgICAgICAgICAgIHByZkZ1bmMgPSBcInNoYTI1NlwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJmID09PSBcImhtYWMtc2hhNTEyXCIpIHtcbiAgICAgICAgICAgICAgICBwcmZGdW5jID0gXCJzaGE1MTJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93RXJyb3IoXCJwcmZcIiwgcHJmKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gcGFyc2VJbnQoc2VhcmNoUGF0aChkYXRhLCBcImNyeXB0by9rZGZwYXJhbXMvY1wiKSk7XG4gICAgICAgICAgICBjb25zdCBka0xlbiA9IHBhcnNlSW50KHNlYXJjaFBhdGgoZGF0YSwgXCJjcnlwdG8va2RmcGFyYW1zL2RrbGVuXCIpKTtcbiAgICAgICAgICAgIGlmIChka0xlbiAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICB0aHJvd0Vycm9yKFwiZGtsZW5cIiwgZGtMZW4pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBia2RmMkZ1bmMocGFzc3dvcmRCeXRlcywgc2FsdCwgY291bnQsIGRrTGVuLCBwcmZGdW5jKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIGtleS1kZXJpdmF0aW9uIGZ1bmN0aW9uXCIsIFwia2RmXCIsIGtkZik7XG59XG5leHBvcnQgZnVuY3Rpb24gZGVjcnlwdFN5bmMoanNvbiwgcGFzc3dvcmQpIHtcbiAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICBjb25zdCBrZXkgPSBfY29tcHV0ZUtkZktleShkYXRhLCBwYXNzd29yZCwgcGJrZGYyU3luYywgc2NyeXB0LnN5bmNTY3J5cHQpO1xuICAgIHJldHVybiBfZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY3J5cHQoanNvbiwgcGFzc3dvcmQsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBkYXRhID0gSlNPTi5wYXJzZShqc29uKTtcbiAgICAgICAgY29uc3Qga2V5ID0geWllbGQgX2NvbXB1dGVLZGZLZXkoZGF0YSwgcGFzc3dvcmQsIHBia2RmMiwgc2NyeXB0LnNjcnlwdCwgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBfZ2V0QWNjb3VudChkYXRhLCBrZXkpO1xuICAgIH0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY3J5cHQoYWNjb3VudCwgcGFzc3dvcmQsIG9wdGlvbnMsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICB0cnkge1xuICAgICAgICAvLyBDaGVjayB0aGUgYWRkcmVzcyBtYXRjaGVzIHRoZSBwcml2YXRlIGtleVxuICAgICAgICBpZiAoZ2V0QWRkcmVzcyhhY2NvdW50LmFkZHJlc3MpICE9PSBjb21wdXRlQWRkcmVzcyhhY2NvdW50LnByaXZhdGVLZXkpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJhZGRyZXNzL3ByaXZhdGVLZXkgbWlzbWF0Y2hcIik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgdGhlIG1uZW1vbmljIChpZiBhbnkpIG1hdGNoZXMgdGhlIHByaXZhdGUga2V5XG4gICAgICAgIGlmIChoYXNNbmVtb25pYyhhY2NvdW50KSkge1xuICAgICAgICAgICAgY29uc3QgbW5lbW9uaWMgPSBhY2NvdW50Lm1uZW1vbmljO1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IEhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMucGhyYXNlLCBudWxsLCBtbmVtb25pYy5sb2NhbGUpLmRlcml2ZVBhdGgobW5lbW9uaWMucGF0aCB8fCBkZWZhdWx0UGF0aCk7XG4gICAgICAgICAgICBpZiAobm9kZS5wcml2YXRlS2V5ICE9IGFjY291bnQucHJpdmF0ZUtleSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIm1uZW1vbmljIG1pc21hdGNoXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlKTtcbiAgICB9XG4gICAgLy8gVGhlIG9wdGlvbnMgYXJlIG9wdGlvbmFsLCBzbyBhZGp1c3QgdGhlIGNhbGwgYXMgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiAob3B0aW9ucykgPT09IFwiZnVuY3Rpb25cIiAmJiAhcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICBwcm9ncmVzc0NhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBjb25zdCBwcml2YXRlS2V5ID0gYXJyYXlpZnkoYWNjb3VudC5wcml2YXRlS2V5KTtcbiAgICBjb25zdCBwYXNzd29yZEJ5dGVzID0gZ2V0UGFzc3dvcmQocGFzc3dvcmQpO1xuICAgIGxldCBlbnRyb3B5ID0gbnVsbDtcbiAgICBsZXQgcGF0aCA9IG51bGw7XG4gICAgbGV0IGxvY2FsZSA9IG51bGw7XG4gICAgaWYgKGhhc01uZW1vbmljKGFjY291bnQpKSB7XG4gICAgICAgIGNvbnN0IHNyY01uZW1vbmljID0gYWNjb3VudC5tbmVtb25pYztcbiAgICAgICAgZW50cm9weSA9IGFycmF5aWZ5KG1uZW1vbmljVG9FbnRyb3B5KHNyY01uZW1vbmljLnBocmFzZSwgc3JjTW5lbW9uaWMubG9jYWxlIHx8IFwiZW5cIikpO1xuICAgICAgICBwYXRoID0gc3JjTW5lbW9uaWMucGF0aCB8fCBkZWZhdWx0UGF0aDtcbiAgICAgICAgbG9jYWxlID0gc3JjTW5lbW9uaWMubG9jYWxlIHx8IFwiZW5cIjtcbiAgICB9XG4gICAgbGV0IGNsaWVudCA9IG9wdGlvbnMuY2xpZW50O1xuICAgIGlmICghY2xpZW50KSB7XG4gICAgICAgIGNsaWVudCA9IFwiZXRoZXJzLmpzXCI7XG4gICAgfVxuICAgIC8vIENoZWNrL2dlbmVyYXRlIHRoZSBzYWx0XG4gICAgbGV0IHNhbHQgPSBudWxsO1xuICAgIGlmIChvcHRpb25zLnNhbHQpIHtcbiAgICAgICAgc2FsdCA9IGFycmF5aWZ5KG9wdGlvbnMuc2FsdCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBzYWx0ID0gcmFuZG9tQnl0ZXMoMzIpO1xuICAgICAgICA7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRlIGluaXRpYWxpemF0aW9uIHZlY3RvclxuICAgIGxldCBpdiA9IG51bGw7XG4gICAgaWYgKG9wdGlvbnMuaXYpIHtcbiAgICAgICAgaXYgPSBhcnJheWlmeShvcHRpb25zLml2KTtcbiAgICAgICAgaWYgKGl2Lmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaXZcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGl2ID0gcmFuZG9tQnl0ZXMoMTYpO1xuICAgIH1cbiAgICAvLyBPdmVycmlkZSB0aGUgdXVpZFxuICAgIGxldCB1dWlkUmFuZG9tID0gbnVsbDtcbiAgICBpZiAob3B0aW9ucy51dWlkKSB7XG4gICAgICAgIHV1aWRSYW5kb20gPSBhcnJheWlmeShvcHRpb25zLnV1aWQpO1xuICAgICAgICBpZiAodXVpZFJhbmRvbS5sZW5ndGggIT09IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHV1aWRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHV1aWRSYW5kb20gPSByYW5kb21CeXRlcygxNik7XG4gICAgfVxuICAgIC8vIE92ZXJyaWRlIHRoZSBzY3J5cHQgcGFzc3dvcmQtYmFzZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24gcGFyYW1ldGVyc1xuICAgIGxldCBOID0gKDEgPDwgMTcpLCByID0gOCwgcCA9IDE7XG4gICAgaWYgKG9wdGlvbnMuc2NyeXB0KSB7XG4gICAgICAgIGlmIChvcHRpb25zLnNjcnlwdC5OKSB7XG4gICAgICAgICAgICBOID0gb3B0aW9ucy5zY3J5cHQuTjtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5zY3J5cHQucikge1xuICAgICAgICAgICAgciA9IG9wdGlvbnMuc2NyeXB0LnI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuc2NyeXB0LnApIHtcbiAgICAgICAgICAgIHAgPSBvcHRpb25zLnNjcnlwdC5wO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIFdlIHRha2UgNjQgYnl0ZXM6XG4gICAgLy8gICAtIDMyIGJ5dGVzICAgQXMgbm9ybWFsIGZvciB0aGUgV2ViMyBzZWNyZXQgc3RvcmFnZSAoZGVyaXZlZEtleSwgbWFjUHJlZml4KVxuICAgIC8vICAgLSAzMiBieXRlcyAgIEFFUyBrZXkgdG8gZW5jcnlwdCBtbmVtb25pYyB3aXRoIChyZXF1aXJlZCBoZXJlIHRvIGJlIEV0aGVycyBXYWxsZXQpXG4gICAgcmV0dXJuIHNjcnlwdC5zY3J5cHQocGFzc3dvcmRCeXRlcywgc2FsdCwgTiwgciwgcCwgNjQsIHByb2dyZXNzQ2FsbGJhY2spLnRoZW4oKGtleSkgPT4ge1xuICAgICAgICBrZXkgPSBhcnJheWlmeShrZXkpO1xuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgdXNlZCB0byBlbmNyeXB0IHRoZSB3YWxsZXQgKGFzIHBlciBXZWIzIHNlY3JldCBzdG9yYWdlKVxuICAgICAgICBjb25zdCBkZXJpdmVkS2V5ID0ga2V5LnNsaWNlKDAsIDE2KTtcbiAgICAgICAgY29uc3QgbWFjUHJlZml4ID0ga2V5LnNsaWNlKDE2LCAzMik7XG4gICAgICAgIC8vIFRoaXMgd2lsbCBiZSB1c2VkIHRvIGVuY3J5cHQgdGhlIG1uZW1vbmljIHBocmFzZSAoaWYgYW55KVxuICAgICAgICBjb25zdCBtbmVtb25pY0tleSA9IGtleS5zbGljZSgzMiwgNjQpO1xuICAgICAgICAvLyBFbmNyeXB0IHRoZSBwcml2YXRlIGtleVxuICAgICAgICBjb25zdCBjb3VudGVyID0gbmV3IGFlcy5Db3VudGVyKGl2KTtcbiAgICAgICAgY29uc3QgYWVzQ3RyID0gbmV3IGFlcy5Nb2RlT2ZPcGVyYXRpb24uY3RyKGRlcml2ZWRLZXksIGNvdW50ZXIpO1xuICAgICAgICBjb25zdCBjaXBoZXJ0ZXh0ID0gYXJyYXlpZnkoYWVzQ3RyLmVuY3J5cHQocHJpdmF0ZUtleSkpO1xuICAgICAgICAvLyBDb21wdXRlIHRoZSBtZXNzYWdlIGF1dGhlbnRpY2F0aW9uIGNvZGUsIHVzZWQgdG8gY2hlY2sgdGhlIHBhc3N3b3JkXG4gICAgICAgIGNvbnN0IG1hYyA9IGtlY2NhazI1Nihjb25jYXQoW21hY1ByZWZpeCwgY2lwaGVydGV4dF0pKTtcbiAgICAgICAgLy8gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZXRoZXJldW0vd2lraS93aWtpL1dlYjMtU2VjcmV0LVN0b3JhZ2UtRGVmaW5pdGlvblxuICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgYWRkcmVzczogYWNjb3VudC5hZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgaWQ6IHV1aWRWNCh1dWlkUmFuZG9tKSxcbiAgICAgICAgICAgIHZlcnNpb246IDMsXG4gICAgICAgICAgICBDcnlwdG86IHtcbiAgICAgICAgICAgICAgICBjaXBoZXI6IFwiYWVzLTEyOC1jdHJcIixcbiAgICAgICAgICAgICAgICBjaXBoZXJwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgaXY6IGhleGxpZnkoaXYpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IGhleGxpZnkoY2lwaGVydGV4dCkuc3Vic3RyaW5nKDIpLFxuICAgICAgICAgICAgICAgIGtkZjogXCJzY3J5cHRcIixcbiAgICAgICAgICAgICAgICBrZGZwYXJhbXM6IHtcbiAgICAgICAgICAgICAgICAgICAgc2FsdDogaGV4bGlmeShzYWx0KS5zdWJzdHJpbmcoMiksXG4gICAgICAgICAgICAgICAgICAgIG46IE4sXG4gICAgICAgICAgICAgICAgICAgIGRrbGVuOiAzMixcbiAgICAgICAgICAgICAgICAgICAgcDogcCxcbiAgICAgICAgICAgICAgICAgICAgcjogclxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbWFjOiBtYWMuc3Vic3RyaW5nKDIpXG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIElmIHdlIGhhdmUgYSBtbmVtb25pYywgZW5jcnlwdCBpdCBpbnRvIHRoZSBKU09OIHdhbGxldFxuICAgICAgICBpZiAoZW50cm9weSkge1xuICAgICAgICAgICAgY29uc3QgbW5lbW9uaWNJdiA9IHJhbmRvbUJ5dGVzKDE2KTtcbiAgICAgICAgICAgIGNvbnN0IG1uZW1vbmljQ291bnRlciA9IG5ldyBhZXMuQ291bnRlcihtbmVtb25pY0l2KTtcbiAgICAgICAgICAgIGNvbnN0IG1uZW1vbmljQWVzQ3RyID0gbmV3IGFlcy5Nb2RlT2ZPcGVyYXRpb24uY3RyKG1uZW1vbmljS2V5LCBtbmVtb25pY0NvdW50ZXIpO1xuICAgICAgICAgICAgY29uc3QgbW5lbW9uaWNDaXBoZXJ0ZXh0ID0gYXJyYXlpZnkobW5lbW9uaWNBZXNDdHIuZW5jcnlwdChlbnRyb3B5KSk7XG4gICAgICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgY29uc3QgdGltZXN0YW1wID0gKG5vdy5nZXRVVENGdWxsWWVhcigpICsgXCItXCIgK1xuICAgICAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ01vbnRoKCkgKyAxLCAyKSArIFwiLVwiICtcbiAgICAgICAgICAgICAgICB6cGFkKG5vdy5nZXRVVENEYXRlKCksIDIpICsgXCJUXCIgK1xuICAgICAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ0hvdXJzKCksIDIpICsgXCItXCIgK1xuICAgICAgICAgICAgICAgIHpwYWQobm93LmdldFVUQ01pbnV0ZXMoKSwgMikgKyBcIi1cIiArXG4gICAgICAgICAgICAgICAgenBhZChub3cuZ2V0VVRDU2Vjb25kcygpLCAyKSArIFwiLjBaXCIpO1xuICAgICAgICAgICAgZGF0YVtcIngtZXRoZXJzXCJdID0ge1xuICAgICAgICAgICAgICAgIGNsaWVudDogY2xpZW50LFxuICAgICAgICAgICAgICAgIGdldGhGaWxlbmFtZTogKFwiVVRDLS1cIiArIHRpbWVzdGFtcCArIFwiLS1cIiArIGRhdGEuYWRkcmVzcyksXG4gICAgICAgICAgICAgICAgbW5lbW9uaWNDb3VudGVyOiBoZXhsaWZ5KG1uZW1vbmljSXYpLnN1YnN0cmluZygyKSxcbiAgICAgICAgICAgICAgICBtbmVtb25pY0NpcGhlcnRleHQ6IGhleGxpZnkobW5lbW9uaWNDaXBoZXJ0ZXh0KS5zdWJzdHJpbmcoMiksXG4gICAgICAgICAgICAgICAgcGF0aDogcGF0aCxcbiAgICAgICAgICAgICAgICBsb2NhbGU6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiBcIjAuMVwiXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShkYXRhKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtleXN0b3JlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gfSBmcm9tICdAZXRoZXJzcHJvamVjdC9zdHJpbmdzJztcbmV4cG9ydCBmdW5jdGlvbiBsb29zZUFycmF5aWZ5KGhleFN0cmluZykge1xuICAgIGlmICh0eXBlb2YgKGhleFN0cmluZykgPT09ICdzdHJpbmcnICYmIGhleFN0cmluZy5zdWJzdHJpbmcoMCwgMikgIT09ICcweCcpIHtcbiAgICAgICAgaGV4U3RyaW5nID0gJzB4JyArIGhleFN0cmluZztcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5aWZ5KGhleFN0cmluZyk7XG59XG5leHBvcnQgZnVuY3Rpb24genBhZCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgdmFsdWUgPSBTdHJpbmcodmFsdWUpO1xuICAgIHdoaWxlICh2YWx1ZS5sZW5ndGggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAnMCcgKyB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGdldFBhc3N3b3JkKHBhc3N3b3JkKSB7XG4gICAgaWYgKHR5cGVvZiAocGFzc3dvcmQpID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdG9VdGY4Qnl0ZXMocGFzc3dvcmQsIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybS5ORktDKTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5aWZ5KHBhc3N3b3JkKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBzZWFyY2hQYXRoKG9iamVjdCwgcGF0aCkge1xuICAgIGxldCBjdXJyZW50Q2hpbGQgPSBvYmplY3Q7XG4gICAgY29uc3QgY29tcHMgPSBwYXRoLnRvTG93ZXJDYXNlKCkuc3BsaXQoJy8nKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbXBzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIC8vIFNlYXJjaCBmb3IgYSBjaGlsZCBvYmplY3Qgd2l0aCBhIGNhc2UtaW5zZW5zaXRpdmUgbWF0Y2hpbmcga2V5XG4gICAgICAgIGxldCBtYXRjaGluZ0NoaWxkID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gY3VycmVudENoaWxkKSB7XG4gICAgICAgICAgICBpZiAoa2V5LnRvTG93ZXJDYXNlKCkgPT09IGNvbXBzW2ldKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2hpbmdDaGlsZCA9IGN1cnJlbnRDaGlsZFtrZXldO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIERpZG4ndCBmaW5kIG9uZS4gOicoXG4gICAgICAgIGlmIChtYXRjaGluZ0NoaWxkID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICAvLyBOb3cgY2hlY2sgdGhpcyBjaGlsZC4uLlxuICAgICAgICBjdXJyZW50Q2hpbGQgPSBtYXRjaGluZ0NoaWxkO1xuICAgIH1cbiAgICByZXR1cm4gY3VycmVudENoaWxkO1xufVxuLy8gU2VlOiBodHRwczovL3d3dy5pZXRmLm9yZy9yZmMvcmZjNDEyMi50eHQgKFNlY3Rpb24gNC40KVxuZXhwb3J0IGZ1bmN0aW9uIHV1aWRWNChyYW5kb21CeXRlcykge1xuICAgIGNvbnN0IGJ5dGVzID0gYXJyYXlpZnkocmFuZG9tQnl0ZXMpO1xuICAgIC8vIFNlY3Rpb246IDQuMS4zOlxuICAgIC8vIC0gdGltZV9oaV9hbmRfdmVyc2lvblsxMjoxNl0gPSAwYjAxMDBcbiAgICBieXRlc1s2XSA9IChieXRlc1s2XSAmIDB4MGYpIHwgMHg0MDtcbiAgICAvLyBTZWN0aW9uIDQuNFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs2XSA9IDBiMFxuICAgIC8vIC0gY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZFs3XSA9IDBiMVxuICAgIGJ5dGVzWzhdID0gKGJ5dGVzWzhdICYgMHgzZikgfCAweDgwO1xuICAgIGNvbnN0IHZhbHVlID0gaGV4bGlmeShieXRlcyk7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDIsIDEwKSxcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDEwLCAxNCksXG4gICAgICAgIHZhbHVlLnN1YnN0cmluZygxNCwgMTgpLFxuICAgICAgICB2YWx1ZS5zdWJzdHJpbmcoMTgsIDIyKSxcbiAgICAgICAgdmFsdWUuc3Vic3RyaW5nKDIyLCAzNCksXG4gICAgXS5qb2luKFwiLVwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXV0aWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHNoYTMgZnJvbSBcImpzLXNoYTNcIjtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5leHBvcnQgZnVuY3Rpb24ga2VjY2FrMjU2KGRhdGEpIHtcbiAgICByZXR1cm4gJzB4JyArIHNoYTMua2VjY2FrXzI1NihhcnJheWlmeShkYXRhKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwibG9nZ2VyLzUuNS4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmxldCBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gZmFsc2U7XG5sZXQgX2NlbnNvckVycm9ycyA9IGZhbHNlO1xuY29uc3QgTG9nTGV2ZWxzID0geyBkZWJ1ZzogMSwgXCJkZWZhdWx0XCI6IDIsIGluZm86IDIsIHdhcm5pbmc6IDMsIGVycm9yOiA0LCBvZmY6IDUgfTtcbmxldCBfbG9nTGV2ZWwgPSBMb2dMZXZlbHNbXCJkZWZhdWx0XCJdO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5sZXQgX2dsb2JhbExvZ2dlciA9IG51bGw7XG5mdW5jdGlvbiBfY2hlY2tOb3JtYWxpemUoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgbWlzc2luZyA9IFtdO1xuICAgICAgICAvLyBNYWtlIHN1cmUgYWxsIGZvcm1zIG9mIG5vcm1hbGl6YXRpb24gYXJlIHN1cHBvcnRlZFxuICAgICAgICBbXCJORkRcIiwgXCJORkNcIiwgXCJORktEXCIsIFwiTkZLQ1wiXS5mb3JFYWNoKChmb3JtKSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmIChcInRlc3RcIi5ub3JtYWxpemUoZm9ybSkgIT09IFwidGVzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCBub3JtYWxpemVcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIG1pc3NpbmcucHVzaChmb3JtKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChtaXNzaW5nLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwibWlzc2luZyBcIiArIG1pc3Npbmcuam9pbihcIiwgXCIpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoU3RyaW5nLmZyb21DaGFyQ29kZSgweGU5KS5ub3JtYWxpemUoXCJORkRcIikgIT09IFN0cmluZy5mcm9tQ2hhckNvZGUoMHg2NSwgMHgwMzAxKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYnJva2VuIGltcGxlbWVudGF0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICByZXR1cm4gZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5jb25zdCBfbm9ybWFsaXplRXJyb3IgPSBfY2hlY2tOb3JtYWxpemUoKTtcbmV4cG9ydCB2YXIgTG9nTGV2ZWw7XG4oZnVuY3Rpb24gKExvZ0xldmVsKSB7XG4gICAgTG9nTGV2ZWxbXCJERUJVR1wiXSA9IFwiREVCVUdcIjtcbiAgICBMb2dMZXZlbFtcIklORk9cIl0gPSBcIklORk9cIjtcbiAgICBMb2dMZXZlbFtcIldBUk5JTkdcIl0gPSBcIldBUk5JTkdcIjtcbiAgICBMb2dMZXZlbFtcIkVSUk9SXCJdID0gXCJFUlJPUlwiO1xuICAgIExvZ0xldmVsW1wiT0ZGXCJdID0gXCJPRkZcIjtcbn0pKExvZ0xldmVsIHx8IChMb2dMZXZlbCA9IHt9KSk7XG5leHBvcnQgdmFyIEVycm9yQ29kZTtcbihmdW5jdGlvbiAoRXJyb3JDb2RlKSB7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEdlbmVyaWMgRXJyb3JzXG4gICAgLy8gVW5rbm93biBFcnJvclxuICAgIEVycm9yQ29kZVtcIlVOS05PV05fRVJST1JcIl0gPSBcIlVOS05PV05fRVJST1JcIjtcbiAgICAvLyBOb3QgSW1wbGVtZW50ZWRcbiAgICBFcnJvckNvZGVbXCJOT1RfSU1QTEVNRU5URURcIl0gPSBcIk5PVF9JTVBMRU1FTlRFRFwiO1xuICAgIC8vIFVuc3VwcG9ydGVkIE9wZXJhdGlvblxuICAgIC8vICAgLSBvcGVyYXRpb25cbiAgICBFcnJvckNvZGVbXCJVTlNVUFBPUlRFRF9PUEVSQVRJT05cIl0gPSBcIlVOU1VQUE9SVEVEX09QRVJBVElPTlwiO1xuICAgIC8vIE5ldHdvcmsgRXJyb3IgKGkuZS4gRXRoZXJldW0gTmV0d29yaywgc3VjaCBhcyBhbiBpbnZhbGlkIGNoYWluIElEKVxuICAgIC8vICAgLSBldmVudCAoXCJub05ldHdvcmtcIiBpcyBub3QgcmUtdGhyb3duIGluIHByb3ZpZGVyLnJlYWR5OyBvdGhlcndpc2UgdGhyb3duKVxuICAgIEVycm9yQ29kZVtcIk5FVFdPUktfRVJST1JcIl0gPSBcIk5FVFdPUktfRVJST1JcIjtcbiAgICAvLyBTb21lIHNvcnQgb2YgYmFkIHJlc3BvbnNlIGZyb20gdGhlIHNlcnZlclxuICAgIEVycm9yQ29kZVtcIlNFUlZFUl9FUlJPUlwiXSA9IFwiU0VSVkVSX0VSUk9SXCI7XG4gICAgLy8gVGltZW91dFxuICAgIEVycm9yQ29kZVtcIlRJTUVPVVRcIl0gPSBcIlRJTUVPVVRcIjtcbiAgICAvLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gT3BlcmF0aW9uYWwgIEVycm9yc1xuICAgIC8vIEJ1ZmZlciBPdmVycnVuXG4gICAgRXJyb3JDb2RlW1wiQlVGRkVSX09WRVJSVU5cIl0gPSBcIkJVRkZFUl9PVkVSUlVOXCI7XG4gICAgLy8gTnVtZXJpYyBGYXVsdFxuICAgIC8vICAgLSBvcGVyYXRpb246IHRoZSBvcGVyYXRpb24gYmVpbmcgZXhlY3V0ZWRcbiAgICAvLyAgIC0gZmF1bHQ6IHRoZSByZWFzb24gdGhpcyBmYXVsdGVkXG4gICAgRXJyb3JDb2RlW1wiTlVNRVJJQ19GQVVMVFwiXSA9IFwiTlVNRVJJQ19GQVVMVFwiO1xuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBBcmd1bWVudCBFcnJvcnNcbiAgICAvLyBNaXNzaW5nIG5ldyBvcGVyYXRvciB0byBhbiBvYmplY3RcbiAgICAvLyAgLSBuYW1lOiBUaGUgbmFtZSBvZiB0aGUgY2xhc3NcbiAgICBFcnJvckNvZGVbXCJNSVNTSU5HX05FV1wiXSA9IFwiTUlTU0lOR19ORVdcIjtcbiAgICAvLyBJbnZhbGlkIGFyZ3VtZW50IChlLmcuIHZhbHVlIGlzIGluY29tcGF0aWJsZSB3aXRoIHR5cGUpIHRvIGEgZnVuY3Rpb246XG4gICAgLy8gICAtIGFyZ3VtZW50OiBUaGUgYXJndW1lbnQgbmFtZSB0aGF0IHdhcyBpbnZhbGlkXG4gICAgLy8gICAtIHZhbHVlOiBUaGUgdmFsdWUgb2YgdGhlIGFyZ3VtZW50XG4gICAgRXJyb3JDb2RlW1wiSU5WQUxJRF9BUkdVTUVOVFwiXSA9IFwiSU5WQUxJRF9BUkdVTUVOVFwiO1xuICAgIC8vIE1pc3NpbmcgYXJndW1lbnQgdG8gYSBmdW5jdGlvbjpcbiAgICAvLyAgIC0gY291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIHJlY2VpdmVkXG4gICAgLy8gICAtIGV4cGVjdGVkQ291bnQ6IFRoZSBudW1iZXIgb2YgYXJndW1lbnRzIGV4cGVjdGVkXG4gICAgRXJyb3JDb2RlW1wiTUlTU0lOR19BUkdVTUVOVFwiXSA9IFwiTUlTU0lOR19BUkdVTUVOVFwiO1xuICAgIC8vIFRvbyBtYW55IGFyZ3VtZW50c1xuICAgIC8vICAgLSBjb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgcmVjZWl2ZWRcbiAgICAvLyAgIC0gZXhwZWN0ZWRDb3VudDogVGhlIG51bWJlciBvZiBhcmd1bWVudHMgZXhwZWN0ZWRcbiAgICBFcnJvckNvZGVbXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCJdID0gXCJVTkVYUEVDVEVEX0FSR1VNRU5UXCI7XG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vL1xuICAgIC8vIEJsb2NrY2hhaW4gRXJyb3JzXG4gICAgLy8gQ2FsbCBleGNlcHRpb25cbiAgICAvLyAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uXG4gICAgLy8gIC0gYWRkcmVzcz86IHRoZSBjb250cmFjdCBhZGRyZXNzXG4gICAgLy8gIC0gYXJncz86IFRoZSBhcmd1bWVudHMgcGFzc2VkIGludG8gdGhlIGZ1bmN0aW9uXG4gICAgLy8gIC0gbWV0aG9kPzogVGhlIFNvbGlkaXR5IG1ldGhvZCBzaWduYXR1cmVcbiAgICAvLyAgLSBlcnJvclNpZ25hdHVyZT86IFRoZSBFSVA4NDggZXJyb3Igc2lnbmF0dXJlXG4gICAgLy8gIC0gZXJyb3JBcmdzPzogVGhlIEVJUDg0OCBlcnJvciBwYXJhbWV0ZXJzXG4gICAgLy8gIC0gcmVhc29uOiBUaGUgcmVhc29uIChvbmx5IGZvciBFSVA4NDggXCJFcnJvcihzdHJpbmcpXCIpXG4gICAgRXJyb3JDb2RlW1wiQ0FMTF9FWENFUFRJT05cIl0gPSBcIkNBTExfRVhDRVBUSU9OXCI7XG4gICAgLy8gSW5zdWZmaWNpZW50IGZ1bmRzICg8IHZhbHVlICsgZ2FzTGltaXQgKiBnYXNQcmljZSlcbiAgICAvLyAgIC0gdHJhbnNhY3Rpb246IHRoZSB0cmFuc2FjdGlvbiBhdHRlbXB0ZWRcbiAgICBFcnJvckNvZGVbXCJJTlNVRkZJQ0lFTlRfRlVORFNcIl0gPSBcIklOU1VGRklDSUVOVF9GVU5EU1wiO1xuICAgIC8vIE5vbmNlIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIk5PTkNFX0VYUElSRURcIl0gPSBcIk5PTkNFX0VYUElSRURcIjtcbiAgICAvLyBUaGUgcmVwbGFjZW1lbnQgZmVlIGZvciB0aGUgdHJhbnNhY3Rpb24gaXMgdG9vIGxvd1xuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIGF0dGVtcHRlZFxuICAgIEVycm9yQ29kZVtcIlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VEXCJdID0gXCJSRVBMQUNFTUVOVF9VTkRFUlBSSUNFRFwiO1xuICAgIC8vIFRoZSBnYXMgbGltaXQgY291bGQgbm90IGJlIGVzdGltYXRlZFxuICAgIC8vICAgLSB0cmFuc2FjdGlvbjogdGhlIHRyYW5zYWN0aW9uIHBhc3NlZCB0byBlc3RpbWF0ZUdhc1xuICAgIEVycm9yQ29kZVtcIlVOUFJFRElDVEFCTEVfR0FTX0xJTUlUXCJdID0gXCJVTlBSRURJQ1RBQkxFX0dBU19MSU1JVFwiO1xuICAgIC8vIFRoZSB0cmFuc2FjdGlvbiB3YXMgcmVwbGFjZWQgYnkgb25lIHdpdGggYSBoaWdoZXIgZ2FzIHByaWNlXG4gICAgLy8gICAtIHJlYXNvbjogXCJjYW5jZWxsZWRcIiwgXCJyZXBsYWNlZFwiIG9yIFwicmVwcmljZWRcIlxuICAgIC8vICAgLSBjYW5jZWxsZWQ6IHRydWUgaWYgcmVhc29uID09IFwiY2FuY2VsbGVkXCIgb3IgcmVhc29uID09IFwicmVwbGFjZWRcIilcbiAgICAvLyAgIC0gaGFzaDogb3JpZ2luYWwgdHJhbnNhY3Rpb24gaGFzaFxuICAgIC8vICAgLSByZXBsYWNlbWVudDogdGhlIGZ1bGwgVHJhbnNhY3Rpb25zUmVzcG9uc2UgZm9yIHRoZSByZXBsYWNlbWVudFxuICAgIC8vICAgLSByZWNlaXB0OiB0aGUgcmVjZWlwdCBvZiB0aGUgcmVwbGFjZW1lbnRcbiAgICBFcnJvckNvZGVbXCJUUkFOU0FDVElPTl9SRVBMQUNFRFwiXSA9IFwiVFJBTlNBQ1RJT05fUkVQTEFDRURcIjtcbn0pKEVycm9yQ29kZSB8fCAoRXJyb3JDb2RlID0ge30pKTtcbjtcbmNvbnN0IEhFWCA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuZXhwb3J0IGNsYXNzIExvZ2dlciB7XG4gICAgY29uc3RydWN0b3IodmVyc2lvbikge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2ZXJzaW9uXCIsIHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogdmVyc2lvbixcbiAgICAgICAgICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2xvZyhsb2dMZXZlbCwgYXJncykge1xuICAgICAgICBjb25zdCBsZXZlbCA9IGxvZ0xldmVsLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChMb2dMZXZlbHNbbGV2ZWxdID09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsb2cgbGV2ZWwgbmFtZVwiLCBcImxvZ0xldmVsXCIsIGxvZ0xldmVsKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX2xvZ0xldmVsID4gTG9nTGV2ZWxzW2xldmVsXSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUubG9nLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgIH1cbiAgICBkZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLkRFQlVHLCBhcmdzKTtcbiAgICB9XG4gICAgaW5mbyguLi5hcmdzKSB7XG4gICAgICAgIHRoaXMuX2xvZyhMb2dnZXIubGV2ZWxzLklORk8sIGFyZ3MpO1xuICAgIH1cbiAgICB3YXJuKC4uLmFyZ3MpIHtcbiAgICAgICAgdGhpcy5fbG9nKExvZ2dlci5sZXZlbHMuV0FSTklORywgYXJncyk7XG4gICAgfVxuICAgIG1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgLy8gRXJyb3JzIGFyZSBiZWluZyBjZW5zb3JlZFxuICAgICAgICBpZiAoX2NlbnNvckVycm9ycykge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubWFrZUVycm9yKFwiY2Vuc29yZWQgZXJyb3JcIiwgY29kZSwge30pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghY29kZSkge1xuICAgICAgICAgICAgY29kZSA9IExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXBhcmFtcykge1xuICAgICAgICAgICAgcGFyYW1zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVzc2FnZURldGFpbHMgPSBbXTtcbiAgICAgICAgT2JqZWN0LmtleXMocGFyYW1zKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcGFyYW1zW2tleV07XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGhleCA9IFwiXCI7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdmFsdWUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhleCArPSBIRVhbdmFsdWVbaV0gPj4gNF07XG4gICAgICAgICAgICAgICAgICAgICAgICBoZXggKz0gSEVYW3ZhbHVlW2ldICYgMHgwZl07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChrZXkgKyBcIj1VaW50OEFycmF5KDB4XCIgKyBoZXggKyBcIilcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlRGV0YWlscy5wdXNoKGtleSArIFwiPVwiICsgSlNPTi5zdHJpbmdpZnkocGFyYW1zW2tleV0udG9TdHJpbmcoKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZURldGFpbHMucHVzaChgY29kZT0ke2NvZGV9YCk7XG4gICAgICAgIG1lc3NhZ2VEZXRhaWxzLnB1c2goYHZlcnNpb249JHt0aGlzLnZlcnNpb259YCk7XG4gICAgICAgIGNvbnN0IHJlYXNvbiA9IG1lc3NhZ2U7XG4gICAgICAgIGlmIChtZXNzYWdlRGV0YWlscy5sZW5ndGgpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgKz0gXCIgKFwiICsgbWVzc2FnZURldGFpbHMuam9pbihcIiwgXCIpICsgXCIpXCI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQFRPRE86IEFueT8/XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5yZWFzb24gPSByZWFzb247XG4gICAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgZXJyb3Jba2V5XSA9IHBhcmFtc1trZXldO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cbiAgICB0aHJvd0Vycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcykge1xuICAgICAgICB0aHJvdyB0aGlzLm1ha2VFcnJvcihtZXNzYWdlLCBjb2RlLCBwYXJhbXMpO1xuICAgIH1cbiAgICB0aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGhyb3dFcnJvcihtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgIGFyZ3VtZW50OiBuYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3NlcnQoY29uZGl0aW9uLCBtZXNzYWdlLCBjb2RlLCBwYXJhbXMpIHtcbiAgICAgICAgaWYgKCEhY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIGNvZGUsIHBhcmFtcyk7XG4gICAgfVxuICAgIGFzc2VydEFyZ3VtZW50KGNvbmRpdGlvbiwgbWVzc2FnZSwgbmFtZSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKCEhY29uZGl0aW9uKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy50aHJvd0FyZ3VtZW50RXJyb3IobWVzc2FnZSwgbmFtZSwgdmFsdWUpO1xuICAgIH1cbiAgICBjaGVja05vcm1hbGl6ZShtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcInBsYXRmb3JtIG1pc3NpbmcgU3RyaW5nLnByb3RvdHlwZS5ub3JtYWxpemVcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX25vcm1hbGl6ZUVycm9yKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJwbGF0Zm9ybSBtaXNzaW5nIFN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIlN0cmluZy5wcm90b3R5cGUubm9ybWFsaXplXCIsIGZvcm06IF9ub3JtYWxpemVFcnJvclxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tTYWZlVWludDUzKHZhbHVlLCBtZXNzYWdlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXNzYWdlID09IG51bGwpIHtcbiAgICAgICAgICAgIG1lc3NhZ2UgPSBcInZhbHVlIG5vdCBzYWZlXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlIDwgMCB8fCB2YWx1ZSA+PSAweDFmZmZmZmZmZmZmZmZmKSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IobWVzc2FnZSwgTG9nZ2VyLmVycm9ycy5OVU1FUklDX0ZBVUxULCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNoZWNrU2FmZUludGVnZXJcIixcbiAgICAgICAgICAgICAgICBmYXVsdDogXCJvdXQtb2Ytc2FmZS1yYW5nZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlOiB2YWx1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICUgMSkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKG1lc3NhZ2UsIExvZ2dlci5lcnJvcnMuTlVNRVJJQ19GQVVMVCwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjaGVja1NhZmVJbnRlZ2VyXCIsXG4gICAgICAgICAgICAgICAgZmF1bHQ6IFwibm9uLWludGVnZXJcIixcbiAgICAgICAgICAgICAgICB2YWx1ZTogdmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNoZWNrQXJndW1lbnRDb3VudChjb3VudCwgZXhwZWN0ZWRDb3VudCwgbWVzc2FnZSkge1xuICAgICAgICBpZiAobWVzc2FnZSkge1xuICAgICAgICAgICAgbWVzc2FnZSA9IFwiOiBcIiArIG1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gXCJcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY291bnQgPCBleHBlY3RlZENvdW50KSB7XG4gICAgICAgICAgICB0aGlzLnRocm93RXJyb3IoXCJtaXNzaW5nIGFyZ3VtZW50XCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLk1JU1NJTkdfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvdW50ID4gZXhwZWN0ZWRDb3VudCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwidG9vIG1hbnkgYXJndW1lbnRzXCIgKyBtZXNzYWdlLCBMb2dnZXIuZXJyb3JzLlVORVhQRUNURURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICBjb3VudDogY291bnQsXG4gICAgICAgICAgICAgICAgZXhwZWN0ZWRDb3VudDogZXhwZWN0ZWRDb3VudFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tOZXcodGFyZ2V0LCBraW5kKSB7XG4gICAgICAgIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY2hlY2tBYnN0cmFjdCh0YXJnZXQsIGtpbmQpIHtcbiAgICAgICAgaWYgKHRhcmdldCA9PT0ga2luZCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwiY2Fubm90IGluc3RhbnRpYXRlIGFic3RyYWN0IGNsYXNzIFwiICsgSlNPTi5zdHJpbmdpZnkoa2luZC5uYW1lKSArIFwiIGRpcmVjdGx5OyB1c2UgYSBzdWItY2xhc3NcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHsgbmFtZTogdGFyZ2V0Lm5hbWUsIG9wZXJhdGlvbjogXCJuZXdcIiB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0YXJnZXQgPT09IE9iamVjdCB8fCB0YXJnZXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhpcy50aHJvd0Vycm9yKFwibWlzc2luZyBuZXdcIiwgTG9nZ2VyLmVycm9ycy5NSVNTSU5HX05FVywgeyBuYW1lOiBraW5kLm5hbWUgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgc3RhdGljIGdsb2JhbExvZ2dlcigpIHtcbiAgICAgICAgaWYgKCFfZ2xvYmFsTG9nZ2VyKSB7XG4gICAgICAgICAgICBfZ2xvYmFsTG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2dsb2JhbExvZ2dlcjtcbiAgICB9XG4gICAgc3RhdGljIHNldENlbnNvcnNoaXAoY2Vuc29yc2hpcCwgcGVybWFuZW50KSB7XG4gICAgICAgIGlmICghY2Vuc29yc2hpcCAmJiBwZXJtYW5lbnQpIHtcbiAgICAgICAgICAgIHRoaXMuZ2xvYmFsTG9nZ2VyKCkudGhyb3dFcnJvcihcImNhbm5vdCBwZXJtYW5lbnRseSBkaXNhYmxlIGNlbnNvcnNoaXBcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX3Blcm1hbmVudENlbnNvckVycm9ycykge1xuICAgICAgICAgICAgaWYgKCFjZW5zb3JzaGlwKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5nbG9iYWxMb2dnZXIoKS50aHJvd0Vycm9yKFwiZXJyb3IgY2Vuc29yc2hpcCBwZXJtYW5lbnRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwic2V0Q2Vuc29yc2hpcFwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfY2Vuc29yRXJyb3JzID0gISFjZW5zb3JzaGlwO1xuICAgICAgICBfcGVybWFuZW50Q2Vuc29yRXJyb3JzID0gISFwZXJtYW5lbnQ7XG4gICAgfVxuICAgIHN0YXRpYyBzZXRMb2dMZXZlbChsb2dMZXZlbCkge1xuICAgICAgICBjb25zdCBsZXZlbCA9IExvZ0xldmVsc1tsb2dMZXZlbC50b0xvd2VyQ2FzZSgpXTtcbiAgICAgICAgaWYgKGxldmVsID09IG51bGwpIHtcbiAgICAgICAgICAgIExvZ2dlci5nbG9iYWxMb2dnZXIoKS53YXJuKFwiaW52YWxpZCBsb2cgbGV2ZWwgLSBcIiArIGxvZ0xldmVsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBfbG9nTGV2ZWwgPSBsZXZlbDtcbiAgICB9XG4gICAgc3RhdGljIGZyb20odmVyc2lvbikge1xuICAgICAgICByZXR1cm4gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbiAgICB9XG59XG5Mb2dnZXIuZXJyb3JzID0gRXJyb3JDb2RlO1xuTG9nZ2VyLmxldmVscyA9IExvZ0xldmVsO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIm5ldHdvcmtzLzUuNS4xXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbjtcbmZ1bmN0aW9uIGlzUmVuZXR3b3JrYWJsZSh2YWx1ZSkge1xuICAgIHJldHVybiAodmFsdWUgJiYgdHlwZW9mICh2YWx1ZS5yZW5ldHdvcmspID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZnVuY3Rpb24gZXRoRGVmYXVsdFByb3ZpZGVyKG5ldHdvcmspIHtcbiAgICBjb25zdCBmdW5jID0gZnVuY3Rpb24gKHByb3ZpZGVycywgb3B0aW9ucykge1xuICAgICAgICBpZiAob3B0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcHJvdmlkZXJMaXN0ID0gW107XG4gICAgICAgIGlmIChwcm92aWRlcnMuSW5mdXJhUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5JbmZ1cmFQcm92aWRlcihuZXR3b3JrLCBvcHRpb25zLmluZnVyYSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLkV0aGVyc2NhblByb3ZpZGVyKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHByb3ZpZGVyTGlzdC5wdXNoKG5ldyBwcm92aWRlcnMuRXRoZXJzY2FuUHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5ldGhlcnNjYW4pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByb3ZpZGVycy5BbGNoZW15UHJvdmlkZXIpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcHJvdmlkZXJMaXN0LnB1c2gobmV3IHByb3ZpZGVycy5BbGNoZW15UHJvdmlkZXIobmV0d29yaywgb3B0aW9ucy5hbGNoZW15KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlcnMuUG9ja2V0UHJvdmlkZXIpIHtcbiAgICAgICAgICAgIC8vIFRoZXNlIG5ldHdvcmtzIGFyZSBjdXJyZW50bHkgZmF1bHR5IG9uIFBvY2tldCBhcyB0aGVpclxuICAgICAgICAgICAgLy8gbmV0d29yayBkb2VzIG5vdCBoYW5kbGUgdGhlIEJlcmxpbiBoYXJkZm9yaywgd2hpY2ggaXNcbiAgICAgICAgICAgIC8vIGxpdmUgb24gdGhlc2Ugb25lcy5cbiAgICAgICAgICAgIC8vIEBUT0RPOiBUaGlzIGdvZXMgYXdheSBvbmNlIFBvY2tldCBoYXMgdXBncmFkZWQgdGhlaXIgbm9kZXNcbiAgICAgICAgICAgIGNvbnN0IHNraXAgPSBbXCJnb2VybGlcIiwgXCJyb3BzdGVuXCIsIFwicmlua2VieVwiXTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgcHJvdmlkZXJzLlBvY2tldFByb3ZpZGVyKG5ldHdvcmspO1xuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5uZXR3b3JrICYmIHNraXAuaW5kZXhPZihwcm92aWRlci5uZXR3b3JrLm5hbWUpID09PSAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLkNsb3VkZmxhcmVQcm92aWRlcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwcm92aWRlckxpc3QucHVzaChuZXcgcHJvdmlkZXJzLkNsb3VkZmxhcmVQcm92aWRlcihuZXR3b3JrKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm92aWRlckxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvdmlkZXJzLkZhbGxiYWNrUHJvdmlkZXIpIHtcbiAgICAgICAgICAgIGxldCBxdW9ydW0gPSAxO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMucXVvcnVtICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBxdW9ydW0gPSBvcHRpb25zLnF1b3J1bTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKG5ldHdvcmsgPT09IFwiaG9tZXN0ZWFkXCIpIHtcbiAgICAgICAgICAgICAgICBxdW9ydW0gPSAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIG5ldyBwcm92aWRlcnMuRmFsbGJhY2tQcm92aWRlcihwcm92aWRlckxpc3QsIHF1b3J1bSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHByb3ZpZGVyTGlzdFswXTtcbiAgICB9O1xuICAgIGZ1bmMucmVuZXR3b3JrID0gZnVuY3Rpb24gKG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIGV0aERlZmF1bHRQcm92aWRlcihuZXR3b3JrKTtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jO1xufVxuZnVuY3Rpb24gZXRjRGVmYXVsdFByb3ZpZGVyKHVybCwgbmV0d29yaykge1xuICAgIGNvbnN0IGZ1bmMgPSBmdW5jdGlvbiAocHJvdmlkZXJzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmIChwcm92aWRlcnMuSnNvblJwY1Byb3ZpZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHByb3ZpZGVycy5Kc29uUnBjUHJvdmlkZXIodXJsLCBuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9O1xuICAgIGZ1bmMucmVuZXR3b3JrID0gZnVuY3Rpb24gKG5ldHdvcmspIHtcbiAgICAgICAgcmV0dXJuIGV0Y0RlZmF1bHRQcm92aWRlcih1cmwsIG5ldHdvcmspO1xuICAgIH07XG4gICAgcmV0dXJuIGZ1bmM7XG59XG5jb25zdCBob21lc3RlYWQgPSB7XG4gICAgY2hhaW5JZDogMSxcbiAgICBlbnNBZGRyZXNzOiBcIjB4MDAwMDAwMDAwMDBDMkUwNzRlQzY5QTBkRmIyOTk3QkE2QzdkMmUxZVwiLFxuICAgIG5hbWU6IFwiaG9tZXN0ZWFkXCIsXG4gICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwiaG9tZXN0ZWFkXCIpXG59O1xuY29uc3Qgcm9wc3RlbiA9IHtcbiAgICBjaGFpbklkOiAzLFxuICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG4gICAgbmFtZTogXCJyb3BzdGVuXCIsXG4gICAgX2RlZmF1bHRQcm92aWRlcjogZXRoRGVmYXVsdFByb3ZpZGVyKFwicm9wc3RlblwiKVxufTtcbmNvbnN0IGNsYXNzaWNNb3Jkb3IgPSB7XG4gICAgY2hhaW5JZDogNjMsXG4gICAgbmFtZTogXCJjbGFzc2ljTW9yZG9yXCIsXG4gICAgX2RlZmF1bHRQcm92aWRlcjogZXRjRGVmYXVsdFByb3ZpZGVyKFwiaHR0cHM6Ly93d3cuZXRoZXJjbHVzdGVyLmNvbS9tb3Jkb3JcIiwgXCJjbGFzc2ljTW9yZG9yXCIpXG59O1xuLy8gU2VlOiBodHRwczovL2NoYWlubGlzdC5vcmdcbmNvbnN0IG5ldHdvcmtzID0ge1xuICAgIHVuc3BlY2lmaWVkOiB7IGNoYWluSWQ6IDAsIG5hbWU6IFwidW5zcGVjaWZpZWRcIiB9LFxuICAgIGhvbWVzdGVhZDogaG9tZXN0ZWFkLFxuICAgIG1haW5uZXQ6IGhvbWVzdGVhZCxcbiAgICBtb3JkZW46IHsgY2hhaW5JZDogMiwgbmFtZTogXCJtb3JkZW5cIiB9LFxuICAgIHJvcHN0ZW46IHJvcHN0ZW4sXG4gICAgdGVzdG5ldDogcm9wc3RlbixcbiAgICByaW5rZWJ5OiB7XG4gICAgICAgIGNoYWluSWQ6IDQsXG4gICAgICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG4gICAgICAgIG5hbWU6IFwicmlua2VieVwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJyaW5rZWJ5XCIpXG4gICAgfSxcbiAgICBrb3Zhbjoge1xuICAgICAgICBjaGFpbklkOiA0MixcbiAgICAgICAgbmFtZTogXCJrb3ZhblwiLFxuICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiBldGhEZWZhdWx0UHJvdmlkZXIoXCJrb3ZhblwiKVxuICAgIH0sXG4gICAgZ29lcmxpOiB7XG4gICAgICAgIGNoYWluSWQ6IDUsXG4gICAgICAgIGVuc0FkZHJlc3M6IFwiMHgwMDAwMDAwMDAwMEMyRTA3NGVDNjlBMGRGYjI5OTdCQTZDN2QyZTFlXCIsXG4gICAgICAgIG5hbWU6IFwiZ29lcmxpXCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0aERlZmF1bHRQcm92aWRlcihcImdvZXJsaVwiKVxuICAgIH0sXG4gICAgLy8gRVRDIChTZWU6ICMzNTEpXG4gICAgY2xhc3NpYzoge1xuICAgICAgICBjaGFpbklkOiA2MSxcbiAgICAgICAgbmFtZTogXCJjbGFzc2ljXCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi9cXC93d3cuZXRoZXJjbHVzdGVyLmNvbS9ldGNcIiwgXCJjbGFzc2ljXCIpXG4gICAgfSxcbiAgICBjbGFzc2ljTW9yZGVuOiB7IGNoYWluSWQ6IDYyLCBuYW1lOiBcImNsYXNzaWNNb3JkZW5cIiB9LFxuICAgIGNsYXNzaWNNb3Jkb3I6IGNsYXNzaWNNb3Jkb3IsXG4gICAgY2xhc3NpY1Rlc3RuZXQ6IGNsYXNzaWNNb3Jkb3IsXG4gICAgY2xhc3NpY0tvdHRpOiB7XG4gICAgICAgIGNoYWluSWQ6IDYsXG4gICAgICAgIG5hbWU6IFwiY2xhc3NpY0tvdHRpXCIsXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGV0Y0RlZmF1bHRQcm92aWRlcihcImh0dHBzOi9cXC93d3cuZXRoZXJjbHVzdGVyLmNvbS9rb3R0aVwiLCBcImNsYXNzaWNLb3R0aVwiKVxuICAgIH0sXG4gICAgeGRhaTogeyBjaGFpbklkOiAxMDAsIG5hbWU6IFwieGRhaVwiIH0sXG4gICAgbWF0aWM6IHsgY2hhaW5JZDogMTM3LCBuYW1lOiBcIm1hdGljXCIgfSxcbiAgICBtYXRpY211bTogeyBjaGFpbklkOiA4MDAwMSwgbmFtZTogXCJtYXRpY211bVwiIH0sXG4gICAgb3B0aW1pc206IHsgY2hhaW5JZDogMTAsIG5hbWU6IFwib3B0aW1pc21cIiB9LFxuICAgIFwib3B0aW1pc20ta292YW5cIjogeyBjaGFpbklkOiA2OSwgbmFtZTogXCJvcHRpbWlzbS1rb3ZhblwiIH0sXG4gICAgXCJvcHRpbWlzbS1nb2VybGlcIjogeyBjaGFpbklkOiA0MjAsIG5hbWU6IFwib3B0aW1pc20tZ29lcmxpXCIgfSxcbiAgICBhcmJpdHJ1bTogeyBjaGFpbklkOiA0MjE2MSwgbmFtZTogXCJhcmJpdHJ1bVwiIH0sXG4gICAgXCJhcmJpdHJ1bS1yaW5rZWJ5XCI6IHsgY2hhaW5JZDogNDIxNjExLCBuYW1lOiBcImFyYml0cnVtLXJpbmtlYnlcIiB9LFxuICAgIGJuYjogeyBjaGFpbklkOiA1NiwgbmFtZTogXCJibmJcIiB9LFxuICAgIGJuYnQ6IHsgY2hhaW5JZDogOTcsIG5hbWU6IFwiYm5idFwiIH0sXG59O1xuLyoqXG4gKiAgZ2V0TmV0d29ya1xuICpcbiAqICBDb252ZXJ0cyBhIG5hbWVkIGNvbW1vbiBuZXR3b3JrcyBvciBjaGFpbiBJRCAobmV0d29yayBJRCkgdG8gYSBOZXR3b3JrXG4gKiAgYW5kIHZlcmlmaWVzIGEgbmV0d29yayBpcyBhIHZhbGlkIE5ldHdvcmsuLlxuICovXG5leHBvcnQgZnVuY3Rpb24gZ2V0TmV0d29yayhuZXR3b3JrKSB7XG4gICAgLy8gTm8gbmV0d29yayAobnVsbClcbiAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gbmV0d29ya3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YW5kYXJkID0gbmV0d29ya3NbbmFtZV07XG4gICAgICAgICAgICBpZiAoc3RhbmRhcmQuY2hhaW5JZCA9PT0gbmV0d29yaykge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IHN0YW5kYXJkLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IHN0YW5kYXJkLmNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgIGVuc0FkZHJlc3M6IChzdGFuZGFyZC5lbnNBZGRyZXNzIHx8IG51bGwpLFxuICAgICAgICAgICAgICAgICAgICBfZGVmYXVsdFByb3ZpZGVyOiAoc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlciB8fCBudWxsKVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYWluSWQ6IG5ldHdvcmssXG4gICAgICAgICAgICBuYW1lOiBcInVua25vd25cIlxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAodHlwZW9mIChuZXR3b3JrKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBzdGFuZGFyZCA9IG5ldHdvcmtzW25ldHdvcmtdO1xuICAgICAgICBpZiAoc3RhbmRhcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG5hbWU6IHN0YW5kYXJkLm5hbWUsXG4gICAgICAgICAgICBjaGFpbklkOiBzdGFuZGFyZC5jaGFpbklkLFxuICAgICAgICAgICAgZW5zQWRkcmVzczogc3RhbmRhcmQuZW5zQWRkcmVzcyxcbiAgICAgICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IChzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyIHx8IG51bGwpXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHN0YW5kYXJkID0gbmV0d29ya3NbbmV0d29yay5uYW1lXTtcbiAgICAvLyBOb3QgYSBzdGFuZGFyZCBuZXR3b3JrOyBjaGVjayB0aGF0IGl0IGlzIGEgdmFsaWQgbmV0d29yayBpbiBnZW5lcmFsXG4gICAgaWYgKCFzdGFuZGFyZCkge1xuICAgICAgICBpZiAodHlwZW9mIChuZXR3b3JrLmNoYWluSWQpICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBuZXR3b3JrIGNoYWluSWRcIiwgXCJuZXR3b3JrXCIsIG5ldHdvcmspO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgIH1cbiAgICAvLyBNYWtlIHN1cmUgdGhlIGNoYWluSWQgbWF0Y2hlcyB0aGUgZXhwZWN0ZWQgbmV0d29yayBjaGFpbklkIChvciBpcyAwOyBkaXNhYmxlIEVJUC0xNTUpXG4gICAgaWYgKG5ldHdvcmsuY2hhaW5JZCAhPT0gMCAmJiBuZXR3b3JrLmNoYWluSWQgIT09IHN0YW5kYXJkLmNoYWluSWQpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm5ldHdvcmsgY2hhaW5JZCBtaXNtYXRjaFwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBJbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIGFkZCBhbiBhdHRhY2ggZnVuY3Rpb24gdG8gYSBkZWZhdWx0UHJvdmlkZXJcbiAgICAvLyBjbGFzcyBhbmQgbW92ZSB0aGUgX2RlZmF1bHRQcm92aWRlciBpbnRlcm5hbCB0byB0aGlzIGZpbGUgKGV4dGVuZCBOZXR3b3JrKVxuICAgIGxldCBkZWZhdWx0UHJvdmlkZXIgPSBuZXR3b3JrLl9kZWZhdWx0UHJvdmlkZXIgfHwgbnVsbDtcbiAgICBpZiAoZGVmYXVsdFByb3ZpZGVyID09IG51bGwgJiYgc3RhbmRhcmQuX2RlZmF1bHRQcm92aWRlcikge1xuICAgICAgICBpZiAoaXNSZW5ldHdvcmthYmxlKHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXIpKSB7XG4gICAgICAgICAgICBkZWZhdWx0UHJvdmlkZXIgPSBzdGFuZGFyZC5fZGVmYXVsdFByb3ZpZGVyLnJlbmV0d29yayhuZXR3b3JrKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlZmF1bHRQcm92aWRlciA9IHN0YW5kYXJkLl9kZWZhdWx0UHJvdmlkZXI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gU3RhbmRhcmQgTmV0d29yayAoYWxsb3cgb3ZlcnJpZGluZyB0aGUgRU5TIGFkZHJlc3MpXG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZTogbmV0d29yay5uYW1lLFxuICAgICAgICBjaGFpbklkOiBzdGFuZGFyZC5jaGFpbklkLFxuICAgICAgICBlbnNBZGRyZXNzOiAobmV0d29yay5lbnNBZGRyZXNzIHx8IHN0YW5kYXJkLmVuc0FkZHJlc3MgfHwgbnVsbCksXG4gICAgICAgIF9kZWZhdWx0UHJvdmlkZXI6IGRlZmF1bHRQcm92aWRlclxuICAgIH07XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgeyBwYmtkZjIgfSBmcm9tIFwiLi9wYmtkZjJcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGNvbXB1dGVIbWFjIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3NoYTJcIjtcbmV4cG9ydCBmdW5jdGlvbiBwYmtkZjIocGFzc3dvcmQsIHNhbHQsIGl0ZXJhdGlvbnMsIGtleWxlbiwgaGFzaEFsZ29yaXRobSkge1xuICAgIHBhc3N3b3JkID0gYXJyYXlpZnkocGFzc3dvcmQpO1xuICAgIHNhbHQgPSBhcnJheWlmeShzYWx0KTtcbiAgICBsZXQgaExlbjtcbiAgICBsZXQgbCA9IDE7XG4gICAgY29uc3QgREsgPSBuZXcgVWludDhBcnJheShrZXlsZW4pO1xuICAgIGNvbnN0IGJsb2NrMSA9IG5ldyBVaW50OEFycmF5KHNhbHQubGVuZ3RoICsgNCk7XG4gICAgYmxvY2sxLnNldChzYWx0KTtcbiAgICAvL3NhbHQuY29weShibG9jazEsIDAsIDAsIHNhbHQubGVuZ3RoKVxuICAgIGxldCByO1xuICAgIGxldCBUO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDw9IGw7IGkrKykge1xuICAgICAgICAvL2Jsb2NrMS53cml0ZVVJbnQzMkJFKGksIHNhbHQubGVuZ3RoKVxuICAgICAgICBibG9jazFbc2FsdC5sZW5ndGhdID0gKGkgPj4gMjQpICYgMHhmZjtcbiAgICAgICAgYmxvY2sxW3NhbHQubGVuZ3RoICsgMV0gPSAoaSA+PiAxNikgJiAweGZmO1xuICAgICAgICBibG9jazFbc2FsdC5sZW5ndGggKyAyXSA9IChpID4+IDgpICYgMHhmZjtcbiAgICAgICAgYmxvY2sxW3NhbHQubGVuZ3RoICsgM10gPSBpICYgMHhmZjtcbiAgICAgICAgLy9sZXQgVSA9IGNyZWF0ZUhtYWMocGFzc3dvcmQpLnVwZGF0ZShibG9jazEpLmRpZ2VzdCgpO1xuICAgICAgICBsZXQgVSA9IGFycmF5aWZ5KGNvbXB1dGVIbWFjKGhhc2hBbGdvcml0aG0sIHBhc3N3b3JkLCBibG9jazEpKTtcbiAgICAgICAgaWYgKCFoTGVuKSB7XG4gICAgICAgICAgICBoTGVuID0gVS5sZW5ndGg7XG4gICAgICAgICAgICBUID0gbmV3IFVpbnQ4QXJyYXkoaExlbik7XG4gICAgICAgICAgICBsID0gTWF0aC5jZWlsKGtleWxlbiAvIGhMZW4pO1xuICAgICAgICAgICAgciA9IGtleWxlbiAtIChsIC0gMSkgKiBoTGVuO1xuICAgICAgICB9XG4gICAgICAgIC8vVS5jb3B5KFQsIDAsIDAsIGhMZW4pXG4gICAgICAgIFQuc2V0KFUpO1xuICAgICAgICBmb3IgKGxldCBqID0gMTsgaiA8IGl0ZXJhdGlvbnM7IGorKykge1xuICAgICAgICAgICAgLy9VID0gY3JlYXRlSG1hYyhwYXNzd29yZCkudXBkYXRlKFUpLmRpZ2VzdCgpO1xuICAgICAgICAgICAgVSA9IGFycmF5aWZ5KGNvbXB1dGVIbWFjKGhhc2hBbGdvcml0aG0sIHBhc3N3b3JkLCBVKSk7XG4gICAgICAgICAgICBmb3IgKGxldCBrID0gMDsgayA8IGhMZW47IGsrKylcbiAgICAgICAgICAgICAgICBUW2tdIF49IFVba107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGVzdFBvcyA9IChpIC0gMSkgKiBoTGVuO1xuICAgICAgICBjb25zdCBsZW4gPSAoaSA9PT0gbCA/IHIgOiBoTGVuKTtcbiAgICAgICAgLy9ULmNvcHkoREssIGRlc3RQb3MsIDAsIGxlbilcbiAgICAgICAgREsuc2V0KGFycmF5aWZ5KFQpLnNsaWNlKDAsIGxlbiksIGRlc3RQb3MpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4bGlmeShESyk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYmtkZjIuanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInByb3BlcnRpZXMvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgZnVuY3Rpb24gZGVmaW5lUmVhZE9ubHkob2JqZWN0LCBuYW1lLCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIG5hbWUsIHtcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgfSk7XG59XG4vLyBDcmF3bCB1cCB0aGUgY29uc3RydWN0b3IgY2hhaW4gdG8gZmluZCBhIHN0YXRpYyBtZXRob2RcbmV4cG9ydCBmdW5jdGlvbiBnZXRTdGF0aWMoY3Rvciwga2V5KSB7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCAzMjsgaSsrKSB7XG4gICAgICAgIGlmIChjdG9yW2tleV0pIHtcbiAgICAgICAgICAgIHJldHVybiBjdG9yW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjdG9yLnByb3RvdHlwZSB8fCB0eXBlb2YgKGN0b3IucHJvdG90eXBlKSAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY3RvciA9IE9iamVjdC5nZXRQcm90b3R5cGVPZihjdG9yLnByb3RvdHlwZSkuY29uc3RydWN0b3I7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlc29sdmVQcm9wZXJ0aWVzKG9iamVjdCkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHByb21pc2VzID0gT2JqZWN0LmtleXMob2JqZWN0KS5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBvYmplY3Rba2V5XTtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodmFsdWUpLnRoZW4oKHYpID0+ICh7IGtleToga2V5LCB2YWx1ZTogdiB9KSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCByZXN1bHRzID0geWllbGQgUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0cy5yZWR1Y2UoKGFjY3VtLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGFjY3VtWyhyZXN1bHQua2V5KV0gPSByZXN1bHQudmFsdWU7XG4gICAgICAgICAgICByZXR1cm4gYWNjdW07XG4gICAgICAgIH0sIHt9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjaGVja1Byb3BlcnRpZXMob2JqZWN0LCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFvYmplY3QgfHwgdHlwZW9mIChvYmplY3QpICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG9iamVjdFwiLCBcIm9iamVjdFwiLCBvYmplY3QpO1xuICAgIH1cbiAgICBPYmplY3Qua2V5cyhvYmplY3QpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBpZiAoIXByb3BlcnRpZXNba2V5XSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgb2JqZWN0IGtleSAtIFwiICsga2V5LCBcInRyYW5zYWN0aW9uOlwiICsga2V5LCBvYmplY3QpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hhbGxvd0NvcHkob2JqZWN0KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gb2JqZWN0W2tleV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5jb25zdCBvcGFxdWUgPSB7IGJpZ2ludDogdHJ1ZSwgYm9vbGVhbjogdHJ1ZSwgXCJmdW5jdGlvblwiOiB0cnVlLCBudW1iZXI6IHRydWUsIHN0cmluZzogdHJ1ZSB9O1xuZnVuY3Rpb24gX2lzRnJvemVuKG9iamVjdCkge1xuICAgIC8vIE9wYXF1ZSBvYmplY3RzIGFyZSBub3QgbXV0YWJsZSwgc28gc2FmZSB0byBjb3B5IGJ5IGFzc2lnbm1lbnRcbiAgICBpZiAob2JqZWN0ID09PSB1bmRlZmluZWQgfHwgb2JqZWN0ID09PSBudWxsIHx8IG9wYXF1ZVt0eXBlb2YgKG9iamVjdCldKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheShvYmplY3QpIHx8IHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBpZiAoIU9iamVjdC5pc0Zyb3plbihvYmplY3QpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbGV0IHZhbHVlID0gbnVsbDtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5c1tpXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBhY2Nlc3NpbmcgYSB2YWx1ZSB0cmlnZ2VycyBhbiBlcnJvciwgaXQgaXMgYSBnZXR0ZXJcbiAgICAgICAgICAgICAgICAvLyBkZXNpZ25lZCB0byBkbyBzbyAoZS5nLiBSZXN1bHQpIGFuZCBpcyB0aGVyZWZvcmUgXCJmcm96ZW5cIlxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFfaXNGcm96ZW4odmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgQ2Fubm90IGRlZXBDb3B5ICR7dHlwZW9mIChvYmplY3QpfWAsIFwib2JqZWN0XCIsIG9iamVjdCk7XG59XG4vLyBSZXR1cm5zIGEgbmV3IGNvcHkgb2Ygb2JqZWN0LCBzdWNoIHRoYXQgbm8gcHJvcGVydGllcyBtYXkgYmUgcmVwbGFjZWQuXG4vLyBOZXcgcHJvcGVydGllcyBtYXkgYmUgYWRkZWQgb25seSB0byBvYmplY3RzLlxuZnVuY3Rpb24gX2RlZXBDb3B5KG9iamVjdCkge1xuICAgIGlmIChfaXNGcm96ZW4ob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cbiAgICAvLyBBcnJheXMgYXJlIG11dGFibGUsIHNvIHdlIG5lZWQgdG8gY3JlYXRlIGEgY29weVxuICAgIGlmIChBcnJheS5pc0FycmF5KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUob2JqZWN0Lm1hcCgoaXRlbSkgPT4gZGVlcENvcHkoaXRlbSkpKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAob2JqZWN0KSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gb2JqZWN0KSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHJlc3VsdCwga2V5LCBkZWVwQ29weSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKGBDYW5ub3QgZGVlcENvcHkgJHt0eXBlb2YgKG9iamVjdCl9YCwgXCJvYmplY3RcIiwgb2JqZWN0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBkZWVwQ29weShvYmplY3QpIHtcbiAgICByZXR1cm4gX2RlZXBDb3B5KG9iamVjdCk7XG59XG5leHBvcnQgY2xhc3MgRGVzY3JpcHRpb24ge1xuICAgIGNvbnN0cnVjdG9yKGluZm8pIHtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gaW5mbykge1xuICAgICAgICAgICAgdGhpc1trZXldID0gZGVlcENvcHkoaW5mb1trZXldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJwcm92aWRlcnMvNS41LjFcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgc2hvd1Rocm90dGxlTWVzc2FnZSB9IGZyb20gXCIuL2Zvcm1hdHRlclwiO1xuaW1wb3J0IHsgV2ViU29ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi93ZWJzb2NrZXQtcHJvdmlkZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IFVybEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiO1xuLy8gVGhpcyBrZXkgd2FzIHByb3ZpZGVkIHRvIGV0aGVycy5qcyBieSBBbGNoZW15IHRvIGJlIHVzZWQgYnkgdGhlXG4vLyBkZWZhdWx0IHByb3ZpZGVyLCBidXQgaXQgaXMgcmVjb21tZW5kZWQgdGhhdCBmb3IgeW91ciBvd25cbi8vIHByb2R1Y3Rpb24gZW52aXJvbm1lbnRzLCB0aGF0IHlvdSBhY3F1aXJlIHlvdXIgb3duIEFQSSBrZXkgYXQ6XG4vLyAgIGh0dHBzOi8vZGFzaGJvYXJkLmFsY2hlbXlhcGkuaW9cbmNvbnN0IGRlZmF1bHRBcGlLZXkgPSBcIl9nZzd3U1NpMEtNQnNkS25HVmZIRHVlcTZ4TUI5RWtDXCI7XG5leHBvcnQgY2xhc3MgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIGV4dGVuZHMgV2ViU29ja2V0UHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IG5ldyBBbGNoZW15UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KTtcbiAgICAgICAgY29uc3QgdXJsID0gcHJvdmlkZXIuY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKVxuICAgICAgICAgICAgLnJlcGxhY2UoXCIuYWxjaGVteWFwaS5cIiwgXCIud3MuYWxjaGVteWFwaS5cIik7XG4gICAgICAgIHN1cGVyKHVybCwgcHJvdmlkZXIubmV0d29yayk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYXBpS2V5XCIsIHByb3ZpZGVyLmFwaUtleSk7XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpO1xuICAgIH1cbn1cbmV4cG9ydCBjbGFzcyBBbGNoZW15UHJvdmlkZXIgZXh0ZW5kcyBVcmxKc29uUnBjUHJvdmlkZXIge1xuICAgIHN0YXRpYyBnZXRXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEFwaUtleShhcGlLZXkpIHtcbiAgICAgICAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGVmYXVsdEFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYXBpS2V5ICYmIHR5cGVvZiAoYXBpS2V5KSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYXBpS2V5XCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwaUtleTtcbiAgICB9XG4gICAgc3RhdGljIGdldFVybChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgbGV0IGhvc3QgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmsubmFtZSkge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1tYWlubmV0LmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1yb3BzdGVuLmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1yaW5rZWJ5LmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZ29lcmxpXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLWdvZXJsaS5hbGNoZW15YXBpLmlvL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImtvdmFuXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiZXRoLWtvdmFuLmFsY2hlbXlhcGkuaW8vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJtYXRpY211bVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInBvbHlnb24tbXVtYmFpLmcuYWxjaGVteS5jb20vdjIvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW1cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJhcmItbWFpbm5ldC5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImFyYml0cnVtLXJpbmtlYnlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJhcmItcmlua2VieS5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcIm9wdGltaXNtXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwib3B0LW1haW5uZXQuZy5hbGNoZW15LmNvbS92Mi9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbS1rb3ZhblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm9wdC1rb3Zhbi5nLmFsY2hlbXkuY29tL3YyL1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgYXJndW1lbnRzWzBdKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWxsb3dHemlwOiB0cnVlLFxuICAgICAgICAgICAgdXJsOiAoXCJodHRwczovXCIgKyBcIi9cIiArIGhvc3QgKyBhcGlLZXkpLFxuICAgICAgICAgICAgdGhyb3R0bGVDYWxsYmFjazogKGF0dGVtcHQsIHVybCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChhcGlLZXkgPT09IGRlZmF1bHRBcGlLZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd1Rocm90dGxlTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpc0NvbW11bml0eVJlc291cmNlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuYXBpS2V5ID09PSBkZWZhdWx0QXBpS2V5KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1hbGNoZW15LXByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBGb3JrRXZlbnQsIFByb3ZpZGVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBCYXNlNTggfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmFzZXhcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleENvbmNhdCwgaGV4RGF0YUxlbmd0aCwgaGV4RGF0YVNsaWNlLCBoZXhsaWZ5LCBoZXhWYWx1ZSwgaGV4WmVyb1BhZCwgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IEhhc2haZXJvIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0IHsgbmFtZWhhc2ggfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiO1xuaW1wb3J0IHsgZ2V0TmV0d29yayB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9uZXR3b3Jrc1wiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHksIGdldFN0YXRpYywgcmVzb2x2ZVByb3BlcnRpZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgc2hhMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3NoYTJcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuaW1wb3J0IHsgZmV0Y2hKc29uLCBwb2xsIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dlYlwiO1xuaW1wb3J0IGJlY2gzMiBmcm9tIFwiYmVjaDMyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBGb3JtYXR0ZXIgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRXZlbnQgU2VyaWFsaXplaW5nXG5mdW5jdGlvbiBjaGVja1RvcGljKHRvcGljKSB7XG4gICAgaWYgKHRvcGljID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFwibnVsbFwiO1xuICAgIH1cbiAgICBpZiAoaGV4RGF0YUxlbmd0aCh0b3BpYykgIT09IDMyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRvcGljXCIsIFwidG9waWNcIiwgdG9waWMpO1xuICAgIH1cbiAgICByZXR1cm4gdG9waWMudG9Mb3dlckNhc2UoKTtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZVRvcGljcyh0b3BpY3MpIHtcbiAgICAvLyBSZW1vdmUgdHJhaWxpbmcgbnVsbCBBTkQtdG9waWNzOyB0aGV5IGFyZSByZWR1bmRhbnRcbiAgICB0b3BpY3MgPSB0b3BpY3Muc2xpY2UoKTtcbiAgICB3aGlsZSAodG9waWNzLmxlbmd0aCA+IDAgJiYgdG9waWNzW3RvcGljcy5sZW5ndGggLSAxXSA9PSBudWxsKSB7XG4gICAgICAgIHRvcGljcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRvcGljcy5tYXAoKHRvcGljKSA9PiB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHRvcGljKSkge1xuICAgICAgICAgICAgLy8gT25seSB0cmFjayB1bmlxdWUgT1ItdG9waWNzXG4gICAgICAgICAgICBjb25zdCB1bmlxdWUgPSB7fTtcbiAgICAgICAgICAgIHRvcGljLmZvckVhY2goKHRvcGljKSA9PiB7XG4gICAgICAgICAgICAgICAgdW5pcXVlW2NoZWNrVG9waWModG9waWMpXSA9IHRydWU7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIFRoZSBvcmRlciBvZiBPUi10b3BpY3MgZG9lcyBub3QgbWF0dGVyXG4gICAgICAgICAgICBjb25zdCBzb3J0ZWQgPSBPYmplY3Qua2V5cyh1bmlxdWUpO1xuICAgICAgICAgICAgc29ydGVkLnNvcnQoKTtcbiAgICAgICAgICAgIHJldHVybiBzb3J0ZWQuam9pbihcInxcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2hlY2tUb3BpYyh0b3BpYyk7XG4gICAgICAgIH1cbiAgICB9KS5qb2luKFwiJlwiKTtcbn1cbmZ1bmN0aW9uIGRlc2VyaWFsaXplVG9waWNzKGRhdGEpIHtcbiAgICBpZiAoZGF0YSA9PT0gXCJcIikge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIHJldHVybiBkYXRhLnNwbGl0KC8mL2cpLm1hcCgodG9waWMpID0+IHtcbiAgICAgICAgaWYgKHRvcGljID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY29tcHMgPSB0b3BpYy5zcGxpdChcInxcIikubWFwKCh0b3BpYykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuICgodG9waWMgPT09IFwibnVsbFwiKSA/IG51bGwgOiB0b3BpYyk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKChjb21wcy5sZW5ndGggPT09IDEpID8gY29tcHNbMF0gOiBjb21wcyk7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBnZXRFdmVudFRhZyhldmVudE5hbWUpIHtcbiAgICBpZiAodHlwZW9mIChldmVudE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGV2ZW50TmFtZSA9IGV2ZW50TmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICBpZiAoaGV4RGF0YUxlbmd0aChldmVudE5hbWUpID09PSAzMikge1xuICAgICAgICAgICAgcmV0dXJuIFwidHg6XCIgKyBldmVudE5hbWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2ZW50TmFtZS5pbmRleE9mKFwiOlwiKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudE5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShldmVudE5hbWUpKSB7XG4gICAgICAgIHJldHVybiBcImZpbHRlcjoqOlwiICsgc2VyaWFsaXplVG9waWNzKGV2ZW50TmFtZSk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEZvcmtFdmVudC5pc0ZvcmtFdmVudChldmVudE5hbWUpKSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwibm90IGltcGxlbWVudGVkXCIpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgaW1wbGVtZW50ZWRcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV2ZW50TmFtZSAmJiB0eXBlb2YgKGV2ZW50TmFtZSkgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgcmV0dXJuIFwiZmlsdGVyOlwiICsgKGV2ZW50TmFtZS5hZGRyZXNzIHx8IFwiKlwiKSArIFwiOlwiICsgc2VyaWFsaXplVG9waWNzKGV2ZW50TmFtZS50b3BpY3MgfHwgW10pO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGV2ZW50IC0gXCIgKyBldmVudE5hbWUpO1xufVxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBIZWxwZXIgT2JqZWN0XG5mdW5jdGlvbiBnZXRUaW1lKCkge1xuICAgIHJldHVybiAobmV3IERhdGUoKSkuZ2V0VGltZSgpO1xufVxuZnVuY3Rpb24gc3RhbGwoZHVyYXRpb24pIHtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgc2V0VGltZW91dChyZXNvbHZlLCBkdXJhdGlvbik7XG4gICAgfSk7XG59XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFByb3ZpZGVyIE9iamVjdFxuLyoqXG4gKiAgRXZlbnRUeXBlXG4gKiAgIC0gXCJibG9ja1wiXG4gKiAgIC0gXCJwb2xsXCJcbiAqICAgLSBcImRpZFBvbGxcIlxuICogICAtIFwicGVuZGluZ1wiXG4gKiAgIC0gXCJlcnJvclwiXG4gKiAgIC0gXCJuZXR3b3JrXCJcbiAqICAgLSBmaWx0ZXJcbiAqICAgLSB0b3BpY3MgYXJyYXlcbiAqICAgLSB0cmFuc2FjdGlvbiBoYXNoXG4gKi9cbmNvbnN0IFBvbGxhYmxlRXZlbnRzID0gW1wiYmxvY2tcIiwgXCJuZXR3b3JrXCIsIFwicGVuZGluZ1wiLCBcInBvbGxcIl07XG5leHBvcnQgY2xhc3MgRXZlbnQge1xuICAgIGNvbnN0cnVjdG9yKHRhZywgbGlzdGVuZXIsIG9uY2UpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJ0YWdcIiwgdGFnKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJsaXN0ZW5lclwiLCBsaXN0ZW5lcik7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwib25jZVwiLCBvbmNlKTtcbiAgICB9XG4gICAgZ2V0IGV2ZW50KCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInR4XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaGFzaDtcbiAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5maWx0ZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMudGFnO1xuICAgIH1cbiAgICBnZXQgdHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudGFnLnNwbGl0KFwiOlwiKVswXTtcbiAgICB9XG4gICAgZ2V0IGhhc2goKSB7XG4gICAgICAgIGNvbnN0IGNvbXBzID0gdGhpcy50YWcuc3BsaXQoXCI6XCIpO1xuICAgICAgICBpZiAoY29tcHNbMF0gIT09IFwidHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbXBzWzFdO1xuICAgIH1cbiAgICBnZXQgZmlsdGVyKCkge1xuICAgICAgICBjb25zdCBjb21wcyA9IHRoaXMudGFnLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgaWYgKGNvbXBzWzBdICE9PSBcImZpbHRlclwiKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gY29tcHNbMV07XG4gICAgICAgIGNvbnN0IHRvcGljcyA9IGRlc2VyaWFsaXplVG9waWNzKGNvbXBzWzJdKTtcbiAgICAgICAgY29uc3QgZmlsdGVyID0ge307XG4gICAgICAgIGlmICh0b3BpY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgZmlsdGVyLnRvcGljcyA9IHRvcGljcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoYWRkcmVzcyAmJiBhZGRyZXNzICE9PSBcIipcIikge1xuICAgICAgICAgICAgZmlsdGVyLmFkZHJlc3MgPSBhZGRyZXNzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmaWx0ZXI7XG4gICAgfVxuICAgIHBvbGxhYmxlKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMudGFnLmluZGV4T2YoXCI6XCIpID49IDAgfHwgUG9sbGFibGVFdmVudHMuaW5kZXhPZih0aGlzLnRhZykgPj0gMCk7XG4gICAgfVxufVxuO1xuLy8gaHR0cHM6Ly9naXRodWIuY29tL3NhdG9zaGlsYWJzL3NsaXBzL2Jsb2IvbWFzdGVyL3NsaXAtMDA0NC5tZFxuY29uc3QgY29pbkluZm9zID0ge1xuICAgIFwiMFwiOiB7IHN5bWJvbDogXCJidGNcIiwgcDJwa2g6IDB4MDAsIHAyc2g6IDB4MDUsIHByZWZpeDogXCJiY1wiIH0sXG4gICAgXCIyXCI6IHsgc3ltYm9sOiBcImx0Y1wiLCBwMnBraDogMHgzMCwgcDJzaDogMHgzMiwgcHJlZml4OiBcImx0Y1wiIH0sXG4gICAgXCIzXCI6IHsgc3ltYm9sOiBcImRvZ2VcIiwgcDJwa2g6IDB4MWUsIHAyc2g6IDB4MTYgfSxcbiAgICBcIjYwXCI6IHsgc3ltYm9sOiBcImV0aFwiLCBpbGs6IFwiZXRoXCIgfSxcbiAgICBcIjYxXCI6IHsgc3ltYm9sOiBcImV0Y1wiLCBpbGs6IFwiZXRoXCIgfSxcbiAgICBcIjcwMFwiOiB7IHN5bWJvbDogXCJ4ZGFpXCIsIGlsazogXCJldGhcIiB9LFxufTtcbmZ1bmN0aW9uIGJ5dGVzMzJpZnkodmFsdWUpIHtcbiAgICByZXR1cm4gaGV4WmVyb1BhZChCaWdOdW1iZXIuZnJvbSh2YWx1ZSkudG9IZXhTdHJpbmcoKSwgMzIpO1xufVxuLy8gQ29tcHV0ZSB0aGUgQmFzZTU4Q2hlY2sgZW5jb2RlZCBkYXRhIChjaGVja3N1bSBpcyBmaXJzdCA0IGJ5dGVzIG9mIHNoYTI1NmQpXG5mdW5jdGlvbiBiYXNlNThFbmNvZGUoZGF0YSkge1xuICAgIHJldHVybiBCYXNlNTguZW5jb2RlKGNvbmNhdChbZGF0YSwgaGV4RGF0YVNsaWNlKHNoYTI1NihzaGEyNTYoZGF0YSkpLCAwLCA0KV0pKTtcbn1cbmNvbnN0IG1hdGNoZXJzID0gW1xuICAgIG5ldyBSZWdFeHAoXCJeKGh0dHBzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxuICAgIG5ldyBSZWdFeHAoXCJeKGRhdGEpOiguKikkXCIsIFwiaVwiKSxcbiAgICBuZXcgUmVnRXhwKFwiXihpcGZzKTovXFwvKC4qKSRcIiwgXCJpXCIpLFxuICAgIG5ldyBSZWdFeHAoXCJeZWlwMTU1OlswLTldKy8oZXJjWzAtOV0rKTooLiopJFwiLCBcImlcIiksXG5dO1xuZnVuY3Rpb24gX3BhcnNlU3RyaW5nKHJlc3VsdCkge1xuICAgIHRyeSB7XG4gICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoX3BhcnNlQnl0ZXMocmVzdWx0KSk7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBfcGFyc2VCeXRlcyhyZXN1bHQpIHtcbiAgICBpZiAocmVzdWx0ID09PSBcIjB4XCIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IG9mZnNldCA9IEJpZ051bWJlci5mcm9tKGhleERhdGFTbGljZShyZXN1bHQsIDAsIDMyKSkudG9OdW1iZXIoKTtcbiAgICBjb25zdCBsZW5ndGggPSBCaWdOdW1iZXIuZnJvbShoZXhEYXRhU2xpY2UocmVzdWx0LCBvZmZzZXQsIG9mZnNldCArIDMyKSkudG9OdW1iZXIoKTtcbiAgICByZXR1cm4gaGV4RGF0YVNsaWNlKHJlc3VsdCwgb2Zmc2V0ICsgMzIsIG9mZnNldCArIDMyICsgbGVuZ3RoKTtcbn1cbmV4cG9ydCBjbGFzcyBSZXNvbHZlciB7XG4gICAgLy8gVGhlIHJlc29sdmVkQWRkcmVzcyBpcyBvbmx5IGZvciBjcmVhdGluZyBhIFJldmVyc2VMb29rdXAgcmVzb2x2ZXJcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlciwgYWRkcmVzcywgbmFtZSwgcmVzb2x2ZWRBZGRyZXNzKSB7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvdmlkZXJcIiwgcHJvdmlkZXIpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIm5hbWVcIiwgbmFtZSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYWRkcmVzc1wiLCBwcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhhZGRyZXNzKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3Jlc29sdmVkQWRkcmVzc1wiLCByZXNvbHZlZEFkZHJlc3MpO1xuICAgIH1cbiAgICBfZmV0Y2hCeXRlcyhzZWxlY3RvciwgcGFyYW1ldGVycykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gZS5nLiBrZWNjYWsyNTYoXCJhZGRyKGJ5dGVzMzIsdWludDI1NilcIilcbiAgICAgICAgICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICAgICAgICAgIHRvOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YTogaGV4Q29uY2F0KFtzZWxlY3RvciwgbmFtZWhhc2godGhpcy5uYW1lKSwgKHBhcmFtZXRlcnMgfHwgXCIweFwiKV0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3BhcnNlQnl0ZXMoeWllbGQgdGhpcy5wcm92aWRlci5jYWxsKHR4KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0QWRkcmVzcyhjb2luVHlwZSwgaGV4Qnl0ZXMpIHtcbiAgICAgICAgY29uc3QgY29pbkluZm8gPSBjb2luSW5mb3NbU3RyaW5nKGNvaW5UeXBlKV07XG4gICAgICAgIGlmIChjb2luSW5mbyA9PSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihgdW5zdXBwb3J0ZWQgY29pbiB0eXBlOiAke2NvaW5UeXBlfWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBgZ2V0QWRkcmVzcygke2NvaW5UeXBlfSlgXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29pbkluZm8uaWxrID09PSBcImV0aFwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5mb3JtYXR0ZXIuYWRkcmVzcyhoZXhCeXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShoZXhCeXRlcyk7XG4gICAgICAgIC8vIFAyUEtIOiBPUF9EVVAgT1BfSEFTSDE2MCA8cHViS2V5SGFzaD4gT1BfRVFVQUxWRVJJRlkgT1BfQ0hFQ0tTSUdcbiAgICAgICAgaWYgKGNvaW5JbmZvLnAycGtoICE9IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHAycGtoID0gaGV4Qnl0ZXMubWF0Y2goL14weDc2YTkoWzAtOWEtZl1bMC05YS1mXSkoWzAtOWEtZl0qKTg4YWMkLyk7XG4gICAgICAgICAgICBpZiAocDJwa2gpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsZW5ndGggPSBwYXJzZUludChwMnBraFsxXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChwMnBraFsyXS5sZW5ndGggPT09IGxlbmd0aCAqIDIgJiYgbGVuZ3RoID49IDEgJiYgbGVuZ3RoIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBiYXNlNThFbmNvZGUoY29uY2F0KFtbY29pbkluZm8ucDJwa2hdLCAoXCIweFwiICsgcDJwa2hbMl0pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBQMlNIOiBPUF9IQVNIMTYwIDxzY3JpcHRIYXNoPiBPUF9FUVVBTFxuICAgICAgICBpZiAoY29pbkluZm8ucDJzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBwMnNoID0gaGV4Qnl0ZXMubWF0Y2goL14weGE5KFswLTlhLWZdWzAtOWEtZl0pKFswLTlhLWZdKik4NyQvKTtcbiAgICAgICAgICAgIGlmIChwMnNoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQocDJzaFsxXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChwMnNoWzJdLmxlbmd0aCA9PT0gbGVuZ3RoICogMiAmJiBsZW5ndGggPj0gMSAmJiBsZW5ndGggPD0gNzUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGJhc2U1OEVuY29kZShjb25jYXQoW1tjb2luSW5mby5wMnNoXSwgKFwiMHhcIiArIHAyc2hbMl0pXSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBCZWNoMzJcbiAgICAgICAgaWYgKGNvaW5JbmZvLnByZWZpeCAhPSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBieXRlc1sxXTtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAxNDEubWVkaWF3aWtpI3dpdG5lc3MtcHJvZ3JhbVxuICAgICAgICAgICAgbGV0IHZlcnNpb24gPSBieXRlc1swXTtcbiAgICAgICAgICAgIGlmICh2ZXJzaW9uID09PSAweDAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGxlbmd0aCAhPT0gMjAgJiYgbGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uID0gLTE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmVyc2lvbiA9IC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHZlcnNpb24gPj0gMCAmJiBieXRlcy5sZW5ndGggPT09IDIgKyBsZW5ndGggJiYgbGVuZ3RoID49IDEgJiYgbGVuZ3RoIDw9IDc1KSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgd29yZHMgPSBiZWNoMzIudG9Xb3JkcyhieXRlcy5zbGljZSgyKSk7XG4gICAgICAgICAgICAgICAgd29yZHMudW5zaGlmdCh2ZXJzaW9uKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gYmVjaDMyLmVuY29kZShjb2luSW5mby5wcmVmaXgsIHdvcmRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZ2V0QWRkcmVzcyhjb2luVHlwZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGNvaW5UeXBlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb2luVHlwZSA9IDYwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgRXRoZXJldW0sIHVzZSB0aGUgc3RhbmRhcmQgYGFkZHIoYnl0ZXMzMilgXG4gICAgICAgICAgICBpZiAoY29pblR5cGUgPT09IDYwKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgLy8ga2VjY2FrMjU2KFwiYWRkcihieXRlczMyKVwiKVxuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRvOiB0aGlzLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiAoXCIweDNiM2I1N2RlXCIgKyBuYW1laGFzaCh0aGlzLm5hbWUpLnN1YnN0cmluZygyKSlcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaGV4Qnl0ZXMgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgICAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PT0gXCIweFwiIHx8IGhleEJ5dGVzID09PSBIYXNoWmVybykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmNhbGxBZGRyZXNzKGhleEJ5dGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLkNBTExfRVhDRVBUSU9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBrZWNjYWsyNTYoXCJhZGRyKGJ5dGVzMzIsdWludDI1NlwiKVxuICAgICAgICAgICAgY29uc3QgaGV4Qnl0ZXMgPSB5aWVsZCB0aGlzLl9mZXRjaEJ5dGVzKFwiMHhmMWNiN2UwNlwiLCBieXRlczMyaWZ5KGNvaW5UeXBlKSk7XG4gICAgICAgICAgICAvLyBObyBhZGRyZXNzXG4gICAgICAgICAgICBpZiAoaGV4Qnl0ZXMgPT0gbnVsbCB8fCBoZXhCeXRlcyA9PT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBhZGRyZXNzXG4gICAgICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhjb2luVHlwZSwgaGV4Qnl0ZXMpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKGBpbnZhbGlkIG9yIHVuc3VwcG9ydGVkIGNvaW4gZGF0YWAsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogYGdldEFkZHJlc3MoJHtjb2luVHlwZX0pYCxcbiAgICAgICAgICAgICAgICAgICAgY29pblR5cGU6IGNvaW5UeXBlLFxuICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhCeXRlc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRBdmF0YXIoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rYWdlID0gW107XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIC8vIHRlc3QgZGF0YSBmb3IgcmljbW9vLmV0aFxuICAgICAgICAgICAgICAgIC8vY29uc3QgYXZhdGFyID0gXCJlaXAxNTU6MS9lcmM3MjE6MHgyNjUzODVjN2Y0MTMyMjI4QTBkNTRFQjFBOWU3NDYwYjkxYzBjQzY4LzI5MjMzXCI7XG4gICAgICAgICAgICAgICAgY29uc3QgYXZhdGFyID0geWllbGQgdGhpcy5nZXRUZXh0KFwiYXZhdGFyXCIpO1xuICAgICAgICAgICAgICAgIGlmIChhdmF0YXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBtYXRjaGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IGF2YXRhci5tYXRjaChtYXRjaGVyc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChtYXRjaCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKG1hdGNoWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cHNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHsgbGlua2FnZSwgdXJsOiBhdmF0YXIgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJkYXRhXCIsIGNvbnRlbnQ6IGF2YXRhciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IGF2YXRhciB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImlwZnNcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcImlwZnNcIiwgY29udGVudDogYXZhdGFyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB7IGxpbmthZ2UsIHVybDogYGh0dHBzOi9cXC9nYXRld2F5LmlwZnMuaW8vaXBmcy8ke2F2YXRhci5zdWJzdHJpbmcoNyl9YCB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzcyMVwiOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSBcImVyYzExNTVcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIERlcGVuZGluZyBvbiB0aGUgRVJDIHR5cGUsIHVzZSB0b2tlblVSSSh1aW50MjU2KSBvciB1cmwodWludDI1NilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RvciA9IChtYXRjaFsxXSA9PT0gXCJlcmM3MjFcIikgPyBcIjB4Yzg3YjU2ZGRcIiA6IFwiMHgwZTg5MzQxY1wiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxpbmthZ2UucHVzaCh7IHR5cGU6IG1hdGNoWzFdLCBjb250ZW50OiBhdmF0YXIgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIG93bmVyIG9mIHRoaXMgbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG93bmVyID0gKHRoaXMuX3Jlc29sdmVkQWRkcmVzcyB8fCAoeWllbGQgdGhpcy5nZXRBZGRyZXNzKCkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjb21wcyA9IChtYXRjaFsyXSB8fCBcIlwiKS5zcGxpdChcIi9cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvbXBzLmxlbmd0aCAhPT0gMikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYWRkciA9IHlpZWxkIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoY29tcHNbMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuSWQgPSBoZXhaZXJvUGFkKEJpZ051bWJlci5mcm9tKGNvbXBzWzFdKS50b0hleFN0cmluZygpLCAzMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgdGhhdCB0aGlzIGFjY291bnQgb3ducyB0aGUgdG9rZW5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09IFwiZXJjNzIxXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb3duZXJPZih1aW50MjU2IHRva2VuSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHRva2VuT3duZXIgPSB0aGlzLnByb3ZpZGVyLmZvcm1hdHRlci5jYWxsQWRkcmVzcyh5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IGFkZHIsIGRhdGE6IGhleENvbmNhdChbXCIweDYzNTIyMTFlXCIsIHRva2VuSWRdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvd25lciAhPT0gdG9rZW5Pd25lcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJvd25lclwiLCBjb250ZW50OiB0b2tlbk93bmVyIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChtYXRjaFsxXSA9PT0gXCJlcmMxMTU1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gYmFsYW5jZU9mKGFkZHJlc3Mgb3duZXIsIHVpbnQyNTYgdG9rZW5JZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmFsYW5jZSA9IEJpZ051bWJlci5mcm9tKHlpZWxkIHRoaXMucHJvdmlkZXIuY2FsbCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0bzogYWRkciwgZGF0YTogaGV4Q29uY2F0KFtcIjB4MDBmZGQ1OGVcIiwgaGV4WmVyb1BhZChvd25lciwgMzIpLCB0b2tlbklkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmFsYW5jZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJiYWxhbmNlXCIsIGNvbnRlbnQ6IGJhbGFuY2UudG9TdHJpbmcoKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgdG9rZW4gY29udHJhY3QgZm9yIHRoZSBtZXRhZGF0YSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdG86IHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoY29tcHNbMF0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhOiBoZXhDb25jYXQoW3NlbGVjdG9yLCB0b2tlbklkXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxldCBtZXRhZGF0YVVybCA9IF9wYXJzZVN0cmluZyh5aWVsZCB0aGlzLnByb3ZpZGVyLmNhbGwodHgpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWV0YWRhdGFVcmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlua2FnZS5wdXNoKHsgdHlwZTogXCJtZXRhZGF0YS11cmxcIiwgY29udGVudDogbWV0YWRhdGFVcmwgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gRVJDLTExNTUgYWxsb3dzIGEgZ2VuZXJpYyB7aWR9IGluIHRoZSBVUkxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWF0Y2hbMV0gPT09IFwiZXJjMTE1NVwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGFkYXRhVXJsID0gbWV0YWRhdGFVcmwucmVwbGFjZShcIntpZH1cIiwgdG9rZW5JZC5zdWJzdHJpbmcoMikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHRva2VuIG1ldGFkYXRhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWV0YWRhdGEgPSB5aWVsZCBmZXRjaEpzb24obWV0YWRhdGFVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFB1bGwgdGhlIGltYWdlIFVSTCBvdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIW1ldGFkYXRhIHx8IHR5cGVvZiAobWV0YWRhdGEuaW1hZ2UpICE9PSBcInN0cmluZ1wiIHx8ICFtZXRhZGF0YS5pbWFnZS5tYXRjaCgvXihodHRwczpcXC9cXC98ZGF0YTopL2kpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcIm1ldGFkYXRhXCIsIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KG1ldGFkYXRhKSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsaW5rYWdlLnB1c2goeyB0eXBlOiBcInVybFwiLCBjb250ZW50OiBtZXRhZGF0YS5pbWFnZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geyBsaW5rYWdlLCB1cmw6IG1ldGFkYXRhLmltYWdlIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRDb250ZW50SGFzaCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIGtlY2NhazI1NihcImNvbnRlbnRoYXNoKClcIilcbiAgICAgICAgICAgIGNvbnN0IGhleEJ5dGVzID0geWllbGQgdGhpcy5fZmV0Y2hCeXRlcyhcIjB4YmMxYzU4ZDFcIik7XG4gICAgICAgICAgICAvLyBObyBjb250ZW50aGFzaFxuICAgICAgICAgICAgaWYgKGhleEJ5dGVzID09IG51bGwgfHwgaGV4Qnl0ZXMgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSVBGUyAoQ0lEOiAxLCBUeXBlOiBEQUctUEIpXG4gICAgICAgICAgICBjb25zdCBpcGZzID0gaGV4Qnl0ZXMubWF0Y2goL14weGUzMDEwMTcwKChbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXVswLTlhLWZdKShbMC05YS1mXSopKSQvKTtcbiAgICAgICAgICAgIGlmIChpcGZzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoaXBmc1szXSwgMTYpO1xuICAgICAgICAgICAgICAgIGlmIChpcGZzWzRdLmxlbmd0aCA9PT0gbGVuZ3RoICogMikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gXCJpcGZzOi9cXC9cIiArIEJhc2U1OC5lbmNvZGUoXCIweFwiICsgaXBmc1sxXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gU3dhcm0gKENJRDogMSwgVHlwZTogc3dhcm0tbWFuaWZlc3Q7IGhhc2gvbGVuZ3RoIGhhcmQtY29kZWQgdG8ga2VjY2FrMjU2LzMyKVxuICAgICAgICAgICAgY29uc3Qgc3dhcm0gPSBoZXhCeXRlcy5tYXRjaCgvXjB4ZTQwMTAxZmEwMTFiMjAoWzAtOWEtZl0qKSQvKTtcbiAgICAgICAgICAgIGlmIChzd2FybSkge1xuICAgICAgICAgICAgICAgIGlmIChzd2FybVsxXS5sZW5ndGggPT09ICgzMiAqIDIpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBcImJ6ejovXFwvXCIgKyBzd2FybVsxXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYGludmFsaWQgb3IgdW5zdXBwb3J0ZWQgY29udGVudCBoYXNoIGRhdGFgLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRDb250ZW50SGFzaCgpXCIsXG4gICAgICAgICAgICAgICAgZGF0YTogaGV4Qnl0ZXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VGV4dChrZXkpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBrZXkgZW5jb2RlZCBhcyBwYXJhbWV0ZXIgdG8gZmV0Y2hCeXRlc1xuICAgICAgICAgICAgbGV0IGtleUJ5dGVzID0gdG9VdGY4Qnl0ZXMoa2V5KTtcbiAgICAgICAgICAgIC8vIFRoZSBub2RlaGFzaCBjb25zdW1lcyB0aGUgZmlyc3Qgc2xvdCwgc28gdGhlIHN0cmluZyBwb2ludGVyIHRhcmdldHNcbiAgICAgICAgICAgIC8vIG9mZnNldCA2NCwgd2l0aCB0aGUgbGVuZ3RoIGF0IG9mZnNldCA2NCBhbmQgZGF0YSBzdGFydGluZyBhdCBvZmZzZXQgOTZcbiAgICAgICAgICAgIGtleUJ5dGVzID0gY29uY2F0KFtieXRlczMyaWZ5KDY0KSwgYnl0ZXMzMmlmeShrZXlCeXRlcy5sZW5ndGgpLCBrZXlCeXRlc10pO1xuICAgICAgICAgICAgLy8gUGFkIHRvIHdvcmQtc2l6ZSAoMzIgYnl0ZXMpXG4gICAgICAgICAgICBpZiAoKGtleUJ5dGVzLmxlbmd0aCAlIDMyKSAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGtleUJ5dGVzID0gY29uY2F0KFtrZXlCeXRlcywgaGV4WmVyb1BhZChcIjB4XCIsIDMyIC0gKGtleS5sZW5ndGggJSAzMikpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBoZXhCeXRlcyA9IHlpZWxkIHRoaXMuX2ZldGNoQnl0ZXMoXCIweDU5ZDFkNDNjXCIsIGhleGxpZnkoa2V5Qnl0ZXMpKTtcbiAgICAgICAgICAgIGlmIChoZXhCeXRlcyA9PSBudWxsIHx8IGhleEJ5dGVzID09PSBcIjB4XCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoaGV4Qnl0ZXMpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5sZXQgZGVmYXVsdEZvcm1hdHRlciA9IG51bGw7XG5sZXQgbmV4dFBvbGxJZCA9IDE7XG5leHBvcnQgY2xhc3MgQmFzZVByb3ZpZGVyIGV4dGVuZHMgUHJvdmlkZXIge1xuICAgIC8qKlxuICAgICAqICByZWFkeVxuICAgICAqXG4gICAgICogIEEgUHJvbWlzZTxOZXR3b3JrPiB0aGF0IHJlc29sdmVzIG9ubHkgb25jZSB0aGUgcHJvdmlkZXIgaXMgcmVhZHkuXG4gICAgICpcbiAgICAgKiAgU3ViLWNsYXNzZXMgdGhhdCBjYWxsIHRoZSBzdXBlciB3aXRoIGEgbmV0d29yayB3aXRob3V0IGEgY2hhaW5JZFxuICAgICAqICBNVVNUIHNldCB0aGlzLiBTdGFuZGFyZCBuYW1lZCBuZXR3b3JrcyBoYXZlIGEga25vd24gY2hhaW5JZC5cbiAgICAgKlxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKG5ldHdvcmspIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KG5ldy50YXJnZXQsIFByb3ZpZGVyKTtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gRXZlbnRzIGJlaW5nIGxpc3RlbmVkIHRvXG4gICAgICAgIHRoaXMuX2V2ZW50cyA9IFtdO1xuICAgICAgICB0aGlzLl9lbWl0dGVkID0geyBibG9jazogLTIgfTtcbiAgICAgICAgdGhpcy5mb3JtYXR0ZXIgPSBuZXcudGFyZ2V0LmdldEZvcm1hdHRlcigpO1xuICAgICAgICAvLyBJZiBuZXR3b3JrIGlzIGFueSwgdGhpcyBQcm92aWRlciBhbGxvd3MgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgLy8gbmV0d29yayB0byBjaGFuZ2UgZHluYW1pY2FsbHksIGFuZCB3ZSBhdXRvLWRldGVjdCB0aGVcbiAgICAgICAgLy8gY3VycmVudCBuZXR3b3JrXG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYW55TmV0d29ya1wiLCAobmV0d29yayA9PT0gXCJhbnlcIikpO1xuICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICBuZXR3b3JrID0gdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ldHdvcmsgaW5zdGFuY2VvZiBQcm9taXNlKSB7XG4gICAgICAgICAgICB0aGlzLl9uZXR3b3JrUHJvbWlzZSA9IG5ldHdvcms7XG4gICAgICAgICAgICAvLyBTcXVhc2ggYW55IFwidW5oYW5kbGVkIHByb21pc2VcIiBlcnJvcnM7IHRoYXQgZG8gbm90IG5lZWQgdG8gYmUgaGFuZGxlZFxuICAgICAgICAgICAgbmV0d29yay5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgICAgICAvLyBUcmlnZ2VyIGluaXRpYWwgbmV0d29yayBzZXR0aW5nIChhc3luYylcbiAgICAgICAgICAgIHRoaXMuX3JlYWR5KCkuY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qga25vd25OZXR3b3JrID0gZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0TmV0d29ya1wiKShuZXR3b3JrKTtcbiAgICAgICAgICAgIGlmIChrbm93bk5ldHdvcmspIHtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9uZXR3b3JrXCIsIGtub3duTmV0d29yayk7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBrbm93bk5ldHdvcmssIG51bGwpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbmV0d29ya1wiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IC0xMDI0O1xuICAgICAgICB0aGlzLl9sYXN0QmxvY2tOdW1iZXIgPSAtMjtcbiAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gNDAwMDtcbiAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IDA7XG4gICAgfVxuICAgIF9yZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBsZXQgbmV0d29yayA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmtQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXR3b3JrID0geWllbGQgdGhpcy5fbmV0d29ya1Byb21pc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVHJ5IHRoZSBQcm92aWRlcidzIG5ldHdvcmsgZGV0ZWN0aW9uICh0aGlzIE1VU1QgdGhyb3cgaWYgaXQgY2Fubm90KVxuICAgICAgICAgICAgICAgIGlmIChuZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbmV0d29yayA9IHlpZWxkIHRoaXMuZGV0ZWN0TmV0d29yaygpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBUaGlzIHNob3VsZCBuZXZlciBoYXBwZW47IGV2ZXJ5IFByb3ZpZGVyIHN1Yi1jbGFzcyBzaG91bGQgaGF2ZVxuICAgICAgICAgICAgICAgIC8vIHN1Z2dlc3RlZCBhIG5ldHdvcmsgYnkgaGVyZSAob3IgaGF2ZSB0aHJvd24pLlxuICAgICAgICAgICAgICAgIGlmICghbmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vIG5ldHdvcmsgZGV0ZWN0ZWRcIiwgTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFBvc3NpYmxlIHRoaXMgY2FsbCBzdGFja2VkIHNvIGRvIG5vdCBjYWxsIGRlZmluZVJlYWRPbmx5IGFnYWluXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX25ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5hbnlOZXR3b3JrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXR3b3JrID0gbmV0d29yaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX25ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fbmV0d29yaztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFRoaXMgd2lsbCBhbHdheXMgcmV0dXJuIHRoZSBtb3N0IHJlY2VudGx5IGVzdGFibGlzaGVkIG5ldHdvcmsuXG4gICAgLy8gRm9yIFwiYW55XCIsIHRoaXMgY2FuIGNoYW5nZSAoYSBcIm5ldHdvcmtcIiBldmVudCBpcyBlbWl0dGVkIGJlZm9yZVxuICAgIC8vIGFueSBjaGFuZ2UgaXMgcmVmbGVjdGVkKTsgb3RoZXJ3aXNlIHRoaXMgY2Fubm90IGNoYW5nZVxuICAgIGdldCByZWFkeSgpIHtcbiAgICAgICAgcmV0dXJuIHBvbGwoKCkgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3JlYWR5KCkudGhlbigobmV0d29yaykgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBuZXR3b3JrO1xuICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5ldHdvcmsgaXNuJ3QgcnVubmluZyB5ZXQsIHdlIHdpbGwgd2FpdFxuICAgICAgICAgICAgICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IgJiYgZXJyb3IuZXZlbnQgPT09IFwibm9OZXR3b3JrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIEBUT0RPOiBSZW1vdmUgdGhpcyBhbmQganVzdCBjcmVhdGUgYSBzaW5nbGV0b24gZm9ybWF0dGVyXG4gICAgc3RhdGljIGdldEZvcm1hdHRlcigpIHtcbiAgICAgICAgaWYgKGRlZmF1bHRGb3JtYXR0ZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgZGVmYXVsdEZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZGVmYXVsdEZvcm1hdHRlcjtcbiAgICB9XG4gICAgLy8gQFRPRE86IFJlbW92ZSB0aGlzIGFuZCBqdXN0IHVzZSBnZXROZXR3b3JrXG4gICAgc3RhdGljIGdldE5ldHdvcmsobmV0d29yaykge1xuICAgICAgICByZXR1cm4gZ2V0TmV0d29yaygobmV0d29yayA9PSBudWxsKSA/IFwiaG9tZXN0ZWFkXCIgOiBuZXR3b3JrKTtcbiAgICB9XG4gICAgLy8gRmV0Y2hlcyB0aGUgYmxvY2tOdW1iZXIsIGJ1dCB3aWxsIHJldXNlIGFueSByZXN1bHQgdGhhdCBpcyBsZXNzXG4gICAgLy8gdGhhbiBtYXhBZ2Ugb2xkIG9yIGhhcyBiZWVuIHJlcXVlc3RlZCBzaW5jZSB0aGUgbGFzdCByZXF1ZXN0XG4gICAgX2dldEludGVybmFsQmxvY2tOdW1iZXIobWF4QWdlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLl9yZWFkeSgpO1xuICAgICAgICAgICAgLy8gQWxsb3dpbmcgc3RhbGUgZGF0YSB1cCB0byBtYXhBZ2Ugb2xkXG4gICAgICAgICAgICBpZiAobWF4QWdlID4gMCkge1xuICAgICAgICAgICAgICAgIC8vIFdoaWxlIHRoZXJlIGFyZSBwZW5kaW5nIGludGVybmFsIGJsb2NrIHJlcXVlc3RzLi4uXG4gICAgICAgICAgICAgICAgd2hpbGUgKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gLi4uXCJyZW1lbWJlclwiIHdoaWNoIGZldGNoIHdlIHN0YXJ0ZWQgd2l0aFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBpbnRlcm5hbEJsb2NrTnVtYmVyID0gdGhpcy5faW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIHRoZSByZXN1bHQgaXMgbm90IHRvbyBzdGFsZVxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgaW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICgoZ2V0VGltZSgpIC0gcmVzdWx0LnJlc3BUaW1lKSA8PSBtYXhBZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVG9vIG9sZDsgZmV0Y2ggYSBuZXcgdmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGZldGNoIHJlamVjdGVkOyBpZiB3ZSBhcmUgdGhlIGZpcnN0IHRvIGdldCB0aGVcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHJlamVjdGlvbiwgZHJvcCB0aHJvdWdoIHNvIHdlIHJlcGxhY2UgaXQgd2l0aCBhIG5ld1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gZmV0Y2g7IGFsbCBvdGhlcnMgYmxvY2tlZCB3aWxsIHRoZW4gZ2V0IHRoYXQgZmV0Y2hcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdoaWNoIHdvbid0IG1hdGNoIHRoZSBvbmUgdGhleSBcInJlbWVtYmVyZWRcIiBhbmQgbG9vcFxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPT09IGludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHJlcVRpbWUgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICBjb25zdCBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIgPSByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXI6IHRoaXMucGVyZm9ybShcImdldEJsb2NrTnVtYmVyXCIsIHt9KSxcbiAgICAgICAgICAgICAgICBuZXR3b3JrRXJyb3I6IHRoaXMuZ2V0TmV0d29yaygpLnRoZW4oKG5ldHdvcmspID0+IChudWxsKSwgKGVycm9yKSA9PiAoZXJyb3IpKVxuICAgICAgICAgICAgfSkudGhlbigoeyBibG9ja051bWJlciwgbmV0d29ya0Vycm9yIH0pID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmV0d29ya0Vycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFVucmVtZW1iZXIgdGhpcyBiYWQgaW50ZXJuYWwgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl9pbnRlcm5hbEJsb2NrTnVtYmVyID09PSBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldHdvcmtFcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzcFRpbWUgPSBnZXRUaW1lKCk7XG4gICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBCaWdOdW1iZXIuZnJvbShibG9ja051bWJlcikudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPCB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyID0gdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fbWF4SW50ZXJuYWxCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgIHRoaXMuX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcik7IC8vIEBUT0RPOiBTdGlsbCBuZWVkIHRoaXM/XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgYmxvY2tOdW1iZXIsIHJlcVRpbWUsIHJlc3BUaW1lIH07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPSBjaGVja0ludGVybmFsQmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAvLyBTd2FsbG93IHVuaGFuZGxlZCBleGNlcHRpb25zOyBpZiBuZWVkZWQgdGhleSBhcmUgaGFuZGxlZCBlbHNlIHdoZXJlXG4gICAgICAgICAgICBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gRG9uJ3QgbnVsbCB0aGUgZGVhZCAocmVqZWN0ZWQpIGZldGNoLCBpZiBpdCBoYXMgYWxyZWFkeSBiZWVuIHVwZGF0ZWRcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJuYWxCbG9ja051bWJlciA9PT0gY2hlY2tJbnRlcm5hbEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuICh5aWVsZCBjaGVja0ludGVybmFsQmxvY2tOdW1iZXIpLmJsb2NrTnVtYmVyO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcG9sbCgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHBvbGxJZCA9IG5leHRQb2xsSWQrKztcbiAgICAgICAgICAgIC8vIFRyYWNrIGFsbCBydW5uaW5nIHByb21pc2VzLCBzbyB3ZSBjYW4gdHJpZ2dlciBhIHBvc3QtcG9sbCBvbmNlIHRoZXkgYXJlIGNvbXBsZXRlXG4gICAgICAgICAgICBjb25zdCBydW5uZXJzID0gW107XG4gICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgdGhpcy5wb2xsaW5nSW50ZXJ2YWwgLyAyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgLy8gRW1pdCBhIHBvbGwgZXZlbnQgYWZ0ZXIgd2UgaGF2ZSB0aGUgbGF0ZXN0IChmYXN0KSBibG9jayBudW1iZXJcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInBvbGxcIiwgcG9sbElkLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICAvLyBJZiB0aGUgYmxvY2sgaGFzIG5vdCBjaGFuZ2VkLCBtZWguXG4gICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT09IHRoaXMuX2xhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRpZFBvbGxcIiwgcG9sbElkKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXJzdCBwb2xsaW5nIGN5Y2xlLCB0cmlnZ2VyIGEgXCJibG9ja1wiIGV2ZW50c1xuICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWQuYmxvY2sgPT09IC0yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChNYXRoLmFicygodGhpcy5fZW1pdHRlZC5ibG9jaykgLSBibG9ja051bWJlcikgPiAxMDAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oYG5ldHdvcmsgYmxvY2sgc2tldyBkZXRlY3RlZDsgc2tpcHBpbmcgYmxvY2sgZXZlbnRzIChlbWl0dGVkPSR7dGhpcy5fZW1pdHRlZC5ibG9ja30gYmxvY2tOdW1iZXIke2Jsb2NrTnVtYmVyfSlgKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBsb2dnZXIubWFrZUVycm9yKFwibmV0d29yayBibG9jayBza2V3IGRldGVjdGVkXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlcjogYmxvY2tOdW1iZXIsXG4gICAgICAgICAgICAgICAgICAgIGV2ZW50OiBcImJsb2NrU2tld1wiLFxuICAgICAgICAgICAgICAgICAgICBwcmV2aW91c0Jsb2NrTnVtYmVyOiB0aGlzLl9lbWl0dGVkLmJsb2NrXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImJsb2NrXCIsIGJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8vIE5vdGlmeSBhbGwgbGlzdGVuZXIgZm9yIGVhY2ggYmxvY2sgdGhhdCBoYXMgcGFzc2VkXG4gICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IHRoaXMuX2VtaXR0ZWQuYmxvY2sgKyAxOyBpIDw9IGJsb2NrTnVtYmVyOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiYmxvY2tcIiwgaSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gVGhlIGVtaXR0ZWQgYmxvY2sgd2FzIHVwZGF0ZWQsIGNoZWNrIGZvciBvYnNvbGV0ZSBldmVudHNcbiAgICAgICAgICAgIGlmICh0aGlzLl9lbWl0dGVkLmJsb2NrICE9PSBibG9ja051bWJlcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWQuYmxvY2sgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyh0aGlzLl9lbWl0dGVkKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlIGJsb2NrIGV2ZW50IGRvZXMgbm90IGV4cGlyZVxuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5ID09PSBcImJsb2NrXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgYmxvY2sgd2Ugd2VyZSBhdCB3aGVuIHdlIGVtaXR0ZWQgdGhpcyBldmVudFxuICAgICAgICAgICAgICAgICAgICBjb25zdCBldmVudEJsb2NrTnVtYmVyID0gdGhpcy5fZW1pdHRlZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAvLyBXZSBjYW5ub3QgZ2FyYmFnZSBjb2xsZWN0IHBlbmRpbmcgdHJhbnNhY3Rpb25zIG9yIGJsb2NrcyBoZXJlXG4gICAgICAgICAgICAgICAgICAgIC8vIFRoZXkgc2hvdWxkIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGJ5IHRoZSBQcm92aWRlciB3aGVuIHNldHRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gXCJwZW5kaW5nXCIgZXZlbnRzXG4gICAgICAgICAgICAgICAgICAgIGlmIChldmVudEJsb2NrTnVtYmVyID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEV2aWN0IGFueSB0cmFuc2FjdGlvbiBoYXNoZXMgb3IgYmxvY2sgaGFzaGVzIG92ZXIgMTIgYmxvY2tzXG4gICAgICAgICAgICAgICAgICAgIC8vIG9sZCwgc2luY2UgdGhleSBzaG91bGQgbm90IHJldHVybiBudWxsIGFueXdheXNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrTnVtYmVyIC0gZXZlbnRCbG9ja051bWJlciA+IDEyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5fZW1pdHRlZFtrZXldO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXJzdCBwb2xsaW5nIGN5Y2xlXG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdEJsb2NrTnVtYmVyID09PSAtMikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpbmQgYWxsIHRyYW5zYWN0aW9uIGhhc2hlcyB3ZSBhcmUgd2FpdGluZyBvblxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzLmZvckVhY2goKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChldmVudC50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJ0eFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gZXZlbnQuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBydW5uZXIgPSB0aGlzLmdldFRyYW5zYWN0aW9uUmVjZWlwdChoYXNoKS50aGVuKChyZWNlaXB0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0IHx8IHJlY2VpcHQuYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZFtcInQ6XCIgKyBoYXNoXSA9IHJlY2VpcHQuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGhhc2gsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBydW5uZXJzLnB1c2gocnVubmVyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJmaWx0ZXJcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsdGVyID0gZXZlbnQuZmlsdGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgZmlsdGVyLmZyb21CbG9jayA9IHRoaXMuX2xhc3RCbG9ja051bWJlciArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWx0ZXIudG9CbG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcnVubmVyID0gdGhpcy5nZXRMb2dzKGZpbHRlcikudGhlbigobG9ncykgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChsb2dzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ3MuZm9yRWFjaCgobG9nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJiOlwiICsgbG9nLmJsb2NrSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgbG9nLnRyYW5zYWN0aW9uSGFzaF0gPSBsb2cuYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChmaWx0ZXIsIGxvZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgdGhpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5lcnMucHVzaChydW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgLy8gT25jZSBhbGwgZXZlbnRzIGZvciB0aGlzIGxvb3AgaGF2ZSBiZWVuIHByb2Nlc3NlZCwgZW1pdCBcImRpZFBvbGxcIlxuICAgICAgICAgICAgUHJvbWlzZS5hbGwocnVubmVycykudGhlbigoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGlkUG9sbFwiLCBwb2xsSWQpO1xuICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7IHRoaXMuZW1pdChcImVycm9yXCIsIGVycm9yKTsgfSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBEZXByZWNhdGVkOyBkbyBub3QgdXNlIHRoaXNcbiAgICByZXNldEV2ZW50c0Jsb2NrKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIHRoaXMuX2xhc3RCbG9ja051bWJlciA9IGJsb2NrTnVtYmVyIC0gMTtcbiAgICAgICAgaWYgKHRoaXMucG9sbGluZykge1xuICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZ2V0IG5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9uZXR3b3JrO1xuICAgIH1cbiAgICAvLyBUaGlzIG1ldGhvZCBzaG91bGQgcXVlcnkgdGhlIG5ldHdvcmsgaWYgdGhlIHVuZGVybHlpbmcgbmV0d29ya1xuICAgIC8vIGNhbiBjaGFuZ2UsIHN1Y2ggYXMgd2hlbiBjb25uZWN0ZWQgdG8gYSBKU09OLVJQQyBiYWNrZW5kXG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcInByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgbmV0d29yayBkZXRlY3Rpb25cIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicHJvdmlkZXIuZGV0ZWN0TmV0d29ya1wiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldE5ldHdvcmsoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0geWllbGQgdGhpcy5fcmVhZHkoKTtcbiAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSB3ZSBhcmUgc3RpbGwgY29ubmVjdGVkIHRvIHRoZSBzYW1lIG5ldHdvcms7IHRoaXMgaXNcbiAgICAgICAgICAgIC8vIG9ubHkgYW4gZXh0ZXJuYWwgY2FsbCBmb3IgYmFja2VuZHMgd2hpY2ggY2FuIGhhdmUgdGhlIHVuZGVybHlpbmdcbiAgICAgICAgICAgIC8vIG5ldHdvcmsgY2hhbmdlIHNwb250YW5lb3VzbHlcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnROZXR3b3JrID0geWllbGQgdGhpcy5kZXRlY3ROZXR3b3JrKCk7XG4gICAgICAgICAgICBpZiAobmV0d29yay5jaGFpbklkICE9PSBjdXJyZW50TmV0d29yay5jaGFpbklkKSB7XG4gICAgICAgICAgICAgICAgLy8gV2UgYXJlIGFsbG93aW5nIG5ldHdvcmsgY2hhbmdlcywgdGhpbmdzIGNhbiBnZXQgY29tcGxleCBmYXN0O1xuICAgICAgICAgICAgICAgIC8vIG1ha2Ugc3VyZSB5b3Uga25vdyB3aGF0IHlvdSBhcmUgZG9pbmcgaWYgeW91IHVzZSBcImFueVwiXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuYW55TmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9uZXR3b3JrID0gY3VycmVudE5ldHdvcms7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IGFsbCBpbnRlcm5hbCBibG9jayBudW1iZXIgZ3VhcmRzIGFuZCBjYWNoZXNcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbGFzdEJsb2NrTnVtYmVyID0gLTI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IC0yO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tYXhJbnRlcm5hbEJsb2NrTnVtYmVyID0gLTEwMjQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2ludGVybmFsQmxvY2tOdW1iZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGUgXCJuZXR3b3JrXCIgZXZlbnQgTVVTVCBoYXBwZW4gYmVmb3JlIHRoaXMgbWV0aG9kIHJlc29sdmVzXG4gICAgICAgICAgICAgICAgICAgIC8vIHNvIGFueSBldmVudHMgaGF2ZSBhIGNoYW5jZSB0byB1bnJlZ2lzdGVyLCBzbyB3ZSBzdGFsbCBhblxuICAgICAgICAgICAgICAgICAgICAvLyBhZGRpdGlvbmFsIGV2ZW50IGxvb3AgYmVmb3JlIHJldHVybmluZyBmcm9tIC90aGlzLyBjYWxsXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcIm5ldHdvcmtcIiwgY3VycmVudE5ldHdvcmssIG5ldHdvcmspO1xuICAgICAgICAgICAgICAgICAgICB5aWVsZCBzdGFsbCgwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25ldHdvcms7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbG9nZ2VyLm1ha2VFcnJvcihcInVuZGVybHlpbmcgbmV0d29yayBjaGFuZ2VkXCIsIExvZ2dlci5lcnJvcnMuTkVUV09SS19FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBldmVudDogXCJjaGFuZ2VkXCIsXG4gICAgICAgICAgICAgICAgICAgIG5ldHdvcms6IG5ldHdvcmssXG4gICAgICAgICAgICAgICAgICAgIGRldGVjdGVkTmV0d29yazogY3VycmVudE5ldHdvcmtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJlcnJvclwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBibG9ja051bWJlcigpIHtcbiAgICAgICAgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyB0aGlzLnBvbGxpbmdJbnRlcnZhbCAvIDIpLnRoZW4oKGJsb2NrTnVtYmVyKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9zZXRGYXN0QmxvY2tOdW1iZXIoYmxvY2tOdW1iZXIpO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHsgfSk7XG4gICAgICAgIHJldHVybiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyICE9IG51bGwpID8gdGhpcy5fZmFzdEJsb2NrTnVtYmVyIDogLTE7XG4gICAgfVxuICAgIGdldCBwb2xsaW5nKCkge1xuICAgICAgICByZXR1cm4gKHRoaXMuX3BvbGxlciAhPSBudWxsKTtcbiAgICB9XG4gICAgc2V0IHBvbGxpbmcodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlICYmICF0aGlzLl9wb2xsZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX3BvbGxlciA9IHNldEludGVydmFsKCgpID0+IHsgdGhpcy5wb2xsKCk7IH0sIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fYm9vdHN0cmFwUG9sbCkge1xuICAgICAgICAgICAgICAgIHRoaXMuX2Jvb3RzdHJhcFBvbGwgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wb2xsKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGJsb2NrIGFkZGl0aW9uYWwgcG9sbHMgdW50aWwgdGhlIHBvbGxpbmcgaW50ZXJ2YWxcbiAgICAgICAgICAgICAgICAgICAgLy8gaXMgZG9uZSwgdG8gcHJldmVudCBvdmVyd2hlbG1pbmcgdGhlIHBvbGwgZnVuY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fYm9vdHN0cmFwUG9sbCA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gSWYgcG9sbGluZyB3YXMgZGlzYWJsZWQsIHNvbWV0aGluZyBtYXkgcmVxdWlyZSBhIHBva2VcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHNpbmNlIHN0YXJ0aW5nIHRoZSBib290c3RyYXAgcG9sbCBhbmQgaXQgd2FzIGRpc2FibGVkXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucG9sbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2xlYXIgb3V0IHRoZSBib290c3RyYXAgc28gd2UgY2FuIGRvIGFub3RoZXJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2Jvb3RzdHJhcFBvbGwgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIXZhbHVlICYmIHRoaXMuX3BvbGxlcikge1xuICAgICAgICAgICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9wb2xsZXIpO1xuICAgICAgICAgICAgdGhpcy5fcG9sbGVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXQgcG9sbGluZ0ludGVydmFsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcG9sbGluZ0ludGVydmFsO1xuICAgIH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSAhPT0gXCJudW1iZXJcIiB8fCB2YWx1ZSA8PSAwIHx8IHBhcnNlSW50KFN0cmluZyh2YWx1ZSkpICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIHBvbGxpbmcgaW50ZXJ2YWxcIik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcG9sbGluZ0ludGVydmFsID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9wb2xsZXIpIHtcbiAgICAgICAgICAgIGNsZWFySW50ZXJ2YWwodGhpcy5fcG9sbGVyKTtcbiAgICAgICAgICAgIHRoaXMuX3BvbGxlciA9IHNldEludGVydmFsKCgpID0+IHsgdGhpcy5wb2xsKCk7IH0sIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2dldEZhc3RCbG9ja051bWJlcigpIHtcbiAgICAgICAgY29uc3Qgbm93ID0gZ2V0VGltZSgpO1xuICAgICAgICAvLyBTdGFsZSBibG9jayBudW1iZXIsIHJlcXVlc3QgYSBuZXdlciB2YWx1ZVxuICAgICAgICBpZiAoKG5vdyAtIHRoaXMuX2Zhc3RRdWVyeURhdGUpID4gMiAqIHRoaXMuX3BvbGxpbmdJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhpcy5fZmFzdFF1ZXJ5RGF0ZSA9IG5vdztcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSB0aGlzLmdldEJsb2NrTnVtYmVyKCkudGhlbigoYmxvY2tOdW1iZXIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fZmFzdEJsb2NrTnVtYmVyID09IG51bGwgfHwgYmxvY2tOdW1iZXIgPiB0aGlzLl9mYXN0QmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZmFzdEJsb2NrTnVtYmVyID0gYmxvY2tOdW1iZXI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9mYXN0QmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyUHJvbWlzZTtcbiAgICB9XG4gICAgX3NldEZhc3RCbG9ja051bWJlcihibG9ja051bWJlcikge1xuICAgICAgICAvLyBPbGRlciBibG9jaywgbWF5YmUgYSBzdGFsZSByZXF1ZXN0XG4gICAgICAgIGlmICh0aGlzLl9mYXN0QmxvY2tOdW1iZXIgIT0gbnVsbCAmJiBibG9ja051bWJlciA8IHRoaXMuX2Zhc3RCbG9ja051bWJlcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdGltZSB3ZSB1cGRhdGVkIHRoZSBibG9ja251bWJlclxuICAgICAgICB0aGlzLl9mYXN0UXVlcnlEYXRlID0gZ2V0VGltZSgpO1xuICAgICAgICAvLyBOZXdlciBibG9jayBudW1iZXIsIHVzZSAgaXRcbiAgICAgICAgaWYgKHRoaXMuX2Zhc3RCbG9ja051bWJlciA9PSBudWxsIHx8IGJsb2NrTnVtYmVyID4gdGhpcy5fZmFzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICB0aGlzLl9mYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgIHRoaXMuX2Zhc3RCbG9ja051bWJlclByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoYmxvY2tOdW1iZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHdhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl93YWl0Rm9yVHJhbnNhY3Rpb24odHJhbnNhY3Rpb25IYXNoLCAoY29uZmlybWF0aW9ucyA9PSBudWxsKSA/IDEgOiBjb25maXJtYXRpb25zLCB0aW1lb3V0IHx8IDAsIG51bGwpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX3dhaXRGb3JUcmFuc2FjdGlvbih0cmFuc2FjdGlvbkhhc2gsIGNvbmZpcm1hdGlvbnMsIHRpbWVvdXQsIHJlcGxhY2VhYmxlKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCByZWNlaXB0ID0geWllbGQgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQodHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgIC8vIFJlY2VpcHQgaXMgYWxyZWFkeSBnb29kXG4gICAgICAgICAgICBpZiAoKHJlY2VpcHQgPyByZWNlaXB0LmNvbmZpcm1hdGlvbnMgOiAwKSA+PSBjb25maXJtYXRpb25zKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBQb2xsIHVudGlsIHRoZSByZWNlaXB0IGlzIGdvb2QuLi5cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FuY2VsRnVuY3MgPSBbXTtcbiAgICAgICAgICAgICAgICBsZXQgZG9uZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFscmVhZHlEb25lID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLmZvckVhY2goKGZ1bmMpID0+IHsgZnVuYygpOyB9KTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgbWluZWRIYW5kbGVyID0gKHJlY2VpcHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY2VpcHQuY29uZmlybWF0aW9ucyA8IGNvbmZpcm1hdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoYWxyZWFkeURvbmUoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVjZWlwdCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uKHRyYW5zYWN0aW9uSGFzaCwgbWluZWRIYW5kbGVyKTtcbiAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKCgpID0+IHsgdGhpcy5yZW1vdmVMaXN0ZW5lcih0cmFuc2FjdGlvbkhhc2gsIG1pbmVkSGFuZGxlcik7IH0pO1xuICAgICAgICAgICAgICAgIGlmIChyZXBsYWNlYWJsZSkge1xuICAgICAgICAgICAgICAgICAgICBsZXQgbGFzdEJsb2NrTnVtYmVyID0gcmVwbGFjZWFibGUuc3RhcnRCbG9jaztcbiAgICAgICAgICAgICAgICAgICAgbGV0IHNjYW5uZWRCbG9jayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlcGxhY2VIYW5kbGVyID0gKGJsb2NrTnVtYmVyKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFdhaXQgMSBzZWNvbmQ7IHRoaXMgaXMgb25seSB1c2VkIGluIHRoZSBjYXNlIG9mIGEgZmF1bHQsIHNvXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSB3aWxsIHRyYWRlIG9mZiBhIGxpdHRsZSBiaXQgb2YgbGF0ZW5jeSBmb3IgbW9yZSBjb25zaXN0ZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZXN1bHRzIGFuZCBmZXdlciBKU09OLVJQQyBjYWxsc1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgc3RhbGwoMTAwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmdldFRyYW5zYWN0aW9uQ291bnQocmVwbGFjZWFibGUuZnJvbSkudGhlbigobm9uY2UpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChub25jZSA8PSByZXBsYWNlYWJsZS5ub25jZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEZpcnN0IGNoZWNrIGlmIHRoZSB0cmFuc2FjdGlvbiB3YXMgbWluZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgbWluZWQgPSB5aWVsZCB0aGlzLmdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobWluZWQgJiYgbWluZWQuYmxvY2tOdW1iZXIgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBGaXJzdCB0aW1lIHNjYW5uaW5nLiBXZSBzdGFydCBhIGxpdHRsZSBlYXJsaWVyIGZvciBzb21lXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdpZ2dsZSByb29tIGhlcmUgdG8gaGFuZGxlIHRoZSBldmVudHVhbGx5IGNvbnNpc3RlbnQgbmF0dXJlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIG9mIGJsb2NrY2hhaW4gKGUuZy4gdGhlIGdldFRyYW5zYWN0aW9uQ291bnQgd2FzIGZvciBhXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGRpZmZlcmVudCBibG9jaylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYW5uZWRCbG9jayA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2sgPSBsYXN0QmxvY2tOdW1iZXIgLSAzO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNjYW5uZWRCbG9jayA8IHJlcGxhY2VhYmxlLnN0YXJ0QmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY2FubmVkQmxvY2sgPSByZXBsYWNlYWJsZS5zdGFydEJsb2NrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChzY2FubmVkQmxvY2sgPD0gYmxvY2tOdW1iZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB5aWVsZCB0aGlzLmdldEJsb2NrV2l0aFRyYW5zYWN0aW9ucyhzY2FubmVkQmxvY2spO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgdGkgPSAwOyB0aSA8IGJsb2NrLnRyYW5zYWN0aW9ucy5sZW5ndGg7IHRpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGJsb2NrLnRyYW5zYWN0aW9uc1t0aV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3VjY2Vzc2Z1bGx5IG1pbmVkIVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5oYXNoID09PSB0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaGVzIG91ciB0cmFuc2FjdGlvbiBmcm9tIGFuZCBub25jZTsgaXRzIGEgcmVwbGFjZW1lbnRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHguZnJvbSA9PT0gcmVwbGFjZWFibGUuZnJvbSAmJiB0eC5ub25jZSA9PT0gcmVwbGFjZWFibGUubm9uY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBHZXQgdGhlIHJlY2VpcHQgb2YgdGhlIHJlcGxhY2VtZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlY2VpcHQgPSB5aWVsZCB0aGlzLndhaXRGb3JUcmFuc2FjdGlvbih0eC5oYXNoLCBjb25maXJtYXRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWxyZWFkeSByZXNvbHZlZCBvciByZWplY3RlZCAocHJvbGx5IGEgdGltZW91dClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBUaGUgcmVhc29uIHdlIHdlcmUgcmVwbGFjZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHJlYXNvbiA9IFwicmVwbGFjZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR4LmRhdGEgPT09IHJlcGxhY2VhYmxlLmRhdGEgJiYgdHgudG8gPT09IHJlcGxhY2VhYmxlLnRvICYmIHR4LnZhbHVlLmVxKHJlcGxhY2VhYmxlLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJyZXByaWNlZFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR4LmRhdGEgPT09IFwiMHhcIiAmJiB0eC5mcm9tID09PSB0eC50byAmJiB0eC52YWx1ZS5pc1plcm8oKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVhc29uID0gXCJjYW5jZWxsZWRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHBsYWluIHdoeSB3ZSB3ZXJlIHJlcGxhY2VkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidHJhbnNhY3Rpb24gd2FzIHJlcGxhY2VkXCIsIExvZ2dlci5lcnJvcnMuVFJBTlNBQ1RJT05fUkVQTEFDRUQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbmNlbGxlZDogKHJlYXNvbiA9PT0gXCJyZXBsYWNlZFwiIHx8IHJlYXNvbiA9PT0gXCJjYW5jZWxsZWRcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXBsYWNlbWVudDogdGhpcy5fd3JhcFRyYW5zYWN0aW9uKHR4KSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhc2g6IHRyYW5zYWN0aW9uSGFzaCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlY2VpcHRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2Nhbm5lZEJsb2NrKys7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9uY2UoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwiYmxvY2tcIiwgcmVwbGFjZUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICBjYW5jZWxGdW5jcy5wdXNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlTGlzdGVuZXIoXCJibG9ja1wiLCByZXBsYWNlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mICh0aW1lb3V0KSA9PT0gXCJudW1iZXJcIiAmJiB0aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGFscmVhZHlEb25lKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QobG9nZ2VyLm1ha2VFcnJvcihcInRpbWVvdXQgZXhjZWVkZWRcIiwgTG9nZ2VyLmVycm9ycy5USU1FT1VULCB7IHRpbWVvdXQ6IHRpbWVvdXQgfSkpO1xuICAgICAgICAgICAgICAgICAgICB9LCB0aW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyLnVucmVmKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lci51bnJlZigpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbmNlbEZ1bmNzLnB1c2goKCkgPT4geyBjbGVhclRpbWVvdXQodGltZXIpOyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldEJsb2NrTnVtYmVyKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRHYXNQcmljZSgpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0R2FzUHJpY2VcIiwge30pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRHYXNQcmljZVwiLFxuICAgICAgICAgICAgICAgICAgICByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRCYWxhbmNlKGFkZHJlc3NPck5hbWUsIGJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICBhZGRyZXNzOiB0aGlzLl9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpLFxuICAgICAgICAgICAgICAgIGJsb2NrVGFnOiB0aGlzLl9nZXRCbG9ja1RhZyhibG9ja1RhZylcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0QmFsYW5jZVwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRCYWxhbmNlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0VHJhbnNhY3Rpb25Db3VudChhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uQ291bnRcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHJlc3VsdCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRUcmFuc2FjdGlvbkNvdW50XCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0Q29kZShhZGRyZXNzT3JOYW1lLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldENvZGVcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRDb2RlXCIsXG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcywgcmVzdWx0LCBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0U3RvcmFnZUF0KGFkZHJlc3NPck5hbWUsIHBvc2l0aW9uLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgYWRkcmVzczogdGhpcy5fZ2V0QWRkcmVzcyhhZGRyZXNzT3JOYW1lKSxcbiAgICAgICAgICAgICAgICBibG9ja1RhZzogdGhpcy5fZ2V0QmxvY2tUYWcoYmxvY2tUYWcpLFxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiBQcm9taXNlLnJlc29sdmUocG9zaXRpb24pLnRoZW4oKHApID0+IGhleFZhbHVlKHApKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRTdG9yYWdlQXRcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJnZXRTdG9yYWdlQXRcIixcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLCByZXN1bHQsIGVycm9yXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBUaGlzIHNob3VsZCBiZSBjYWxsZWQgYnkgYW55IHN1YmNsYXNzIHdyYXBwaW5nIGEgVHJhbnNhY3Rpb25SZXNwb25zZVxuICAgIF93cmFwVHJhbnNhY3Rpb24odHgsIGhhc2gsIHN0YXJ0QmxvY2spIHtcbiAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiBoZXhEYXRhTGVuZ3RoKGhhc2gpICE9PSAzMikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZSAtIHNlbmRUcmFuc2FjdGlvblwiKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSB0eDtcbiAgICAgICAgLy8gQ2hlY2sgdGhlIGhhc2ggd2UgZXhwZWN0IGlzIHRoZSBzYW1lIGFzIHRoZSBoYXNoIHRoZSBzZXJ2ZXIgcmVwb3J0ZWRcbiAgICAgICAgaWYgKGhhc2ggIT0gbnVsbCAmJiB0eC5oYXNoICE9PSBoYXNoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIlRyYW5zYWN0aW9uIGhhc2ggbWlzbWF0Y2ggZnJvbSBQcm92aWRlci5zZW5kVHJhbnNhY3Rpb24uXCIsIExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwgeyBleHBlY3RlZEhhc2g6IHR4Lmhhc2gsIHJldHVybmVkSGFzaDogaGFzaCB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQud2FpdCA9IChjb25maXJtcywgdGltZW91dCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpcm1zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maXJtcyA9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGltZW91dCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGltZW91dCA9IDA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBHZXQgdGhlIGRldGFpbHMgdG8gZGV0ZWN0IHJlcGxhY2VtZW50XG4gICAgICAgICAgICBsZXQgcmVwbGFjZW1lbnQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBpZiAoY29uZmlybXMgIT09IDAgJiYgc3RhcnRCbG9jayAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVwbGFjZW1lbnQgPSB7XG4gICAgICAgICAgICAgICAgICAgIGRhdGE6IHR4LmRhdGEsXG4gICAgICAgICAgICAgICAgICAgIGZyb206IHR4LmZyb20sXG4gICAgICAgICAgICAgICAgICAgIG5vbmNlOiB0eC5ub25jZSxcbiAgICAgICAgICAgICAgICAgICAgdG86IHR4LnRvLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogdHgudmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0QmxvY2tcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IHlpZWxkIHRoaXMuX3dhaXRGb3JUcmFuc2FjdGlvbih0eC5oYXNoLCBjb25maXJtcywgdGltZW91dCwgcmVwbGFjZW1lbnQpO1xuICAgICAgICAgICAgaWYgKHJlY2VpcHQgPT0gbnVsbCAmJiBjb25maXJtcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gTm8gbG9uZ2VyIHBlbmRpbmcsIGFsbG93IHRoZSBwb2xsaW5nIGxvb3AgdG8gZ2FyYmFnZSBjb2xsZWN0IHRoaXNcbiAgICAgICAgICAgIHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHguaGFzaF0gPSByZWNlaXB0LmJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgaWYgKHJlY2VpcHQuc3RhdHVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ0cmFuc2FjdGlvbiBmYWlsZWRcIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2g6IHR4Lmhhc2gsXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zYWN0aW9uOiB0eCxcbiAgICAgICAgICAgICAgICAgICAgcmVjZWlwdDogcmVjZWlwdFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHJlY2VpcHQ7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgY29uc3QgaGV4VHggPSB5aWVsZCBQcm9taXNlLnJlc29sdmUoc2lnbmVkVHJhbnNhY3Rpb24pLnRoZW4odCA9PiBoZXhsaWZ5KHQpKTtcbiAgICAgICAgICAgIGNvbnN0IHR4ID0gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb24oc2lnbmVkVHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgaWYgKHR4LmNvbmZpcm1hdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGhhc2ggPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJzZW5kVHJhbnNhY3Rpb25cIiwgeyBzaWduZWRUcmFuc2FjdGlvbjogaGV4VHggfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCwgaGFzaCwgYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IudHJhbnNhY3Rpb24gPSB0eDtcbiAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbkhhc2ggPSB0eC5oYXNoO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2dldFRyYW5zYWN0aW9uUmVxdWVzdCh0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0geWllbGQgdHJhbnNhY3Rpb247XG4gICAgICAgICAgICBjb25zdCB0eCA9IHt9O1xuICAgICAgICAgICAgW1wiZnJvbVwiLCBcInRvXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbigodikgPT4gKHYgPyB0aGlzLl9nZXRBZGRyZXNzKHYpIDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBbXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwibWF4RmVlUGVyR2FzXCIsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR4W2tleV0gPSBQcm9taXNlLnJlc29sdmUodmFsdWVzW2tleV0pLnRoZW4oKHYpID0+ICh2ID8gQmlnTnVtYmVyLmZyb20odikgOiBudWxsKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIFtcInR5cGVcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlc1trZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0eFtrZXldID0gUHJvbWlzZS5yZXNvbHZlKHZhbHVlc1trZXldKS50aGVuKCh2KSA9PiAoKHYgIT0gbnVsbCkgPyB2IDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAodmFsdWVzLmFjY2Vzc0xpc3QpIHtcbiAgICAgICAgICAgICAgICB0eC5hY2Nlc3NMaXN0ID0gdGhpcy5mb3JtYXR0ZXIuYWNjZXNzTGlzdCh2YWx1ZXMuYWNjZXNzTGlzdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbXCJkYXRhXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZXNba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHhba2V5XSA9IFByb21pc2UucmVzb2x2ZSh2YWx1ZXNba2V5XSkudGhlbigodikgPT4gKHYgPyBoZXhsaWZ5KHYpIDogbnVsbCkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIudHJhbnNhY3Rpb25SZXF1ZXN0KHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHR4KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0RmlsdGVyKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgZmlsdGVyID0geWllbGQgZmlsdGVyO1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgICAgICBpZiAoZmlsdGVyLmFkZHJlc3MgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5hZGRyZXNzID0gdGhpcy5fZ2V0QWRkcmVzcyhmaWx0ZXIuYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBbXCJibG9ja0hhc2hcIiwgXCJ0b3BpY3NcIl0uZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlcltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXN1bHRba2V5XSA9IGZpbHRlcltrZXldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBbXCJmcm9tQmxvY2tcIiwgXCJ0b0Jsb2NrXCJdLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChmaWx0ZXJba2V5XSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzdWx0W2tleV0gPSB0aGlzLl9nZXRCbG9ja1RhZyhmaWx0ZXJba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZvcm1hdHRlci5maWx0ZXIoeWllbGQgcmVzb2x2ZVByb3BlcnRpZXMocmVzdWx0KSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjYWxsKHRyYW5zYWN0aW9uLCBibG9ja1RhZykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7XG4gICAgICAgICAgICAgICAgdHJhbnNhY3Rpb246IHRoaXMuX2dldFRyYW5zYWN0aW9uUmVxdWVzdCh0cmFuc2FjdGlvbiksXG4gICAgICAgICAgICAgICAgYmxvY2tUYWc6IHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrVGFnKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJjYWxsXCIsIHBhcmFtcyk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBoZXhsaWZ5KHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzdWx0IGZyb20gYmFja2VuZFwiLCBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUiwge1xuICAgICAgICAgICAgICAgICAgICBtZXRob2Q6IFwiY2FsbFwiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGVzdGltYXRlR2FzKHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICB5aWVsZCB0aGlzLmdldE5ldHdvcmsoKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHlpZWxkIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgICAgICB0cmFuc2FjdGlvbjogdGhpcy5fZ2V0VHJhbnNhY3Rpb25SZXF1ZXN0KHRyYW5zYWN0aW9uKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJlc3RpbWF0ZUdhc1wiLCBwYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20ocmVzdWx0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImJhZCByZXN1bHQgZnJvbSBiYWNrZW5kXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZDogXCJlc3RpbWF0ZUdhc1wiLFxuICAgICAgICAgICAgICAgICAgICBwYXJhbXMsIHJlc3VsdCwgZXJyb3JcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9nZXRBZGRyZXNzKGFkZHJlc3NPck5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGFkZHJlc3NPck5hbWUgPSB5aWVsZCBhZGRyZXNzT3JOYW1lO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzc09yTmFtZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhZGRyZXNzIG9yIEVOUyBuYW1lXCIsIFwibmFtZVwiLCBhZGRyZXNzT3JOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLnJlc29sdmVOYW1lKGFkZHJlc3NPck5hbWUpO1xuICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiRU5TIG5hbWUgbm90IGNvbmZpZ3VyZWRcIiwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBgcmVzb2x2ZU5hbWUoJHtKU09OLnN0cmluZ2lmeShhZGRyZXNzT3JOYW1lKX0pYFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZywgaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBibG9ja0hhc2hPckJsb2NrVGFnID0geWllbGQgYmxvY2tIYXNoT3JCbG9ja1RhZztcbiAgICAgICAgICAgIC8vIElmIGJsb2NrVGFnIGlzIGEgbnVtYmVyIChub3QgXCJsYXRlc3RcIiwgZXRjKSwgdGhpcyBpcyB0aGUgYmxvY2sgbnVtYmVyXG4gICAgICAgICAgICBsZXQgYmxvY2tOdW1iZXIgPSAtMTI4O1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0ge1xuICAgICAgICAgICAgICAgIGluY2x1ZGVUcmFuc2FjdGlvbnM6ICEhaW5jbHVkZVRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhibG9ja0hhc2hPckJsb2NrVGFnLCAzMikpIHtcbiAgICAgICAgICAgICAgICBwYXJhbXMuYmxvY2tIYXNoID0gYmxvY2tIYXNoT3JCbG9ja1RhZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5ibG9ja1RhZyA9IHlpZWxkIHRoaXMuX2dldEJsb2NrVGFnKGJsb2NrSGFzaE9yQmxvY2tUYWcpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcocGFyYW1zLmJsb2NrVGFnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSBwYXJzZUludChwYXJhbXMuYmxvY2tUYWcuc3Vic3RyaW5nKDIpLCAxNik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJsb2NrIGhhc2ggb3IgYmxvY2sgdGFnXCIsIFwiYmxvY2tIYXNoT3JCbG9ja1RhZ1wiLCBibG9ja0hhc2hPckJsb2NrVGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gcG9sbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYmxvY2sgPSB5aWVsZCB0aGlzLnBlcmZvcm0oXCJnZXRCbG9ja1wiLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIC8vIEJsb2NrIHdhcyBub3QgZm91bmRcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBGb3IgYmxvY2toYXNoZXMsIGlmIHdlIGRpZG4ndCBzYXkgaXQgZXhpc3RlZCwgdGhhdCBibG9ja2hhc2ggbWF5XG4gICAgICAgICAgICAgICAgICAgIC8vIG5vdCBleGlzdC4gSWYgd2UgZGlkIHNlZSBpdCB0aG91Z2gsIHBlcmhhcHMgZnJvbSBhIGxvZywgd2Uga25vd1xuICAgICAgICAgICAgICAgICAgICAvLyBpdCBleGlzdHMsIGFuZCB0aGlzIG5vZGUgaXMganVzdCBub3QgY2F1Z2h0IHVwIHlldC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja0hhc2ggIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJiOlwiICsgcGFyYW1zLmJsb2NrSGFzaF0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBibG9jayB0YWdzLCBpZiB3ZSBhcmUgYXNraW5nIGZvciBhIGZ1dHVyZSBibG9jaywgd2UgcmV0dXJuIG51bGxcbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPiB0aGlzLl9lbWl0dGVkLmJsb2NrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0cnkgb24gdGhlIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gQWRkIHRyYW5zYWN0aW9uc1xuICAgICAgICAgICAgICAgIGlmIChpbmNsdWRlVHJhbnNhY3Rpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmxvY2sudHJhbnNhY3Rpb25zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IGJsb2NrLnRyYW5zYWN0aW9uc1tpXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHguY29uZmlybWF0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICh0eC5jb25maXJtYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IHlpZWxkIHRoaXMuX2dldEludGVybmFsQmxvY2tOdW1iZXIoMTAwICsgMiAqIHRoaXMucG9sbGluZ0ludGVydmFsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQWRkIHRoZSBjb25maXJtYXRpb25zIHVzaW5nIHRoZSBmYXN0IGJsb2NrIG51bWJlciAocGVzc2ltaXN0aWMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXIgLSB0eC5ibG9ja051bWJlcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25zIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlybWF0aW9ucyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSBjb25maXJtYXRpb25zO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrV2l0aFR4cyA9IHRoaXMuZm9ybWF0dGVyLmJsb2NrV2l0aFRyYW5zYWN0aW9ucyhibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrV2l0aFR4cy50cmFuc2FjdGlvbnMgPSBibG9ja1dpdGhUeHMudHJhbnNhY3Rpb25zLm1hcCgodHgpID0+IHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYmxvY2tXaXRoVHhzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuYmxvY2soYmxvY2spO1xuICAgICAgICAgICAgfSksIHsgb25jZVBvbGw6IHRoaXMgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5fZ2V0QmxvY2soYmxvY2tIYXNoT3JCbG9ja1RhZywgZmFsc2UpKTtcbiAgICB9XG4gICAgZ2V0QmxvY2tXaXRoVHJhbnNhY3Rpb25zKGJsb2NrSGFzaE9yQmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLl9nZXRCbG9jayhibG9ja0hhc2hPckJsb2NrVGFnLCB0cnVlKSk7XG4gICAgfVxuICAgIGdldFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uSGFzaCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkhhc2ggPSB5aWVsZCB0cmFuc2FjdGlvbkhhc2g7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7IHRyYW5zYWN0aW9uSGFzaDogdGhpcy5mb3JtYXR0ZXIuaGFzaCh0cmFuc2FjdGlvbkhhc2gsIHRydWUpIH07XG4gICAgICAgICAgICByZXR1cm4gcG9sbCgoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0VHJhbnNhY3Rpb25cIiwgcGFyYW1zKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX2VtaXR0ZWRbXCJ0OlwiICsgdHJhbnNhY3Rpb25IYXNoXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVzcG9uc2UocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAodHguYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHguY29uZmlybWF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNvbmZpcm1hdGlvbnMgdXNpbmcgdGhlIGZhc3QgYmxvY2sgbnVtYmVyIChwZXNzaW1pc3RpYylcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXIgLSB0eC5ibG9ja051bWJlcikgKyAxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29uZmlybWF0aW9ucyA8PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25maXJtYXRpb25zID0gMTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0eC5jb25maXJtYXRpb25zID0gY29uZmlybWF0aW9ucztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuX3dyYXBUcmFuc2FjdGlvbih0eCk7XG4gICAgICAgICAgICB9KSwgeyBvbmNlUG9sbDogdGhpcyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFRyYW5zYWN0aW9uUmVjZWlwdCh0cmFuc2FjdGlvbkhhc2gpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0TmV0d29yaygpO1xuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoID0geWllbGQgdHJhbnNhY3Rpb25IYXNoO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1zID0geyB0cmFuc2FjdGlvbkhhc2g6IHRoaXMuZm9ybWF0dGVyLmhhc2godHJhbnNhY3Rpb25IYXNoLCB0cnVlKSB9O1xuICAgICAgICAgICAgcmV0dXJuIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHRoaXMucGVyZm9ybShcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiLCBwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fZW1pdHRlZFtcInQ6XCIgKyB0cmFuc2FjdGlvbkhhc2hdID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFwiZ2V0aC1ldGNcIiByZXR1cm5zIHJlY2VpcHRzIGJlZm9yZSB0aGV5IGFyZSByZWFkeVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQuYmxvY2tIYXNoID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcmVjZWlwdCA9IHRoaXMuZm9ybWF0dGVyLnJlY2VpcHQocmVzdWx0KTtcbiAgICAgICAgICAgICAgICBpZiAocmVjZWlwdC5ibG9ja051bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuY29uZmlybWF0aW9ucyA9IDA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlY2VpcHQuY29uZmlybWF0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgICAgICAvLyBBZGQgdGhlIGNvbmZpcm1hdGlvbnMgdXNpbmcgdGhlIGZhc3QgYmxvY2sgbnVtYmVyIChwZXNzaW1pc3RpYylcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbmZpcm1hdGlvbnMgPSAoYmxvY2tOdW1iZXIgLSByZWNlaXB0LmJsb2NrTnVtYmVyKSArIDE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maXJtYXRpb25zIDw9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnMgPSAxO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJlY2VpcHQuY29uZmlybWF0aW9ucyA9IGNvbmZpcm1hdGlvbnM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZWNlaXB0O1xuICAgICAgICAgICAgfSksIHsgb25jZVBvbGw6IHRoaXMgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRMb2dzKGZpbHRlcikge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB5aWVsZCByZXNvbHZlUHJvcGVydGllcyh7IGZpbHRlcjogdGhpcy5fZ2V0RmlsdGVyKGZpbHRlcikgfSk7XG4gICAgICAgICAgICBjb25zdCBsb2dzID0geWllbGQgdGhpcy5wZXJmb3JtKFwiZ2V0TG9nc1wiLCBwYXJhbXMpO1xuICAgICAgICAgICAgbG9ncy5mb3JFYWNoKChsb2cpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobG9nLnJlbW92ZWQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2cucmVtb3ZlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5hcnJheU9mKHRoaXMuZm9ybWF0dGVyLmZpbHRlckxvZy5iaW5kKHRoaXMuZm9ybWF0dGVyKSkobG9ncyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRFdGhlclByaWNlKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgeWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wZXJmb3JtKFwiZ2V0RXRoZXJQcmljZVwiLCB7fSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0QmxvY2tUYWcoYmxvY2tUYWcpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGJsb2NrVGFnID0geWllbGQgYmxvY2tUYWc7XG4gICAgICAgICAgICBpZiAodHlwZW9mIChibG9ja1RhZykgPT09IFwibnVtYmVyXCIgJiYgYmxvY2tUYWcgPCAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGJsb2NrVGFnICUgMSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBCbG9ja1RhZ1wiLCBcImJsb2NrVGFnXCIsIGJsb2NrVGFnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGV0IGJsb2NrTnVtYmVyID0geWllbGQgdGhpcy5fZ2V0SW50ZXJuYWxCbG9ja051bWJlcigxMDAgKyAyICogdGhpcy5wb2xsaW5nSW50ZXJ2YWwpO1xuICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyICs9IGJsb2NrVGFnO1xuICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA8IDApIHtcbiAgICAgICAgICAgICAgICAgICAgYmxvY2tOdW1iZXIgPSAwO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mb3JtYXR0ZXIuYmxvY2tUYWcoYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmJsb2NrVGFnKGJsb2NrVGFnKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldFJlc29sdmVyKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuX2dldFJlc29sdmVyKG5hbWUpO1xuICAgICAgICAgICAgICAgIGlmIChhZGRyZXNzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgUmVzb2x2ZXIodGhpcywgYWRkcmVzcywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfZ2V0UmVzb2x2ZXIobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gR2V0IHRoZSByZXNvbHZlciBmcm9tIHRoZSBibG9ja2NoYWluXG4gICAgICAgICAgICBjb25zdCBuZXR3b3JrID0geWllbGQgdGhpcy5nZXROZXR3b3JrKCk7XG4gICAgICAgICAgICAvLyBObyBFTlMuLi5cbiAgICAgICAgICAgIGlmICghbmV0d29yay5lbnNBZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJuZXR3b3JrIGRvZXMgbm90IHN1cHBvcnQgRU5TXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJFTlNcIiwgbmV0d29yazogbmV0d29yay5uYW1lIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VjY2FrMjU2KFwicmVzb2x2ZXIoYnl0ZXMzMilcIilcbiAgICAgICAgICAgIGNvbnN0IHRyYW5zYWN0aW9uID0ge1xuICAgICAgICAgICAgICAgIHRvOiBuZXR3b3JrLmVuc0FkZHJlc3MsXG4gICAgICAgICAgICAgICAgZGF0YTogKFwiMHgwMTc4YjhiZlwiICsgbmFtZWhhc2gobmFtZSkuc3Vic3RyaW5nKDIpKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0dGVyLmNhbGxBZGRyZXNzKHlpZWxkIHRoaXMuY2FsbCh0cmFuc2FjdGlvbikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04pIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgcmVzb2x2ZU5hbWUobmFtZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgbmFtZSA9IHlpZWxkIG5hbWU7XG4gICAgICAgICAgICAvLyBJZiBpdCBpcyBhbHJlYWR5IGFuIGFkZHJlc3MsIG5vdGhpbmcgdG8gcmVzb2x2ZVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRoaXMuZm9ybWF0dGVyLmFkZHJlc3MobmFtZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgaXMgaXMgYSBoZXhzdHJpbmcsIHRoZSBhZGRyZXNzIGlzIGJhZCAoU2VlICM2OTQpXG4gICAgICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKG5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgKG5hbWUpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgRU5TIG5hbWVcIiwgXCJuYW1lXCIsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBhZGRyIGZyb20gdGhlIHJlc292bGVyXG4gICAgICAgICAgICBjb25zdCByZXNvbHZlciA9IHlpZWxkIHRoaXMuZ2V0UmVzb2x2ZXIobmFtZSk7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4geWllbGQgcmVzb2x2ZXIuZ2V0QWRkcmVzcygpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgbG9va3VwQWRkcmVzcyhhZGRyZXNzKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBhZGRyZXNzID0geWllbGQgYWRkcmVzcztcbiAgICAgICAgICAgIGFkZHJlc3MgPSB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKGFkZHJlc3MpO1xuICAgICAgICAgICAgY29uc3QgcmV2ZXJzZU5hbWUgPSBhZGRyZXNzLnN1YnN0cmluZygyKS50b0xvd2VyQ2FzZSgpICsgXCIuYWRkci5yZXZlcnNlXCI7XG4gICAgICAgICAgICBjb25zdCByZXNvbHZlckFkZHJlc3MgPSB5aWVsZCB0aGlzLl9nZXRSZXNvbHZlcihyZXZlcnNlTmFtZSk7XG4gICAgICAgICAgICBpZiAoIXJlc29sdmVyQWRkcmVzcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8ga2VjY2FrKFwibmFtZShieXRlczMyKVwiKVxuICAgICAgICAgICAgbGV0IGJ5dGVzID0gYXJyYXlpZnkoeWllbGQgdGhpcy5jYWxsKHtcbiAgICAgICAgICAgICAgICB0bzogcmVzb2x2ZXJBZGRyZXNzLFxuICAgICAgICAgICAgICAgIGRhdGE6IChcIjB4NjkxZjM0MzFcIiArIG5hbWVoYXNoKHJldmVyc2VOYW1lKS5zdWJzdHJpbmcoMikpXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAvLyBTdHJpcCBvZmYgdGhlIGR5bmFtaWMgc3RyaW5nIHBvaW50ZXIgKDB4MjApXG4gICAgICAgICAgICBpZiAoYnl0ZXMubGVuZ3RoIDwgMzIgfHwgIUJpZ051bWJlci5mcm9tKGJ5dGVzLnNsaWNlKDAsIDMyKSkuZXEoMzIpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBieXRlcyA9IGJ5dGVzLnNsaWNlKDMyKTtcbiAgICAgICAgICAgIC8vIE5vdCBhIGxlbmd0aC1wcmVmaXhlZCBzdHJpbmdcbiAgICAgICAgICAgIGlmIChieXRlcy5sZW5ndGggPCAzMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gR2V0IHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZyAoZnJvbSB0aGUgbGVuZ3RoLXByZWZpeClcbiAgICAgICAgICAgIGNvbnN0IGxlbmd0aCA9IEJpZ051bWJlci5mcm9tKGJ5dGVzLnNsaWNlKDAsIDMyKSkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIGJ5dGVzID0gYnl0ZXMuc2xpY2UoMzIpO1xuICAgICAgICAgICAgLy8gTGVuZ3RoIGxvbmdlciB0aGFuIGF2YWlsYWJsZSBkYXRhXG4gICAgICAgICAgICBpZiAobGVuZ3RoID4gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBuYW1lID0gdG9VdGY4U3RyaW5nKGJ5dGVzLnNsaWNlKDAsIGxlbmd0aCkpO1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSByZXZlcnNlIHJlY29yZCBtYXRjaGVzIHRoZSBmb3dhcmQgcmVjb3JkXG4gICAgICAgICAgICBjb25zdCBhZGRyID0geWllbGQgdGhpcy5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChhZGRyICE9IGFkZHJlc3MpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuYW1lO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0QXZhdGFyKG5hbWVPckFkZHJlc3MpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCByZXNvbHZlciA9IG51bGw7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcobmFtZU9yQWRkcmVzcykpIHtcbiAgICAgICAgICAgICAgICAvLyBBZGRyZXNzOyByZXZlcnNlIGxvb2t1cFxuICAgICAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB0aGlzLmZvcm1hdHRlci5hZGRyZXNzKG5hbWVPckFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJldmVyc2VOYW1lID0gYWRkcmVzcy5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKSArIFwiLmFkZHIucmV2ZXJzZVwiO1xuICAgICAgICAgICAgICAgIGNvbnN0IHJlc29sdmVyQWRkcmVzcyA9IHlpZWxkIHRoaXMuX2dldFJlc29sdmVyKHJldmVyc2VOYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIXJlc29sdmVyQWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVzb2x2ZXIgPSBuZXcgUmVzb2x2ZXIodGhpcywgcmVzb2x2ZXJBZGRyZXNzLCBcIl9cIiwgYWRkcmVzcyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBFTlMgbmFtZTsgZm9yd2FyZCBsb29rdXBcbiAgICAgICAgICAgICAgICByZXNvbHZlciA9IHlpZWxkIHRoaXMuZ2V0UmVzb2x2ZXIobmFtZU9yQWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgaWYgKCFyZXNvbHZlcikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhdmF0YXIgPSB5aWVsZCByZXNvbHZlci5nZXRBdmF0YXIoKTtcbiAgICAgICAgICAgIGlmIChhdmF0YXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGF2YXRhci51cmw7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBwZXJmb3JtKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihtZXRob2QgKyBcIiBub3QgaW1wbGVtZW50ZWRcIiwgTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHsgb3BlcmF0aW9uOiBtZXRob2QgfSk7XG4gICAgfVxuICAgIF9zdGFydEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMucG9sbGluZyA9ICh0aGlzLl9ldmVudHMuZmlsdGVyKChlKSA9PiBlLnBvbGxhYmxlKCkpLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICBfc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIHRoaXMucG9sbGluZyA9ICh0aGlzLl9ldmVudHMuZmlsdGVyKChlKSA9PiBlLnBvbGxhYmxlKCkpLmxlbmd0aCA+IDApO1xuICAgIH1cbiAgICBfYWRkRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGxpc3RlbmVyLCBvbmNlKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50ID0gbmV3IEV2ZW50KGdldEV2ZW50VGFnKGV2ZW50TmFtZSksIGxpc3RlbmVyLCBvbmNlKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzLnB1c2goZXZlbnQpO1xuICAgICAgICB0aGlzLl9zdGFydEV2ZW50KGV2ZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICAgIG9uKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgZmFsc2UpO1xuICAgIH1cbiAgICBvbmNlKGV2ZW50TmFtZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBsaXN0ZW5lciwgdHJ1ZSk7XG4gICAgfVxuICAgIGVtaXQoZXZlbnROYW1lLCAuLi5hcmdzKSB7XG4gICAgICAgIGxldCByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgbGV0IHN0b3BwZWQgPSBbXTtcbiAgICAgICAgbGV0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBldmVudC5saXN0ZW5lci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgcmVzdWx0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGlmIChldmVudC5vbmNlKSB7XG4gICAgICAgICAgICAgICAgc3RvcHBlZC5wdXNoKGV2ZW50KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSk7XG4gICAgICAgIHN0b3BwZWQuZm9yRWFjaCgoZXZlbnQpID0+IHsgdGhpcy5fc3RvcEV2ZW50KGV2ZW50KTsgfSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIGxpc3RlbmVyQ291bnQoZXZlbnROYW1lKSB7XG4gICAgICAgIGlmICghZXZlbnROYW1lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZXZlbnRUYWcgPSBnZXRFdmVudFRhZyhldmVudE5hbWUpO1xuICAgICAgICByZXR1cm4gdGhpcy5fZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoZXZlbnQudGFnID09PSBldmVudFRhZyk7XG4gICAgICAgIH0pLmxlbmd0aDtcbiAgICB9XG4gICAgbGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9ldmVudHMubWFwKChldmVudCkgPT4gZXZlbnQubGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGxldCBldmVudFRhZyA9IGdldEV2ZW50VGFnKGV2ZW50TmFtZSk7XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudHNcbiAgICAgICAgICAgIC5maWx0ZXIoKGV2ZW50KSA9PiAoZXZlbnQudGFnID09PSBldmVudFRhZykpXG4gICAgICAgICAgICAubWFwKChldmVudCkgPT4gZXZlbnQubGlzdGVuZXIpO1xuICAgIH1cbiAgICBvZmYoZXZlbnROYW1lLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAobGlzdGVuZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RvcHBlZCA9IFtdO1xuICAgICAgICBsZXQgZm91bmQgPSBmYWxzZTtcbiAgICAgICAgbGV0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgdGhpcy5fZXZlbnRzID0gdGhpcy5fZXZlbnRzLmZpbHRlcigoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmIChldmVudC50YWcgIT09IGV2ZW50VGFnIHx8IGV2ZW50Lmxpc3RlbmVyICE9IGxpc3RlbmVyKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZm91bmQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGZvdW5kID0gdHJ1ZTtcbiAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBzdG9wcGVkLmZvckVhY2goKGV2ZW50KSA9PiB7IHRoaXMuX3N0b3BFdmVudChldmVudCk7IH0pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gICAgcmVtb3ZlQWxsTGlzdGVuZXJzKGV2ZW50TmFtZSkge1xuICAgICAgICBsZXQgc3RvcHBlZCA9IFtdO1xuICAgICAgICBpZiAoZXZlbnROYW1lID09IG51bGwpIHtcbiAgICAgICAgICAgIHN0b3BwZWQgPSB0aGlzLl9ldmVudHM7XG4gICAgICAgICAgICB0aGlzLl9ldmVudHMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGV2ZW50VGFnID0gZ2V0RXZlbnRUYWcoZXZlbnROYW1lKTtcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50cyA9IHRoaXMuX2V2ZW50cy5maWx0ZXIoKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50LnRhZyAhPT0gZXZlbnRUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHN0b3BwZWQucHVzaChldmVudCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3RvcHBlZC5mb3JFYWNoKChldmVudCkgPT4geyB0aGlzLl9zdG9wRXZlbnQoZXZlbnQpOyB9KTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YmFzZS1wcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgVXJsSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vdXJsLWpzb24tcnBjLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgY2xhc3MgQ2xvdWRmbGFyZVByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSkge1xuICAgICAgICBpZiAoYXBpS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhcGlLZXkgbm90IHN1cHBvcnRlZCBmb3IgY2xvdWRmbGFyZVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBzdGF0aWMgZ2V0VXJsKG5ldHdvcmssIGFwaUtleSkge1xuICAgICAgICBsZXQgaG9zdCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAobmV0d29yay5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9jbG91ZGZsYXJlLWV0aC5jb20vXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBhcmd1bWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBob3N0O1xuICAgIH1cbiAgICBwZXJmb3JtKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgcGVyZm9ybTogeyBnZXQ6ICgpID0+IHN1cGVyLnBlcmZvcm0gfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoZSBDbG91ZGZsYXJlIHByb3ZpZGVyIGRvZXMgbm90IHN1cHBvcnQgZXRoX2Jsb2NrTnVtYmVyLFxuICAgICAgICAgICAgLy8gc28gd2UgZ2V0IHRoZSBsYXRlc3QgYmxvY2sgYW5kIHB1bGwgaXQgZnJvbSB0aGF0XG4gICAgICAgICAgICBpZiAobWV0aG9kID09PSBcImdldEJsb2NrTnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBibG9jayA9IHlpZWxkIF9zdXBlci5wZXJmb3JtLmNhbGwodGhpcywgXCJnZXRCbG9ja1wiLCB7IGJsb2NrVGFnOiBcImxhdGVzdFwiIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybiBibG9jay5udW1iZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gX3N1cGVyLnBlcmZvcm0uY2FsbCh0aGlzLCBtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNsb3VkZmxhcmUtcHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGhleGxpZnksIGhleFZhbHVlLCBpc0hleFN0cmluZyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgZGVlcENvcHksIGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBmZXRjaEpzb24gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvd2ViXCI7XG5pbXBvcnQgeyBzaG93VGhyb3R0bGVNZXNzYWdlIH0gZnJvbSBcIi4vZm9ybWF0dGVyXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5pbXBvcnQgeyBCYXNlUHJvdmlkZXIgfSBmcm9tIFwiLi9iYXNlLXByb3ZpZGVyXCI7XG4vLyBUaGUgdHJhbnNhY3Rpb24gaGFzIGFscmVhZHkgYmVlbiBzYW5pdGl6ZWQgYnkgdGhlIGNhbGxzIGluIFByb3ZpZGVyXG5mdW5jdGlvbiBnZXRUcmFuc2FjdGlvblBvc3REYXRhKHRyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgZm9yIChsZXQga2V5IGluIHRyYW5zYWN0aW9uKSB7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB2YWx1ZSA9IHRyYW5zYWN0aW9uW2tleV07XG4gICAgICAgIGlmIChrZXkgPT09IFwidHlwZVwiICYmIHZhbHVlID09PSAwKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBRdWFudGl0eS10eXBlcyByZXF1aXJlIG5vIGxlYWRpbmcgemVybywgdW5sZXNzIDBcbiAgICAgICAgaWYgKHsgdHlwZTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBtYXhGZWVQZXJHczogdHJ1ZSwgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IHRydWUsIG5vbmNlOiB0cnVlLCB2YWx1ZTogdHJ1ZSB9W2tleV0pIHtcbiAgICAgICAgICAgIHZhbHVlID0gaGV4VmFsdWUoaGV4bGlmeSh2YWx1ZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gXCJhY2Nlc3NMaXN0XCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gXCJbXCIgKyBhY2Nlc3NMaXN0aWZ5KHZhbHVlKS5tYXAoKHNldCkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBge2FkZHJlc3M6XCIke3NldC5hZGRyZXNzfVwiLHN0b3JhZ2VLZXlzOltcIiR7c2V0LnN0b3JhZ2VLZXlzLmpvaW4oJ1wiLFwiJyl9XCJdfWA7XG4gICAgICAgICAgICB9KS5qb2luKFwiLFwiKSArIFwiXVwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFsdWUgPSBoZXhsaWZ5KHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0UmVzdWx0KHJlc3VsdCkge1xuICAgIC8vIGdldExvZ3MsIGdldEhpc3RvcnkgaGF2ZSB3ZWlyZCBzdWNjZXNzIHJlc3BvbnNlc1xuICAgIGlmIChyZXN1bHQuc3RhdHVzID09IDAgJiYgKHJlc3VsdC5tZXNzYWdlID09PSBcIk5vIHJlY29yZHMgZm91bmRcIiB8fCByZXN1bHQubWVzc2FnZSA9PT0gXCJObyB0cmFuc2FjdGlvbnMgZm91bmRcIikpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5yZXN1bHQ7XG4gICAgfVxuICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IDEgfHwgcmVzdWx0Lm1lc3NhZ2UgIT0gXCJPS1wiKSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiaW52YWxpZCByZXNwb25zZVwiKTtcbiAgICAgICAgZXJyb3IucmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgaWYgKChyZXN1bHQucmVzdWx0IHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInJhdGUgbGltaXRcIikgPj0gMCkge1xuICAgICAgICAgICAgZXJyb3IudGhyb3R0bGVSZXRyeSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0SnNvblJlc3VsdChyZXN1bHQpIHtcbiAgICAvLyBUaGlzIHJlc3BvbnNlIGluZGljYXRlcyB3ZSBhcmUgYmVpbmcgdGhyb3R0bGVkXG4gICAgaWYgKHJlc3VsdCAmJiByZXN1bHQuc3RhdHVzID09IDAgJiYgcmVzdWx0Lm1lc3NhZ2UgPT0gXCJOT1RPS1wiICYmIChyZXN1bHQucmVzdWx0IHx8IFwiXCIpLnRvTG93ZXJDYXNlKCkuaW5kZXhPZihcInJhdGUgbGltaXRcIikgPj0gMCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcInRocm90dGxlZCByZXNwb25zZVwiKTtcbiAgICAgICAgZXJyb3IucmVzdWx0ID0gSlNPTi5zdHJpbmdpZnkocmVzdWx0KTtcbiAgICAgICAgZXJyb3IudGhyb3R0bGVSZXRyeSA9IHRydWU7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAocmVzdWx0Lmpzb25ycGMgIT0gXCIyLjBcIikge1xuICAgICAgICAvLyBAVE9ETzogbm90IGFueVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihcImludmFsaWQgcmVzcG9uc2VcIik7XG4gICAgICAgIGVycm9yLnJlc3VsdCA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdCk7XG4gICAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgIC8vIEBUT0RPOiBub3QgYW55XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHJlc3VsdC5lcnJvci5tZXNzYWdlIHx8IFwidW5rbm93biBlcnJvclwiKTtcbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvci5jb2RlKSB7XG4gICAgICAgICAgICBlcnJvci5jb2RlID0gcmVzdWx0LmVycm9yLmNvZGU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdC5lcnJvci5kYXRhKSB7XG4gICAgICAgICAgICBlcnJvci5kYXRhID0gcmVzdWx0LmVycm9yLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQucmVzdWx0O1xufVxuLy8gVGhlIGJsb2NrVGFnIHdhcyBub3JtYWxpemVkIGFzIGEgc3RyaW5nIGJ5IHRoZSBQcm92aWRlciBwcmUtcGVyZm9ybSBvcGVyYXRpb25zXG5mdW5jdGlvbiBjaGVja0xvZ1RhZyhibG9ja1RhZykge1xuICAgIGlmIChibG9ja1RhZyA9PT0gXCJwZW5kaW5nXCIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwicGVuZGluZyBub3Qgc3VwcG9ydGVkXCIpO1xuICAgIH1cbiAgICBpZiAoYmxvY2tUYWcgPT09IFwibGF0ZXN0XCIpIHtcbiAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgIH1cbiAgICByZXR1cm4gcGFyc2VJbnQoYmxvY2tUYWcuc3Vic3RyaW5nKDIpLCAxNik7XG59XG5jb25zdCBkZWZhdWx0QXBpS2V5ID0gXCI5RDEzWkU3WFNCVEo5NE45Qk5KMk1BMzNWTUFZMllQSVJCXCI7XG5mdW5jdGlvbiBjaGVja0Vycm9yKG1ldGhvZCwgZXJyb3IsIHRyYW5zYWN0aW9uKSB7XG4gICAgLy8gVW5kbyB0aGUgXCJjb252ZW5pZW5jZVwiIHNvbWUgbm9kZXMgYXJlIGF0dGVtcHRpbmcgdG8gcHJldmVudCBiYWNrd2FyZHNcbiAgICAvLyBpbmNvbXBhdGliaWxpdHk7IG1heWJlIGZvciB2NiBjb25zaWRlciBmb3J3YXJkaW5nIHJldmVydHMgYXMgZXJyb3JzXG4gICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIgJiYgZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IpIHtcbiAgICAgICAgY29uc3QgZSA9IGVycm9yLmVycm9yO1xuICAgICAgICAvLyBFdGhlcnNjYW4ga2VlcHMgY2hhbmdpbmcgdGhlaXIgc3RyaW5nXG4gICAgICAgIGlmIChlICYmIChlLm1lc3NhZ2UubWF0Y2goL3JldmVydGVkL2kpIHx8IGUubWVzc2FnZS5tYXRjaCgvVk0gZXhlY3V0aW9uIGVycm9yL2kpKSkge1xuICAgICAgICAgICAgLy8gRXRoZXJzY2FuIHByZWZpeGVzIHRoZSBkYXRhIGxpa2UgXCJSZXZlcnRlZCAweDEyMzRcIlxuICAgICAgICAgICAgbGV0IGRhdGEgPSBlLmRhdGE7XG4gICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgIGRhdGEgPSBcIjB4XCIgKyBkYXRhLnJlcGxhY2UoL14uKjB4L2ksIFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGlzSGV4U3RyaW5nKGRhdGEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm1pc3NpbmcgcmV2ZXJ0IGRhdGEgaW4gY2FsbCBleGNlcHRpb25cIiwgTG9nZ2VyLmVycm9ycy5DQUxMX0VYQ0VQVElPTiwge1xuICAgICAgICAgICAgICAgIGVycm9yLCBkYXRhOiBcIjB4XCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIEdldCB0aGUgbWVzc2FnZSBmcm9tIGFueSBuZXN0ZWQgZXJyb3Igc3RydWN0dXJlXG4gICAgbGV0IG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIGlmIChlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUikge1xuICAgICAgICBpZiAoZXJyb3IuZXJyb3IgJiYgdHlwZW9mIChlcnJvci5lcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLmVycm9yLm1lc3NhZ2U7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChlcnJvci5ib2R5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgbWVzc2FnZSA9IGVycm9yLmJvZHk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIChlcnJvci5yZXNwb25zZVRleHQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBtZXNzYWdlID0gZXJyb3IucmVzcG9uc2VUZXh0O1xuICAgICAgICB9XG4gICAgfVxuICAgIG1lc3NhZ2UgPSAobWVzc2FnZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIFwiSW5zdWZmaWNpZW50IGZ1bmRzLiBUaGUgYWNjb3VudCB5b3UgdHJpZWQgdG8gc2VuZCB0cmFuc2FjdGlvbiBmcm9tIGRvZXMgbm90IGhhdmUgZW5vdWdoIGZ1bmRzLiBSZXF1aXJlZCAyMTQ2NDAwMDAwMDAwMCBhbmQgZ290OiAwXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvaW5zdWZmaWNpZW50IGZ1bmRzLykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnN1ZmZpY2llbnQgZnVuZHMgZm9yIGludHJpbnNpYyB0cmFuc2FjdGlvbiBjb3N0XCIsIExvZ2dlci5lcnJvcnMuSU5TVUZGSUNJRU5UX0ZVTkRTLCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJUcmFuc2FjdGlvbiB3aXRoIHRoZSBzYW1lIGhhc2ggd2FzIGFscmVhZHkgaW1wb3J0ZWQuXCJcbiAgICBpZiAobWVzc2FnZS5tYXRjaCgvc2FtZSBoYXNoIHdhcyBhbHJlYWR5IGltcG9ydGVkfHRyYW5zYWN0aW9uIG5vbmNlIGlzIHRvbyBsb3d8bm9uY2UgdG9vIGxvdy8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibm9uY2UgaGFzIGFscmVhZHkgYmVlbiB1c2VkXCIsIExvZ2dlci5lcnJvcnMuTk9OQ0VfRVhQSVJFRCwge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFwiVHJhbnNhY3Rpb24gZ2FzIHByaWNlIGlzIHRvbyBsb3cuIFRoZXJlIGlzIGFub3RoZXIgdHJhbnNhY3Rpb24gd2l0aCBzYW1lIG5vbmNlIGluIHRoZSBxdWV1ZS4gVHJ5IGluY3JlYXNpbmcgdGhlIGdhcyBwcmljZSBvciBpbmNyZW1lbnRpbmcgdGhlIG5vbmNlLlwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL2Fub3RoZXIgdHJhbnNhY3Rpb24gd2l0aCBzYW1lIG5vbmNlLykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBMb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL2V4ZWN1dGlvbiBmYWlsZWQgZHVlIHRvIGFuIGV4Y2VwdGlvbnxleGVjdXRpb24gcmV2ZXJ0ZWQvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIiwgTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xufVxuZXhwb3J0IGNsYXNzIEV0aGVyc2NhblByb3ZpZGVyIGV4dGVuZHMgQmFzZVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KG5ldy50YXJnZXQsIEV0aGVyc2NhblByb3ZpZGVyKTtcbiAgICAgICAgc3VwZXIobmV0d29yayk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYmFzZVVybFwiLCB0aGlzLmdldEJhc2VVcmwoKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYXBpS2V5XCIsIGFwaUtleSB8fCBkZWZhdWx0QXBpS2V5KTtcbiAgICB9XG4gICAgZ2V0QmFzZVVybCgpIHtcbiAgICAgICAgc3dpdGNoICh0aGlzLm5ldHdvcmsgPyB0aGlzLm5ldHdvcmsubmFtZSA6IFwiaW52YWxpZFwiKSB7XG4gICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS5ldGhlcnNjYW4uaW9cIjtcbiAgICAgICAgICAgIGNhc2UgXCJyb3BzdGVuXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiaHR0cHM6L1xcL2FwaS1yb3BzdGVuLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcInJpbmtlYnlcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLXJpbmtlYnkuZXRoZXJzY2FuLmlvXCI7XG4gICAgICAgICAgICBjYXNlIFwia292YW5cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gXCJodHRwczovXFwvYXBpLWtvdmFuLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBcImh0dHBzOi9cXC9hcGktZ29lcmxpLmV0aGVyc2Nhbi5pb1wiO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIG5ldHdvcmtcIiwgXCJuZXR3b3JrXCIsIG5hbWUpO1xuICAgIH1cbiAgICBnZXRVcmwobW9kdWxlLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcXVlcnkgPSBPYmplY3Qua2V5cyhwYXJhbXMpLnJlZHVjZSgoYWNjdW0sIGtleSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBwYXJhbXNba2V5XTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgYWNjdW0gKz0gYCYke2tleX09JHt2YWx1ZX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICB9LCBcIlwiKTtcbiAgICAgICAgY29uc3QgYXBpS2V5ID0gKCh0aGlzLmFwaUtleSkgPyBgJmFwaWtleT0ke3RoaXMuYXBpS2V5fWAgOiBcIlwiKTtcbiAgICAgICAgcmV0dXJuIGAke3RoaXMuYmFzZVVybH0vYXBpP21vZHVsZT0ke21vZHVsZX0ke3F1ZXJ5fSR7YXBpS2V5fWA7XG4gICAgfVxuICAgIGdldFBvc3RVcmwoKSB7XG4gICAgICAgIHJldHVybiBgJHt0aGlzLmJhc2VVcmx9L2FwaWA7XG4gICAgfVxuICAgIGdldFBvc3REYXRhKG1vZHVsZSwgcGFyYW1zKSB7XG4gICAgICAgIHBhcmFtcy5tb2R1bGUgPSBtb2R1bGU7XG4gICAgICAgIHBhcmFtcy5hcGlrZXkgPSB0aGlzLmFwaUtleTtcbiAgICAgICAgcmV0dXJuIHBhcmFtcztcbiAgICB9XG4gICAgZmV0Y2gobW9kdWxlLCBwYXJhbXMsIHBvc3QpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IChwb3N0ID8gdGhpcy5nZXRQb3N0VXJsKCkgOiB0aGlzLmdldFVybChtb2R1bGUsIHBhcmFtcykpO1xuICAgICAgICAgICAgY29uc3QgcGF5bG9hZCA9IChwb3N0ID8gdGhpcy5nZXRQb3N0RGF0YShtb2R1bGUsIHBhcmFtcykgOiBudWxsKTtcbiAgICAgICAgICAgIGNvbnN0IHByb2NGdW5jID0gKG1vZHVsZSA9PT0gXCJwcm94eVwiKSA/IGdldEpzb25SZXN1bHQgOiBnZXRSZXN1bHQ7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiB1cmwsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHtcbiAgICAgICAgICAgICAgICB1cmw6IHVybCxcbiAgICAgICAgICAgICAgICB0aHJvdHRsZVNsb3RJbnRlcnZhbDogMTAwMCxcbiAgICAgICAgICAgICAgICB0aHJvdHRsZUNhbGxiYWNrOiAoYXR0ZW1wdCwgdXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmlzQ29tbXVuaXR5UmVzb3VyY2UoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2hvd1Rocm90dGxlTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGxldCBwYXlsb2FkU3RyID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChwYXlsb2FkKSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbi5oZWFkZXJzID0geyBcImNvbnRlbnQtdHlwZVwiOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiIH07XG4gICAgICAgICAgICAgICAgcGF5bG9hZFN0ciA9IE9iamVjdC5rZXlzKHBheWxvYWQpLm1hcCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBgJHtrZXl9PSR7cGF5bG9hZFtrZXldfWA7XG4gICAgICAgICAgICAgICAgfSkuam9pbihcIiZcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBmZXRjaEpzb24oY29ubmVjdGlvbiwgcGF5bG9hZFN0ciwgcHJvY0Z1bmMgfHwgZ2V0SnNvblJlc3VsdCk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdDogdXJsLFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiBkZWVwQ29weShyZXN1bHQpLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXRlY3ROZXR3b3JrKCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV0d29yaztcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBlcmZvcm0obWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgX3N1cGVyID0gT2JqZWN0LmNyZWF0ZShudWxsLCB7XG4gICAgICAgICAgICBwZXJmb3JtOiB7IGdldDogKCkgPT4gc3VwZXIucGVyZm9ybSB9XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7IGFjdGlvbjogXCJldGhfYmxvY2tOdW1iZXJcIiB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7IGFjdGlvbjogXCJldGhfZ2FzUHJpY2VcIiB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgICAgICAvLyBSZXR1cm5zIGJhc2UtMTAgcmVzdWx0XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwiYWNjb3VudFwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiYmFsYW5jZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHBhcmFtcy5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHBhcmFtcy5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0Q29kZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgYWRkcmVzczogcGFyYW1zLmFkZHJlc3MsXG4gICAgICAgICAgICAgICAgICAgICAgICB0YWc6IHBhcmFtcy5ibG9ja1RhZ1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZUF0XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcImV0aF9nZXRTdG9yYWdlQXRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGFkZHJlc3M6IHBhcmFtcy5hZGRyZXNzLFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IHBhcmFtcy5wb3NpdGlvbixcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcGFyYW1zLmJsb2NrVGFnXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJzZW5kVHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX3NlbmRSYXdUcmFuc2FjdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGV4OiBwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgfSwgdHJ1ZSkuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2tFcnJvcihcInNlbmRUcmFuc2FjdGlvblwiLCBlcnJvciwgcGFyYW1zLnNpZ25lZFRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZldGNoKFwicHJveHlcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0QmxvY2tCeU51bWJlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRhZzogcGFyYW1zLmJsb2NrVGFnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvb2xlYW46IChwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9ucyA/IFwidHJ1ZVwiIDogXCJmYWxzZVwiKVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2V0QmxvY2sgYnkgYmxvY2tIYXNoIG5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZmV0Y2goXCJwcm94eVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eGhhc2g6IHBhcmFtcy50cmFuc2FjdGlvbkhhc2hcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5mZXRjaChcInByb3h5XCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJldGhfZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0eGhhc2g6IHBhcmFtcy50cmFuc2FjdGlvbkhhc2hcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcImNhbGxcIjoge1xuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICE9PSBcImxhdGVzdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFdGhlcnNjYW5Qcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IGJsb2NrVGFnIGZvciBjYWxsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3REYXRhID0gZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YShwYXJhbXMudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBwb3N0RGF0YS5tb2R1bGUgPSBcInByb3h5XCI7XG4gICAgICAgICAgICAgICAgICAgIHBvc3REYXRhLmFjdGlvbiA9IFwiZXRoX2NhbGxcIjtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLmZldGNoKFwicHJveHlcIiwgcG9zdERhdGEsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrRXJyb3IoXCJjYWxsXCIsIGVycm9yLCBwYXJhbXMudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJlc3RpbWF0ZUdhc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHBvc3REYXRhID0gZ2V0VHJhbnNhY3Rpb25Qb3N0RGF0YShwYXJhbXMudHJhbnNhY3Rpb24pO1xuICAgICAgICAgICAgICAgICAgICBwb3N0RGF0YS5tb2R1bGUgPSBcInByb3h5XCI7XG4gICAgICAgICAgICAgICAgICAgIHBvc3REYXRhLmFjdGlvbiA9IFwiZXRoX2VzdGltYXRlR2FzXCI7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5mZXRjaChcInByb3h5XCIsIHBvc3REYXRhLCB0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKFwiZXN0aW1hdGVHYXNcIiwgZXJyb3IsIHBhcmFtcy50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcImdldExvZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBhcmdzID0geyBhY3Rpb246IFwiZ2V0TG9nc1wiIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyLmZyb21CbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy5mcm9tQmxvY2sgPSBjaGVja0xvZ1RhZyhwYXJhbXMuZmlsdGVyLmZyb21CbG9jayk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIudG9CbG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJncy50b0Jsb2NrID0gY2hlY2tMb2dUYWcocGFyYW1zLmZpbHRlci50b0Jsb2NrKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzLmFkZHJlc3MgPSBwYXJhbXMuZmlsdGVyLmFkZHJlc3M7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFdlIGNhbiBoYW5kbGUgc2xpZ2h0bHkgbW9yZSBjb21wbGljYXRlZCBsb2dzIHVzaW5nIHRoZSBsb2dzIEFQSVxuICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MgJiYgcGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5maWx0ZXIudG9waWNzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHRvcGljIGNvdW50XCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IHRvcGljczogcGFyYW1zLmZpbHRlci50b3BpY3MgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmZpbHRlci50b3BpY3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9waWMwID0gcGFyYW1zLmZpbHRlci50b3BpY3NbMF07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAodG9waWMwKSAhPT0gXCJzdHJpbmdcIiB8fCB0b3BpYzAubGVuZ3RoICE9PSA2Nikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVuc3VwcG9ydGVkIHRvcGljIGZvcm1hdFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwgeyB0b3BpYzA6IHRvcGljMCB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJncy50b3BpYzAgPSB0b3BpYzA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgY29uc3QgbG9ncyA9IHlpZWxkIHRoaXMuZmV0Y2goXCJsb2dzXCIsIGFyZ3MpO1xuICAgICAgICAgICAgICAgICAgICAvLyBDYWNoZSB0eEhhc2ggPT4gYmxvY2tIYXNoXG4gICAgICAgICAgICAgICAgICAgIGxldCBibG9ja3MgPSB7fTtcbiAgICAgICAgICAgICAgICAgICAgLy8gQWRkIGFueSBtaXNzaW5nIGJsb2NrSGFzaCB0byB0aGUgbG9nc1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxvZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvZyA9IGxvZ3NbaV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAobG9nLmJsb2NrSGFzaCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2tzW2xvZy5ibG9ja051bWJlcl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrID0geWllbGQgdGhpcy5nZXRCbG9jayhsb2cuYmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChibG9jaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBibG9ja3NbbG9nLmJsb2NrTnVtYmVyXSA9IGJsb2NrLmhhc2g7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgbG9nLmJsb2NrSGFzaCA9IGJsb2Nrc1tsb2cuYmxvY2tOdW1iZXJdO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZ2V0RXRoZXJQcmljZVwiOlxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXR3b3JrLm5hbWUgIT09IFwiaG9tZXN0ZWFkXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAwLjA7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHBhcnNlRmxvYXQoKHlpZWxkIHRoaXMuZmV0Y2goXCJzdGF0c1wiLCB7IGFjdGlvbjogXCJldGhwcmljZVwiIH0pKS5ldGh1c2QpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIF9zdXBlci5wZXJmb3JtLmNhbGwodGhpcywgbWV0aG9kLCBwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gTm90ZTogVGhlIGBwYWdlYCBwYWdlIHBhcmFtZXRlciBvbmx5IGFsbG93cyBwYWdpbmF0aW9uIHdpdGhpbiB0aGVcbiAgICAvLyAgICAgICAxMCwwMDAgd2luZG93IGF2YWlsYWJsZSB3aXRob3V0IGEgcGFnZSBhbmQgb2Zmc2V0IHBhcmFtZXRlclxuICAgIC8vICAgICAgIEVycm9yOiBSZXN1bHQgd2luZG93IGlzIHRvbyBsYXJnZSwgUGFnZU5vIHggT2Zmc2V0IHNpemUgbXVzdFxuICAgIC8vICAgICAgICAgICAgICBiZSBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gMTAwMDBcbiAgICBnZXRIaXN0b3J5KGFkZHJlc3NPck5hbWUsIHN0YXJ0QmxvY2ssIGVuZEJsb2NrKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbXMgPSB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInR4bGlzdFwiLFxuICAgICAgICAgICAgICAgIGFkZHJlc3M6ICh5aWVsZCB0aGlzLnJlc29sdmVOYW1lKGFkZHJlc3NPck5hbWUpKSxcbiAgICAgICAgICAgICAgICBzdGFydGJsb2NrOiAoKHN0YXJ0QmxvY2sgPT0gbnVsbCkgPyAwIDogc3RhcnRCbG9jayksXG4gICAgICAgICAgICAgICAgZW5kYmxvY2s6ICgoZW5kQmxvY2sgPT0gbnVsbCkgPyA5OTk5OTk5OSA6IGVuZEJsb2NrKSxcbiAgICAgICAgICAgICAgICBzb3J0OiBcImFzY1wiXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0geWllbGQgdGhpcy5mZXRjaChcImFjY291bnRcIiwgcGFyYW1zKTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQubWFwKCh0eCkgPT4ge1xuICAgICAgICAgICAgICAgIFtcImNvbnRyYWN0QWRkcmVzc1wiLCBcInRvXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodHhba2V5XSA9PSBcIlwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgdHhba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGlmICh0eC5jcmVhdGVzID09IG51bGwgJiYgdHguY29udHJhY3RBZGRyZXNzICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgdHguY3JlYXRlcyA9IHR4LmNvbnRyYWN0QWRkcmVzcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuZm9ybWF0dGVyLnRyYW5zYWN0aW9uUmVzcG9uc2UodHgpO1xuICAgICAgICAgICAgICAgIGlmICh0eC50aW1lU3RhbXApIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS50aW1lc3RhbXAgPSBwYXJzZUludCh0eC50aW1lU3RhbXApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gaXRlbTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLmFwaUtleSA9PT0gZGVmYXVsdEFwaUtleSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZXRoZXJzY2FuLXByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlclwiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgaXNIZXhTdHJpbmcgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZXBDb3B5LCBkZWZpbmVSZWFkT25seSwgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgc2h1ZmZsZWQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcmFuZG9tXCI7XG5pbXBvcnQgeyBwb2xsIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dlYlwiO1xuaW1wb3J0IHsgQmFzZVByb3ZpZGVyIH0gZnJvbSBcIi4vYmFzZS1wcm92aWRlclwiO1xuaW1wb3J0IHsgaXNDb21tdW5pdHlSZXNvdXJjZSB9IGZyb20gXCIuL2Zvcm1hdHRlclwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZnVuY3Rpb24gbm93KCkgeyByZXR1cm4gKG5ldyBEYXRlKCkpLmdldFRpbWUoKTsgfVxuLy8gUmV0dXJucyB0byBuZXR3b3JrIGFzIGxvbmcgYXMgYWxsIGFncmVlLCBvciBudWxsIGlmIGFueSBpcyBudWxsLlxuLy8gVGhyb3dzIGFuIGVycm9yIGlmIGFueSB0d28gbmV0d29ya3MgZG8gbm90IG1hdGNoLlxuZnVuY3Rpb24gY2hlY2tOZXR3b3JrcyhuZXR3b3Jrcykge1xuICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbmV0d29ya3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgbmV0d29yayA9IG5ldHdvcmtzW2ldO1xuICAgICAgICAvLyBOdWxsISBXZSBkbyBub3Qga25vdyBvdXIgbmV0d29yazsgYmFpbC5cbiAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdCkge1xuICAgICAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBuZXR3b3JrIG1hdGNoZXMgdGhlIHByZXZpb3VzIG5ldHdvcmtzXG4gICAgICAgICAgICBpZiAoIShyZXN1bHQubmFtZSA9PT0gbmV0d29yay5uYW1lICYmIHJlc3VsdC5jaGFpbklkID09PSBuZXR3b3JrLmNoYWluSWQgJiZcbiAgICAgICAgICAgICAgICAoKHJlc3VsdC5lbnNBZGRyZXNzID09PSBuZXR3b3JrLmVuc0FkZHJlc3MpIHx8IChyZXN1bHQuZW5zQWRkcmVzcyA9PSBudWxsICYmIG5ldHdvcmsuZW5zQWRkcmVzcyA9PSBudWxsKSkpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInByb3ZpZGVyIG1pc21hdGNoXCIsIFwibmV0d29ya3NcIiwgbmV0d29ya3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gbmV0d29yaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gbWVkaWFuKHZhbHVlcywgbWF4RGVsdGEpIHtcbiAgICB2YWx1ZXMgPSB2YWx1ZXMuc2xpY2UoKS5zb3J0KCk7XG4gICAgY29uc3QgbWlkZGxlID0gTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMik7XG4gICAgLy8gT2RkIGxlbmd0aDsgdGFrZSB0aGUgbWlkZGxlXG4gICAgaWYgKHZhbHVlcy5sZW5ndGggJSAyKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZXNbbWlkZGxlXTtcbiAgICB9XG4gICAgLy8gRXZlbiBsZW5ndGg7IHRha2UgdGhlIGF2ZXJhZ2Ugb2YgdGhlIHR3byBtaWRkbGVcbiAgICBjb25zdCBhID0gdmFsdWVzW21pZGRsZSAtIDFdLCBiID0gdmFsdWVzW21pZGRsZV07XG4gICAgaWYgKG1heERlbHRhICE9IG51bGwgJiYgTWF0aC5hYnMoYSAtIGIpID4gbWF4RGVsdGEpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiAoYSArIGIpIC8gMjtcbn1cbmZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gXCJudWxsXCI7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcIm51bWJlclwiIHx8IHR5cGVvZiAodmFsdWUpID09PSBcImJvb2xlYW5cIikge1xuICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKEJpZ051bWJlci5pc0JpZ051bWJlcih2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZS5tYXAoKGkpID0+IHNlcmlhbGl6ZShpKSkpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCBrZXlzID0gT2JqZWN0LmtleXModmFsdWUpO1xuICAgICAgICBrZXlzLnNvcnQoKTtcbiAgICAgICAgcmV0dXJuIFwie1wiICsga2V5cy5tYXAoKGtleSkgPT4ge1xuICAgICAgICAgICAgbGV0IHYgPSB2YWx1ZVtrZXldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiAodikgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgIHYgPSBcIltmdW5jdGlvbl1cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHYgPSBzZXJpYWxpemUodik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoa2V5KSArIFwiOlwiICsgdjtcbiAgICAgICAgfSkuam9pbihcIixcIikgKyBcIn1cIjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB2YWx1ZSB0eXBlOiBcIiArIHR5cGVvZiAodmFsdWUpKTtcbn1cbi8vIE5leHQgcmVxdWVzdCBJRCB0byB1c2UgZm9yIGVtaXR0aW5nIGRlYnVnIGluZm9cbmxldCBuZXh0UmlkID0gMTtcbjtcbmZ1bmN0aW9uIHN0YWxsKGR1cmF0aW9uKSB7XG4gICAgbGV0IGNhbmNlbCA9IG51bGw7XG4gICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICBsZXQgcHJvbWlzZSA9IChuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAodGltZXIpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgfTtcbiAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KGNhbmNlbCwgZHVyYXRpb24pO1xuICAgIH0pKTtcbiAgICBjb25zdCB3YWl0ID0gKGZ1bmMpID0+IHtcbiAgICAgICAgcHJvbWlzZSA9IHByb21pc2UudGhlbihmdW5jKTtcbiAgICAgICAgcmV0dXJuIHByb21pc2U7XG4gICAgfTtcbiAgICBmdW5jdGlvbiBnZXRQcm9taXNlKCkge1xuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG4gICAgcmV0dXJuIHsgY2FuY2VsLCBnZXRQcm9taXNlLCB3YWl0IH07XG59XG5jb25zdCBGb3J3YXJkRXJyb3JzID0gW1xuICAgIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sXG4gICAgTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsXG4gICAgTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELFxuICAgIExvZ2dlci5lcnJvcnMuUkVQTEFDRU1FTlRfVU5ERVJQUklDRUQsXG4gICAgTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVFxuXTtcbmNvbnN0IEZvcndhcmRQcm9wZXJ0aWVzID0gW1xuICAgIFwiYWRkcmVzc1wiLFxuICAgIFwiYXJnc1wiLFxuICAgIFwiZXJyb3JBcmdzXCIsXG4gICAgXCJlcnJvclNpZ25hdHVyZVwiLFxuICAgIFwibWV0aG9kXCIsXG4gICAgXCJ0cmFuc2FjdGlvblwiLFxuXTtcbjtcbmZ1bmN0aW9uIGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbm93KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgICB3ZWlnaHQ6IGNvbmZpZy53ZWlnaHRcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXN1bHQsIFwicHJvdmlkZXJcIiwgeyBnZXQ6ICgpID0+IGNvbmZpZy5wcm92aWRlciB9KTtcbiAgICBpZiAoY29uZmlnLnN0YXJ0KSB7XG4gICAgICAgIHJlc3VsdC5zdGFydCA9IGNvbmZpZy5zdGFydDtcbiAgICB9XG4gICAgaWYgKG5vdykge1xuICAgICAgICByZXN1bHQuZHVyYXRpb24gPSAobm93IC0gY29uZmlnLnN0YXJ0KTtcbiAgICB9XG4gICAgaWYgKGNvbmZpZy5kb25lKSB7XG4gICAgICAgIGlmIChjb25maWcuZXJyb3IpIHtcbiAgICAgICAgICAgIHJlc3VsdC5lcnJvciA9IGNvbmZpZy5lcnJvcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5yZXN1bHQgPSBjb25maWcucmVzdWx0IHx8IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZWRUYWxseShub3JtYWxpemUsIHF1b3J1bSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuICAgICAgICAvLyBDb3VudCB0aGUgdm90ZXMgZm9yIGVhY2ggcmVzdWx0XG4gICAgICAgIGNvbnN0IHRhbGx5ID0ge307XG4gICAgICAgIGNvbmZpZ3MuZm9yRWFjaCgoYykgPT4ge1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBub3JtYWxpemUoYy5yZXN1bHQpO1xuICAgICAgICAgICAgaWYgKCF0YWxseVt2YWx1ZV0pIHtcbiAgICAgICAgICAgICAgICB0YWxseVt2YWx1ZV0gPSB7IGNvdW50OiAwLCByZXN1bHQ6IGMucmVzdWx0IH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0YWxseVt2YWx1ZV0uY291bnQrKztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIENoZWNrIGZvciBhIHF1b3J1bSBvbiBhbnkgZ2l2ZW4gcmVzdWx0XG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0YWxseSk7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgY2hlY2sgPSB0YWxseVtrZXlzW2ldXTtcbiAgICAgICAgICAgIGlmIChjaGVjay5jb3VudCA+PSBxdW9ydW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2hlY2sucmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIE5vIHF1cm91bVxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH07XG59XG5mdW5jdGlvbiBnZXRQcm9jZXNzRnVuYyhwcm92aWRlciwgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICBsZXQgbm9ybWFsaXplID0gc2VyaWFsaXplO1xuICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgLy8gUmV0dXJuIHRoZSBtZWRpYW4gdmFsdWUsIHVubGVzcyB0aGVyZSBpcyAobWVkaWFuICsgMSkgaXMgYWxzb1xuICAgICAgICAgICAgLy8gcHJlc2VudCwgaW4gd2hpY2ggY2FzZSB0aGF0IGlzIHByb2JhYmx5IHRydWUgYW5kIHRoZSBtZWRpYW5cbiAgICAgICAgICAgIC8vIGlzIGdvaW5nIHRvIGJlIHN0YWxlIHNvb24uIEluIHRoZSBldmVudCBvZiBhIG1hbGljaW91cyBub2RlLFxuICAgICAgICAgICAgLy8gdGhlIGxpZSB3aWxsIGJlIHRydWUgc29vbiBlbm91Z2guXG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNvbmZpZ3MpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBjb25maWdzLm1hcCgoYykgPT4gYy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIC8vIEdldCB0aGUgbWVkaWFuIGJsb2NrIG51bWJlclxuICAgICAgICAgICAgICAgIGxldCBibG9ja051bWJlciA9IG1lZGlhbihjb25maWdzLm1hcCgoYykgPT4gYy5yZXN1bHQpLCAyKTtcbiAgICAgICAgICAgICAgICBpZiAoYmxvY2tOdW1iZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBibG9ja051bWJlciA9IE1hdGguY2VpbChibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIG5leHQgYmxvY2sgaGVpZ2h0IGlzIHByZXNlbnQsIGl0cyBwcm9sbHkgc2FmZSB0byB1c2VcbiAgICAgICAgICAgICAgICBpZiAodmFsdWVzLmluZGV4T2YoYmxvY2tOdW1iZXIgKyAxKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrTnVtYmVyKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIERvbid0IGV2ZXIgcm9sbCBiYWNrIHRoZSBibG9ja051bWJlclxuICAgICAgICAgICAgICAgIGlmIChibG9ja051bWJlciA+PSBwcm92aWRlci5faGlnaGVzdEJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyLl9oaWdoZXN0QmxvY2tOdW1iZXIgPSBibG9ja051bWJlcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLl9oaWdoZXN0QmxvY2tOdW1iZXI7XG4gICAgICAgICAgICB9O1xuICAgICAgICBjYXNlIFwiZ2V0R2FzUHJpY2VcIjpcbiAgICAgICAgICAgIC8vIFJldHVybiB0aGUgbWlkZGxlIChyb3VuZCBpbmRleCB1cCkgdmFsdWUsIHNpbWlsYXIgdG8gbWVkaWFuXG4gICAgICAgICAgICAvLyBidXQgZG8gbm90IGF2ZXJhZ2UgZXZlbiBlbnRyaWVzIGFuZCBjaG9vc2UgdGhlIGhpZ2hlci5cbiAgICAgICAgICAgIC8vIE1hbGljaW91cyBhY3RvcnMgbXVzdCBjb21wcm9taXNlIDUwJSBvZiB0aGUgbm9kZXMgdG8gbGllLlxuICAgICAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChjb25maWdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gY29uZmlncy5tYXAoKGMpID0+IGMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICB2YWx1ZXMuc29ydCgpO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZXNbTWF0aC5mbG9vcih2YWx1ZXMubGVuZ3RoIC8gMildO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgY2FzZSBcImdldEV0aGVyUHJpY2VcIjpcbiAgICAgICAgICAgIC8vIFJldHVybnMgdGhlIG1lZGlhbiBwcmljZS4gTWFsaWNpb3VzIGFjdG9ycyBtdXN0IGNvbXByb21pc2UgYXRcbiAgICAgICAgICAgIC8vIGxlYXN0IDUwJSBvZiB0aGUgbm9kZXMgdG8gbGllIChpbiBhIG1lYW5pbmdmdWwgd2F5KS5cbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoY29uZmlncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBtZWRpYW4oY29uZmlncy5tYXAoKGMpID0+IGMucmVzdWx0KSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAvLyBObyBhZGRpdGlvbmFsIG5vcm1hbGl6aW5nIHJlcXVpcmVkOyBzZXJpYWxpemUgaXMgZW5vdWdoXG4gICAgICAgIGNhc2UgXCJnZXRCYWxhbmNlXCI6XG4gICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgIGNhc2UgXCJnZXRDb2RlXCI6XG4gICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjpcbiAgICAgICAgY2FzZSBcImNhbGxcIjpcbiAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6XG4gICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gV2UgZHJvcCB0aGUgY29uZmlybWF0aW9ucyBmcm9tIHRyYW5zYWN0aW9ucyBhcyBpdCBpcyBhcHByb3hpbWF0ZVxuICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgY2FzZSBcImdldFRyYW5zYWN0aW9uUmVjZWlwdFwiOlxuICAgICAgICAgICAgbm9ybWFsaXplID0gZnVuY3Rpb24gKHR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKHR4ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR4ID0gc2hhbGxvd0NvcHkodHgpO1xuICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAtMTtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplKHR4KTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgLy8gV2UgZHJvcCB0aGUgY29uZmlybWF0aW9ucyBmcm9tIHRyYW5zYWN0aW9ucyBhcyBpdCBpcyBhcHByb3hpbWF0ZVxuICAgICAgICBjYXNlIFwiZ2V0QmxvY2tcIjpcbiAgICAgICAgICAgIC8vIFdlIGRyb3AgdGhlIGNvbmZpcm1hdGlvbnMgZnJvbSB0cmFuc2FjdGlvbnMgYXMgaXQgaXMgYXBwcm94aW1hdGVcbiAgICAgICAgICAgIGlmIChwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9ucykge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZSA9IGZ1bmN0aW9uIChibG9jaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYmxvY2sgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgYmxvY2sgPSBzaGFsbG93Q29weShibG9jayk7XG4gICAgICAgICAgICAgICAgICAgIGJsb2NrLnRyYW5zYWN0aW9ucyA9IGJsb2NrLnRyYW5zYWN0aW9ucy5tYXAoKHR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eCA9IHNoYWxsb3dDb3B5KHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR4LmNvbmZpcm1hdGlvbnMgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0eDtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoYmxvY2spO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemUgPSBmdW5jdGlvbiAoYmxvY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGJsb2NrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzZXJpYWxpemUoYmxvY2spO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInVua25vd24gbWV0aG9kOiBcIiArIG1ldGhvZCk7XG4gICAgfVxuICAgIC8vIFJldHVybiB0aGUgcmVzdWx0IGlmIGFuZCBvbmx5IGlmIHRoZSBleHBlY3RlZCBxdW9ydW0gaXNcbiAgICAvLyBzYXRpc2ZpZWQgYW5kIGFncmVlZCB1cG9uIGZvciB0aGUgZmluYWwgcmVzdWx0LlxuICAgIHJldHVybiBub3JtYWxpemVkVGFsbHkobm9ybWFsaXplLCBwcm92aWRlci5xdW9ydW0pO1xufVxuLy8gSWYgd2UgYXJlIGRvaW5nIGEgYmxvY2tUYWcgcXVlcnksIHdlIG5lZWQgdG8gbWFrZSBzdXJlIHRoZSBiYWNrZW5kIGlzXG4vLyBjYXVnaHQgdXAgdG8gdGhlIEZhbGxiYWNrUHJvdmlkZXIsIGJlZm9yZSBzZW5kaW5nIGEgcmVxdWVzdCB0byBpdC5cbmZ1bmN0aW9uIHdhaXRGb3JTeW5jKGNvbmZpZywgYmxvY2tOdW1iZXIpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBjb25zdCBwcm92aWRlciA9IChjb25maWcucHJvdmlkZXIpO1xuICAgICAgICBpZiAoKHByb3ZpZGVyLmJsb2NrTnVtYmVyICE9IG51bGwgJiYgcHJvdmlkZXIuYmxvY2tOdW1iZXIgPj0gYmxvY2tOdW1iZXIpIHx8IGJsb2NrTnVtYmVyID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwb2xsKCgpID0+IHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIFdlIGFyZSBzeW5jZWRcbiAgICAgICAgICAgICAgICAgICAgaWYgKHByb3ZpZGVyLmJsb2NrTnVtYmVyID49IGJsb2NrTnVtYmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShwcm92aWRlcik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gV2UncmUgZG9uZTsganVzdCBxdWl0XG4gICAgICAgICAgICAgICAgICAgIGlmIChjb25maWcuY2FuY2VsbGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzb2x2ZShudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBUcnkgYWdhaW4sIG5leHQgYmxvY2tcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc29sdmUodW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICB9LCAwKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9LCB7IG9uY2VQb2xsOiBwcm92aWRlciB9KTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJ1bm5lcihjb25maWcsIGN1cnJlbnRCbG9ja051bWJlciwgbWV0aG9kLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICBsZXQgcHJvdmlkZXIgPSBjb25maWcucHJvdmlkZXI7XG4gICAgICAgIHN3aXRjaCAobWV0aG9kKSB7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmxvY2tOdW1iZXJcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRHYXNQcmljZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlclttZXRob2RdKCk7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0RXRoZXJQcmljZVwiOlxuICAgICAgICAgICAgICAgIGlmIChwcm92aWRlci5nZXRFdGhlclByaWNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRFdGhlclByaWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdldEJhbGFuY2VcIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvbkNvdW50XCI6XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuYmxvY2tUYWcgJiYgaXNIZXhTdHJpbmcocGFyYW1zLmJsb2NrVGFnKSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlciA9IHlpZWxkIHdhaXRGb3JTeW5jKGNvbmZpZywgY3VycmVudEJsb2NrTnVtYmVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyW21ldGhvZF0ocGFyYW1zLmFkZHJlc3MsIHBhcmFtcy5ibG9ja1RhZyB8fCBcImxhdGVzdFwiKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRTdG9yYWdlQXRcIjpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICYmIGlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSB5aWVsZCB3YWl0Rm9yU3luYyhjb25maWcsIGN1cnJlbnRCbG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlci5nZXRTdG9yYWdlQXQocGFyYW1zLmFkZHJlc3MsIHBhcmFtcy5wb3NpdGlvbiwgcGFyYW1zLmJsb2NrVGFnIHx8IFwibGF0ZXN0XCIpO1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZyAmJiBpc0hleFN0cmluZyhwYXJhbXMuYmxvY2tUYWcpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0geWllbGQgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJbKHBhcmFtcy5pbmNsdWRlVHJhbnNhY3Rpb25zID8gXCJnZXRCbG9ja1dpdGhUcmFuc2FjdGlvbnNcIiA6IFwiZ2V0QmxvY2tcIildKHBhcmFtcy5ibG9ja1RhZyB8fCBwYXJhbXMuYmxvY2tIYXNoKTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXN0aW1hdGVHYXNcIjpcbiAgICAgICAgICAgICAgICBpZiAocGFyYW1zLmJsb2NrVGFnICYmIGlzSGV4U3RyaW5nKHBhcmFtcy5ibG9ja1RhZykpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXIgPSB5aWVsZCB3YWl0Rm9yU3luYyhjb25maWcsIGN1cnJlbnRCbG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBwcm92aWRlclttZXRob2RdKHBhcmFtcy50cmFuc2FjdGlvbik7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgIGNhc2UgXCJnZXRUcmFuc2FjdGlvblJlY2VpcHRcIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXJbbWV0aG9kXShwYXJhbXMudHJhbnNhY3Rpb25IYXNoKTtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRMb2dzXCI6IHtcbiAgICAgICAgICAgICAgICBsZXQgZmlsdGVyID0gcGFyYW1zLmZpbHRlcjtcbiAgICAgICAgICAgICAgICBpZiAoKGZpbHRlci5mcm9tQmxvY2sgJiYgaXNIZXhTdHJpbmcoZmlsdGVyLmZyb21CbG9jaykpIHx8IChmaWx0ZXIudG9CbG9jayAmJiBpc0hleFN0cmluZyhmaWx0ZXIudG9CbG9jaykpKSB7XG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyID0geWllbGQgd2FpdEZvclN5bmMoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcHJvdmlkZXIuZ2V0TG9ncyhmaWx0ZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcInVua25vd24gbWV0aG9kIGVycm9yXCIsIExvZ2dlci5lcnJvcnMuVU5LTk9XTl9FUlJPUiwge1xuICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICBwYXJhbXM6IHBhcmFtc1xuICAgICAgICB9KTtcbiAgICB9KTtcbn1cbmV4cG9ydCBjbGFzcyBGYWxsYmFja1Byb3ZpZGVyIGV4dGVuZHMgQmFzZVByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3Rvcihwcm92aWRlcnMsIHF1b3J1bSkge1xuICAgICAgICBsb2dnZXIuY2hlY2tOZXcobmV3LnRhcmdldCwgRmFsbGJhY2tQcm92aWRlcik7XG4gICAgICAgIGlmIChwcm92aWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzc2luZyBwcm92aWRlcnNcIiwgXCJwcm92aWRlcnNcIiwgcHJvdmlkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwcm92aWRlckNvbmZpZ3MgPSBwcm92aWRlcnMubWFwKChjb25maWdPclByb3ZpZGVyLCBpbmRleCkgPT4ge1xuICAgICAgICAgICAgaWYgKFByb3ZpZGVyLmlzUHJvdmlkZXIoY29uZmlnT3JQcm92aWRlcikpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBzdGFsbFRpbWVvdXQgPSBpc0NvbW11bml0eVJlc291cmNlKGNvbmZpZ09yUHJvdmlkZXIpID8gMjAwMCA6IDc1MDtcbiAgICAgICAgICAgICAgICBjb25zdCBwcmlvcml0eSA9IDE7XG4gICAgICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5mcmVlemUoeyBwcm92aWRlcjogY29uZmlnT3JQcm92aWRlciwgd2VpZ2h0OiAxLCBzdGFsbFRpbWVvdXQsIHByaW9yaXR5IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gc2hhbGxvd0NvcHkoY29uZmlnT3JQcm92aWRlcik7XG4gICAgICAgICAgICBpZiAoY29uZmlnLnByaW9yaXR5ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcucHJpb3JpdHkgPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbmZpZy5zdGFsbFRpbWVvdXQgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbmZpZy5zdGFsbFRpbWVvdXQgPSBpc0NvbW11bml0eVJlc291cmNlKGNvbmZpZ09yUHJvdmlkZXIpID8gMjAwMCA6IDc1MDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjb25maWcud2VpZ2h0ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25maWcud2VpZ2h0ID0gMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHdlaWdodCA9IGNvbmZpZy53ZWlnaHQ7XG4gICAgICAgICAgICBpZiAod2VpZ2h0ICUgMSB8fCB3ZWlnaHQgPiA1MTIgfHwgd2VpZ2h0IDwgMSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHdlaWdodDsgbXVzdCBiZSBpbnRlZ2VyIGluIFsxLCA1MTJdXCIsIGBwcm92aWRlcnNbJHtpbmRleH1dLndlaWdodGAsIHdlaWdodCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmZyZWV6ZShjb25maWcpO1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgdG90YWwgPSBwcm92aWRlckNvbmZpZ3MucmVkdWNlKChhY2N1bSwgYykgPT4gKGFjY3VtICsgYy53ZWlnaHQpLCAwKTtcbiAgICAgICAgaWYgKHF1b3J1bSA9PSBudWxsKSB7XG4gICAgICAgICAgICBxdW9ydW0gPSB0b3RhbCAvIDI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocXVvcnVtID4gdG90YWwpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJxdW9ydW0gd2lsbCBhbHdheXMgZmFpbDsgbGFyZ2VyIHRoYW4gdG90YWwgd2VpZ2h0XCIsIFwicXVvcnVtXCIsIHF1b3J1bSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQXJlIGFsbCBwcm92aWRlcnMnIG5ldHdvcmtzIGFyZSBrbm93blxuICAgICAgICBsZXQgbmV0d29ya09yUmVhZHkgPSBjaGVja05ldHdvcmtzKHByb3ZpZGVyQ29uZmlncy5tYXAoKGMpID0+IChjLnByb3ZpZGVyKS5uZXR3b3JrKSk7XG4gICAgICAgIC8vIE5vdCBhbGwgbmV0d29ya3MgYXJlIGtub3duOyB3ZSBtdXN0IHN0YWxsXG4gICAgICAgIGlmIChuZXR3b3JrT3JSZWFkeSA9PSBudWxsKSB7XG4gICAgICAgICAgICBuZXR3b3JrT3JSZWFkeSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kZXRlY3ROZXR3b3JrKCkudGhlbihyZXNvbHZlLCByZWplY3QpO1xuICAgICAgICAgICAgICAgIH0sIDApO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIobmV0d29ya09yUmVhZHkpO1xuICAgICAgICAvLyBQcmVzZXJ2ZSBhIGNvcHksIHNvIHdlIGRvIG5vdCBnZXQgbXV0YXRlZFxuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInByb3ZpZGVyQ29uZmlnc1wiLCBPYmplY3QuZnJlZXplKHByb3ZpZGVyQ29uZmlncykpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcInF1b3J1bVwiLCBxdW9ydW0pO1xuICAgICAgICB0aGlzLl9oaWdoZXN0QmxvY2tOdW1iZXIgPSAtMTtcbiAgICB9XG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ldHdvcmtzID0geWllbGQgUHJvbWlzZS5hbGwodGhpcy5wcm92aWRlckNvbmZpZ3MubWFwKChjKSA9PiBjLnByb3ZpZGVyLmdldE5ldHdvcmsoKSkpO1xuICAgICAgICAgICAgcmV0dXJuIGNoZWNrTmV0d29ya3MobmV0d29ya3MpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgcGVyZm9ybShtZXRob2QsIHBhcmFtcykge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gU2VuZGluZyB0cmFuc2FjdGlvbnMgaXMgc3BlY2lhbDsgYWx3YXlzIGJyb2FkY2FzdCBpdCB0byBhbGwgYmFja2VuZHNcbiAgICAgICAgICAgIGlmIChtZXRob2QgPT09IFwic2VuZFRyYW5zYWN0aW9uXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHRzID0geWllbGQgUHJvbWlzZS5hbGwodGhpcy5wcm92aWRlckNvbmZpZ3MubWFwKChjKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjLnByb3ZpZGVyLnNlbmRUcmFuc2FjdGlvbihwYXJhbXMuc2lnbmVkVHJhbnNhY3Rpb24pLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdC5oYXNoO1xuICAgICAgICAgICAgICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIC8vIEFueSBzdWNjZXNzIGlzIGdvb2QgZW5vdWdoIChvdGhlciBlcnJvcnMgYXJlIGxpa2VseSBcImFscmVhZHkgc2VlblwiIGVycm9yc1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSByZXN1bHRzW2ldO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIChyZXN1bHQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFRoZXkgd2VyZSBhbGwgYW4gZXJyb3I7IHBpY2sgdGhlIGZpcnN0IGVycm9yXG4gICAgICAgICAgICAgICAgdGhyb3cgcmVzdWx0c1swXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFdlIG5lZWQgdG8gbWFrZSBzdXJlIHdlIGFyZSBpbiBzeW5jIHdpdGggb3VyIGJhY2tlbmRzLCBzbyB3ZSBuZWVkXG4gICAgICAgICAgICAvLyB0byBrbm93IHRoaXMgYmVmb3JlIHdlIGNhbiBtYWtlIGEgbG90IG9mIGNhbGxzXG4gICAgICAgICAgICBpZiAodGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyID09PSAtMSAmJiBtZXRob2QgIT09IFwiZ2V0QmxvY2tOdW1iZXJcIikge1xuICAgICAgICAgICAgICAgIHlpZWxkIHRoaXMuZ2V0QmxvY2tOdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHByb2Nlc3NGdW5jID0gZ2V0UHJvY2Vzc0Z1bmModGhpcywgbWV0aG9kLCBwYXJhbXMpO1xuICAgICAgICAgICAgLy8gU2h1ZmZsZSB0aGUgcHJvdmlkZXJzIGFuZCB0aGVuIHNvcnQgdGhlbSBieSB0aGVpciBwcmlvcml0eTsgd2VcbiAgICAgICAgICAgIC8vIHNoYWxsb3dDb3B5IHRoZW0gc2luY2Ugd2Ugd2lsbCBzdG9yZSB0aGUgcmVzdWx0IGluIHRoZW0gdG9vXG4gICAgICAgICAgICBjb25zdCBjb25maWdzID0gc2h1ZmZsZWQodGhpcy5wcm92aWRlckNvbmZpZ3MubWFwKHNoYWxsb3dDb3B5KSk7XG4gICAgICAgICAgICBjb25maWdzLnNvcnQoKGEsIGIpID0+IChhLnByaW9yaXR5IC0gYi5wcmlvcml0eSkpO1xuICAgICAgICAgICAgY29uc3QgY3VycmVudEJsb2NrTnVtYmVyID0gdGhpcy5faGlnaGVzdEJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICAgICAgbGV0IGZpcnN0ID0gdHJ1ZTtcbiAgICAgICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgdDAgPSBub3coKTtcbiAgICAgICAgICAgICAgICAvLyBDb21wdXRlIHRoZSBpbmZsaWdodCB3ZWlnaHQgKGV4Y2x1ZGUgYW55dGhpbmcgcGFzdClcbiAgICAgICAgICAgICAgICBsZXQgaW5mbGlnaHRXZWlnaHQgPSBjb25maWdzLmZpbHRlcigoYykgPT4gKGMucnVubmVyICYmICgodDAgLSBjLnN0YXJ0KSA8IGMuc3RhbGxUaW1lb3V0KSkpXG4gICAgICAgICAgICAgICAgICAgIC5yZWR1Y2UoKGFjY3VtLCBjKSA9PiAoYWNjdW0gKyBjLndlaWdodCksIDApO1xuICAgICAgICAgICAgICAgIC8vIFN0YXJ0IHJ1bm5pbmcgZW5vdWdoIHRvIG1lZXQgcXVvcnVtXG4gICAgICAgICAgICAgICAgd2hpbGUgKGluZmxpZ2h0V2VpZ2h0IDwgdGhpcy5xdW9ydW0gJiYgaSA8IGNvbmZpZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbmZpZyA9IGNvbmZpZ3NbaSsrXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmlkID0gbmV4dFJpZCsrO1xuICAgICAgICAgICAgICAgICAgICBjb25maWcuc3RhcnQgPSBub3coKTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0YWxsZXIgPSBzdGFsbChjb25maWcuc3RhbGxUaW1lb3V0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uZmlnLnN0YWxsZXIud2FpdCgoKSA9PiB7IGNvbmZpZy5zdGFsbGVyID0gbnVsbDsgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbmZpZy5ydW5uZXIgPSBnZXRSdW5uZXIoY29uZmlnLCBjdXJyZW50QmxvY2tOdW1iZXIsIG1ldGhvZCwgcGFyYW1zKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5kb25lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZy5yZXN1bHQgPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KFwiZGVidWdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kOiBleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsIG5vdygpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBkZWVwQ29weShwYXJhbXMpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnLmVycm9yID0gZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KFwiZGVidWdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBiYWNrZW5kOiBleHBvc2VEZWJ1Z0NvbmZpZyhjb25maWcsIG5vdygpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBkZWVwQ29weShwYXJhbXMpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5saXN0ZW5lckNvdW50KFwiZGVidWdcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVxdWVzdFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJpZDogcmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJhY2tlbmQ6IGV4cG9zZURlYnVnQ29uZmlnKGNvbmZpZywgbnVsbCksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogeyBtZXRob2Q6IG1ldGhvZCwgcGFyYW1zOiBkZWVwQ29weShwYXJhbXMpIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0V2VpZ2h0ICs9IGNvbmZpZy53ZWlnaHQ7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIFdhaXQgZm9yIGFueXRoaW5nIG1lYW5pbmdmdWwgdG8gZmluaXNoIG9yIHN0YWxsIG91dFxuICAgICAgICAgICAgICAgIGNvbnN0IHdhaXRpbmcgPSBbXTtcbiAgICAgICAgICAgICAgICBjb25maWdzLmZvckVhY2goKGMpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGMuZG9uZSB8fCAhYy5ydW5uZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB3YWl0aW5nLnB1c2goYy5ydW5uZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYy5zdGFsbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB3YWl0aW5nLnB1c2goYy5zdGFsbGVyLmdldFByb21pc2UoKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAod2FpdGluZy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgeWllbGQgUHJvbWlzZS5yYWNlKHdhaXRpbmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBDaGVjayB0aGUgcXVvcnVtIGFuZCBwcm9jZXNzIHRoZSByZXN1bHRzOyB0aGUgcHJvY2VzcyBmdW5jdGlvblxuICAgICAgICAgICAgICAgIC8vIG1heSBhZGRpdGlvbmFsbHkgZGVjaWRlIHRoZSBxdW9ydW0gaXMgbm90IG1ldFxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdHMgPSBjb25maWdzLmZpbHRlcigoYykgPT4gKGMuZG9uZSAmJiBjLmVycm9yID09IG51bGwpKTtcbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0cy5sZW5ndGggPj0gdGhpcy5xdW9ydW0pIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gU2h1dCBkb3duIGFueSBzdGFsbGVyc1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjLnN0YWxsZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYy5zdGFsbGVyLmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmaXJzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgc3RhbGwoMTAwKS5nZXRQcm9taXNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZmlyc3QgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gTm8gcmVzdWx0LCBjaGVjayBmb3IgZXJyb3JzIHRoYXQgc2hvdWxkIGJlIGZvcndhcmRlZFxuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGNvbmZpZ3MucmVkdWNlKChhY2N1bSwgYykgPT4ge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWMuZG9uZSB8fCBjLmVycm9yID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjb25zdCBjb2RlID0gKGMuZXJyb3IpLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChGb3J3YXJkRXJyb3JzLmluZGV4T2YoY29kZSkgPj0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFhY2N1bVtjb2RlXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGFjY3VtW2NvZGVdID0geyBlcnJvcjogYy5lcnJvciwgd2VpZ2h0OiAwIH07XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2N1bVtjb2RlXS53ZWlnaHQgKz0gYy53ZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGFjY3VtO1xuICAgICAgICAgICAgICAgIH0sICh7fSkpO1xuICAgICAgICAgICAgICAgIE9iamVjdC5rZXlzKGVycm9ycykuZm9yRWFjaCgoZXJyb3JDb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRhbGx5ID0gZXJyb3JzW2Vycm9yQ29kZV07XG4gICAgICAgICAgICAgICAgICAgIGlmICh0YWxseS53ZWlnaHQgPCB0aGlzLnF1b3J1bSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFNodXQgZG93biBhbnkgc3RhbGxlcnNcbiAgICAgICAgICAgICAgICAgICAgY29uZmlncy5mb3JFYWNoKGMgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGMuc3RhbGxlci5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGUgPSAodGFsbHkuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwcm9wcyA9IHt9O1xuICAgICAgICAgICAgICAgICAgICBGb3J3YXJkUHJvcGVydGllcy5mb3JFYWNoKChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZVtuYW1lXSA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvcHNbbmFtZV0gPSBlW25hbWVdO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoZS5yZWFzb24gfHwgZS5tZXNzYWdlLCBlcnJvckNvZGUsIHByb3BzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBBbGwgY29uZmlncyBoYXZlIHJ1biB0byBjb21wbGV0aW9uOyB3ZSB3aWxsIG5ldmVyIGdldCBtb3JlIGRhdGFcbiAgICAgICAgICAgICAgICBpZiAoY29uZmlncy5maWx0ZXIoKGMpID0+ICFjLmRvbmUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTaHV0IGRvd24gYW55IHN0YWxsZXJzOyBzaG91bGRuJ3QgYmUgYW55XG4gICAgICAgICAgICBjb25maWdzLmZvckVhY2goYyA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGMuc3RhbGxlcikge1xuICAgICAgICAgICAgICAgICAgICBjLnN0YWxsZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiZmFpbGVkIHRvIG1lZXQgcXVvcnVtXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICAgICAgLy9yZXN1bHRzOiBjb25maWdzLm1hcCgoYykgPT4gYy5yZXN1bHQpLFxuICAgICAgICAgICAgICAgIC8vZXJyb3JzOiBjb25maWdzLm1hcCgoYykgPT4gYy5lcnJvciksXG4gICAgICAgICAgICAgICAgcmVzdWx0czogY29uZmlncy5tYXAoKGMpID0+IGV4cG9zZURlYnVnQ29uZmlnKGMpKSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhbGxiYWNrLXByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q29udHJhY3RBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FkZHJlc3NcIjtcbmltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgaGV4VmFsdWUsIGhleFplcm9QYWQsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBBZGRyZXNzWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcbmltcG9ydCB7IHNoYWxsb3dDb3B5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IGFjY2Vzc0xpc3RpZnksIHBhcnNlIGFzIHBhcnNlVHJhbnNhY3Rpb24gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvdHJhbnNhY3Rpb25zXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5leHBvcnQgY2xhc3MgRm9ybWF0dGVyIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrTmV3KG5ldy50YXJnZXQsIEZvcm1hdHRlcik7XG4gICAgICAgIHRoaXMuZm9ybWF0cyA9IHRoaXMuZ2V0RGVmYXVsdEZvcm1hdHMoKTtcbiAgICB9XG4gICAgZ2V0RGVmYXVsdEZvcm1hdHMoKSB7XG4gICAgICAgIGNvbnN0IGZvcm1hdHMgPSAoe30pO1xuICAgICAgICBjb25zdCBhZGRyZXNzID0gdGhpcy5hZGRyZXNzLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IGJpZ051bWJlciA9IHRoaXMuYmlnTnVtYmVyLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IGJsb2NrVGFnID0gdGhpcy5ibG9ja1RhZy5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhLmJpbmQodGhpcyk7XG4gICAgICAgIGNvbnN0IGhhc2ggPSB0aGlzLmhhc2guYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgaGV4ID0gdGhpcy5oZXguYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgbnVtYmVyID0gdGhpcy5udW1iZXIuYmluZCh0aGlzKTtcbiAgICAgICAgY29uc3QgdHlwZSA9IHRoaXMudHlwZS5iaW5kKHRoaXMpO1xuICAgICAgICBjb25zdCBzdHJpY3REYXRhID0gKHYpID0+IHsgcmV0dXJuIHRoaXMuZGF0YSh2LCB0cnVlKTsgfTtcbiAgICAgICAgZm9ybWF0cy50cmFuc2FjdGlvbiA9IHtcbiAgICAgICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICAgICAgYWNjZXNzTGlzdDogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmFjY2Vzc0xpc3QuYmluZCh0aGlzKSwgbnVsbCksXG4gICAgICAgICAgICBibG9ja0hhc2g6IEZvcm1hdHRlci5hbGxvd051bGwoaGFzaCwgbnVsbCksXG4gICAgICAgICAgICBibG9ja051bWJlcjogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsIG51bGwpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsIG51bGwpLFxuICAgICAgICAgICAgY29uZmlybWF0aW9uczogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIsIG51bGwpLFxuICAgICAgICAgICAgZnJvbTogYWRkcmVzcyxcbiAgICAgICAgICAgIC8vIGVpdGhlciAoZ2FzUHJpY2UpIG9yIChtYXhQcmlvcml0eUZlZVBlckdhcyArIG1heEZlZVBlckdhcylcbiAgICAgICAgICAgIC8vIG11c3QgYmUgc2V0XG4gICAgICAgICAgICBnYXNQcmljZTogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgZ2FzTGltaXQ6IGJpZ051bWJlcixcbiAgICAgICAgICAgIHRvOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIG51bGwpLFxuICAgICAgICAgICAgdmFsdWU6IGJpZ051bWJlcixcbiAgICAgICAgICAgIG5vbmNlOiBudW1iZXIsXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgcjogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnVpbnQyNTYpLFxuICAgICAgICAgICAgczogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLnVpbnQyNTYpLFxuICAgICAgICAgICAgdjogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgY3JlYXRlczogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLCBudWxsKSxcbiAgICAgICAgICAgIHJhdzogRm9ybWF0dGVyLmFsbG93TnVsbChkYXRhKSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy50cmFuc2FjdGlvblJlcXVlc3QgPSB7XG4gICAgICAgICAgICBmcm9tOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MpLFxuICAgICAgICAgICAgbm9uY2U6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIGdhc0xpbWl0OiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJpZ051bWJlciksXG4gICAgICAgICAgICBnYXNQcmljZTogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgbWF4UHJpb3JpdHlGZWVQZXJHYXM6IEZvcm1hdHRlci5hbGxvd051bGwoYmlnTnVtYmVyKSxcbiAgICAgICAgICAgIG1heEZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwoYWRkcmVzcyksXG4gICAgICAgICAgICB2YWx1ZTogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgZGF0YTogRm9ybWF0dGVyLmFsbG93TnVsbChzdHJpY3REYXRhKSxcbiAgICAgICAgICAgIHR5cGU6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyKSxcbiAgICAgICAgICAgIGFjY2Vzc0xpc3Q6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hY2Nlc3NMaXN0LmJpbmQodGhpcyksIG51bGwpLFxuICAgICAgICB9O1xuICAgICAgICBmb3JtYXRzLnJlY2VpcHRMb2cgPSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbkluZGV4OiBudW1iZXIsXG4gICAgICAgICAgICBibG9ja051bWJlcjogbnVtYmVyLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBoYXNoLFxuICAgICAgICAgICAgYWRkcmVzczogYWRkcmVzcyxcbiAgICAgICAgICAgIHRvcGljczogRm9ybWF0dGVyLmFycmF5T2YoaGFzaCksXG4gICAgICAgICAgICBkYXRhOiBkYXRhLFxuICAgICAgICAgICAgbG9nSW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgIGJsb2NrSGFzaDogaGFzaCxcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5yZWNlaXB0ID0ge1xuICAgICAgICAgICAgdG86IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hZGRyZXNzLCBudWxsKSxcbiAgICAgICAgICAgIGZyb206IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy5hZGRyZXNzLCBudWxsKSxcbiAgICAgICAgICAgIGNvbnRyYWN0QWRkcmVzczogRm9ybWF0dGVyLmFsbG93TnVsbChhZGRyZXNzLCBudWxsKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSW5kZXg6IG51bWJlcixcbiAgICAgICAgICAgIC8vIHNob3VsZCBiZSBhbGxvd051bGwoaGFzaCksIGJ1dCBicm9rZW4tRUlQLTY1OCBzdXBwb3J0IGlzIGhhbmRsZWQgaW4gcmVjZWlwdFxuICAgICAgICAgICAgcm9vdDogRm9ybWF0dGVyLmFsbG93TnVsbChoZXgpLFxuICAgICAgICAgICAgZ2FzVXNlZDogYmlnTnVtYmVyLFxuICAgICAgICAgICAgbG9nc0Jsb29tOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGRhdGEpLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBoYXNoLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25IYXNoOiBoYXNoLFxuICAgICAgICAgICAgbG9nczogRm9ybWF0dGVyLmFycmF5T2YodGhpcy5yZWNlaXB0TG9nLmJpbmQodGhpcykpLFxuICAgICAgICAgICAgYmxvY2tOdW1iZXI6IG51bWJlcixcbiAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwobnVtYmVyLCBudWxsKSxcbiAgICAgICAgICAgIGN1bXVsYXRpdmVHYXNVc2VkOiBiaWdOdW1iZXIsXG4gICAgICAgICAgICBlZmZlY3RpdmVHYXNQcmljZTogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpLFxuICAgICAgICAgICAgc3RhdHVzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKG51bWJlciksXG4gICAgICAgICAgICB0eXBlOiB0eXBlXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMuYmxvY2sgPSB7XG4gICAgICAgICAgICBoYXNoOiBoYXNoLFxuICAgICAgICAgICAgcGFyZW50SGFzaDogaGFzaCxcbiAgICAgICAgICAgIG51bWJlcjogbnVtYmVyLFxuICAgICAgICAgICAgdGltZXN0YW1wOiBudW1iZXIsXG4gICAgICAgICAgICBub25jZTogRm9ybWF0dGVyLmFsbG93TnVsbChoZXgpLFxuICAgICAgICAgICAgZGlmZmljdWx0eTogdGhpcy5kaWZmaWN1bHR5LmJpbmQodGhpcyksXG4gICAgICAgICAgICBnYXNMaW1pdDogYmlnTnVtYmVyLFxuICAgICAgICAgICAgZ2FzVXNlZDogYmlnTnVtYmVyLFxuICAgICAgICAgICAgbWluZXI6IGFkZHJlc3MsXG4gICAgICAgICAgICBleHRyYURhdGE6IGRhdGEsXG4gICAgICAgICAgICB0cmFuc2FjdGlvbnM6IEZvcm1hdHRlci5hbGxvd051bGwoRm9ybWF0dGVyLmFycmF5T2YoaGFzaCkpLFxuICAgICAgICAgICAgYmFzZUZlZVBlckdhczogRm9ybWF0dGVyLmFsbG93TnVsbChiaWdOdW1iZXIpXG4gICAgICAgIH07XG4gICAgICAgIGZvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zID0gc2hhbGxvd0NvcHkoZm9ybWF0cy5ibG9jayk7XG4gICAgICAgIGZvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zLnRyYW5zYWN0aW9ucyA9IEZvcm1hdHRlci5hbGxvd051bGwoRm9ybWF0dGVyLmFycmF5T2YodGhpcy50cmFuc2FjdGlvblJlc3BvbnNlLmJpbmQodGhpcykpKTtcbiAgICAgICAgZm9ybWF0cy5maWx0ZXIgPSB7XG4gICAgICAgICAgICBmcm9tQmxvY2s6IEZvcm1hdHRlci5hbGxvd051bGwoYmxvY2tUYWcsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICB0b0Jsb2NrOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGJsb2NrVGFnLCB1bmRlZmluZWQpLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhhc2gsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICBhZGRyZXNzOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGFkZHJlc3MsIHVuZGVmaW5lZCksXG4gICAgICAgICAgICB0b3BpY3M6IEZvcm1hdHRlci5hbGxvd051bGwodGhpcy50b3BpY3MuYmluZCh0aGlzKSwgdW5kZWZpbmVkKSxcbiAgICAgICAgfTtcbiAgICAgICAgZm9ybWF0cy5maWx0ZXJMb2cgPSB7XG4gICAgICAgICAgICBibG9ja051bWJlcjogRm9ybWF0dGVyLmFsbG93TnVsbChudW1iZXIpLFxuICAgICAgICAgICAgYmxvY2tIYXNoOiBGb3JtYXR0ZXIuYWxsb3dOdWxsKGhhc2gpLFxuICAgICAgICAgICAgdHJhbnNhY3Rpb25JbmRleDogbnVtYmVyLFxuICAgICAgICAgICAgcmVtb3ZlZDogRm9ybWF0dGVyLmFsbG93TnVsbCh0aGlzLmJvb2xlYW4uYmluZCh0aGlzKSksXG4gICAgICAgICAgICBhZGRyZXNzOiBhZGRyZXNzLFxuICAgICAgICAgICAgZGF0YTogRm9ybWF0dGVyLmFsbG93RmFsc2lzaChkYXRhLCBcIjB4XCIpLFxuICAgICAgICAgICAgdG9waWNzOiBGb3JtYXR0ZXIuYXJyYXlPZihoYXNoKSxcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uSGFzaDogaGFzaCxcbiAgICAgICAgICAgIGxvZ0luZGV4OiBudW1iZXIsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBmb3JtYXRzO1xuICAgIH1cbiAgICBhY2Nlc3NMaXN0KGFjY2Vzc0xpc3QpIHtcbiAgICAgICAgcmV0dXJuIGFjY2Vzc0xpc3RpZnkoYWNjZXNzTGlzdCB8fCBbXSk7XG4gICAgfVxuICAgIC8vIFJlcXVpcmVzIGEgQmlnTnVtYmVyaXNoIHRoYXQgaXMgd2l0aGluIHRoZSBJRUVFNzU0IHNhZmUgaW50ZWdlciByYW5nZTsgcmV0dXJucyBhIG51bWJlclxuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBudW1iZXIobnVtYmVyKSB7XG4gICAgICAgIGlmIChudW1iZXIgPT09IFwiMHhcIikge1xuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKG51bWJlcikudG9OdW1iZXIoKTtcbiAgICB9XG4gICAgdHlwZShudW1iZXIpIHtcbiAgICAgICAgaWYgKG51bWJlciA9PT0gXCIweFwiIHx8IG51bWJlciA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gQmlnTnVtYmVyLmZyb20obnVtYmVyKS50b051bWJlcigpO1xuICAgIH1cbiAgICAvLyBTdHJpY3QhIFVzZWQgb24gaW5wdXQuXG4gICAgYmlnTnVtYmVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBCaWdOdW1iZXIuZnJvbSh2YWx1ZSk7XG4gICAgfVxuICAgIC8vIFJlcXVpcmVzIGEgYm9vbGVhbiwgXCJ0cnVlXCIgb3IgIFwiZmFsc2VcIjsgcmV0dXJucyBhIGJvb2xlYW5cbiAgICBib29sZWFuKHZhbHVlKSB7XG4gICAgICAgIGlmICh0eXBlb2YgKHZhbHVlKSA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJ0cnVlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA9PT0gXCJmYWxzZVwiKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgYm9vbGVhbiAtIFwiICsgdmFsdWUpO1xuICAgIH1cbiAgICBoZXgodmFsdWUsIHN0cmljdCkge1xuICAgICAgICBpZiAodHlwZW9mICh2YWx1ZSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGlmICghc3RyaWN0ICYmIHZhbHVlLnN1YnN0cmluZygwLCAyKSAhPT0gXCIweFwiKSB7XG4gICAgICAgICAgICAgICAgdmFsdWUgPSBcIjB4XCIgKyB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyh2YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGFzaFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICB9XG4gICAgZGF0YSh2YWx1ZSwgc3RyaWN0KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHRoaXMuaGV4KHZhbHVlLCBzdHJpY3QpO1xuICAgICAgICBpZiAoKHJlc3VsdC5sZW5ndGggJSAyKSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBkYXRhOyBvZGQtbGVuZ3RoIC0gXCIgKyB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gUmVxdWlyZXMgYW4gYWRkcmVzc1xuICAgIC8vIFN0cmljdCEgVXNlZCBvbiBpbnB1dC5cbiAgICBhZGRyZXNzKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBnZXRBZGRyZXNzKHZhbHVlKTtcbiAgICB9XG4gICAgY2FsbEFkZHJlc3ModmFsdWUpIHtcbiAgICAgICAgaWYgKCFpc0hleFN0cmluZyh2YWx1ZSwgMzIpKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhZGRyZXNzID0gZ2V0QWRkcmVzcyhoZXhEYXRhU2xpY2UodmFsdWUsIDEyKSk7XG4gICAgICAgIHJldHVybiAoYWRkcmVzcyA9PT0gQWRkcmVzc1plcm8pID8gbnVsbCA6IGFkZHJlc3M7XG4gICAgfVxuICAgIGNvbnRyYWN0QWRkcmVzcyh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZ2V0Q29udHJhY3RBZGRyZXNzKHZhbHVlKTtcbiAgICB9XG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIGJsb2NrVGFnKGJsb2NrVGFnKSB7XG4gICAgICAgIGlmIChibG9ja1RhZyA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gXCJsYXRlc3RcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYmxvY2tUYWcgPT09IFwiZWFybGllc3RcIikge1xuICAgICAgICAgICAgcmV0dXJuIFwiMHgwXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJsb2NrVGFnID09PSBcImxhdGVzdFwiIHx8IGJsb2NrVGFnID09PSBcInBlbmRpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGJsb2NrVGFnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgKGJsb2NrVGFnKSA9PT0gXCJudW1iZXJcIiB8fCBpc0hleFN0cmluZyhibG9ja1RhZykpIHtcbiAgICAgICAgICAgIHJldHVybiBoZXhWYWx1ZShibG9ja1RhZyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBibG9ja1RhZ1wiKTtcbiAgICB9XG4gICAgLy8gUmVxdWlyZXMgYSBoYXNoLCBvcHRpb25hbGx5IHJlcXVpcmVzIDB4IHByZWZpeDsgcmV0dXJucyBwcmVmaXhlZCBsb3dlcmNhc2UgaGFzaC5cbiAgICBoYXNoKHZhbHVlLCBzdHJpY3QpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gdGhpcy5oZXgodmFsdWUsIHN0cmljdCk7XG4gICAgICAgIGlmIChoZXhEYXRhTGVuZ3RoKHJlc3VsdCkgIT09IDMyKSB7XG4gICAgICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgaGFzaFwiLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSBkaWZmaWN1bHR5IGFzIGEgbnVtYmVyLCBvciBpZiB0b28gbGFyZ2UgKGkuZS4gUG9BIG5ldHdvcmspIG51bGxcbiAgICBkaWZmaWN1bHR5KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB2ID0gQmlnTnVtYmVyLmZyb20odmFsdWUpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcmV0dXJuIHYudG9OdW1iZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgdWludDI1Nih2YWx1ZSkge1xuICAgICAgICBpZiAoIWlzSGV4U3RyaW5nKHZhbHVlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1aW50MjU2XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoZXhaZXJvUGFkKHZhbHVlLCAzMik7XG4gICAgfVxuICAgIF9ibG9jayh2YWx1ZSwgZm9ybWF0KSB7XG4gICAgICAgIGlmICh2YWx1ZS5hdXRob3IgIT0gbnVsbCAmJiB2YWx1ZS5taW5lciA9PSBudWxsKSB7XG4gICAgICAgICAgICB2YWx1ZS5taW5lciA9IHZhbHVlLmF1dGhvcjtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaGUgZGlmZmljdWx0eSBtYXkgbmVlZCB0byBjb21lIGZyb20gX2RpZmZpY3VsdHkgaW4gcmVjdXJzZWQgYmxvY2tzXG4gICAgICAgIGNvbnN0IGRpZmZpY3VsdHkgPSAodmFsdWUuX2RpZmZpY3VsdHkgIT0gbnVsbCkgPyB2YWx1ZS5fZGlmZmljdWx0eSA6IHZhbHVlLmRpZmZpY3VsdHk7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IEZvcm1hdHRlci5jaGVjayhmb3JtYXQsIHZhbHVlKTtcbiAgICAgICAgcmVzdWx0Ll9kaWZmaWN1bHR5ID0gKChkaWZmaWN1bHR5ID09IG51bGwpID8gbnVsbCA6IEJpZ051bWJlci5mcm9tKGRpZmZpY3VsdHkpKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgYmxvY2sodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLCB0aGlzLmZvcm1hdHMuYmxvY2spO1xuICAgIH1cbiAgICBibG9ja1dpdGhUcmFuc2FjdGlvbnModmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Jsb2NrKHZhbHVlLCB0aGlzLmZvcm1hdHMuYmxvY2tXaXRoVHJhbnNhY3Rpb25zKTtcbiAgICB9XG4gICAgLy8gU3RyaWN0ISBVc2VkIG9uIGlucHV0LlxuICAgIHRyYW5zYWN0aW9uUmVxdWVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy50cmFuc2FjdGlvblJlcXVlc3QsIHZhbHVlKTtcbiAgICB9XG4gICAgdHJhbnNhY3Rpb25SZXNwb25zZSh0cmFuc2FjdGlvbikge1xuICAgICAgICAvLyBSZW5hbWUgZ2FzIHRvIGdhc0xpbWl0XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5nYXMgIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5nYXNMaW1pdCA9IHRyYW5zYWN0aW9uLmdhcztcbiAgICAgICAgfVxuICAgICAgICAvLyBTb21lIGNsaWVudHMgKFRlc3RSUEMpIGRvIHN0cmFuZ2UgdGhpbmdzIGxpa2UgcmV0dXJuIDB4MCBmb3IgdGhlXG4gICAgICAgIC8vIDAgYWRkcmVzczsgY29ycmVjdCB0aGlzIHRvIGJlIGEgcmVhbCBhZGRyZXNzXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50byAmJiBCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbi50bykuaXNaZXJvKCkpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnRvID0gXCIweDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDBcIjtcbiAgICAgICAgfVxuICAgICAgICAvLyBSZW5hbWUgaW5wdXQgdG8gZGF0YVxuICAgICAgICBpZiAodHJhbnNhY3Rpb24uaW5wdXQgIT0gbnVsbCAmJiB0cmFuc2FjdGlvbi5kYXRhID09IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmRhdGEgPSB0cmFuc2FjdGlvbi5pbnB1dDtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiB0byBhbmQgY3JlYXRlcyBhcmUgZW1wdHksIHBvcHVsYXRlIHRoZSBjcmVhdGVzIGZyb20gdGhlIHRyYW5zYWN0aW9uXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi50byA9PSBudWxsICYmIHRyYW5zYWN0aW9uLmNyZWF0ZXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdHJhbnNhY3Rpb24uY3JlYXRlcyA9IHRoaXMuY29udHJhY3RBZGRyZXNzKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoKHRyYW5zYWN0aW9uLnR5cGUgPT09IDEgfHwgdHJhbnNhY3Rpb24udHlwZSA9PT0gMikgJiYgdHJhbnNhY3Rpb24uYWNjZXNzTGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0ID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVzdWx0ID0gRm9ybWF0dGVyLmNoZWNrKHRoaXMuZm9ybWF0cy50cmFuc2FjdGlvbiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uY2hhaW5JZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgY2hhaW5JZCA9IHRyYW5zYWN0aW9uLmNoYWluSWQ7XG4gICAgICAgICAgICBpZiAoaXNIZXhTdHJpbmcoY2hhaW5JZCkpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gQmlnTnVtYmVyLmZyb20oY2hhaW5JZCkudG9OdW1iZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxldCBjaGFpbklkID0gdHJhbnNhY3Rpb24ubmV0d29ya0lkO1xuICAgICAgICAgICAgLy8gZ2V0aC1ldGMgcmV0dXJucyBjaGFpbklkXG4gICAgICAgICAgICBpZiAoY2hhaW5JZCA9PSBudWxsICYmIHJlc3VsdC52ID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gdHJhbnNhY3Rpb24uY2hhaW5JZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0hleFN0cmluZyhjaGFpbklkKSkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSBCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIgJiYgcmVzdWx0LnYgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNoYWluSWQgPSAocmVzdWx0LnYgLSAzNSkgLyAyO1xuICAgICAgICAgICAgICAgIGlmIChjaGFpbklkIDwgMCkge1xuICAgICAgICAgICAgICAgICAgICBjaGFpbklkID0gMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2hhaW5JZCA9IHBhcnNlSW50KGNoYWluSWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiAoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0gMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5jaGFpbklkID0gY2hhaW5JZDtcbiAgICAgICAgfVxuICAgICAgICAvLyAweDAwMDAuLi4gc2hvdWxkIGFjdHVhbGx5IGJlIG51bGxcbiAgICAgICAgaWYgKHJlc3VsdC5ibG9ja0hhc2ggJiYgcmVzdWx0LmJsb2NrSGFzaC5yZXBsYWNlKC8wL2csIFwiXCIpID09PSBcInhcIikge1xuICAgICAgICAgICAgcmVzdWx0LmJsb2NrSGFzaCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgdHJhbnNhY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHBhcnNlVHJhbnNhY3Rpb24odmFsdWUpO1xuICAgIH1cbiAgICByZWNlaXB0TG9nKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnJlY2VpcHRMb2csIHZhbHVlKTtcbiAgICB9XG4gICAgcmVjZWlwdCh2YWx1ZSkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLnJlY2VpcHQsIHZhbHVlKTtcbiAgICAgICAgLy8gUlNLIGluY29ycmVjdGx5IGltcGxlbWVudGVkIEVJUC02NTgsIHNvIHdlIG11bmdlIHRoaW5ncyBhIGJpdCBoZXJlIGZvciBpdFxuICAgICAgICBpZiAocmVzdWx0LnJvb3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5yb290Lmxlbmd0aCA8PSA0KSB7XG4gICAgICAgICAgICAgICAgLy8gQ291bGQgYmUgMHgwMCwgMHgwLCAweDAxIG9yIDB4MVxuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gQmlnTnVtYmVyLmZyb20ocmVzdWx0LnJvb3QpLnRvTnVtYmVyKCk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlID09PSAwIHx8IHZhbHVlID09PSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIE1ha2Ugc3VyZSBpZiBib3RoIGFyZSBzcGVjaWZpZWQsIHRoZXkgbWF0Y2hcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5zdGF0dXMgIT0gbnVsbCAmJiAocmVzdWx0LnN0YXR1cyAhPT0gdmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiYWx0LXJvb3Qtc3RhdHVzL3N0YXR1cyBtaXNtYXRjaFwiLCBcInZhbHVlXCIsIHsgcm9vdDogcmVzdWx0LnJvb3QsIHN0YXR1czogcmVzdWx0LnN0YXR1cyB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXN1bHQuc3RhdHVzID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSByZXN1bHQucm9vdDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGFsdC1yb290LXN0YXR1c1wiLCBcInZhbHVlLnJvb3RcIiwgcmVzdWx0LnJvb3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHJlc3VsdC5yb290Lmxlbmd0aCAhPT0gNjYpIHtcbiAgICAgICAgICAgICAgICAvLyBNdXN0IGJlIGEgdmFsaWQgYnl0ZXMzMlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHJvb3QgaGFzaFwiLCBcInZhbHVlLnJvb3RcIiwgcmVzdWx0LnJvb3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQuc3RhdHVzICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ieXphbnRpdW0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHRvcGljcyh2YWx1ZSkge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZS5tYXAoKHYpID0+IHRoaXMudG9waWNzKHYpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh2YWx1ZSAhPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5oYXNoKHZhbHVlLCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgZmlsdGVyKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBGb3JtYXR0ZXIuY2hlY2sodGhpcy5mb3JtYXRzLmZpbHRlciwgdmFsdWUpO1xuICAgIH1cbiAgICBmaWx0ZXJMb2codmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIEZvcm1hdHRlci5jaGVjayh0aGlzLmZvcm1hdHMuZmlsdGVyTG9nLCB2YWx1ZSk7XG4gICAgfVxuICAgIHN0YXRpYyBjaGVjayhmb3JtYXQsIG9iamVjdCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZm9ybWF0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZm9ybWF0W2tleV0ob2JqZWN0W2tleV0pO1xuICAgICAgICAgICAgICAgIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgZXJyb3IuY2hlY2tLZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgZXJyb3IuY2hlY2tWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIGlmIHZhbHVlIGlzIG51bGwtaXNoLCBudWxsVmFsdWUgaXMgcmV0dXJuZWRcbiAgICBzdGF0aWMgYWxsb3dOdWxsKGZvcm1hdCwgbnVsbFZhbHVlKSB7XG4gICAgICAgIHJldHVybiAoZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBudWxsVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIElmIHZhbHVlIGlzIGZhbHNlLWlzaCwgcmVwbGFjZVZhbHVlIGlzIHJldHVybmVkXG4gICAgc3RhdGljIGFsbG93RmFsc2lzaChmb3JtYXQsIHJlcGxhY2VWYWx1ZSkge1xuICAgICAgICByZXR1cm4gKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICAgICAgaWYgKCF2YWx1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlVmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZm9ybWF0KHZhbHVlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIFJlcXVpcmVzIGFuIEFycmF5IHNhdGlzZnlpbmcgY2hlY2tcbiAgICBzdGF0aWMgYXJyYXlPZihmb3JtYXQpIHtcbiAgICAgICAgcmV0dXJuIChmdW5jdGlvbiAoYXJyYXkpIHtcbiAgICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcnJheSkpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJub3QgYW4gYXJyYXlcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goZm9ybWF0KHZhbHVlKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydCBmdW5jdGlvbiBpc0NvbW11bml0eVJlc291cmNhYmxlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAmJiB0eXBlb2YgKHZhbHVlLmlzQ29tbXVuaXR5UmVzb3VyY2UpID09PSBcImZ1bmN0aW9uXCIpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGlzQ29tbXVuaXR5UmVzb3VyY2UodmFsdWUpIHtcbiAgICByZXR1cm4gKGlzQ29tbXVuaXR5UmVzb3VyY2FibGUodmFsdWUpICYmIHZhbHVlLmlzQ29tbXVuaXR5UmVzb3VyY2UoKSk7XG59XG4vLyBTaG93IHRoZSB0aHJvdHRsZSBtZXNzYWdlIG9ubHkgb25jZVxubGV0IHRocm90dGxlTWVzc2FnZSA9IGZhbHNlO1xuZXhwb3J0IGZ1bmN0aW9uIHNob3dUaHJvdHRsZU1lc3NhZ2UoKSB7XG4gICAgaWYgKHRocm90dGxlTWVzc2FnZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHRocm90dGxlTWVzc2FnZSA9IHRydWU7XG4gICAgY29uc29sZS5sb2coXCI9PT09PT09PT0gTk9USUNFID09PT09PT09PVwiKTtcbiAgICBjb25zb2xlLmxvZyhcIlJlcXVlc3QtUmF0ZSBFeGNlZWRlZCAgKHRoaXMgbWVzc2FnZSB3aWxsIG5vdCBiZSByZXBlYXRlZClcIik7XG4gICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgY29uc29sZS5sb2coXCJUaGUgZGVmYXVsdCBBUEkga2V5cyBmb3IgZWFjaCBzZXJ2aWNlIGFyZSBwcm92aWRlZCBhcyBhIGhpZ2hseS10aHJvdHRsZWQsXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiY29tbXVuaXR5IHJlc291cmNlIGZvciBsb3ctdHJhZmZpYyBwcm9qZWN0cyBhbmQgZWFybHkgcHJvdG90eXBpbmcuXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiV2hpbGUgeW91ciBhcHBsaWNhdGlvbiB3aWxsIGNvbnRpbnVlIHRvIGZ1bmN0aW9uLCB3ZSBoaWdobHkgcmVjb21tZW5kZWRcIik7XG4gICAgY29uc29sZS5sb2coXCJzaWduaW5nIHVwIGZvciB5b3VyIG93biBBUEkga2V5cyB0byBpbXByb3ZlIHBlcmZvcm1hbmNlLCBpbmNyZWFzZSB5b3VyXCIpO1xuICAgIGNvbnNvbGUubG9nKFwicmVxdWVzdCByYXRlL2xpbWl0IGFuZCBlbmFibGUgb3RoZXIgcGVya3MsIHN1Y2ggYXMgbWV0cmljcyBhbmQgYWR2YW5jZWQgQVBJcy5cIik7XG4gICAgY29uc29sZS5sb2coXCJcIik7XG4gICAgY29uc29sZS5sb2coXCJGb3IgbW9yZSBkZXRhaWxzOiBodHRwczovXFwvZG9jcy5ldGhlcnMuaW8vYXBpLWtleXMvXCIpO1xuICAgIGNvbnNvbGUubG9nKFwiPT09PT09PT09PT09PT09PT09PT09PT09PT1cIik7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1mb3JtYXR0ZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBQcm92aWRlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1wcm92aWRlclwiO1xuaW1wb3J0IHsgZ2V0TmV0d29yayB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9uZXR3b3Jrc1wiO1xuaW1wb3J0IHsgQmFzZVByb3ZpZGVyLCBSZXNvbHZlciB9IGZyb20gXCIuL2Jhc2UtcHJvdmlkZXJcIjtcbmltcG9ydCB7IEFsY2hlbXlQcm92aWRlciwgQWxjaGVteVdlYlNvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vYWxjaGVteS1wcm92aWRlclwiO1xuaW1wb3J0IHsgQ2xvdWRmbGFyZVByb3ZpZGVyIH0gZnJvbSBcIi4vY2xvdWRmbGFyZS1wcm92aWRlclwiO1xuaW1wb3J0IHsgRXRoZXJzY2FuUHJvdmlkZXIgfSBmcm9tIFwiLi9ldGhlcnNjYW4tcHJvdmlkZXJcIjtcbmltcG9ydCB7IEZhbGxiYWNrUHJvdmlkZXIgfSBmcm9tIFwiLi9mYWxsYmFjay1wcm92aWRlclwiO1xuaW1wb3J0IHsgSXBjUHJvdmlkZXIgfSBmcm9tIFwiLi9pcGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IEluZnVyYVByb3ZpZGVyLCBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL2luZnVyYS1wcm92aWRlclwiO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyLCBKc29uUnBjU2lnbmVyIH0gZnJvbSBcIi4vanNvbi1ycGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IEpzb25ScGNCYXRjaFByb3ZpZGVyIH0gZnJvbSBcIi4vanNvbi1ycGMtYmF0Y2gtcHJvdmlkZXJcIjtcbmltcG9ydCB7IE5vZGVzbWl0aFByb3ZpZGVyIH0gZnJvbSBcIi4vbm9kZXNtaXRoLXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBQb2NrZXRQcm92aWRlciB9IGZyb20gXCIuL3BvY2tldC1wcm92aWRlclwiO1xuaW1wb3J0IHsgU3RhdGljSnNvblJwY1Byb3ZpZGVyLCBVcmxKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi91cmwtanNvbi1ycGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IFdlYjNQcm92aWRlciB9IGZyb20gXCIuL3dlYjMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IFdlYlNvY2tldFByb3ZpZGVyIH0gZnJvbSBcIi4vd2Vic29ja2V0LXByb3ZpZGVyXCI7XG5pbXBvcnQgeyBGb3JtYXR0ZXIsIGlzQ29tbXVuaXR5UmVzb3VyY2FibGUsIGlzQ29tbXVuaXR5UmVzb3VyY2UsIHNob3dUaHJvdHRsZU1lc3NhZ2UgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gSGVscGVyIEZ1bmN0aW9uc1xuZnVuY3Rpb24gZ2V0RGVmYXVsdFByb3ZpZGVyKG5ldHdvcmssIG9wdGlvbnMpIHtcbiAgICBpZiAobmV0d29yayA9PSBudWxsKSB7XG4gICAgICAgIG5ldHdvcmsgPSBcImhvbWVzdGVhZFwiO1xuICAgIH1cbiAgICAvLyBJZiBwYXNzZWQgYSBVUkwsIGZpZ3VyZSBvdXQgdGhlIHJpZ2h0IHR5cGUgb2YgcHJvdmlkZXIgYmFzZWQgb24gdGhlIHNjaGVtZVxuICAgIGlmICh0eXBlb2YgKG5ldHdvcmspID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIC8vIEBUT0RPOiBBZGQgc3VwcG9ydCBmb3IgSXBjUHJvdmlkZXI7IG1heWJlIGlmIGl0IGVuZHMgaW4gXCIuaXBjXCI/XG4gICAgICAgIC8vIEhhbmRsZSBodHRwIGFuZCB3cyAoYW5kIHRoZWlyIHNlY3VyZSB2YXJpYW50cylcbiAgICAgICAgY29uc3QgbWF0Y2ggPSBuZXR3b3JrLm1hdGNoKC9eKHdzfGh0dHApcz86L2kpO1xuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHN3aXRjaCAobWF0Y2hbMV0pIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiaHR0cFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gbmV3IEpzb25ScGNQcm92aWRlcihuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwid3NcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBXZWJTb2NrZXRQcm92aWRlcihuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgVVJMIHNjaGVtZVwiLCBcIm5ldHdvcmtcIiwgbmV0d29yayk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbiA9IGdldE5ldHdvcmsobmV0d29yayk7XG4gICAgaWYgKCFuIHx8ICFuLl9kZWZhdWx0UHJvdmlkZXIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBnZXREZWZhdWx0UHJvdmlkZXIgbmV0d29ya1wiLCBMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXREZWZhdWx0UHJvdmlkZXJcIixcbiAgICAgICAgICAgIG5ldHdvcms6IG5ldHdvcmtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBuLl9kZWZhdWx0UHJvdmlkZXIoe1xuICAgICAgICBGYWxsYmFja1Byb3ZpZGVyLFxuICAgICAgICBBbGNoZW15UHJvdmlkZXIsXG4gICAgICAgIENsb3VkZmxhcmVQcm92aWRlcixcbiAgICAgICAgRXRoZXJzY2FuUHJvdmlkZXIsXG4gICAgICAgIEluZnVyYVByb3ZpZGVyLFxuICAgICAgICBKc29uUnBjUHJvdmlkZXIsXG4gICAgICAgIE5vZGVzbWl0aFByb3ZpZGVyLFxuICAgICAgICBQb2NrZXRQcm92aWRlcixcbiAgICAgICAgV2ViM1Byb3ZpZGVyLFxuICAgICAgICBJcGNQcm92aWRlcixcbiAgICB9LCBvcHRpb25zKTtcbn1cbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRXhwb3J0c1xuZXhwb3J0IHsgXG4vLyBBYnN0cmFjdCBQcm92aWRlcnMgKG9yIEFic3RyYWN0LWlzaClcblByb3ZpZGVyLCBCYXNlUHJvdmlkZXIsIFJlc29sdmVyLCBVcmxKc29uUnBjUHJvdmlkZXIsIFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIENvbmNyZXRlIFByb3ZpZGVyc1xuRmFsbGJhY2tQcm92aWRlciwgQWxjaGVteVByb3ZpZGVyLCBBbGNoZW15V2ViU29ja2V0UHJvdmlkZXIsIENsb3VkZmxhcmVQcm92aWRlciwgRXRoZXJzY2FuUHJvdmlkZXIsIEluZnVyYVByb3ZpZGVyLCBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciwgSnNvblJwY1Byb3ZpZGVyLCBKc29uUnBjQmF0Y2hQcm92aWRlciwgTm9kZXNtaXRoUHJvdmlkZXIsIFBvY2tldFByb3ZpZGVyLCBTdGF0aWNKc29uUnBjUHJvdmlkZXIsIFdlYjNQcm92aWRlciwgV2ViU29ja2V0UHJvdmlkZXIsIElwY1Byb3ZpZGVyLCBcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBTaWduZXJcbkpzb25ScGNTaWduZXIsIFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEZ1bmN0aW9uc1xuZ2V0RGVmYXVsdFByb3ZpZGVyLCBnZXROZXR3b3JrLCBpc0NvbW11bml0eVJlc291cmNlLCBpc0NvbW11bml0eVJlc291cmNhYmxlLCBzaG93VGhyb3R0bGVNZXNzYWdlLCBcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBPYmplY3RzXG5Gb3JtYXR0ZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgV2ViU29ja2V0UHJvdmlkZXIgfSBmcm9tIFwiLi93ZWJzb2NrZXQtcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNob3dUaHJvdHRsZU1lc3NhZ2UgfSBmcm9tIFwiLi9mb3JtYXR0ZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IFVybEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiO1xuY29uc3QgZGVmYXVsdFByb2plY3RJZCA9IFwiODQ4NDIwNzhiMDk5NDY2MzhjMDMxNTdmODM0MDUyMTNcIjtcbmV4cG9ydCBjbGFzcyBJbmZ1cmFXZWJTb2NrZXRQcm92aWRlciBleHRlbmRzIFdlYlNvY2tldFByb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgY29uc3QgcHJvdmlkZXIgPSBuZXcgSW5mdXJhUHJvdmlkZXIobmV0d29yaywgYXBpS2V5KTtcbiAgICAgICAgY29uc3QgY29ubmVjdGlvbiA9IHByb3ZpZGVyLmNvbm5lY3Rpb247XG4gICAgICAgIGlmIChjb25uZWN0aW9uLnBhc3N3b3JkKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIklORlVSQSBXZWJTb2NrZXQgcHJvamVjdCBzZWNyZXRzIHVuc3VwcG9ydGVkXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcIkluZnVyYVByb3ZpZGVyLmdldFdlYlNvY2tldFByb3ZpZGVyKClcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdXJsID0gY29ubmVjdGlvbi51cmwucmVwbGFjZSgvXmh0dHAvaSwgXCJ3c1wiKS5yZXBsYWNlKFwiL3YzL1wiLCBcIi93cy92My9cIik7XG4gICAgICAgIHN1cGVyKHVybCwgbmV0d29yayk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYXBpS2V5XCIsIHByb3ZpZGVyLnByb2plY3RJZCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvamVjdElkXCIsIHByb3ZpZGVyLnByb2plY3RJZCk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwicHJvamVjdFNlY3JldFwiLCBwcm92aWRlci5wcm9qZWN0U2VjcmV0KTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnByb2plY3RJZCA9PT0gZGVmYXVsdFByb2plY3RJZCk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIEluZnVyYVByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBzdGF0aWMgZ2V0V2ViU29ja2V0UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBuZXcgSW5mdXJhV2ViU29ja2V0UHJvdmlkZXIobmV0d29yaywgYXBpS2V5KTtcbiAgICB9XG4gICAgc3RhdGljIGdldEFwaUtleShhcGlLZXkpIHtcbiAgICAgICAgY29uc3QgYXBpS2V5T2JqID0ge1xuICAgICAgICAgICAgYXBpS2V5OiBkZWZhdWx0UHJvamVjdElkLFxuICAgICAgICAgICAgcHJvamVjdElkOiBkZWZhdWx0UHJvamVjdElkLFxuICAgICAgICAgICAgcHJvamVjdFNlY3JldDogbnVsbFxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXBpS2V5ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBhcGlLZXlPYmo7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYXBpS2V5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RJZCA9IGFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdFNlY3JldCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LnByb2plY3RJZCkgPT09IFwic3RyaW5nXCIpLCBcInByb2plY3RTZWNyZXQgcmVxdWlyZXMgYSBwcm9qZWN0SWRcIiwgXCJwcm9qZWN0SWRcIiwgYXBpS2V5LnByb2plY3RJZCk7XG4gICAgICAgICAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKHR5cGVvZiAoYXBpS2V5LnByb2plY3RTZWNyZXQpID09PSBcInN0cmluZ1wiKSwgXCJpbnZhbGlkIHByb2plY3RTZWNyZXRcIiwgXCJwcm9qZWN0U2VjcmV0XCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgICAgIGFwaUtleU9iai5wcm9qZWN0SWQgPSBhcGlLZXkucHJvamVjdElkO1xuICAgICAgICAgICAgYXBpS2V5T2JqLnByb2plY3RTZWNyZXQgPSBhcGlLZXkucHJvamVjdFNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkucHJvamVjdElkKSB7XG4gICAgICAgICAgICBhcGlLZXlPYmoucHJvamVjdElkID0gYXBpS2V5LnByb2plY3RJZDtcbiAgICAgICAgfVxuICAgICAgICBhcGlLZXlPYmouYXBpS2V5ID0gYXBpS2V5T2JqLnByb2plY3RJZDtcbiAgICAgICAgcmV0dXJuIGFwaUtleU9iajtcbiAgICB9XG4gICAgc3RhdGljIGdldFVybChuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgbGV0IGhvc3QgPSBudWxsO1xuICAgICAgICBzd2l0Y2ggKG5ldHdvcmsgPyBuZXR3b3JrLm5hbWUgOiBcInVua25vd25cIikge1xuICAgICAgICAgICAgY2FzZSBcImhvbWVzdGVhZFwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicm9wc3RlblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInJvcHN0ZW4uaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcInJpbmtlYnkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwia292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJrb3Zhbi5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJnb2VybGkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibWF0aWNtdW1cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJwb2x5Z29uLW11bWJhaS5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJvcHRpbWlzbVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcIm9wdGltaXNtLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwib3B0aW1pc20ta292YW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJvcHRpbWlzbS1rb3Zhbi5pbmZ1cmEuaW9cIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJhcmJpdHJ1bVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYml0cnVtLW1haW5uZXQuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYXJiaXRydW0tcmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImFyYml0cnVtLXJpbmtlYnkuaW5mdXJhLmlvXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV0d29ya1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSB7XG4gICAgICAgICAgICBhbGxvd0d6aXA6IHRydWUsXG4gICAgICAgICAgICB1cmw6IChcImh0dHBzOi9cIiArIFwiL1wiICsgaG9zdCArIFwiL3YzL1wiICsgYXBpS2V5LnByb2plY3RJZCksXG4gICAgICAgICAgICB0aHJvdHRsZUNhbGxiYWNrOiAoYXR0ZW1wdCwgdXJsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGFwaUtleS5wcm9qZWN0SWQgPT09IGRlZmF1bHRQcm9qZWN0SWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2hvd1Rocm90dGxlTWVzc2FnZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHRydWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBpZiAoYXBpS2V5LnByb2plY3RTZWNyZXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51c2VyID0gXCJcIjtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ucGFzc3dvcmQgPSBhcGlLZXkucHJvamVjdFNlY3JldDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY29ubmVjdGlvbjtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnByb2plY3RJZCA9PT0gZGVmYXVsdFByb2plY3RJZCk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5mdXJhLXByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuY29uc3QgSXBjUHJvdmlkZXIgPSBudWxsO1xuZXhwb3J0IHsgSXBjUHJvdmlkZXIgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlwYy1wcm92aWRlci5qcy5tYXAiLCJpbXBvcnQgeyBkZWVwQ29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBmZXRjaEpzb24gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvd2ViXCI7XG5pbXBvcnQgeyBKc29uUnBjUHJvdmlkZXIgfSBmcm9tIFwiLi9qc29uLXJwYy1wcm92aWRlclwiO1xuLy8gRXhwZXJpbWVudGFsXG5leHBvcnQgY2xhc3MgSnNvblJwY0JhdGNoUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXIge1xuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHtcbiAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgcGFyYW1zOiBwYXJhbXMsXG4gICAgICAgICAgICBpZDogKHRoaXMuX25leHRJZCsrKSxcbiAgICAgICAgICAgIGpzb25ycGM6IFwiMi4wXCJcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuX3BlbmRpbmdCYXRjaCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQmF0Y2ggPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpbmZsaWdodFJlcXVlc3QgPSB7IHJlcXVlc3QsIHJlc29sdmU6IG51bGwsIHJlamVjdDogbnVsbCB9O1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlc29sdmUgPSByZXNvbHZlO1xuICAgICAgICAgICAgaW5mbGlnaHRSZXF1ZXN0LnJlamVjdCA9IHJlamVjdDtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3BlbmRpbmdCYXRjaC5wdXNoKGluZmxpZ2h0UmVxdWVzdCk7XG4gICAgICAgIGlmICghdGhpcy5fcGVuZGluZ0JhdGNoQWdncmVnYXRvcikge1xuICAgICAgICAgICAgLy8gU2NoZWR1bGUgYmF0Y2ggZm9yIG5leHQgZXZlbnQgbG9vcCArIHNob3J0IGR1cmF0aW9uXG4gICAgICAgICAgICB0aGlzLl9wZW5kaW5nQmF0Y2hBZ2dyZWdhdG9yID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRlaCBjdXJyZW50IGJhdGNoIGFuZCBjbGVhciBpdCwgc28gbmV3IHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgLy8gZ28gaW50byB0aGUgbmV4dCBiYXRjaFxuICAgICAgICAgICAgICAgIGNvbnN0IGJhdGNoID0gdGhpcy5fcGVuZGluZ0JhdGNoO1xuICAgICAgICAgICAgICAgIHRoaXMuX3BlbmRpbmdCYXRjaCA9IG51bGw7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0JhdGNoQWdncmVnYXRvciA9IG51bGw7XG4gICAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZXF1ZXN0IGFzIGFuIGFycmF5IG9mIHJlcXVlc3RzXG4gICAgICAgICAgICAgICAgY29uc3QgcmVxdWVzdCA9IGJhdGNoLm1hcCgoaW5mbGlnaHQpID0+IGluZmxpZ2h0LnJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RCYXRjaFwiLFxuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBkZWVwQ29weShyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZmV0Y2hKc29uKHRoaXMuY29ubmVjdGlvbiwgSlNPTi5zdHJpbmdpZnkocmVxdWVzdCkpLnRoZW4oKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zZTogcmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIC8vIEZvciBlYWNoIHJlc3VsdCwgZmVlZCBpdCB0byB0aGUgY29ycmVjdCBQcm9taXNlLCBkZXBlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgLy8gb24gd2hldGhlciBpdCB3YXMgYSBzdWNjZXNzIG9yIGVycm9yXG4gICAgICAgICAgICAgICAgICAgIGJhdGNoLmZvckVhY2goKGluZmxpZ2h0UmVxdWVzdCwgaW5kZXgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSByZXN1bHRbaW5kZXhdO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBheWxvYWQuZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLmNvZGUgPSBwYXlsb2FkLmVycm9yLmNvZGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IuZGF0YSA9IHBheWxvYWQuZXJyb3IuZGF0YTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbmZsaWdodFJlcXVlc3QucmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZXNvbHZlKHBheWxvYWQucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBiYXRjaC5mb3JFYWNoKChpbmZsaWdodFJlcXVlc3QpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGluZmxpZ2h0UmVxdWVzdC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIDEwKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcHJvbWlzZTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1qc29uLXJwYy1iYXRjaC1wcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgU2lnbmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Fic3RyYWN0LXNpZ25lclwiO1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgaGV4bGlmeSwgaGV4VmFsdWUsIGlzSGV4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBfVHlwZWREYXRhRW5jb2RlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oYXNoXCI7XG5pbXBvcnQgeyBjaGVja1Byb3BlcnRpZXMsIGRlZXBDb3B5LCBkZWZpbmVSZWFkT25seSwgZ2V0U3RhdGljLCByZXNvbHZlUHJvcGVydGllcywgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgdG9VdGY4Qnl0ZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc3RyaW5nc1wiO1xuaW1wb3J0IHsgYWNjZXNzTGlzdGlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IGZldGNoSnNvbiwgcG9sbCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC93ZWJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IEJhc2VQcm92aWRlciB9IGZyb20gXCIuL2Jhc2UtcHJvdmlkZXJcIjtcbmNvbnN0IGVycm9yR2FzID0gW1wiY2FsbFwiLCBcImVzdGltYXRlR2FzXCJdO1xuZnVuY3Rpb24gY2hlY2tFcnJvcihtZXRob2QsIGVycm9yLCBwYXJhbXMpIHtcbiAgICAvLyBVbmRvIHRoZSBcImNvbnZlbmllbmNlXCIgc29tZSBub2RlcyBhcmUgYXR0ZW1wdGluZyB0byBwcmV2ZW50IGJhY2t3YXJkc1xuICAgIC8vIGluY29tcGF0aWJpbGl0eTsgbWF5YmUgZm9yIHY2IGNvbnNpZGVyIGZvcndhcmRpbmcgcmV2ZXJ0cyBhcyBlcnJvcnNcbiAgICBpZiAobWV0aG9kID09PSBcImNhbGxcIiAmJiBlcnJvci5jb2RlID09PSBMb2dnZXIuZXJyb3JzLlNFUlZFUl9FUlJPUikge1xuICAgICAgICBjb25zdCBlID0gZXJyb3IuZXJyb3I7XG4gICAgICAgIGlmIChlICYmIGUubWVzc2FnZS5tYXRjaChcInJldmVydGVkXCIpICYmIGlzSGV4U3RyaW5nKGUuZGF0YSkpIHtcbiAgICAgICAgICAgIHJldHVybiBlLmRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHJldmVydCBkYXRhIGluIGNhbGwgZXhjZXB0aW9uXCIsIExvZ2dlci5lcnJvcnMuQ0FMTF9FWENFUFRJT04sIHtcbiAgICAgICAgICAgIGVycm9yLCBkYXRhOiBcIjB4XCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGxldCBtZXNzYWdlID0gZXJyb3IubWVzc2FnZTtcbiAgICBpZiAoZXJyb3IuY29kZSA9PT0gTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IgJiYgZXJyb3IuZXJyb3IgJiYgdHlwZW9mIChlcnJvci5lcnJvci5tZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IuZXJyb3IubWVzc2FnZTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChlcnJvci5ib2R5KSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBtZXNzYWdlID0gZXJyb3IuYm9keTtcbiAgICB9XG4gICAgZWxzZSBpZiAodHlwZW9mIChlcnJvci5yZXNwb25zZVRleHQpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG1lc3NhZ2UgPSBlcnJvci5yZXNwb25zZVRleHQ7XG4gICAgfVxuICAgIG1lc3NhZ2UgPSAobWVzc2FnZSB8fCBcIlwiKS50b0xvd2VyQ2FzZSgpO1xuICAgIGNvbnN0IHRyYW5zYWN0aW9uID0gcGFyYW1zLnRyYW5zYWN0aW9uIHx8IHBhcmFtcy5zaWduZWRUcmFuc2FjdGlvbjtcbiAgICAvLyBcImluc3VmZmljaWVudCBmdW5kcyBmb3IgZ2FzICogcHJpY2UgKyB2YWx1ZSArIGNvc3QoZGF0YSlcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9pbnN1ZmZpY2llbnQgZnVuZHN8YmFzZSBmZWUgZXhjZWVkcyBnYXMgbGltaXQvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImluc3VmZmljaWVudCBmdW5kcyBmb3IgaW50cmluc2ljIHRyYW5zYWN0aW9uIGNvc3RcIiwgTG9nZ2VyLmVycm9ycy5JTlNVRkZJQ0lFTlRfRlVORFMsIHtcbiAgICAgICAgICAgIGVycm9yLCBtZXRob2QsIHRyYW5zYWN0aW9uXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvLyBcIm5vbmNlIHRvbyBsb3dcIlxuICAgIGlmIChtZXNzYWdlLm1hdGNoKC9ub25jZSB0b28gbG93LykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJub25jZSBoYXMgYWxyZWFkeSBiZWVuIHVzZWRcIiwgTG9nZ2VyLmVycm9ycy5OT05DRV9FWFBJUkVELCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL3JlcGxhY2VtZW50IHRyYW5zYWN0aW9uIHVuZGVycHJpY2VkLykpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJyZXBsYWNlbWVudCBmZWUgdG9vIGxvd1wiLCBMb2dnZXIuZXJyb3JzLlJFUExBQ0VNRU5UX1VOREVSUFJJQ0VELCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgLy8gXCJyZXBsYWNlbWVudCB0cmFuc2FjdGlvbiB1bmRlcnByaWNlZFwiXG4gICAgaWYgKG1lc3NhZ2UubWF0Y2goL29ubHkgcmVwbGF5LXByb3RlY3RlZC8pKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwibGVnYWN5IHByZS1laXAtMTU1IHRyYW5zYWN0aW9ucyBub3Qgc3VwcG9ydGVkXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBlcnJvciwgbWV0aG9kLCB0cmFuc2FjdGlvblxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yR2FzLmluZGV4T2YobWV0aG9kKSA+PSAwICYmIG1lc3NhZ2UubWF0Y2goL2dhcyByZXF1aXJlZCBleGNlZWRzIGFsbG93YW5jZXxhbHdheXMgZmFpbGluZyB0cmFuc2FjdGlvbnxleGVjdXRpb24gcmV2ZXJ0ZWQvKSkge1xuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBlc3RpbWF0ZSBnYXM7IHRyYW5zYWN0aW9uIG1heSBmYWlsIG9yIG1heSByZXF1aXJlIG1hbnVhbCBnYXMgbGltaXRcIiwgTG9nZ2VyLmVycm9ycy5VTlBSRURJQ1RBQkxFX0dBU19MSU1JVCwge1xuICAgICAgICAgICAgZXJyb3IsIG1ldGhvZCwgdHJhbnNhY3Rpb25cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xufVxuZnVuY3Rpb24gdGltZXIodGltZW91dCkge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIHRpbWVvdXQpO1xuICAgIH0pO1xufVxuZnVuY3Rpb24gZ2V0UmVzdWx0KHBheWxvYWQpIHtcbiAgICBpZiAocGF5bG9hZC5lcnJvcikge1xuICAgICAgICAvLyBAVE9ETzogbm90IGFueVxuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihwYXlsb2FkLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBlcnJvci5jb2RlID0gcGF5bG9hZC5lcnJvci5jb2RlO1xuICAgICAgICBlcnJvci5kYXRhID0gcGF5bG9hZC5lcnJvci5kYXRhO1xuICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgcmV0dXJuIHBheWxvYWQucmVzdWx0O1xufVxuZnVuY3Rpb24gZ2V0TG93ZXJDYXNlKHZhbHVlKSB7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBfY29uc3RydWN0b3JHdWFyZCA9IHt9O1xuZXhwb3J0IGNsYXNzIEpzb25ScGNTaWduZXIgZXh0ZW5kcyBTaWduZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbnN0cnVjdG9yR3VhcmQsIHByb3ZpZGVyLCBhZGRyZXNzT3JJbmRleCkge1xuICAgICAgICBsb2dnZXIuY2hlY2tOZXcobmV3LnRhcmdldCwgSnNvblJwY1NpZ25lcik7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIGlmIChjb25zdHJ1Y3Rvckd1YXJkICE9PSBfY29uc3RydWN0b3JHdWFyZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZG8gbm90IGNhbGwgdGhlIEpzb25ScGNTaWduZXIgY29uc3RydWN0b3IgZGlyZWN0bHk7IHVzZSBwcm92aWRlci5nZXRTaWduZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgIGlmIChhZGRyZXNzT3JJbmRleCA9PSBudWxsKSB7XG4gICAgICAgICAgICBhZGRyZXNzT3JJbmRleCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAoYWRkcmVzc09ySW5kZXgpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9hZGRyZXNzXCIsIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWRkcmVzc09ySW5kZXgpKTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2luZGV4XCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiAoYWRkcmVzc09ySW5kZXgpID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9pbmRleFwiLCBhZGRyZXNzT3JJbmRleCk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9hZGRyZXNzXCIsIG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgYWRkcmVzcyBvciBpbmRleFwiLCBcImFkZHJlc3NPckluZGV4XCIsIGFkZHJlc3NPckluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25uZWN0KHByb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBhbHRlciBKU09OLVJQQyBTaWduZXIgY29ubmVjdGlvblwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcImNvbm5lY3RcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29ubmVjdFVuY2hlY2tlZCgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVbmNoZWNrZWRKc29uUnBjU2lnbmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0aGlzLnByb3ZpZGVyLCB0aGlzLl9hZGRyZXNzIHx8IHRoaXMuX2luZGV4KTtcbiAgICB9XG4gICAgZ2V0QWRkcmVzcygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2FkZHJlc3MpIHtcbiAgICAgICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5fYWRkcmVzcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuc2VuZChcImV0aF9hY2NvdW50c1wiLCBbXSkudGhlbigoYWNjb3VudHMpID0+IHtcbiAgICAgICAgICAgIGlmIChhY2NvdW50cy5sZW5ndGggPD0gdGhpcy5faW5kZXgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInVua25vd24gYWNjb3VudCAjXCIgKyB0aGlzLl9pbmRleCwgTG9nZ2VyLmVycm9ycy5VTlNVUFBPUlRFRF9PUEVSQVRJT04sIHtcbiAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uOiBcImdldEFkZHJlc3NcIlxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIuZm9ybWF0dGVyLmFkZHJlc3MoYWNjb3VudHNbdGhpcy5faW5kZXhdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNlbmRVbmNoZWNrZWRUcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICB0cmFuc2FjdGlvbiA9IHNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcbiAgICAgICAgY29uc3QgZnJvbUFkZHJlc3MgPSB0aGlzLmdldEFkZHJlc3MoKS50aGVuKChhZGRyZXNzKSA9PiB7XG4gICAgICAgICAgICBpZiAoYWRkcmVzcykge1xuICAgICAgICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWRkcmVzcztcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFRoZSBKU09OLVJQQyBmb3IgZXRoX3NlbmRUcmFuc2FjdGlvbiB1c2VzIDkwMDAwIGdhczsgaWYgdGhlIHVzZXJcbiAgICAgICAgLy8gd2lzaGVzIHRvIHVzZSB0aGlzLCBpdCBpcyBlYXN5IHRvIHNwZWNpZnkgZXhwbGljaXRseSwgb3RoZXJ3aXNlXG4gICAgICAgIC8vIHdlIGxvb2sgaXQgdXAgZm9yIHRoZW0uXG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5nYXNMaW1pdCA9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBlc3RpbWF0ZSA9IHNoYWxsb3dDb3B5KHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIGVzdGltYXRlLmZyb20gPSBmcm9tQWRkcmVzcztcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLmdhc0xpbWl0ID0gdGhpcy5wcm92aWRlci5lc3RpbWF0ZUdhcyhlc3RpbWF0ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRyYW5zYWN0aW9uLnRvICE9IG51bGwpIHtcbiAgICAgICAgICAgIHRyYW5zYWN0aW9uLnRvID0gUHJvbWlzZS5yZXNvbHZlKHRyYW5zYWN0aW9uLnRvKS50aGVuKCh0bykgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgIGlmICh0byA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBhZGRyZXNzID0geWllbGQgdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZSh0byk7XG4gICAgICAgICAgICAgICAgaWYgKGFkZHJlc3MgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwicHJvdmlkZWQgRU5TIG5hbWUgcmVzb2x2ZXMgdG8gbnVsbFwiLCBcInR4LnRvXCIsIHRvKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFkZHJlc3M7XG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc29sdmVQcm9wZXJ0aWVzKHtcbiAgICAgICAgICAgIHR4OiByZXNvbHZlUHJvcGVydGllcyh0cmFuc2FjdGlvbiksXG4gICAgICAgICAgICBzZW5kZXI6IGZyb21BZGRyZXNzXG4gICAgICAgIH0pLnRoZW4oKHsgdHgsIHNlbmRlciB9KSA9PiB7XG4gICAgICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR4LmZyb20udG9Mb3dlckNhc2UoKSAhPT0gc2VuZGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJmcm9tIGFkZHJlc3MgbWlzbWF0Y2hcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHguZnJvbSA9IHNlbmRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGhleFR4ID0gdGhpcy5wcm92aWRlci5jb25zdHJ1Y3Rvci5oZXhsaWZ5VHJhbnNhY3Rpb24odHgsIHsgZnJvbTogdHJ1ZSB9KTtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2VuZFRyYW5zYWN0aW9uXCIsIFtoZXhUeF0pLnRoZW4oKGhhc2gpID0+IHtcbiAgICAgICAgICAgICAgICByZXR1cm4gaGFzaDtcbiAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiBjaGVja0Vycm9yKFwic2VuZFRyYW5zYWN0aW9uXCIsIGVycm9yLCBoZXhUeCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJzaWduaW5nIHRyYW5zYWN0aW9ucyBpcyB1bnN1cHBvcnRlZFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNpZ25UcmFuc2FjdGlvblwiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIFRoaXMgY2Fubm90IGJlIG1pbmVkIGFueSBlYXJsaWVyIHRoYW4gYW55IHJlY2VudCBibG9ja1xuICAgICAgICAgICAgY29uc3QgYmxvY2tOdW1iZXIgPSB5aWVsZCB0aGlzLnByb3ZpZGVyLl9nZXRJbnRlcm5hbEJsb2NrTnVtYmVyKDEwMCArIDIgKiB0aGlzLnByb3ZpZGVyLnBvbGxpbmdJbnRlcnZhbCk7XG4gICAgICAgICAgICAvLyBTZW5kIHRoZSB0cmFuc2FjdGlvblxuICAgICAgICAgICAgY29uc3QgaGFzaCA9IHlpZWxkIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVW5mb3J0dW5hdGVseSwgSlNPTi1SUEMgb25seSBwcm92aWRlcyBhbmQgb3BhcXVlIHRyYW5zYWN0aW9uIGhhc2hcbiAgICAgICAgICAgICAgICAvLyBmb3IgYSByZXNwb25zZSwgYW5kIHdlIG5lZWQgdGhlIGFjdHVhbCB0cmFuc2FjdGlvbiwgc28gd2UgcG9sbFxuICAgICAgICAgICAgICAgIC8vIGZvciBpdDsgaXQgc2hvdWxkIHNob3cgdXAgdmVyeSBxdWlja2x5XG4gICAgICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHBvbGwoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHlpZWxkIHRoaXMucHJvdmlkZXIuZ2V0VHJhbnNhY3Rpb24oaGFzaCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5fd3JhcFRyYW5zYWN0aW9uKHR4LCBoYXNoLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfSksIHsgb25jZVBvbGw6IHRoaXMucHJvdmlkZXIgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvci50cmFuc2FjdGlvbkhhc2ggPSBoYXNoO1xuICAgICAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2lnbk1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9ICgodHlwZW9mIChtZXNzYWdlKSA9PT0gXCJzdHJpbmdcIikgPyB0b1V0ZjhCeXRlcyhtZXNzYWdlKSA6IG1lc3NhZ2UpO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHlpZWxkIHRoaXMucHJvdmlkZXIuc2VuZChcInBlcnNvbmFsX3NpZ25cIiwgW2hleGxpZnkoZGF0YSksIGFkZHJlc3MudG9Mb3dlckNhc2UoKV0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2xlZ2FjeVNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSAoKHR5cGVvZiAobWVzc2FnZSkgPT09IFwic3RyaW5nXCIpID8gdG9VdGY4Qnl0ZXMobWVzc2FnZSkgOiBtZXNzYWdlKTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ldGhlcmV1bS93aWtpL3dpa2kvSlNPTi1SUEMjZXRoX3NpZ25cbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblwiLCBbYWRkcmVzcy50b0xvd2VyQ2FzZSgpLCBoZXhsaWZ5KGRhdGEpXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgYW55IEVOUyBuYW1lcyAoaW4tcGxhY2UpXG4gICAgICAgICAgICBjb25zdCBwb3B1bGF0ZWQgPSB5aWVsZCBfVHlwZWREYXRhRW5jb2Rlci5yZXNvbHZlTmFtZXMoZG9tYWluLCB0eXBlcywgdmFsdWUsIChuYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucHJvdmlkZXIucmVzb2x2ZU5hbWUobmFtZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFkZHJlc3MgPSB5aWVsZCB0aGlzLmdldEFkZHJlc3MoKTtcbiAgICAgICAgICAgIHJldHVybiB5aWVsZCB0aGlzLnByb3ZpZGVyLnNlbmQoXCJldGhfc2lnblR5cGVkRGF0YV92NFwiLCBbXG4gICAgICAgICAgICAgICAgYWRkcmVzcy50b0xvd2VyQ2FzZSgpLFxuICAgICAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KF9UeXBlZERhdGFFbmNvZGVyLmdldFBheWxvYWQocG9wdWxhdGVkLmRvbWFpbiwgdHlwZXMsIHBvcHVsYXRlZC52YWx1ZSkpXG4gICAgICAgICAgICBdKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHVubG9jayhwYXNzd29yZCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyO1xuICAgICAgICAgICAgY29uc3QgYWRkcmVzcyA9IHlpZWxkIHRoaXMuZ2V0QWRkcmVzcygpO1xuICAgICAgICAgICAgcmV0dXJuIHByb3ZpZGVyLnNlbmQoXCJwZXJzb25hbF91bmxvY2tBY2NvdW50XCIsIFthZGRyZXNzLnRvTG93ZXJDYXNlKCksIHBhc3N3b3JkLCBudWxsXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNsYXNzIFVuY2hlY2tlZEpzb25ScGNTaWduZXIgZXh0ZW5kcyBKc29uUnBjU2lnbmVyIHtcbiAgICBzZW5kVHJhbnNhY3Rpb24odHJhbnNhY3Rpb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VuZFVuY2hlY2tlZFRyYW5zYWN0aW9uKHRyYW5zYWN0aW9uKS50aGVuKChoYXNoKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIGhhc2g6IGhhc2gsXG4gICAgICAgICAgICAgICAgbm9uY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZ2FzTGltaXQ6IG51bGwsXG4gICAgICAgICAgICAgICAgZ2FzUHJpY2U6IG51bGwsXG4gICAgICAgICAgICAgICAgZGF0YTogbnVsbCxcbiAgICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgICBjaGFpbklkOiBudWxsLFxuICAgICAgICAgICAgICAgIGNvbmZpcm1hdGlvbnM6IDAsXG4gICAgICAgICAgICAgICAgZnJvbTogbnVsbCxcbiAgICAgICAgICAgICAgICB3YWl0OiAoY29uZmlybWF0aW9ucykgPT4geyByZXR1cm4gdGhpcy5wcm92aWRlci53YWl0Rm9yVHJhbnNhY3Rpb24oaGFzaCwgY29uZmlybWF0aW9ucyk7IH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmNvbnN0IGFsbG93ZWRUcmFuc2FjdGlvbktleXMgPSB7XG4gICAgY2hhaW5JZDogdHJ1ZSwgZGF0YTogdHJ1ZSwgZ2FzTGltaXQ6IHRydWUsIGdhc1ByaWNlOiB0cnVlLCBub25jZTogdHJ1ZSwgdG86IHRydWUsIHZhbHVlOiB0cnVlLFxuICAgIHR5cGU6IHRydWUsIGFjY2Vzc0xpc3Q6IHRydWUsXG4gICAgbWF4RmVlUGVyR2FzOiB0cnVlLCBtYXhQcmlvcml0eUZlZVBlckdhczogdHJ1ZVxufTtcbmV4cG9ydCBjbGFzcyBKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBCYXNlUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaykge1xuICAgICAgICBsb2dnZXIuY2hlY2tOZXcobmV3LnRhcmdldCwgSnNvblJwY1Byb3ZpZGVyKTtcbiAgICAgICAgbGV0IG5ldHdvcmtPclJlYWR5ID0gbmV0d29yaztcbiAgICAgICAgLy8gVGhlIG5ldHdvcmsgaXMgdW5rbm93biwgcXVlcnkgdGhlIEpTT04tUlBDIGZvciBpdFxuICAgICAgICBpZiAobmV0d29ya09yUmVhZHkgPT0gbnVsbCkge1xuICAgICAgICAgICAgbmV0d29ya09yUmVhZHkgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGV0ZWN0TmV0d29yaygpLnRoZW4oKG5ldHdvcmspID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUobmV0d29yayk7XG4gICAgICAgICAgICAgICAgICAgIH0sIChlcnJvcikgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcihuZXR3b3JrT3JSZWFkeSk7XG4gICAgICAgIC8vIERlZmF1bHQgVVJMXG4gICAgICAgIGlmICghdXJsKSB7XG4gICAgICAgICAgICB1cmwgPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJkZWZhdWx0VXJsXCIpKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiAodXJsKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjb25uZWN0aW9uXCIsIE9iamVjdC5mcmVlemUoe1xuICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICB9KSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImNvbm5lY3Rpb25cIiwgT2JqZWN0LmZyZWV6ZShzaGFsbG93Q29weSh1cmwpKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbmV4dElkID0gNDI7XG4gICAgfVxuICAgIGdldCBfY2FjaGUoKSB7XG4gICAgICAgIGlmICh0aGlzLl9ldmVudExvb3BDYWNoZSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLl9ldmVudExvb3BDYWNoZSA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9ldmVudExvb3BDYWNoZTtcbiAgICB9XG4gICAgc3RhdGljIGRlZmF1bHRVcmwoKSB7XG4gICAgICAgIHJldHVybiBcImh0dHA6L1xcL2xvY2FsaG9zdDo4NTQ1XCI7XG4gICAgfVxuICAgIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIGlmICghdGhpcy5fY2FjaGVbXCJkZXRlY3ROZXR3b3JrXCJdKSB7XG4gICAgICAgICAgICB0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl0gPSB0aGlzLl91bmNhY2hlZERldGVjdE5ldHdvcmsoKTtcbiAgICAgICAgICAgIC8vIENsZWFyIHRoaXMgY2FjaGUgYXQgdGhlIGJlZ2lubmluZyBvZiB0aGUgbmV4dCBldmVudCBsb29wXG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jYWNoZVtcImRldGVjdE5ldHdvcmtcIl0gPSBudWxsO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhY2hlW1wiZGV0ZWN0TmV0d29ya1wiXTtcbiAgICB9XG4gICAgX3VuY2FjaGVkRGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHlpZWxkIHRpbWVyKDApO1xuICAgICAgICAgICAgbGV0IGNoYWluSWQgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjaGFpbklkID0geWllbGQgdGhpcy5zZW5kKFwiZXRoX2NoYWluSWRcIiwgW10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY2hhaW5JZCA9IHlpZWxkIHRoaXMuc2VuZChcIm5ldF92ZXJzaW9uXCIsIFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChjaGFpbklkICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBnZXROZXR3b3JrID0gZ2V0U3RhdGljKHRoaXMuY29uc3RydWN0b3IsIFwiZ2V0TmV0d29ya1wiKTtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZ2V0TmV0d29yayhCaWdOdW1iZXIuZnJvbShjaGFpbklkKS50b051bWJlcigpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNvdWxkIG5vdCBkZXRlY3QgbmV0d29ya1wiLCBMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoYWluSWQ6IGNoYWluSWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBldmVudDogXCJpbnZhbGlkTmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyRXJyb3I6IGVycm9yXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcImNvdWxkIG5vdCBkZXRlY3QgbmV0d29ya1wiLCBMb2dnZXIuZXJyb3JzLk5FVFdPUktfRVJST1IsIHtcbiAgICAgICAgICAgICAgICBldmVudDogXCJub05ldHdvcmtcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBnZXRTaWduZXIoYWRkcmVzc09ySW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBKc29uUnBjU2lnbmVyKF9jb25zdHJ1Y3Rvckd1YXJkLCB0aGlzLCBhZGRyZXNzT3JJbmRleCk7XG4gICAgfVxuICAgIGdldFVuY2hlY2tlZFNpZ25lcihhZGRyZXNzT3JJbmRleCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTaWduZXIoYWRkcmVzc09ySW5kZXgpLmNvbm5lY3RVbmNoZWNrZWQoKTtcbiAgICB9XG4gICAgbGlzdEFjY291bnRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5zZW5kKFwiZXRoX2FjY291bnRzXCIsIFtdKS50aGVuKChhY2NvdW50cykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIGFjY291bnRzLm1hcCgoYSkgPT4gdGhpcy5mb3JtYXR0ZXIuYWRkcmVzcyhhKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZW5kKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgaWQ6ICh0aGlzLl9uZXh0SWQrKyksXG4gICAgICAgICAgICBqc29ucnBjOiBcIjIuMFwiXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICByZXF1ZXN0OiBkZWVwQ29weShyZXF1ZXN0KSxcbiAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBXZSBjYW4gZXhwYW5kIHRoaXMgaW4gdGhlIGZ1dHVyZSB0byBhbnkgY2FsbCwgYnV0IGZvciBub3cgdGhlc2VcbiAgICAgICAgLy8gYXJlIHRoZSBiaWdnZXN0IHdpbnMgYW5kIGRvIG5vdCByZXF1aXJlIGFueSBzZXJpYWxpemluZyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBjYWNoZSA9IChbXCJldGhfY2hhaW5JZFwiLCBcImV0aF9ibG9ja051bWJlclwiXS5pbmRleE9mKG1ldGhvZCkgPj0gMCk7XG4gICAgICAgIGlmIChjYWNoZSAmJiB0aGlzLl9jYWNoZVttZXRob2RdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fY2FjaGVbbWV0aG9kXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBmZXRjaEpzb24odGhpcy5jb25uZWN0aW9uLCBKU09OLnN0cmluZ2lmeShyZXF1ZXN0KSwgZ2V0UmVzdWx0KS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgfSwgKGVycm9yKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBDYWNoZSB0aGUgZmV0Y2gsIGJ1dCBjbGVhciBpdCBvbiB0aGUgbmV4dCBldmVudCBsb29wXG4gICAgICAgIGlmIChjYWNoZSkge1xuICAgICAgICAgICAgdGhpcy5fY2FjaGVbbWV0aG9kXSA9IHJlc3VsdDtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuX2NhY2hlW21ldGhvZF0gPSBudWxsO1xuICAgICAgICAgICAgfSwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcHJlcGFyZVJlcXVlc3QobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgICAgICAgIGNhc2UgXCJnZXRCbG9ja051bWJlclwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfYmxvY2tOdW1iZXJcIiwgW11dO1xuICAgICAgICAgICAgY2FzZSBcImdldEdhc1ByaWNlXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nYXNQcmljZVwiLCBbXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0QmFsYW5jZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmFsYW5jZVwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25Db3VudFwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0VHJhbnNhY3Rpb25Db3VudFwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0Q29kZVwiOlxuICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0Q29kZVwiLCBbZ2V0TG93ZXJDYXNlKHBhcmFtcy5hZGRyZXNzKSwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0U3RvcmFnZUF0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRTdG9yYWdlQXRcIiwgW2dldExvd2VyQ2FzZShwYXJhbXMuYWRkcmVzcyksIHBhcmFtcy5wb3NpdGlvbiwgcGFyYW1zLmJsb2NrVGFnXV07XG4gICAgICAgICAgICBjYXNlIFwic2VuZFRyYW5zYWN0aW9uXCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9zZW5kUmF3VHJhbnNhY3Rpb25cIiwgW3BhcmFtcy5zaWduZWRUcmFuc2FjdGlvbl1dO1xuICAgICAgICAgICAgY2FzZSBcImdldEJsb2NrXCI6XG4gICAgICAgICAgICAgICAgaWYgKHBhcmFtcy5ibG9ja1RhZykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldEJsb2NrQnlOdW1iZXJcIiwgW3BhcmFtcy5ibG9ja1RhZywgISFwYXJhbXMuaW5jbHVkZVRyYW5zYWN0aW9uc11dO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChwYXJhbXMuYmxvY2tIYXNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbXCJldGhfZ2V0QmxvY2tCeUhhc2hcIiwgW3BhcmFtcy5ibG9ja0hhc2gsICEhcGFyYW1zLmluY2x1ZGVUcmFuc2FjdGlvbnNdXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25cIjpcbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldFRyYW5zYWN0aW9uQnlIYXNoXCIsIFtwYXJhbXMudHJhbnNhY3Rpb25IYXNoXV07XG4gICAgICAgICAgICBjYXNlIFwiZ2V0VHJhbnNhY3Rpb25SZWNlaXB0XCI6XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9nZXRUcmFuc2FjdGlvblJlY2VpcHRcIiwgW3BhcmFtcy50cmFuc2FjdGlvbkhhc2hdXTtcbiAgICAgICAgICAgIGNhc2UgXCJjYWxsXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9jYWxsXCIsIFtoZXhsaWZ5VHJhbnNhY3Rpb24ocGFyYW1zLnRyYW5zYWN0aW9uLCB7IGZyb206IHRydWUgfSksIHBhcmFtcy5ibG9ja1RhZ11dO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImVzdGltYXRlR2FzXCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBoZXhsaWZ5VHJhbnNhY3Rpb24gPSBnZXRTdGF0aWModGhpcy5jb25zdHJ1Y3RvciwgXCJoZXhsaWZ5VHJhbnNhY3Rpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtcImV0aF9lc3RpbWF0ZUdhc1wiLCBbaGV4bGlmeVRyYW5zYWN0aW9uKHBhcmFtcy50cmFuc2FjdGlvbiwgeyBmcm9tOiB0cnVlIH0pXV07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZ2V0TG9nc1wiOlxuICAgICAgICAgICAgICAgIGlmIChwYXJhbXMuZmlsdGVyICYmIHBhcmFtcy5maWx0ZXIuYWRkcmVzcyAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcy5maWx0ZXIuYWRkcmVzcyA9IGdldExvd2VyQ2FzZShwYXJhbXMuZmlsdGVyLmFkZHJlc3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gW1wiZXRoX2dldExvZ3NcIiwgW3BhcmFtcy5maWx0ZXJdXTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHBlcmZvcm0obWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIExlZ2FjeSBuZXR3b3JrcyBkbyBub3QgbGlrZSB0aGUgdHlwZSBmaWVsZCBiZWluZyBwYXNzZWQgYWxvbmcgKHdoaWNoXG4gICAgICAgICAgICAvLyBpcyBmYWlyKSwgc28gd2UgZGVsZXRlIHR5cGUgaWYgaXQgaXMgMCBhbmQgYSBub24tRUlQLTE1NTkgbmV0d29ya1xuICAgICAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJjYWxsXCIgfHwgbWV0aG9kID09PSBcImVzdGltYXRlR2FzXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0eCA9IHBhcmFtcy50cmFuc2FjdGlvbjtcbiAgICAgICAgICAgICAgICBpZiAodHggJiYgdHgudHlwZSAhPSBudWxsICYmIEJpZ051bWJlci5mcm9tKHR4LnR5cGUpLmlzWmVybygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIElmIHRoZXJlIGFyZSBubyBFSVAtMTU1OSBwcm9wZXJ0aWVzLCBpdCBtaWdodCBiZSBub24tRUlQLWE1NTlcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR4Lm1heEZlZVBlckdhcyA9PSBudWxsICYmIHR4Lm1heFByaW9yaXR5RmVlUGVyR2FzID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZlZURhdGEgPSB5aWVsZCB0aGlzLmdldEZlZURhdGEoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmZWVEYXRhLm1heEZlZVBlckdhcyA9PSBudWxsICYmIGZlZURhdGEubWF4UHJpb3JpdHlGZWVQZXJHYXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIE5ldHdvcmsgZG9lc24ndCBrbm93IGFib3V0IEVJUC0xNTU5IChhbmQgaGVuY2UgdHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMgPSBzaGFsbG93Q29weShwYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtcy50cmFuc2FjdGlvbiA9IHNoYWxsb3dDb3B5KHR4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLnRyYW5zYWN0aW9uLnR5cGU7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBhcmdzID0gdGhpcy5wcmVwYXJlUmVxdWVzdChtZXRob2QsIHBhcmFtcyk7XG4gICAgICAgICAgICBpZiAoYXJncyA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IobWV0aG9kICsgXCIgbm90IGltcGxlbWVudGVkXCIsIExvZ2dlci5lcnJvcnMuTk9UX0lNUExFTUVOVEVELCB7IG9wZXJhdGlvbjogbWV0aG9kIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXR1cm4geWllbGQgdGhpcy5zZW5kKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNoZWNrRXJyb3IobWV0aG9kLCBlcnJvciwgcGFyYW1zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIF9zdGFydEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGlmIChldmVudC50YWcgPT09IFwicGVuZGluZ1wiKSB7XG4gICAgICAgICAgICB0aGlzLl9zdGFydFBlbmRpbmcoKTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlci5fc3RhcnRFdmVudChldmVudCk7XG4gICAgfVxuICAgIF9zdGFydFBlbmRpbmcoKSB7XG4gICAgICAgIGlmICh0aGlzLl9wZW5kaW5nRmlsdGVyICE9IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICAgICAgY29uc3QgcGVuZGluZ0ZpbHRlciA9IHRoaXMuc2VuZChcImV0aF9uZXdQZW5kaW5nVHJhbnNhY3Rpb25GaWx0ZXJcIiwgW10pO1xuICAgICAgICB0aGlzLl9wZW5kaW5nRmlsdGVyID0gcGVuZGluZ0ZpbHRlcjtcbiAgICAgICAgcGVuZGluZ0ZpbHRlci50aGVuKGZ1bmN0aW9uIChmaWx0ZXJJZCkge1xuICAgICAgICAgICAgZnVuY3Rpb24gcG9sbCgpIHtcbiAgICAgICAgICAgICAgICBzZWxmLnNlbmQoXCJldGhfZ2V0RmlsdGVyQ2hhbmdlc1wiLCBbZmlsdGVySWRdKS50aGVuKGZ1bmN0aW9uIChoYXNoZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdGaWx0ZXIgIT0gcGVuZGluZ0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgbGV0IHNlcSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgICAgICBoYXNoZXMuZm9yRWFjaChmdW5jdGlvbiAoaGFzaCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQFRPRE86IFRoaXMgc2hvdWxkIGJlIGdhcmJhZ2UgY29sbGVjdGVkIGF0IHNvbWUgcG9pbnQuLi4gSG93PyBXaGVuP1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5fZW1pdHRlZFtcInQ6XCIgKyBoYXNoLnRvTG93ZXJDYXNlKCldID0gXCJwZW5kaW5nXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZXEgPSBzZXEudGhlbihmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGYuZ2V0VHJhbnNhY3Rpb24oaGFzaCkudGhlbihmdW5jdGlvbiAodHgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5lbWl0KFwicGVuZGluZ1wiLCB0eCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VxLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRpbWVyKDEwMDApO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNlbGYuX3BlbmRpbmdGaWx0ZXIgIT0gcGVuZGluZ0ZpbHRlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5zZW5kKFwiZXRoX3VuaW5zdGFsbEZpbHRlclwiLCBbZmlsdGVySWRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcG9sbCgpOyB9LCAwKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycm9yKSA9PiB7IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcG9sbCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZpbHRlcklkO1xuICAgICAgICB9KS5jYXRjaCgoZXJyb3IpID0+IHsgfSk7XG4gICAgfVxuICAgIF9zdG9wRXZlbnQoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LnRhZyA9PT0gXCJwZW5kaW5nXCIgJiYgdGhpcy5saXN0ZW5lckNvdW50KFwicGVuZGluZ1wiKSA9PT0gMCkge1xuICAgICAgICAgICAgdGhpcy5fcGVuZGluZ0ZpbHRlciA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIuX3N0b3BFdmVudChldmVudCk7XG4gICAgfVxuICAgIC8vIENvbnZlcnQgYW4gZXRoZXJzLmpzIHRyYW5zYWN0aW9uIGludG8gYSBKU09OLVJQQyB0cmFuc2FjdGlvblxuICAgIC8vICAtIGdhc0xpbWl0ID0+IGdhc1xuICAgIC8vICAtIEFsbCB2YWx1ZXMgaGV4bGlmaWVkXG4gICAgLy8gIC0gQWxsIG51bWVyaWMgdmFsdWVzIHplcm8tc3RyaXBlZFxuICAgIC8vICAtIEFsbCBhZGRyZXNzZXMgYXJlIGxvd2VyY2FzZWRcbiAgICAvLyBOT1RFOiBUaGlzIGFsbG93cyBhIFRyYW5zYWN0aW9uUmVxdWVzdCwgYnV0IGFsbCB2YWx1ZXMgc2hvdWxkIGJlIHJlc29sdmVkXG4gICAgLy8gICAgICAgYmVmb3JlIHRoaXMgaXMgY2FsbGVkXG4gICAgLy8gQFRPRE86IFRoaXMgd2lsbCBsaWtlbHkgYmUgcmVtb3ZlZCBpbiBmdXR1cmUgdmVyc2lvbnMgYW5kIHByZXBhcmVSZXF1ZXN0XG4gICAgLy8gICAgICAgIHdpbGwgYmUgdGhlIHByZWZlcnJlZCBtZXRob2QgZm9yIHRoaXMuXG4gICAgc3RhdGljIGhleGxpZnlUcmFuc2FjdGlvbih0cmFuc2FjdGlvbiwgYWxsb3dFeHRyYSkge1xuICAgICAgICAvLyBDaGVjayBvbmx5IGFsbG93ZWQgcHJvcGVydGllcyBhcmUgZ2l2ZW5cbiAgICAgICAgY29uc3QgYWxsb3dlZCA9IHNoYWxsb3dDb3B5KGFsbG93ZWRUcmFuc2FjdGlvbktleXMpO1xuICAgICAgICBpZiAoYWxsb3dFeHRyYSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gYWxsb3dFeHRyYSkge1xuICAgICAgICAgICAgICAgIGlmIChhbGxvd0V4dHJhW2tleV0pIHtcbiAgICAgICAgICAgICAgICAgICAgYWxsb3dlZFtrZXldID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2tQcm9wZXJ0aWVzKHRyYW5zYWN0aW9uLCBhbGxvd2VkKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgICAgIC8vIFNvbWUgbm9kZXMgKElORlVSQSByb3BzdGVuOyBJTkZVUkEgbWFpbm5ldCBpcyBmaW5lKSBkbyBub3QgbGlrZSBsZWFkaW5nIHplcm9zLlxuICAgICAgICBbXCJnYXNMaW1pdFwiLCBcImdhc1ByaWNlXCIsIFwidHlwZVwiLCBcIm1heEZlZVBlckdhc1wiLCBcIm1heFByaW9yaXR5RmVlUGVyR2FzXCIsIFwibm9uY2VcIiwgXCJ2YWx1ZVwiXS5mb3JFYWNoKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgIGlmICh0cmFuc2FjdGlvbltrZXldID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGhleFZhbHVlKHRyYW5zYWN0aW9uW2tleV0pO1xuICAgICAgICAgICAgaWYgKGtleSA9PT0gXCJnYXNMaW1pdFwiKSB7XG4gICAgICAgICAgICAgICAga2V5ID0gXCJnYXNcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICAgIH0pO1xuICAgICAgICBbXCJmcm9tXCIsIFwidG9cIiwgXCJkYXRhXCJdLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgaWYgKHRyYW5zYWN0aW9uW2tleV0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdFtrZXldID0gaGV4bGlmeSh0cmFuc2FjdGlvbltrZXldKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0KSB7XG4gICAgICAgICAgICByZXN1bHRbXCJhY2Nlc3NMaXN0XCJdID0gYWNjZXNzTGlzdGlmeSh0cmFuc2FjdGlvbi5hY2Nlc3NMaXN0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWpzb24tcnBjLXByb3ZpZGVyLmpzLm1hcCIsIi8qIGlzdGFuYnVsIGlnbm9yZSBmaWxlICovXG5cInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IFVybEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuLy8gU3BlY2lhbCBBUEkga2V5IHByb3ZpZGVkIGJ5IE5vZGVzbWl0aCBmb3IgZXRoZXJzLmpzXG5jb25zdCBkZWZhdWx0QXBpS2V5ID0gXCJFVEhFUlNfSlNfU0hBUkVEXCI7XG5leHBvcnQgY2xhc3MgTm9kZXNtaXRoUHJvdmlkZXIgZXh0ZW5kcyBVcmxKc29uUnBjUHJvdmlkZXIge1xuICAgIHN0YXRpYyBnZXRBcGlLZXkoYXBpS2V5KSB7XG4gICAgICAgIGlmIChhcGlLZXkgJiYgdHlwZW9mIChhcGlLZXkpICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhcGlLZXlcIiwgXCJhcGlLZXlcIiwgYXBpS2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBpS2V5IHx8IGRlZmF1bHRBcGlLZXk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRVcmwobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGxvZ2dlci53YXJuKFwiTm9kZVNtaXRoIHdpbGwgYmUgZGlzY29udGludWVkIG9uIDIwMTktMTItMjA7IHBsZWFzZSBtaWdyYXRlIHRvIGFub3RoZXIgcGxhdGZvcm0uXCIpO1xuICAgICAgICBsZXQgaG9zdCA9IG51bGw7XG4gICAgICAgIHN3aXRjaCAobmV0d29yay5uYW1lKSB7XG4gICAgICAgICAgICBjYXNlIFwiaG9tZXN0ZWFkXCI6XG4gICAgICAgICAgICAgICAgaG9zdCA9IFwiaHR0cHM6Ly9ldGhlcmV1bS5hcGkubm9kZXNtaXRoLmlvL3YxL21haW5uZXQvanNvbnJwY1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJvcHN0ZW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvcm9wc3Rlbi9qc29ucnBjXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicmlua2VieVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9yaW5rZWJ5L2pzb25ycGNcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJnb2VybGlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJodHRwczovL2V0aGVyZXVtLmFwaS5ub2Rlc21pdGguaW8vdjEvZ29lcmxpL2pzb25ycGNcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJrb3ZhblwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImh0dHBzOi8vZXRoZXJldW0uYXBpLm5vZGVzbWl0aC5pby92MS9rb3Zhbi9qc29ucnBjXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIFwibmV0d29ya1wiLCBhcmd1bWVudHNbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoaG9zdCArIFwiP2FwaUtleT1cIiArIGFwaUtleSk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9bm9kZXNtaXRoLXByb3ZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZ2V0U3RhdGljIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IFVybEpzb25ScGNQcm92aWRlciB9IGZyb20gXCIuL3VybC1qc29uLXJwYy1wcm92aWRlclwiO1xuLy8gVGhlc2UgYXJlIGxvYWQtYmFsYW5jZXItYmFzZWQgYXBwbGljYXRpb24gSURzXG5jb25zdCBkZWZhdWx0QXBwbGljYXRpb25JZHMgPSB7XG4gICAgaG9tZXN0ZWFkOiBcIjYwMDRiY2QxMDA0MDI2MTYzM2FkZTk5MFwiLFxuICAgIHJvcHN0ZW46IFwiNjAwNGJkNGQwMDQwMjYxNjMzYWRlOTkxXCIsXG4gICAgcmlua2VieTogXCI2MDA0YmRhMjAwNDAyNjE2MzNhZGU5OTRcIixcbiAgICBnb2VybGk6IFwiNjAwNGJkODYwMDQwMjYxNjMzYWRlOTkyXCIsXG59O1xuZXhwb3J0IGNsYXNzIFBvY2tldFByb3ZpZGVyIGV4dGVuZHMgVXJsSnNvblJwY1Byb3ZpZGVyIHtcbiAgICBjb25zdHJ1Y3RvcihuZXR3b3JrLCBhcGlLZXkpIHtcbiAgICAgICAgLy8gV2UgbmVlZCBhIGJpdCBvZiBjcmVhdGl2aXR5IGluIHRoZSBjb25zdHJ1Y3RvciBiZWNhdXNlXG4gICAgICAgIC8vIFBvY2tldCB1c2VzIGRpZmZlcmVudCBkZWZhdWx0IEFQSSBrZXlzIGJhc2VkIG9uIHRoZSBuZXR3b3JrXG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3QgbiA9IGdldFN0YXRpYyhuZXcudGFyZ2V0LCBcImdldE5ldHdvcmtcIikobmV0d29yayk7XG4gICAgICAgICAgICBpZiAobikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFwcGxpY2F0aW9uSWQgPSBkZWZhdWx0QXBwbGljYXRpb25JZHNbbi5uYW1lXTtcbiAgICAgICAgICAgICAgICBpZiAoYXBwbGljYXRpb25JZCkge1xuICAgICAgICAgICAgICAgICAgICBhcGlLZXkgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhcHBsaWNhdGlvbklkOiBhcHBsaWNhdGlvbklkLFxuICAgICAgICAgICAgICAgICAgICAgICAgbG9hZEJhbGFuY2VyOiB0cnVlXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSWYgdGhlcmUgd2FzIGFueSBpc3N1ZSBhYm92ZSwgd2UgZG9uJ3Qga25vdyB0aGlzIG5ldHdvcmtcbiAgICAgICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwidW5zdXBwb3J0ZWQgbmV0d29ya1wiLCBMb2dnZXIuZXJyb3JzLklOVkFMSURfQVJHVU1FTlQsIHtcbiAgICAgICAgICAgICAgICAgICAgYXJndW1lbnQ6IFwibmV0d29ya1wiLFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZTogbmV0d29ya1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN1cGVyKG5ldHdvcmssIGFwaUtleSk7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRBcGlLZXkoYXBpS2V5KSB7XG4gICAgICAgIC8vIE1vc3QgQVBJIFByb3ZpZGVycyBhbGxvdyBudWxsIHRvIGdldCB0aGUgZGVmYXVsdCBjb25maWd1cmF0aW9uLCBidXRcbiAgICAgICAgLy8gUG9ja2V0IHJlcXVpcmVzIHRoZSBuZXR3b3JrIHRvIGRlY2lkZSB0aGUgZGVmYXVsdCBwcm92aWRlciwgc28gd2VcbiAgICAgICAgLy8gcmVseSBvbiBoaWphY2tpbmcgdGhlIGNvbnN0cnVjdG9yIHRvIGFkZCBhIHNlbnNpYmxlIGRlZmF1bHQgZm9yIHVzXG4gICAgICAgIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIlBvY2tldFByb3ZpZGVyLmdldEFwaUtleSBkb2VzIG5vdCBzdXBwb3J0IG51bGwgYXBpS2V5XCIsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXBpS2V5T2JqID0ge1xuICAgICAgICAgICAgYXBwbGljYXRpb25JZDogbnVsbCxcbiAgICAgICAgICAgIGxvYWRCYWxhbmNlcjogZmFsc2UsXG4gICAgICAgICAgICBhcHBsaWNhdGlvblNlY3JldEtleTogbnVsbFxuICAgICAgICB9O1xuICAgICAgICAvLyBQYXJzZSBhcHBsaWNhdGlvbklkIGFuZCBhcHBsaWNhdGlvblNlY3JldEtleVxuICAgICAgICBpZiAodHlwZW9mIChhcGlLZXkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhcGlLZXlPYmouYXBwbGljYXRpb25JZCA9IGFwaUtleTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KCh0eXBlb2YgKGFwaUtleS5hcHBsaWNhdGlvbklkKSA9PT0gXCJzdHJpbmdcIiksIFwiYXBwbGljYXRpb25TZWNyZXRLZXkgcmVxdWlyZXMgYW4gYXBwbGljYXRpb25JZFwiLCBcImFwcGxpY2F0aW9uSWRcIiwgYXBpS2V5LmFwcGxpY2F0aW9uSWQpO1xuICAgICAgICAgICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KCh0eXBlb2YgKGFwaUtleS5hcHBsaWNhdGlvblNlY3JldEtleSkgPT09IFwic3RyaW5nXCIpLCBcImludmFsaWQgYXBwbGljYXRpb25TZWNyZXRLZXlcIiwgXCJhcHBsaWNhdGlvblNlY3JldEtleVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgICAgICBhcGlLZXlPYmouYXBwbGljYXRpb25JZCA9IGFwaUtleS5hcHBsaWNhdGlvbklkO1xuICAgICAgICAgICAgYXBpS2V5T2JqLmFwcGxpY2F0aW9uU2VjcmV0S2V5ID0gYXBpS2V5LmFwcGxpY2F0aW9uU2VjcmV0S2V5O1xuICAgICAgICAgICAgYXBpS2V5T2JqLmxvYWRCYWxhbmNlciA9ICEhYXBpS2V5LmxvYWRCYWxhbmNlcjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhcGlLZXkuYXBwbGljYXRpb25JZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KCh0eXBlb2YgKGFwaUtleS5hcHBsaWNhdGlvbklkKSA9PT0gXCJzdHJpbmdcIiksIFwiYXBpS2V5LmFwcGxpY2F0aW9uSWQgbXVzdCBiZSBhIHN0cmluZ1wiLCBcImFwaUtleS5hcHBsaWNhdGlvbklkXCIsIGFwaUtleS5hcHBsaWNhdGlvbklkKTtcbiAgICAgICAgICAgIGFwaUtleU9iai5hcHBsaWNhdGlvbklkID0gYXBpS2V5LmFwcGxpY2F0aW9uSWQ7XG4gICAgICAgICAgICBhcGlLZXlPYmoubG9hZEJhbGFuY2VyID0gISFhcGlLZXkubG9hZEJhbGFuY2VyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInVuc3VwcG9ydGVkIFBvY2tldFByb3ZpZGVyIGFwaUtleVwiLCBcImFwaUtleVwiLCBhcGlLZXkpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcGlLZXlPYmo7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRVcmwobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGxldCBob3N0ID0gbnVsbDtcbiAgICAgICAgc3dpdGNoIChuZXR3b3JrID8gbmV0d29yay5uYW1lIDogXCJ1bmtub3duXCIpIHtcbiAgICAgICAgICAgIGNhc2UgXCJob21lc3RlYWRcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtbWFpbm5ldC5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJvcHN0ZW5cIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtcm9wc3Rlbi5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInJpbmtlYnlcIjpcbiAgICAgICAgICAgICAgICBob3N0ID0gXCJldGgtcmlua2VieS5nYXRld2F5LnBva3QubmV0d29ya1wiO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImdvZXJsaVwiOlxuICAgICAgICAgICAgICAgIGhvc3QgPSBcImV0aC1nb2VybGkuZ2F0ZXdheS5wb2t0Lm5ldHdvcmtcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBuZXR3b3JrXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwge1xuICAgICAgICAgICAgICAgICAgICBhcmd1bWVudDogXCJuZXR3b3JrXCIsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuZXR3b3JrXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHVybCA9IG51bGw7XG4gICAgICAgIGlmIChhcGlLZXkubG9hZEJhbGFuY2VyKSB7XG4gICAgICAgICAgICB1cmwgPSBgaHR0cHM6L1xcLyR7aG9zdH0vdjEvbGIvJHthcGlLZXkuYXBwbGljYXRpb25JZH1gO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdXJsID0gYGh0dHBzOi9cXC8ke2hvc3R9L3YxLyR7YXBpS2V5LmFwcGxpY2F0aW9uSWR9YDtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25uZWN0aW9uID0geyB1cmwgfTtcbiAgICAgICAgLy8gSW5pdGlhbGl6ZSBlbXB0eSBoZWFkZXJzXG4gICAgICAgIGNvbm5lY3Rpb24uaGVhZGVycyA9IHt9O1xuICAgICAgICAvLyBBcHBseSBhcHBsaWNhdGlvbiBzZWNyZXQga2V5XG4gICAgICAgIGlmIChhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXkgIT0gbnVsbCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbi51c2VyID0gXCJcIjtcbiAgICAgICAgICAgIGNvbm5lY3Rpb24ucGFzc3dvcmQgPSBhcGlLZXkuYXBwbGljYXRpb25TZWNyZXRLZXk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbm5lY3Rpb247XG4gICAgfVxuICAgIGlzQ29tbXVuaXR5UmVzb3VyY2UoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5hcHBsaWNhdGlvbklkID09PSBkZWZhdWx0QXBwbGljYXRpb25JZHNbdGhpcy5uZXR3b3JrLm5hbWVdKTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb2NrZXQtcHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5LCBnZXRTdGF0aWMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vanNvbi1ycGMtcHJvdmlkZXJcIjtcbi8vIEEgU3RhdGljSnNvblJwY1Byb3ZpZGVyIGlzIHVzZWZ1bCB3aGVuIHlvdSAqa25vdyogZm9yIGNlcnRhaW4gdGhhdFxuLy8gdGhlIGJhY2tlbmQgd2lsbCBuZXZlciBjaGFuZ2UsIGFzIGl0IG5ldmVyIGNhbGxzIGV0aF9jaGFpbklkIHRvXG4vLyB2ZXJpZnkgaXRzIGJhY2tlbmQuIEhvd2V2ZXIsIGlmIHRoZSBiYWNrZW5kIGRvZXMgY2hhbmdlLCB0aGUgZWZmZWN0c1xuLy8gYXJlIHVuZGVmaW5lZCBhbmQgbWF5IGluY2x1ZGU6XG4vLyAtIGluY29uc2lzdGVudCByZXN1bHRzXG4vLyAtIGxvY2tpbmcgdXAgdGhlIFVJXG4vLyAtIGJsb2NrIHNrZXcgd2FybmluZ3Ncbi8vIC0gd3JvbmcgcmVzdWx0c1xuLy8gSWYgdGhlIG5ldHdvcmsgaXMgbm90IGV4cGxpY2l0IChpLmUuIGF1dG8tZGV0ZWN0aW9uIGlzIGV4cGVjdGVkKSwgdGhlXG4vLyBub2RlIE1VU1QgYmUgcnVubmluZyBhbmQgYXZhaWxhYmxlIHRvIHJlc3BvbmQgdG8gcmVxdWVzdHMgQkVGT1JFIHRoaXNcbi8vIGlzIGluc3RhbnRpYXRlZC5cbmV4cG9ydCBjbGFzcyBTdGF0aWNKc29uUnBjUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXIge1xuICAgIGRldGVjdE5ldHdvcmsoKSB7XG4gICAgICAgIGNvbnN0IF9zdXBlciA9IE9iamVjdC5jcmVhdGUobnVsbCwge1xuICAgICAgICAgICAgZGV0ZWN0TmV0d29yazogeyBnZXQ6ICgpID0+IHN1cGVyLmRldGVjdE5ldHdvcmsgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBuZXR3b3JrID0gdGhpcy5uZXR3b3JrO1xuICAgICAgICAgICAgaWYgKG5ldHdvcmsgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIG5ldHdvcmsgPSB5aWVsZCBfc3VwZXIuZGV0ZWN0TmV0d29yay5jYWxsKHRoaXMpO1xuICAgICAgICAgICAgICAgIGlmICghbmV0d29yaykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcIm5vIG5ldHdvcmsgZGV0ZWN0ZWRcIiwgTG9nZ2VyLmVycm9ycy5VTktOT1dOX0VSUk9SLCB7fSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8vIElmIHN0aWxsIG5vdCBzZXQsIHNldCBpdFxuICAgICAgICAgICAgICAgIGlmICh0aGlzLl9uZXR3b3JrID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gQSBzdGF0aWMgbmV0d29yayBkb2VzIG5vdCBzdXBwb3J0IFwiYW55XCJcbiAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbmV0d29ya1wiLCBuZXR3b3JrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibmV0d29ya1wiLCBuZXR3b3JrLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gbmV0d29yaztcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0IGNsYXNzIFVybEpzb25ScGNQcm92aWRlciBleHRlbmRzIFN0YXRpY0pzb25ScGNQcm92aWRlciB7XG4gICAgY29uc3RydWN0b3IobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIGxvZ2dlci5jaGVja0Fic3RyYWN0KG5ldy50YXJnZXQsIFVybEpzb25ScGNQcm92aWRlcik7XG4gICAgICAgIC8vIE5vcm1hbGl6ZSB0aGUgTmV0d29yayBhbmQgQVBJIEtleVxuICAgICAgICBuZXR3b3JrID0gZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0TmV0d29ya1wiKShuZXR3b3JrKTtcbiAgICAgICAgYXBpS2V5ID0gZ2V0U3RhdGljKG5ldy50YXJnZXQsIFwiZ2V0QXBpS2V5XCIpKGFwaUtleSk7XG4gICAgICAgIGNvbnN0IGNvbm5lY3Rpb24gPSBnZXRTdGF0aWMobmV3LnRhcmdldCwgXCJnZXRVcmxcIikobmV0d29yaywgYXBpS2V5KTtcbiAgICAgICAgc3VwZXIoY29ubmVjdGlvbiwgbmV0d29yayk7XG4gICAgICAgIGlmICh0eXBlb2YgKGFwaUtleSkgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiYXBpS2V5XCIsIGFwaUtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXBpS2V5ICE9IG51bGwpIHtcbiAgICAgICAgICAgIE9iamVjdC5rZXlzKGFwaUtleSkuZm9yRWFjaCgoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywga2V5LCBhcGlLZXlba2V5XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3RhcnRQZW5kaW5nKCkge1xuICAgICAgICBsb2dnZXIud2FybihcIldBUk5JTkc6IEFQSSBwcm92aWRlciBkb2VzIG5vdCBzdXBwb3J0IHBlbmRpbmcgZmlsdGVyc1wiKTtcbiAgICB9XG4gICAgaXNDb21tdW5pdHlSZXNvdXJjZSgpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBnZXRTaWduZXIoYWRkcmVzcykge1xuICAgICAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoXCJBUEkgcHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCBzaWduaW5nXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7IG9wZXJhdGlvbjogXCJnZXRTaWduZXJcIiB9KTtcbiAgICB9XG4gICAgbGlzdEFjY291bnRzKCkge1xuICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKFtdKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIGEgZGVmYXVsdEFwaUtleSBpZiBudWxsLCBvdGhlcndpc2UgdmFsaWRhdGUgdGhlIEFQSSBrZXlcbiAgICBzdGF0aWMgZ2V0QXBpS2V5KGFwaUtleSkge1xuICAgICAgICByZXR1cm4gYXBpS2V5O1xuICAgIH1cbiAgICAvLyBSZXR1cm5zIHRoZSB1cmwgb3IgY29ubmVjdGlvbiBmb3IgdGhlIGdpdmVuIG5ldHdvcmsgYW5kIEFQSSBrZXkuIFRoZVxuICAgIC8vIEFQSSBrZXkgd2lsbCBoYXZlIGJlZW4gc2FuaXRpemVkIGJ5IHRoZSBnZXRBcGlLZXkgZmlyc3QsIHNvIGFueSB2YWxpZGF0aW9uXG4gICAgLy8gb3IgdHJhbnNmb3JtYXRpb25zIGNhbiBiZSBkb25lIHRoZXJlLlxuICAgIHN0YXRpYyBnZXRVcmwobmV0d29yaywgYXBpS2V5KSB7XG4gICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcIm5vdCBpbXBsZW1lbnRlZDsgc3ViLWNsYXNzZXMgbXVzdCBvdmVycmlkZSBnZXRVcmxcIiwgTG9nZ2VyLmVycm9ycy5OT1RfSU1QTEVNRU5URUQsIHtcbiAgICAgICAgICAgIG9wZXJhdGlvbjogXCJnZXRVcmxcIlxuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11cmwtanNvbi1ycGMtcHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBkZWVwQ29weSwgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vanNvbi1ycGMtcHJvdmlkZXJcIjtcbmxldCBfbmV4dElkID0gMTtcbmZ1bmN0aW9uIGJ1aWxkV2ViM0xlZ2FjeUZldGNoZXIocHJvdmlkZXIsIHNlbmRGdW5jKSB7XG4gICAgY29uc3QgZmV0Y2hlciA9IFwiV2ViM0xlZ2FjeUZldGNoZXJcIjtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3QgPSB7XG4gICAgICAgICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgaWQ6IChfbmV4dElkKyspLFxuICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXF1ZXN0XCIsXG4gICAgICAgICAgICAgICAgZmV0Y2hlcixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBkZWVwQ29weShyZXF1ZXN0KSxcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZW5kRnVuYyhyZXF1ZXN0LCAoZXJyb3IsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFjdGlvbjogXCJyZXNwb25zZVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgZmV0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgZmV0Y2hlcixcbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKHJlc3BvbnNlLmVycm9yLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBlcnJvci5jb2RlID0gcmVzcG9uc2UuZXJyb3IuY29kZTtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3IuZGF0YSA9IHJlc3BvbnNlLmVycm9yLmRhdGE7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHJlc3BvbnNlLnJlc3VsdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmZ1bmN0aW9uIGJ1aWxkRWlwMTE5M0ZldGNoZXIocHJvdmlkZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1ldGhvZCwgcGFyYW1zKSB7XG4gICAgICAgIGlmIChwYXJhbXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgcGFyYW1zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcmVxdWVzdCA9IHsgbWV0aG9kLCBwYXJhbXMgfTtcbiAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgIGZldGNoZXI6IFwiRWlwMTE5M0ZldGNoZXJcIixcbiAgICAgICAgICAgIHJlcXVlc3Q6IGRlZXBDb3B5KHJlcXVlc3QpLFxuICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBwcm92aWRlci5yZXF1ZXN0KHJlcXVlc3QpLnRoZW4oKHJlc3BvbnNlKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgZmV0Y2hlcjogXCJFaXAxMTkzRmV0Y2hlclwiLFxuICAgICAgICAgICAgICAgIHJlcXVlc3QsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlO1xuICAgICAgICB9LCAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcImRlYnVnXCIsIHtcbiAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICBmZXRjaGVyOiBcIkVpcDExOTNGZXRjaGVyXCIsXG4gICAgICAgICAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfTtcbn1cbmV4cG9ydCBjbGFzcyBXZWIzUHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHByb3ZpZGVyLCBuZXR3b3JrKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja05ldyhuZXcudGFyZ2V0LCBXZWIzUHJvdmlkZXIpO1xuICAgICAgICBpZiAocHJvdmlkZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHBhdGggPSBudWxsO1xuICAgICAgICBsZXQganNvblJwY0ZldGNoRnVuYyA9IG51bGw7XG4gICAgICAgIGxldCBzdWJwcm92aWRlciA9IG51bGw7XG4gICAgICAgIGlmICh0eXBlb2YgKHByb3ZpZGVyKSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBwYXRoID0gXCJ1bmtub3duOlwiO1xuICAgICAgICAgICAganNvblJwY0ZldGNoRnVuYyA9IHByb3ZpZGVyO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcGF0aCA9IHByb3ZpZGVyLmhvc3QgfHwgcHJvdmlkZXIucGF0aCB8fCBcIlwiO1xuICAgICAgICAgICAgaWYgKCFwYXRoICYmIHByb3ZpZGVyLmlzTWV0YU1hc2spIHtcbiAgICAgICAgICAgICAgICBwYXRoID0gXCJtZXRhbWFza1wiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3VicHJvdmlkZXIgPSBwcm92aWRlcjtcbiAgICAgICAgICAgIGlmIChwcm92aWRlci5yZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgaWYgKHBhdGggPT09IFwiXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgcGF0aCA9IFwiZWlwLTExOTM6XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZEVpcDExOTNGZXRjaGVyKHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHByb3ZpZGVyLnNlbmRBc3luYykge1xuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBwcm92aWRlci5zZW5kQXN5bmMuYmluZChwcm92aWRlcikpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAocHJvdmlkZXIuc2VuZCkge1xuICAgICAgICAgICAgICAgIGpzb25ScGNGZXRjaEZ1bmMgPSBidWlsZFdlYjNMZWdhY3lGZXRjaGVyKHByb3ZpZGVyLCBwcm92aWRlci5zZW5kLmJpbmQocHJvdmlkZXIpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ1bnN1cHBvcnRlZCBwcm92aWRlclwiLCBcInByb3ZpZGVyXCIsIHByb3ZpZGVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgICAgIHBhdGggPSBcInVua25vd246XCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgc3VwZXIocGF0aCwgbmV0d29yayk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwianNvblJwY0ZldGNoRnVuY1wiLCBqc29uUnBjRmV0Y2hGdW5jKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBzdWJwcm92aWRlcik7XG4gICAgfVxuICAgIHNlbmQobWV0aG9kLCBwYXJhbXMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuanNvblJwY0ZldGNoRnVuYyhtZXRob2QsIHBhcmFtcyk7XG4gICAgfVxufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2ViMy1wcm92aWRlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2JpZ251bWJlclwiO1xuaW1wb3J0IHsgZGVmaW5lUmVhZE9ubHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0IHsgSnNvblJwY1Byb3ZpZGVyIH0gZnJvbSBcIi4vanNvbi1ycGMtcHJvdmlkZXJcIjtcbmltcG9ydCB7IFdlYlNvY2tldCB9IGZyb20gXCIuL3dzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vKipcbiAqICBOb3RlczpcbiAqXG4gKiAgVGhpcyBwcm92aWRlciBkaWZmZXJzIGEgYml0IGZyb20gdGhlIHBvbGxpbmcgcHJvdmlkZXJzLiBPbmUgbWFpblxuICogIGRpZmZlcmVuY2UgaXMgaG93IGl0IGhhbmRsZXMgY29uc2lzdGVuY3kuIFRoZSBwb2xsaW5nIHByb3ZpZGVyc1xuICogIHdpbGwgc3RhbGwgcmVzcG9uc2VzIHRvIGVuc3VyZSBhIGNvbnNpc3RlbnQgc3RhdGUsIHdoaWxlIHRoaXNcbiAqICBXZWJTb2NrZXQgcHJvdmlkZXIgYXNzdW1lcyB0aGUgY29ubmVjdGVkIGJhY2tlbmQgd2lsbCBtYW5hZ2UgdGhpcy5cbiAqXG4gKiAgRm9yIGV4YW1wbGUsIGlmIGEgcG9sbGluZyBwcm92aWRlciBlbWl0cyBhbiBldmVudCB3aGljaCBpbmRpY2F0ZXNcbiAqICB0aGUgZXZlbnQgb2NjdXJyZWQgaW4gYmxvY2toYXNoIFhYWCwgYSBjYWxsIHRvIGZldGNoIHRoYXQgYmxvY2sgYnlcbiAqICBpdHMgaGFzaCBYWFgsIGlmIG5vdCBwcmVzZW50IHdpbGwgcmV0cnkgdW50aWwgaXQgaXMgcHJlc2VudC4gVGhpc1xuICogIGNhbiBvY2N1ciB3aGVuIHF1ZXJ5aW5nIGEgcG9vbCBvZiBub2RlcyB0aGF0IGFyZSBtaWxkbHkgb3V0IG9mIHN5bmNcbiAqICB3aXRoIGVhY2ggb3RoZXIuXG4gKi9cbmxldCBOZXh0SWQgPSAxO1xuLy8gRm9yIG1vcmUgaW5mbyBhYm91dCB0aGUgUmVhbC10aW1lIEV2ZW50IEFQSSBzZWU6XG4vLyAgIGh0dHBzOi8vZ2V0aC5ldGhlcmV1bS5vcmcvZG9jcy9ycGMvcHVic3ViXG5leHBvcnQgY2xhc3MgV2ViU29ja2V0UHJvdmlkZXIgZXh0ZW5kcyBKc29uUnBjUHJvdmlkZXIge1xuICAgIGNvbnN0cnVjdG9yKHVybCwgbmV0d29yaykge1xuICAgICAgICAvLyBUaGlzIHdpbGwgYmUgYWRkZWQgaW4gdGhlIGZ1dHVyZTsgcGxlYXNlIG9wZW4gYW4gaXNzdWUgdG8gZXhwZWRpdGVcbiAgICAgICAgaWYgKG5ldHdvcmsgPT09IFwiYW55XCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiV2ViU29ja2V0UHJvdmlkZXIgZG9lcyBub3Qgc3VwcG9ydCAnYW55JyBuZXR3b3JrIHlldFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJuZXR3b3JrOmFueVwiXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBzdXBlcih1cmwsIG5ldHdvcmspO1xuICAgICAgICB0aGlzLl9wb2xsaW5nSW50ZXJ2YWwgPSAtMTtcbiAgICAgICAgdGhpcy5fd3NSZWFkeSA9IGZhbHNlO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl93ZWJzb2NrZXRcIiwgbmV3IFdlYlNvY2tldCh0aGlzLmNvbm5lY3Rpb24udXJsKSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3JlcXVlc3RzXCIsIHt9KTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfc3Vic1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3N1Yklkc1wiLCB7fSk7XG4gICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX2RldGVjdE5ldHdvcmtcIiwgc3VwZXIuZGV0ZWN0TmV0d29yaygpKTtcbiAgICAgICAgLy8gU3RhbGwgc2VuZGluZyByZXF1ZXN0cyB1bnRpbCB0aGUgc29ja2V0IGlzIG9wZW4uLi5cbiAgICAgICAgdGhpcy5fd2Vic29ja2V0Lm9ub3BlbiA9ICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3dzUmVhZHkgPSB0cnVlO1xuICAgICAgICAgICAgT2JqZWN0LmtleXModGhpcy5fcmVxdWVzdHMpLmZvckVhY2goKGlkKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0LnNlbmQodGhpcy5fcmVxdWVzdHNbaWRdLnBheWxvYWQpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX3dlYnNvY2tldC5vbm1lc3NhZ2UgPSAobWVzc2FnZUV2ZW50KSA9PiB7XG4gICAgICAgICAgICBjb25zdCBkYXRhID0gbWVzc2FnZUV2ZW50LmRhdGE7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdC5pZCAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgaWQgPSBTdHJpbmcocmVzdWx0LmlkKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcmVxdWVzdHNbaWRdO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9yZXF1ZXN0c1tpZF07XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICByZXF1ZXN0LmNhbGxiYWNrKG51bGwsIHJlc3VsdC5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY3Rpb246IFwicmVzcG9uc2VcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IEpTT04ucGFyc2UocmVxdWVzdC5wYXlsb2FkKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlOiByZXN1bHQucmVzdWx0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcHJvdmlkZXI6IHRoaXNcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBsZXQgZXJyb3IgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0LmVycm9yKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihyZXN1bHQuZXJyb3IubWVzc2FnZSB8fCBcInVua25vd24gZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seShlcnJvciwgXCJjb2RlXCIsIHJlc3VsdC5lcnJvci5jb2RlIHx8IG51bGwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkoZXJyb3IsIFwicmVzcG9uc2VcIiwgZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcihcInVua25vd24gZXJyb3JcIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmVxdWVzdC5jYWxsYmFjayhlcnJvciwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZGVidWdcIiwge1xuICAgICAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlc3BvbnNlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0OiBKU09OLnBhcnNlKHJlcXVlc3QucGF5bG9hZCksXG4gICAgICAgICAgICAgICAgICAgICAgICBwcm92aWRlcjogdGhpc1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChyZXN1bHQubWV0aG9kID09PSBcImV0aF9zdWJzY3JpcHRpb25cIikge1xuICAgICAgICAgICAgICAgIC8vIFN1YnNjcmlwdGlvbi4uLlxuICAgICAgICAgICAgICAgIGNvbnN0IHN1YiA9IHRoaXMuX3N1YnNbcmVzdWx0LnBhcmFtcy5zdWJzY3JpcHRpb25dO1xuICAgICAgICAgICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgICAgICAgICAgLy90aGlzLmVtaXQuYXBwbHkodGhpcywgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICBzdWIucHJvY2Vzc0Z1bmMocmVzdWx0LnBhcmFtcy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcInRoaXMgc2hvdWxkIG5vdCBoYXBwZW5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIC8vIFRoaXMgUHJvdmlkZXIgZG9lcyBub3QgYWN0dWFsbHkgcG9sbCwgYnV0IHdlIHdhbnQgdG8gdHJpZ2dlclxuICAgICAgICAvLyBwb2xsIGV2ZW50cyBmb3IgdGhpbmdzIHRoYXQgZGVwZW5kIG9uIHRoZW0gKGxpa2Ugc3RhbGxpbmcgZm9yXG4gICAgICAgIC8vIGJsb2NrIGFuZCB0cmFuc2FjdGlvbiBsb29rdXBzKVxuICAgICAgICBjb25zdCBmYXV4UG9sbCA9IHNldEludGVydmFsKCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcInBvbGxcIik7XG4gICAgICAgIH0sIDEwMDApO1xuICAgICAgICBpZiAoZmF1eFBvbGwudW5yZWYpIHtcbiAgICAgICAgICAgIGZhdXhQb2xsLnVucmVmKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZGV0ZWN0TmV0d29yaygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RldGVjdE5ldHdvcms7XG4gICAgfVxuICAgIGdldCBwb2xsaW5nSW50ZXJ2YWwoKSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbiAgICByZXNldEV2ZW50c0Jsb2NrKGJsb2NrTnVtYmVyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHJlc2V0IGV2ZW50cyBibG9jayBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInJlc2V0RXZlbnRCbG9ja1wiXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzZXQgcG9sbGluZ0ludGVydmFsKHZhbHVlKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2Fubm90IHNldCBwb2xsaW5nIGludGVydmFsIG9uIFdlYlNvY2tldFByb3ZpZGVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwic2V0UG9sbGluZ0ludGVydmFsXCJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHBvbGwoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNldCBwb2xsaW5nKHZhbHVlKSB7XG4gICAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImNhbm5vdCBzZXQgcG9sbGluZyBvbiBXZWJTb2NrZXRQcm92aWRlclwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcInNldFBvbGxpbmdcIlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgc2VuZChtZXRob2QsIHBhcmFtcykge1xuICAgICAgICBjb25zdCByaWQgPSBOZXh0SWQrKztcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGZ1bmN0aW9uIGNhbGxiYWNrKGVycm9yLCByZXN1bHQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiByZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwYXlsb2FkID0gSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICAgICAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxuICAgICAgICAgICAgICAgIGlkOiByaWQsXG4gICAgICAgICAgICAgICAganNvbnJwYzogXCIyLjBcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCJkZWJ1Z1wiLCB7XG4gICAgICAgICAgICAgICAgYWN0aW9uOiBcInJlcXVlc3RcIixcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBKU09OLnBhcnNlKHBheWxvYWQpLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyOiB0aGlzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RzW1N0cmluZyhyaWQpXSA9IHsgY2FsbGJhY2ssIHBheWxvYWQgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLl93c1JlYWR5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0LnNlbmQocGF5bG9hZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzdGF0aWMgZGVmYXVsdFVybCgpIHtcbiAgICAgICAgcmV0dXJuIFwid3M6L1xcL2xvY2FsaG9zdDo4NTQ2XCI7XG4gICAgfVxuICAgIF9zdWJzY3JpYmUodGFnLCBwYXJhbSwgcHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIGxldCBzdWJJZFByb21pc2UgPSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgICAgIGlmIChzdWJJZFByb21pc2UgPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHN1YklkUHJvbWlzZSA9IFByb21pc2UuYWxsKHBhcmFtKS50aGVuKChwYXJhbSkgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZW5kKFwiZXRoX3N1YnNjcmliZVwiLCBwYXJhbSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3ViSWRzW3RhZ10gPSBzdWJJZFByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzdWJJZCA9IHlpZWxkIHN1YklkUHJvbWlzZTtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNbc3ViSWRdID0geyB0YWcsIHByb2Nlc3NGdW5jIH07XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc3RhcnRFdmVudChldmVudCkge1xuICAgICAgICBzd2l0Y2ggKGV2ZW50LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJibG9ja1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcImJsb2NrXCIsIFtcIm5ld0hlYWRzXCJdLCAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJsb2NrTnVtYmVyID0gQmlnTnVtYmVyLmZyb20ocmVzdWx0Lm51bWJlcikudG9OdW1iZXIoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZW1pdHRlZC5ibG9jayA9IGJsb2NrTnVtYmVyO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJibG9ja1wiLCBibG9ja051bWJlcik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwicGVuZGluZ1wiOlxuICAgICAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZShcInBlbmRpbmdcIiwgW1wibmV3UGVuZGluZ1RyYW5zYWN0aW9uc1wiXSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCJwZW5kaW5nXCIsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiZmlsdGVyXCI6XG4gICAgICAgICAgICAgICAgdGhpcy5fc3Vic2NyaWJlKGV2ZW50LnRhZywgW1wibG9nc1wiLCB0aGlzLl9nZXRGaWx0ZXIoZXZlbnQuZmlsdGVyKV0sIChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdC5yZW1vdmVkID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdC5yZW1vdmVkID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGV2ZW50LmZpbHRlciwgdGhpcy5mb3JtYXR0ZXIuZmlsdGVyTG9nKHJlc3VsdCkpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcInR4XCI6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBlbWl0UmVjZWlwdCA9IChldmVudCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBoYXNoID0gZXZlbnQuaGFzaDtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRUcmFuc2FjdGlvblJlY2VpcHQoaGFzaCkudGhlbigocmVjZWlwdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWNlaXB0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KGhhc2gsIHJlY2VpcHQpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIC8vIEluIGNhc2UgaXQgaXMgYWxyZWFkeSBtaW5lZFxuICAgICAgICAgICAgICAgIGVtaXRSZWNlaXB0KGV2ZW50KTtcbiAgICAgICAgICAgICAgICAvLyBUbyBrZWVwIHRoaW5ncyBzaW1wbGUsIHdlIHN0YXJ0IHVwIGEgc2luZ2xlIG5ld0hlYWRzIHN1YnNjcmlwdGlvblxuICAgICAgICAgICAgICAgIC8vIHRvIGtlZXAgYW4gZXllIG91dCBmb3IgdHJhbnNhY3Rpb25zIHdlIGFyZSB3YXRjaGluZyBmb3IuXG4gICAgICAgICAgICAgICAgLy8gU3RhcnRpbmcgYSBzdWJzY3JpcHRpb24gZm9yIGFuIGV2ZW50IChpLmUuIFwidHhcIikgdGhhdCBpcyBhbHJlYWR5XG4gICAgICAgICAgICAgICAgLy8gcnVubmluZyBpcyAoYmFzaWNhbGx5KSBhIG5vcC5cbiAgICAgICAgICAgICAgICB0aGlzLl9zdWJzY3JpYmUoXCJ0eFwiLCBbXCJuZXdIZWFkc1wiXSwgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMuZmlsdGVyKChlKSA9PiAoZS50eXBlID09PSBcInR4XCIpKS5mb3JFYWNoKGVtaXRSZWNlaXB0KTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIE5vdGhpbmcgaXMgbmVlZGVkXG4gICAgICAgICAgICBjYXNlIFwiZGVidWdcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwb2xsXCI6XG4gICAgICAgICAgICBjYXNlIFwid2lsbFBvbGxcIjpcbiAgICAgICAgICAgIGNhc2UgXCJkaWRQb2xsXCI6XG4gICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJ1bmhhbmRsZWQ6XCIsIGV2ZW50KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBfc3RvcEV2ZW50KGV2ZW50KSB7XG4gICAgICAgIGxldCB0YWcgPSBldmVudC50YWc7XG4gICAgICAgIGlmIChldmVudC50eXBlID09PSBcInR4XCIpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgdHJhbnNhY3Rpb24gZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICBpZiAodGhpcy5fZXZlbnRzLmZpbHRlcigoZSkgPT4gKGUudHlwZSA9PT0gXCJ0eFwiKSkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGFnID0gXCJ0eFwiO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudChldmVudC5ldmVudCkpIHtcbiAgICAgICAgICAgIC8vIFRoZXJlIGFyZSByZW1haW5pbmcgZXZlbnQgbGlzdGVuZXJzXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3ViSWQgPSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgaWYgKCFzdWJJZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdWJJZHNbdGFnXTtcbiAgICAgICAgc3ViSWQudGhlbigoc3ViSWQpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fc3Vic1tzdWJJZF0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fc3Vic1tzdWJJZF07XG4gICAgICAgICAgICB0aGlzLnNlbmQoXCJldGhfdW5zdWJzY3JpYmVcIiwgW3N1YklkXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBkZXN0cm95KCkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gV2FpdCB1bnRpbCB3ZSBoYXZlIGNvbm5lY3RlZCBiZWZvcmUgdHJ5aW5nIHRvIGRpc2Nvbm5lY3RcbiAgICAgICAgICAgIGlmICh0aGlzLl93ZWJzb2NrZXQucmVhZHlTdGF0ZSA9PT0gV2ViU29ja2V0LkNPTk5FQ1RJTkcpIHtcbiAgICAgICAgICAgICAgICB5aWVsZCAobmV3IFByb21pc2UoKHJlc29sdmUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0Lm9ub3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3dlYnNvY2tldC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShmYWxzZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gSGFuZ3VwXG4gICAgICAgICAgICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuLVVTL2RvY3MvV2ViL0FQSS9DbG9zZUV2ZW50I1N0YXR1c19jb2Rlc1xuICAgICAgICAgICAgdGhpcy5fd2Vic29ja2V0LmNsb3NlKDEwMDApO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD13ZWJzb2NrZXQtcHJvdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmxldCBXUyA9IG51bGw7XG50cnkge1xuICAgIFdTID0gV2ViU29ja2V0O1xuICAgIGlmIChXUyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImluamVjdCBwbGVhc2VcIik7XG4gICAgfVxufVxuY2F0Y2ggKGVycm9yKSB7XG4gICAgY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbiAgICBXUyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJXZWJTb2NrZXRzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudFwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgb3BlcmF0aW9uOiBcIm5ldyBXZWJTb2NrZXQoKVwiXG4gICAgICAgIH0pO1xuICAgIH07XG59XG4vL2V4cG9ydCBkZWZhdWx0IFdTO1xuLy9tb2R1bGUuZXhwb3J0cyA9IFdTO1xuZXhwb3J0IHsgV1MgYXMgV2ViU29ja2V0IH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13cy5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwicmFuZG9tLzUuNS4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmV4cG9ydCB7IHJhbmRvbUJ5dGVzIH0gZnJvbSBcIi4vcmFuZG9tXCI7XG5leHBvcnQgeyBzaHVmZmxlZCB9IGZyb20gXCIuL3NodWZmbGVcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbi8vIERlYnVnZ2luZyBsaW5lIGZvciB0ZXN0aW5nIGJyb3dzZXIgbGliIGluIG5vZGVcbi8vY29uc3Qgd2luZG93ID0geyBjcnlwdG86IHsgZ2V0UmFuZG9tVmFsdWVzOiAoKSA9PiB7IH0gfSB9O1xubGV0IGFueUdsb2JhbCA9IG51bGw7XG50cnkge1xuICAgIGFueUdsb2JhbCA9IHdpbmRvdztcbiAgICBpZiAoYW55R2xvYmFsID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IG5leHRcIik7XG4gICAgfVxufVxuY2F0Y2ggKGVycm9yKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgYW55R2xvYmFsID0gZ2xvYmFsO1xuICAgICAgICBpZiAoYW55R2xvYmFsID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcInRyeSBuZXh0XCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBhbnlHbG9iYWwgPSB7fTtcbiAgICB9XG59XG5sZXQgY3J5cHRvID0gYW55R2xvYmFsLmNyeXB0byB8fCBhbnlHbG9iYWwubXNDcnlwdG87XG5pZiAoIWNyeXB0byB8fCAhY3J5cHRvLmdldFJhbmRvbVZhbHVlcykge1xuICAgIGxvZ2dlci53YXJuKFwiV0FSTklORzogTWlzc2luZyBzdHJvbmcgcmFuZG9tIG51bWJlciBzb3VyY2VcIik7XG4gICAgY3J5cHRvID0ge1xuICAgICAgICBnZXRSYW5kb21WYWx1ZXM6IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBsb2dnZXIudGhyb3dFcnJvcihcIm5vIHNlY3VyZSByYW5kb20gc291cmNlIGF2YWlhbGJsZVwiLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbjogXCJjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzXCJcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfTtcbn1cbmV4cG9ydCBmdW5jdGlvbiByYW5kb21CeXRlcyhsZW5ndGgpIHtcbiAgICBpZiAobGVuZ3RoIDw9IDAgfHwgbGVuZ3RoID4gMTAyNCB8fCAobGVuZ3RoICUgMSkgfHwgbGVuZ3RoICE9IGxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGhcIiwgXCJsZW5ndGhcIiwgbGVuZ3RoKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gbmV3IFVpbnQ4QXJyYXkobGVuZ3RoKTtcbiAgICBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzKHJlc3VsdCk7XG4gICAgcmV0dXJuIGFycmF5aWZ5KHJlc3VsdCk7XG59XG47XG4vLyMgc291cmNlTWFwcGluZ1VSTD1yYW5kb20uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5leHBvcnQgZnVuY3Rpb24gc2h1ZmZsZWQoYXJyYXkpIHtcbiAgICBhcnJheSA9IGFycmF5LnNsaWNlKCk7XG4gICAgZm9yIChsZXQgaSA9IGFycmF5Lmxlbmd0aCAtIDE7IGkgPiAwOyBpLS0pIHtcbiAgICAgICAgY29uc3QgaiA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChpICsgMSkpO1xuICAgICAgICBjb25zdCB0bXAgPSBhcnJheVtpXTtcbiAgICAgICAgYXJyYXlbaV0gPSBhcnJheVtqXTtcbiAgICAgICAgYXJyYXlbal0gPSB0bXA7XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNodWZmbGUuanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcInJscC81LjUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vL1NlZTogaHR0cHM6Ly9naXRodWIuY29tL2V0aGVyZXVtL3dpa2kvd2lraS9STFBcbmltcG9ydCB7IGFycmF5aWZ5LCBoZXhsaWZ5LCBpc0J5dGVzTGlrZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZnVuY3Rpb24gYXJyYXlpZnlJbnRlZ2VyKHZhbHVlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgd2hpbGUgKHZhbHVlKSB7XG4gICAgICAgIHJlc3VsdC51bnNoaWZ0KHZhbHVlICYgMHhmZik7XG4gICAgICAgIHZhbHVlID4+PSA4O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gdW5hcnJheWlmeUludGVnZXIoZGF0YSwgb2Zmc2V0LCBsZW5ndGgpIHtcbiAgICBsZXQgcmVzdWx0ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdCA9IChyZXN1bHQgKiAyNTYpICsgZGF0YVtvZmZzZXQgKyBpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIF9lbmNvZGUob2JqZWN0KSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqZWN0KSkge1xuICAgICAgICBsZXQgcGF5bG9hZCA9IFtdO1xuICAgICAgICBvYmplY3QuZm9yRWFjaChmdW5jdGlvbiAoY2hpbGQpIHtcbiAgICAgICAgICAgIHBheWxvYWQgPSBwYXlsb2FkLmNvbmNhdChfZW5jb2RlKGNoaWxkKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocGF5bG9hZC5sZW5ndGggPD0gNTUpIHtcbiAgICAgICAgICAgIHBheWxvYWQudW5zaGlmdCgweGMwICsgcGF5bG9hZC5sZW5ndGgpO1xuICAgICAgICAgICAgcmV0dXJuIHBheWxvYWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGVuZ3RoID0gYXJyYXlpZnlJbnRlZ2VyKHBheWxvYWQubGVuZ3RoKTtcbiAgICAgICAgbGVuZ3RoLnVuc2hpZnQoMHhmNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgICAgICByZXR1cm4gbGVuZ3RoLmNvbmNhdChwYXlsb2FkKTtcbiAgICB9XG4gICAgaWYgKCFpc0J5dGVzTGlrZShvYmplY3QpKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJSTFAgb2JqZWN0IG11c3QgYmUgQnl0ZXNMaWtlXCIsIFwib2JqZWN0XCIsIG9iamVjdCk7XG4gICAgfVxuICAgIGNvbnN0IGRhdGEgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcnJheWlmeShvYmplY3QpKTtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDEgJiYgZGF0YVswXSA8PSAweDdmKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhLmxlbmd0aCA8PSA1NSkge1xuICAgICAgICBkYXRhLnVuc2hpZnQoMHg4MCArIGRhdGEubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5aWZ5SW50ZWdlcihkYXRhLmxlbmd0aCk7XG4gICAgbGVuZ3RoLnVuc2hpZnQoMHhiNyArIGxlbmd0aC5sZW5ndGgpO1xuICAgIHJldHVybiBsZW5ndGguY29uY2F0KGRhdGEpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGVuY29kZShvYmplY3QpIHtcbiAgICByZXR1cm4gaGV4bGlmeShfZW5jb2RlKG9iamVjdCkpO1xufVxuZnVuY3Rpb24gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgY2hpbGRPZmZzZXQsIGxlbmd0aCkge1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlIChjaGlsZE9mZnNldCA8IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZGVjb2RlZCA9IF9kZWNvZGUoZGF0YSwgY2hpbGRPZmZzZXQpO1xuICAgICAgICByZXN1bHQucHVzaChkZWNvZGVkLnJlc3VsdCk7XG4gICAgICAgIGNoaWxkT2Zmc2V0ICs9IGRlY29kZWQuY29uc3VtZWQ7XG4gICAgICAgIGlmIChjaGlsZE9mZnNldCA+IG9mZnNldCArIDEgKyBsZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiY2hpbGQgZGF0YSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG59XG4vLyByZXR1cm5zIHsgY29uc3VtZWQ6IG51bWJlciwgcmVzdWx0OiBPYmplY3QgfVxuZnVuY3Rpb24gX2RlY29kZShkYXRhLCBvZmZzZXQpIHtcbiAgICBpZiAoZGF0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgfVxuICAgIC8vIEFycmF5IHdpdGggZXh0cmEgbGVuZ3RoIHByZWZpeFxuICAgIGlmIChkYXRhW29mZnNldF0gPj0gMHhmOCkge1xuICAgICAgICBjb25zdCBsZW5ndGhMZW5ndGggPSBkYXRhW29mZnNldF0gLSAweGY3O1xuICAgICAgICBpZiAob2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCA+IGRhdGEubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcImRhdGEgc2hvcnQgc2VnbWVudCB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBsb25nIHNlZ21lbnQgdG9vIHNob3J0XCIsIExvZ2dlci5lcnJvcnMuQlVGRkVSX09WRVJSVU4sIHt9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gX2RlY29kZUNoaWxkcmVuKGRhdGEsIG9mZnNldCwgb2Zmc2V0ICsgMSArIGxlbmd0aExlbmd0aCwgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoZGF0YVtvZmZzZXRdID49IDB4YzApIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gZGF0YVtvZmZzZXRdIC0gMHhjMDtcbiAgICAgICAgaWYgKG9mZnNldCArIDEgKyBsZW5ndGggPiBkYXRhLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJkYXRhIGFycmF5IHRvbyBzaG9ydFwiLCBMb2dnZXIuZXJyb3JzLkJVRkZFUl9PVkVSUlVOLCB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9kZWNvZGVDaGlsZHJlbihkYXRhLCBvZmZzZXQsIG9mZnNldCArIDEsIGxlbmd0aCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweGI4KSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aExlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4Yjc7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IHVuYXJyYXlpZnlJbnRlZ2VyKGRhdGEsIG9mZnNldCArIDEsIGxlbmd0aExlbmd0aCk7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSBhcnJheSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoLCBvZmZzZXQgKyAxICsgbGVuZ3RoTGVuZ3RoICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aExlbmd0aCArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIGVsc2UgaWYgKGRhdGFbb2Zmc2V0XSA+PSAweDgwKSB7XG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGRhdGFbb2Zmc2V0XSAtIDB4ODA7XG4gICAgICAgIGlmIChvZmZzZXQgKyAxICsgbGVuZ3RoID4gZGF0YS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiZGF0YSB0b28gc2hvcnRcIiwgTG9nZ2VyLmVycm9ycy5CVUZGRVJfT1ZFUlJVTiwge30pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGhleGxpZnkoZGF0YS5zbGljZShvZmZzZXQgKyAxLCBvZmZzZXQgKyAxICsgbGVuZ3RoKSk7XG4gICAgICAgIHJldHVybiB7IGNvbnN1bWVkOiAoMSArIGxlbmd0aCksIHJlc3VsdDogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IGNvbnN1bWVkOiAxLCByZXN1bHQ6IGhleGxpZnkoZGF0YVtvZmZzZXRdKSB9O1xufVxuZXhwb3J0IGZ1bmN0aW9uIGRlY29kZShkYXRhKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShkYXRhKTtcbiAgICBjb25zdCBkZWNvZGVkID0gX2RlY29kZShieXRlcywgMCk7XG4gICAgaWYgKGRlY29kZWQuY29uc3VtZWQgIT09IGJ5dGVzLmxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBybHAgZGF0YVwiLCBcImRhdGFcIiwgZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBkZWNvZGVkLnJlc3VsdDtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzaGEyLzUuNS4wXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJpbXBvcnQgeyBjb21wdXRlSG1hYywgcmlwZW1kMTYwLCBzaGEyNTYsIHNoYTUxMiB9IGZyb20gXCIuL3NoYTJcIjtcbmltcG9ydCB7IFN1cHBvcnRlZEFsZ29yaXRobSB9IGZyb20gXCIuL3R5cGVzXCI7XG5leHBvcnQgeyBjb21wdXRlSG1hYywgcmlwZW1kMTYwLCBzaGEyNTYsIHNoYTUxMiwgU3VwcG9ydGVkQWxnb3JpdGhtIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCBoYXNoIGZyb20gXCJoYXNoLmpzXCI7XG4vL2NvbnN0IF9yaXBlbWQxNjAgPSBfaGFzaC5yaXBlbWQxNjA7XG5pbXBvcnQgeyBhcnJheWlmeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9ieXRlc1wiO1xuaW1wb3J0IHsgU3VwcG9ydGVkQWxnb3JpdGhtIH0gZnJvbSBcIi4vdHlwZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmV4cG9ydCBmdW5jdGlvbiByaXBlbWQxNjAoZGF0YSkge1xuICAgIHJldHVybiBcIjB4XCIgKyAoaGFzaC5yaXBlbWQxNjAoKS51cGRhdGUoYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKSk7XG59XG5leHBvcnQgZnVuY3Rpb24gc2hhMjU2KGRhdGEpIHtcbiAgICByZXR1cm4gXCIweFwiICsgKGhhc2guc2hhMjU2KCkudXBkYXRlKGFycmF5aWZ5KGRhdGEpKS5kaWdlc3QoXCJoZXhcIikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYTUxMihkYXRhKSB7XG4gICAgcmV0dXJuIFwiMHhcIiArIChoYXNoLnNoYTUxMigpLnVwZGF0ZShhcnJheWlmeShkYXRhKSkuZGlnZXN0KFwiaGV4XCIpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb21wdXRlSG1hYyhhbGdvcml0aG0sIGtleSwgZGF0YSkge1xuICAgIGlmICghU3VwcG9ydGVkQWxnb3JpdGhtW2FsZ29yaXRobV0pIHtcbiAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJ1bnN1cHBvcnRlZCBhbGdvcml0aG0gXCIgKyBhbGdvcml0aG0sIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICBvcGVyYXRpb246IFwiaG1hY1wiLFxuICAgICAgICAgICAgYWxnb3JpdGhtOiBhbGdvcml0aG1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBcIjB4XCIgKyBoYXNoLmhtYWMoaGFzaFthbGdvcml0aG1dLCBhcnJheWlmeShrZXkpKS51cGRhdGUoYXJyYXlpZnkoZGF0YSkpLmRpZ2VzdChcImhleFwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXNoYTIuanMubWFwIiwiZXhwb3J0IHZhciBTdXBwb3J0ZWRBbGdvcml0aG07XG4oZnVuY3Rpb24gKFN1cHBvcnRlZEFsZ29yaXRobSkge1xuICAgIFN1cHBvcnRlZEFsZ29yaXRobVtcInNoYTI1NlwiXSA9IFwic2hhMjU2XCI7XG4gICAgU3VwcG9ydGVkQWxnb3JpdGhtW1wic2hhNTEyXCJdID0gXCJzaGE1MTJcIjtcbn0pKFN1cHBvcnRlZEFsZ29yaXRobSB8fCAoU3VwcG9ydGVkQWxnb3JpdGhtID0ge30pKTtcbjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXR5cGVzLmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzaWduaW5nLWtleS81LjUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiaW1wb3J0IEJOIGZyb20gJ2JuLmpzJztcbmltcG9ydCBoYXNoIGZyb20gJ2hhc2guanMnO1xuXG52YXIgY29tbW9uanNHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsVGhpcyAhPT0gJ3VuZGVmaW5lZCcgPyBnbG9iYWxUaGlzIDogdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyA/IGdsb2JhbCA6IHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJyA/IHNlbGYgOiB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21DanMgKHgpIHtcblx0cmV0dXJuIHggJiYgeC5fX2VzTW9kdWxlICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh4LCAnZGVmYXVsdCcpID8geFsnZGVmYXVsdCddIDogeDtcbn1cblxuZnVuY3Rpb24gY3JlYXRlQ29tbW9uanNNb2R1bGUoZm4sIGJhc2VkaXIsIG1vZHVsZSkge1xuXHRyZXR1cm4gbW9kdWxlID0ge1xuXHRcdHBhdGg6IGJhc2VkaXIsXG5cdFx0ZXhwb3J0czoge30sXG5cdFx0cmVxdWlyZTogZnVuY3Rpb24gKHBhdGgsIGJhc2UpIHtcblx0XHRcdHJldHVybiBjb21tb25qc1JlcXVpcmUocGF0aCwgKGJhc2UgPT09IHVuZGVmaW5lZCB8fCBiYXNlID09PSBudWxsKSA/IG1vZHVsZS5wYXRoIDogYmFzZSk7XG5cdFx0fVxuXHR9LCBmbihtb2R1bGUsIG1vZHVsZS5leHBvcnRzKSwgbW9kdWxlLmV4cG9ydHM7XG59XG5cbmZ1bmN0aW9uIGdldERlZmF1bHRFeHBvcnRGcm9tTmFtZXNwYWNlSWZQcmVzZW50IChuKSB7XG5cdHJldHVybiBuICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCAnZGVmYXVsdCcpID8gblsnZGVmYXVsdCddIDogbjtcbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEV4cG9ydEZyb21OYW1lc3BhY2VJZk5vdE5hbWVkIChuKSB7XG5cdHJldHVybiBuICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChuLCAnZGVmYXVsdCcpICYmIE9iamVjdC5rZXlzKG4pLmxlbmd0aCA9PT0gMSA/IG5bJ2RlZmF1bHQnXSA6IG47XG59XG5cbmZ1bmN0aW9uIGdldEF1Z21lbnRlZE5hbWVzcGFjZShuKSB7XG5cdGlmIChuLl9fZXNNb2R1bGUpIHJldHVybiBuO1xuXHR2YXIgYSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh7fSwgJ19fZXNNb2R1bGUnLCB7dmFsdWU6IHRydWV9KTtcblx0T2JqZWN0LmtleXMobikuZm9yRWFjaChmdW5jdGlvbiAoaykge1xuXHRcdHZhciBkID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihuLCBrKTtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoYSwgaywgZC5nZXQgPyBkIDoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGdldDogZnVuY3Rpb24gKCkge1xuXHRcdFx0XHRyZXR1cm4gbltrXTtcblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG5cdHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjb21tb25qc1JlcXVpcmUgKCkge1xuXHR0aHJvdyBuZXcgRXJyb3IoJ0R5bmFtaWMgcmVxdWlyZXMgYXJlIG5vdCBjdXJyZW50bHkgc3VwcG9ydGVkIGJ5IEByb2xsdXAvcGx1Z2luLWNvbW1vbmpzJyk7XG59XG5cbnZhciBtaW5pbWFsaXN0aWNBc3NlcnQgPSBhc3NlcnQ7XG5cbmZ1bmN0aW9uIGFzc2VydCh2YWwsIG1zZykge1xuICBpZiAoIXZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IobXNnIHx8ICdBc3NlcnRpb24gZmFpbGVkJyk7XG59XG5cbmFzc2VydC5lcXVhbCA9IGZ1bmN0aW9uIGFzc2VydEVxdWFsKGwsIHIsIG1zZykge1xuICBpZiAobCAhPSByKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgKCdBc3NlcnRpb24gZmFpbGVkOiAnICsgbCArICcgIT0gJyArIHIpKTtcbn07XG5cbnZhciB1dGlsc18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBleHBvcnRzO1xuXG5mdW5jdGlvbiB0b0FycmF5KG1zZywgZW5jKSB7XG4gIGlmIChBcnJheS5pc0FycmF5KG1zZykpXG4gICAgcmV0dXJuIG1zZy5zbGljZSgpO1xuICBpZiAoIW1zZylcbiAgICByZXR1cm4gW107XG4gIHZhciByZXMgPSBbXTtcbiAgaWYgKHR5cGVvZiBtc2cgIT09ICdzdHJpbmcnKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspXG4gICAgICByZXNbaV0gPSBtc2dbaV0gfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH1cbiAgaWYgKGVuYyA9PT0gJ2hleCcpIHtcbiAgICBtc2cgPSBtc2cucmVwbGFjZSgvW15hLXowLTldKy9pZywgJycpO1xuICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgIG1zZyA9ICcwJyArIG1zZztcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgIHJlcy5wdXNoKHBhcnNlSW50KG1zZ1tpXSArIG1zZ1tpICsgMV0sIDE2KSk7XG4gIH0gZWxzZSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gbXNnLmNoYXJDb2RlQXQoaSk7XG4gICAgICB2YXIgaGkgPSBjID4+IDg7XG4gICAgICB2YXIgbG8gPSBjICYgMHhmZjtcbiAgICAgIGlmIChoaSlcbiAgICAgICAgcmVzLnB1c2goaGksIGxvKTtcbiAgICAgIGVsc2VcbiAgICAgICAgcmVzLnB1c2gobG8pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzO1xufVxudXRpbHMudG9BcnJheSA9IHRvQXJyYXk7XG5cbmZ1bmN0aW9uIHplcm8yKHdvcmQpIHtcbiAgaWYgKHdvcmQubGVuZ3RoID09PSAxKVxuICAgIHJldHVybiAnMCcgKyB3b3JkO1xuICBlbHNlXG4gICAgcmV0dXJuIHdvcmQ7XG59XG51dGlscy56ZXJvMiA9IHplcm8yO1xuXG5mdW5jdGlvbiB0b0hleChtc2cpIHtcbiAgdmFyIHJlcyA9ICcnO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICByZXMgKz0gemVybzIobXNnW2ldLnRvU3RyaW5nKDE2KSk7XG4gIHJldHVybiByZXM7XG59XG51dGlscy50b0hleCA9IHRvSGV4O1xuXG51dGlscy5lbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoYXJyLCBlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHRvSGV4KGFycik7XG4gIGVsc2VcbiAgICByZXR1cm4gYXJyO1xufTtcbn0pO1xuXG52YXIgdXRpbHNfMSQxID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSBleHBvcnRzO1xuXG5cblxuXG51dGlscy5hc3NlcnQgPSBtaW5pbWFsaXN0aWNBc3NlcnQ7XG51dGlscy50b0FycmF5ID0gdXRpbHNfMS50b0FycmF5O1xudXRpbHMuemVybzIgPSB1dGlsc18xLnplcm8yO1xudXRpbHMudG9IZXggPSB1dGlsc18xLnRvSGV4O1xudXRpbHMuZW5jb2RlID0gdXRpbHNfMS5lbmNvZGU7XG5cbi8vIFJlcHJlc2VudCBudW0gaW4gYSB3LU5BRiBmb3JtXG5mdW5jdGlvbiBnZXROQUYobnVtLCB3LCBiaXRzKSB7XG4gIHZhciBuYWYgPSBuZXcgQXJyYXkoTWF0aC5tYXgobnVtLmJpdExlbmd0aCgpLCBiaXRzKSArIDEpO1xuICBuYWYuZmlsbCgwKTtcblxuICB2YXIgd3MgPSAxIDw8ICh3ICsgMSk7XG4gIHZhciBrID0gbnVtLmNsb25lKCk7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBuYWYubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgejtcbiAgICB2YXIgbW9kID0gay5hbmRsbih3cyAtIDEpO1xuICAgIGlmIChrLmlzT2RkKCkpIHtcbiAgICAgIGlmIChtb2QgPiAod3MgPj4gMSkgLSAxKVxuICAgICAgICB6ID0gKHdzID4+IDEpIC0gbW9kO1xuICAgICAgZWxzZVxuICAgICAgICB6ID0gbW9kO1xuICAgICAgay5pc3Vibih6KTtcbiAgICB9IGVsc2Uge1xuICAgICAgeiA9IDA7XG4gICAgfVxuXG4gICAgbmFmW2ldID0gejtcbiAgICBrLml1c2hybigxKTtcbiAgfVxuXG4gIHJldHVybiBuYWY7XG59XG51dGlscy5nZXROQUYgPSBnZXROQUY7XG5cbi8vIFJlcHJlc2VudCBrMSwgazIgaW4gYSBKb2ludCBTcGFyc2UgRm9ybVxuZnVuY3Rpb24gZ2V0SlNGKGsxLCBrMikge1xuICB2YXIganNmID0gW1xuICAgIFtdLFxuICAgIFtdLFxuICBdO1xuXG4gIGsxID0gazEuY2xvbmUoKTtcbiAgazIgPSBrMi5jbG9uZSgpO1xuICB2YXIgZDEgPSAwO1xuICB2YXIgZDIgPSAwO1xuICB2YXIgbTg7XG4gIHdoaWxlIChrMS5jbXBuKC1kMSkgPiAwIHx8IGsyLmNtcG4oLWQyKSA+IDApIHtcbiAgICAvLyBGaXJzdCBwaGFzZVxuICAgIHZhciBtMTQgPSAoazEuYW5kbG4oMykgKyBkMSkgJiAzO1xuICAgIHZhciBtMjQgPSAoazIuYW5kbG4oMykgKyBkMikgJiAzO1xuICAgIGlmIChtMTQgPT09IDMpXG4gICAgICBtMTQgPSAtMTtcbiAgICBpZiAobTI0ID09PSAzKVxuICAgICAgbTI0ID0gLTE7XG4gICAgdmFyIHUxO1xuICAgIGlmICgobTE0ICYgMSkgPT09IDApIHtcbiAgICAgIHUxID0gMDtcbiAgICB9IGVsc2Uge1xuICAgICAgbTggPSAoazEuYW5kbG4oNykgKyBkMSkgJiA3O1xuICAgICAgaWYgKChtOCA9PT0gMyB8fCBtOCA9PT0gNSkgJiYgbTI0ID09PSAyKVxuICAgICAgICB1MSA9IC1tMTQ7XG4gICAgICBlbHNlXG4gICAgICAgIHUxID0gbTE0O1xuICAgIH1cbiAgICBqc2ZbMF0ucHVzaCh1MSk7XG5cbiAgICB2YXIgdTI7XG4gICAgaWYgKChtMjQgJiAxKSA9PT0gMCkge1xuICAgICAgdTIgPSAwO1xuICAgIH0gZWxzZSB7XG4gICAgICBtOCA9IChrMi5hbmRsbig3KSArIGQyKSAmIDc7XG4gICAgICBpZiAoKG04ID09PSAzIHx8IG04ID09PSA1KSAmJiBtMTQgPT09IDIpXG4gICAgICAgIHUyID0gLW0yNDtcbiAgICAgIGVsc2VcbiAgICAgICAgdTIgPSBtMjQ7XG4gICAgfVxuICAgIGpzZlsxXS5wdXNoKHUyKTtcblxuICAgIC8vIFNlY29uZCBwaGFzZVxuICAgIGlmICgyICogZDEgPT09IHUxICsgMSlcbiAgICAgIGQxID0gMSAtIGQxO1xuICAgIGlmICgyICogZDIgPT09IHUyICsgMSlcbiAgICAgIGQyID0gMSAtIGQyO1xuICAgIGsxLml1c2hybigxKTtcbiAgICBrMi5pdXNocm4oMSk7XG4gIH1cblxuICByZXR1cm4ganNmO1xufVxudXRpbHMuZ2V0SlNGID0gZ2V0SlNGO1xuXG5mdW5jdGlvbiBjYWNoZWRQcm9wZXJ0eShvYmosIG5hbWUsIGNvbXB1dGVyKSB7XG4gIHZhciBrZXkgPSAnXycgKyBuYW1lO1xuICBvYmoucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24gY2FjaGVkUHJvcGVydHkoKSB7XG4gICAgcmV0dXJuIHRoaXNba2V5XSAhPT0gdW5kZWZpbmVkID8gdGhpc1trZXldIDpcbiAgICAgIHRoaXNba2V5XSA9IGNvbXB1dGVyLmNhbGwodGhpcyk7XG4gIH07XG59XG51dGlscy5jYWNoZWRQcm9wZXJ0eSA9IGNhY2hlZFByb3BlcnR5O1xuXG5mdW5jdGlvbiBwYXJzZUJ5dGVzKGJ5dGVzKSB7XG4gIHJldHVybiB0eXBlb2YgYnl0ZXMgPT09ICdzdHJpbmcnID8gdXRpbHMudG9BcnJheShieXRlcywgJ2hleCcpIDpcbiAgICBieXRlcztcbn1cbnV0aWxzLnBhcnNlQnl0ZXMgPSBwYXJzZUJ5dGVzO1xuXG5mdW5jdGlvbiBpbnRGcm9tTEUoYnl0ZXMpIHtcbiAgcmV0dXJuIG5ldyBCTihieXRlcywgJ2hleCcsICdsZScpO1xufVxudXRpbHMuaW50RnJvbUxFID0gaW50RnJvbUxFO1xufSk7XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbnZhciBnZXROQUYgPSB1dGlsc18xJDEuZ2V0TkFGO1xudmFyIGdldEpTRiA9IHV0aWxzXzEkMS5nZXRKU0Y7XG52YXIgYXNzZXJ0JDEgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBCYXNlQ3VydmUodHlwZSwgY29uZikge1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnAgPSBuZXcgQk4oY29uZi5wLCAxNik7XG5cbiAgLy8gVXNlIE1vbnRnb21lcnksIHdoZW4gdGhlcmUgaXMgbm8gZmFzdCByZWR1Y3Rpb24gZm9yIHRoZSBwcmltZVxuICB0aGlzLnJlZCA9IGNvbmYucHJpbWUgPyBCTi5yZWQoY29uZi5wcmltZSkgOiBCTi5tb250KHRoaXMucCk7XG5cbiAgLy8gVXNlZnVsIGZvciBtYW55IGN1cnZlc1xuICB0aGlzLnplcm8gPSBuZXcgQk4oMCkudG9SZWQodGhpcy5yZWQpO1xuICB0aGlzLm9uZSA9IG5ldyBCTigxKS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudHdvID0gbmV3IEJOKDIpLnRvUmVkKHRoaXMucmVkKTtcblxuICAvLyBDdXJ2ZSBjb25maWd1cmF0aW9uLCBvcHRpb25hbFxuICB0aGlzLm4gPSBjb25mLm4gJiYgbmV3IEJOKGNvbmYubiwgMTYpO1xuICB0aGlzLmcgPSBjb25mLmcgJiYgdGhpcy5wb2ludEZyb21KU09OKGNvbmYuZywgY29uZi5nUmVkKTtcblxuICAvLyBUZW1wb3JhcnkgYXJyYXlzXG4gIHRoaXMuX3duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fd25hZlQyID0gbmV3IEFycmF5KDQpO1xuICB0aGlzLl93bmFmVDMgPSBuZXcgQXJyYXkoNCk7XG4gIHRoaXMuX3duYWZUNCA9IG5ldyBBcnJheSg0KTtcblxuICB0aGlzLl9iaXRMZW5ndGggPSB0aGlzLm4gPyB0aGlzLm4uYml0TGVuZ3RoKCkgOiAwO1xuXG4gIC8vIEdlbmVyYWxpemVkIEdyZWcgTWF4d2VsbCdzIHRyaWNrXG4gIHZhciBhZGp1c3RDb3VudCA9IHRoaXMubiAmJiB0aGlzLnAuZGl2KHRoaXMubik7XG4gIGlmICghYWRqdXN0Q291bnQgfHwgYWRqdXN0Q291bnQuY21wbigxMDApID4gMCkge1xuICAgIHRoaXMucmVkTiA9IG51bGw7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy5fbWF4d2VsbFRyaWNrID0gdHJ1ZTtcbiAgICB0aGlzLnJlZE4gPSB0aGlzLm4udG9SZWQodGhpcy5yZWQpO1xuICB9XG59XG52YXIgYmFzZSA9IEJhc2VDdXJ2ZTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5wb2ludCA9IGZ1bmN0aW9uIHBvaW50KCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICB0aHJvdyBuZXcgRXJyb3IoJ05vdCBpbXBsZW1lbnRlZCcpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fZml4ZWROYWZNdWwgPSBmdW5jdGlvbiBfZml4ZWROYWZNdWwocCwgaykge1xuICBhc3NlcnQkMShwLnByZWNvbXB1dGVkKTtcbiAgdmFyIGRvdWJsZXMgPSBwLl9nZXREb3VibGVzKCk7XG5cbiAgdmFyIG5hZiA9IGdldE5BRihrLCAxLCB0aGlzLl9iaXRMZW5ndGgpO1xuICB2YXIgSSA9ICgxIDw8IChkb3VibGVzLnN0ZXAgKyAxKSkgLSAoZG91Ymxlcy5zdGVwICUgMiA9PT0gMCA/IDIgOiAxKTtcbiAgSSAvPSAzO1xuXG4gIC8vIFRyYW5zbGF0ZSBpbnRvIG1vcmUgd2luZG93ZWQgZm9ybVxuICB2YXIgcmVwciA9IFtdO1xuICB2YXIgajtcbiAgdmFyIG5hZlc7XG4gIGZvciAoaiA9IDA7IGogPCBuYWYubGVuZ3RoOyBqICs9IGRvdWJsZXMuc3RlcCkge1xuICAgIG5hZlcgPSAwO1xuICAgIGZvciAodmFyIGwgPSBqICsgZG91Ymxlcy5zdGVwIC0gMTsgbCA+PSBqOyBsLS0pXG4gICAgICBuYWZXID0gKG5hZlcgPDwgMSkgKyBuYWZbbF07XG4gICAgcmVwci5wdXNoKG5hZlcpO1xuICB9XG5cbiAgdmFyIGEgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgdmFyIGIgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgZm9yICh2YXIgaSA9IEk7IGkgPiAwOyBpLS0pIHtcbiAgICBmb3IgKGogPSAwOyBqIDwgcmVwci5sZW5ndGg7IGorKykge1xuICAgICAgbmFmVyA9IHJlcHJbal07XG4gICAgICBpZiAobmFmVyA9PT0gaSlcbiAgICAgICAgYiA9IGIubWl4ZWRBZGQoZG91Ymxlcy5wb2ludHNbal0pO1xuICAgICAgZWxzZSBpZiAobmFmVyA9PT0gLWkpXG4gICAgICAgIGIgPSBiLm1peGVkQWRkKGRvdWJsZXMucG9pbnRzW2pdLm5lZygpKTtcbiAgICB9XG4gICAgYSA9IGEuYWRkKGIpO1xuICB9XG4gIHJldHVybiBhLnRvUCgpO1xufTtcblxuQmFzZUN1cnZlLnByb3RvdHlwZS5fd25hZk11bCA9IGZ1bmN0aW9uIF93bmFmTXVsKHAsIGspIHtcbiAgdmFyIHcgPSA0O1xuXG4gIC8vIFByZWNvbXB1dGUgd2luZG93XG4gIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHModyk7XG4gIHcgPSBuYWZQb2ludHMud25kO1xuICB2YXIgd25kID0gbmFmUG9pbnRzLnBvaW50cztcblxuICAvLyBHZXQgTkFGIGZvcm1cbiAgdmFyIG5hZiA9IGdldE5BRihrLCB3LCB0aGlzLl9iaXRMZW5ndGgpO1xuXG4gIC8vIEFkZCBgdGhpc2AqKE4rMSkgZm9yIGV2ZXJ5IHctTkFGIGluZGV4XG4gIHZhciBhY2MgPSB0aGlzLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcbiAgZm9yICh2YXIgaSA9IG5hZi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIC8vIENvdW50IHplcm9lc1xuICAgIGZvciAodmFyIGwgPSAwOyBpID49IDAgJiYgbmFmW2ldID09PSAwOyBpLS0pXG4gICAgICBsKys7XG4gICAgaWYgKGkgPj0gMClcbiAgICAgIGwrKztcbiAgICBhY2MgPSBhY2MuZGJscChsKTtcblxuICAgIGlmIChpIDwgMClcbiAgICAgIGJyZWFrO1xuICAgIHZhciB6ID0gbmFmW2ldO1xuICAgIGFzc2VydCQxKHogIT09IDApO1xuICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKSB7XG4gICAgICAvLyBKICstIFBcbiAgICAgIGlmICh6ID4gMClcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHduZFsoeiAtIDEpID4+IDFdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLm1peGVkQWRkKHduZFsoLXogLSAxKSA+PiAxXS5uZWcoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEogKy0gSlxuICAgICAgaWYgKHogPiAwKVxuICAgICAgICBhY2MgPSBhY2MuYWRkKHduZFsoeiAtIDEpID4+IDFdKTtcbiAgICAgIGVsc2VcbiAgICAgICAgYWNjID0gYWNjLmFkZCh3bmRbKC16IC0gMSkgPj4gMV0ubmVnKCkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcC50eXBlID09PSAnYWZmaW5lJyA/IGFjYy50b1AoKSA6IGFjYztcbn07XG5cbkJhc2VDdXJ2ZS5wcm90b3R5cGUuX3duYWZNdWxBZGQgPSBmdW5jdGlvbiBfd25hZk11bEFkZChkZWZXLFxuICBwb2ludHMsXG4gIGNvZWZmcyxcbiAgbGVuLFxuICBqYWNvYmlhblJlc3VsdCkge1xuICB2YXIgd25kV2lkdGggPSB0aGlzLl93bmFmVDE7XG4gIHZhciB3bmQgPSB0aGlzLl93bmFmVDI7XG4gIHZhciBuYWYgPSB0aGlzLl93bmFmVDM7XG5cbiAgLy8gRmlsbCBhbGwgYXJyYXlzXG4gIHZhciBtYXggPSAwO1xuICB2YXIgaTtcbiAgdmFyIGo7XG4gIHZhciBwO1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICBwID0gcG9pbnRzW2ldO1xuICAgIHZhciBuYWZQb2ludHMgPSBwLl9nZXROQUZQb2ludHMoZGVmVyk7XG4gICAgd25kV2lkdGhbaV0gPSBuYWZQb2ludHMud25kO1xuICAgIHduZFtpXSA9IG5hZlBvaW50cy5wb2ludHM7XG4gIH1cblxuICAvLyBDb21iIHNtYWxsIHdpbmRvdyBOQUZzXG4gIGZvciAoaSA9IGxlbiAtIDE7IGkgPj0gMTsgaSAtPSAyKSB7XG4gICAgdmFyIGEgPSBpIC0gMTtcbiAgICB2YXIgYiA9IGk7XG4gICAgaWYgKHduZFdpZHRoW2FdICE9PSAxIHx8IHduZFdpZHRoW2JdICE9PSAxKSB7XG4gICAgICBuYWZbYV0gPSBnZXROQUYoY29lZmZzW2FdLCB3bmRXaWR0aFthXSwgdGhpcy5fYml0TGVuZ3RoKTtcbiAgICAgIG5hZltiXSA9IGdldE5BRihjb2VmZnNbYl0sIHduZFdpZHRoW2JdLCB0aGlzLl9iaXRMZW5ndGgpO1xuICAgICAgbWF4ID0gTWF0aC5tYXgobmFmW2FdLmxlbmd0aCwgbWF4KTtcbiAgICAgIG1heCA9IE1hdGgubWF4KG5hZltiXS5sZW5ndGgsIG1heCk7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICB2YXIgY29tYiA9IFtcbiAgICAgIHBvaW50c1thXSwgLyogMSAqL1xuICAgICAgbnVsbCwgLyogMyAqL1xuICAgICAgbnVsbCwgLyogNSAqL1xuICAgICAgcG9pbnRzW2JdLCAvKiA3ICovXG4gICAgXTtcblxuICAgIC8vIFRyeSB0byBhdm9pZCBQcm9qZWN0aXZlIHBvaW50cywgaWYgcG9zc2libGVcbiAgICBpZiAocG9pbnRzW2FdLnkuY21wKHBvaW50c1tiXS55KSA9PT0gMCkge1xuICAgICAgY29tYlsxXSA9IHBvaW50c1thXS5hZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9IGVsc2UgaWYgKHBvaW50c1thXS55LmNtcChwb2ludHNbYl0ueS5yZWROZWcoKSkgPT09IDApIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0uYWRkKHBvaW50c1tiXS5uZWcoKSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbWJbMV0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdKTtcbiAgICAgIGNvbWJbMl0gPSBwb2ludHNbYV0udG9KKCkubWl4ZWRBZGQocG9pbnRzW2JdLm5lZygpKTtcbiAgICB9XG5cbiAgICB2YXIgaW5kZXggPSBbXG4gICAgICAtMywgLyogLTEgLTEgKi9cbiAgICAgIC0xLCAvKiAtMSAwICovXG4gICAgICAtNSwgLyogLTEgMSAqL1xuICAgICAgLTcsIC8qIDAgLTEgKi9cbiAgICAgIDAsIC8qIDAgMCAqL1xuICAgICAgNywgLyogMCAxICovXG4gICAgICA1LCAvKiAxIC0xICovXG4gICAgICAxLCAvKiAxIDAgKi9cbiAgICAgIDMsICAvKiAxIDEgKi9cbiAgICBdO1xuXG4gICAgdmFyIGpzZiA9IGdldEpTRihjb2VmZnNbYV0sIGNvZWZmc1tiXSk7XG4gICAgbWF4ID0gTWF0aC5tYXgoanNmWzBdLmxlbmd0aCwgbWF4KTtcbiAgICBuYWZbYV0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICBuYWZbYl0gPSBuZXcgQXJyYXkobWF4KTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbWF4OyBqKyspIHtcbiAgICAgIHZhciBqYSA9IGpzZlswXVtqXSB8IDA7XG4gICAgICB2YXIgamIgPSBqc2ZbMV1bal0gfCAwO1xuXG4gICAgICBuYWZbYV1bal0gPSBpbmRleFsoamEgKyAxKSAqIDMgKyAoamIgKyAxKV07XG4gICAgICBuYWZbYl1bal0gPSAwO1xuICAgICAgd25kW2FdID0gY29tYjtcbiAgICB9XG4gIH1cblxuICB2YXIgYWNjID0gdGhpcy5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gIHZhciB0bXAgPSB0aGlzLl93bmFmVDQ7XG4gIGZvciAoaSA9IG1heDsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgayA9IDA7XG5cbiAgICB3aGlsZSAoaSA+PSAwKSB7XG4gICAgICB2YXIgemVybyA9IHRydWU7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgICAgdG1wW2pdID0gbmFmW2pdW2ldIHwgMDtcbiAgICAgICAgaWYgKHRtcFtqXSAhPT0gMClcbiAgICAgICAgICB6ZXJvID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBpZiAoIXplcm8pXG4gICAgICAgIGJyZWFrO1xuICAgICAgaysrO1xuICAgICAgaS0tO1xuICAgIH1cbiAgICBpZiAoaSA+PSAwKVxuICAgICAgaysrO1xuICAgIGFjYyA9IGFjYy5kYmxwKGspO1xuICAgIGlmIChpIDwgMClcbiAgICAgIGJyZWFrO1xuXG4gICAgZm9yIChqID0gMDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgeiA9IHRtcFtqXTtcbiAgICAgIHA7XG4gICAgICBpZiAoeiA9PT0gMClcbiAgICAgICAgY29udGludWU7XG4gICAgICBlbHNlIGlmICh6ID4gMClcbiAgICAgICAgcCA9IHduZFtqXVsoeiAtIDEpID4+IDFdO1xuICAgICAgZWxzZSBpZiAoeiA8IDApXG4gICAgICAgIHAgPSB3bmRbal1bKC16IC0gMSkgPj4gMV0ubmVnKCk7XG5cbiAgICAgIGlmIChwLnR5cGUgPT09ICdhZmZpbmUnKVxuICAgICAgICBhY2MgPSBhY2MubWl4ZWRBZGQocCk7XG4gICAgICBlbHNlXG4gICAgICAgIGFjYyA9IGFjYy5hZGQocCk7XG4gICAgfVxuICB9XG4gIC8vIFplcm9pZnkgcmVmZXJlbmNlc1xuICBmb3IgKGkgPSAwOyBpIDwgbGVuOyBpKyspXG4gICAgd25kW2ldID0gbnVsbDtcblxuICBpZiAoamFjb2JpYW5SZXN1bHQpXG4gICAgcmV0dXJuIGFjYztcbiAgZWxzZVxuICAgIHJldHVybiBhY2MudG9QKCk7XG59O1xuXG5mdW5jdGlvbiBCYXNlUG9pbnQoY3VydmUsIHR5cGUpIHtcbiAgdGhpcy5jdXJ2ZSA9IGN1cnZlO1xuICB0aGlzLnR5cGUgPSB0eXBlO1xuICB0aGlzLnByZWNvbXB1dGVkID0gbnVsbDtcbn1cbkJhc2VDdXJ2ZS5CYXNlUG9pbnQgPSBCYXNlUG9pbnQ7XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSgvKm90aGVyKi8pIHtcbiAgdGhyb3cgbmV3IEVycm9yKCdOb3QgaW1wbGVtZW50ZWQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUudmFsaWRhdGUgPSBmdW5jdGlvbiB2YWxpZGF0ZSgpIHtcbiAgcmV0dXJuIHRoaXMuY3VydmUudmFsaWRhdGUodGhpcyk7XG59O1xuXG5CYXNlQ3VydmUucHJvdG90eXBlLmRlY29kZVBvaW50ID0gZnVuY3Rpb24gZGVjb2RlUG9pbnQoYnl0ZXMsIGVuYykge1xuICBieXRlcyA9IHV0aWxzXzEkMS50b0FycmF5KGJ5dGVzLCBlbmMpO1xuXG4gIHZhciBsZW4gPSB0aGlzLnAuYnl0ZUxlbmd0aCgpO1xuXG4gIC8vIHVuY29tcHJlc3NlZCwgaHlicmlkLW9kZCwgaHlicmlkLWV2ZW5cbiAgaWYgKChieXRlc1swXSA9PT0gMHgwNCB8fCBieXRlc1swXSA9PT0gMHgwNiB8fCBieXRlc1swXSA9PT0gMHgwNykgJiZcbiAgICAgIGJ5dGVzLmxlbmd0aCAtIDEgPT09IDIgKiBsZW4pIHtcbiAgICBpZiAoYnl0ZXNbMF0gPT09IDB4MDYpXG4gICAgICBhc3NlcnQkMShieXRlc1tieXRlcy5sZW5ndGggLSAxXSAlIDIgPT09IDApO1xuICAgIGVsc2UgaWYgKGJ5dGVzWzBdID09PSAweDA3KVxuICAgICAgYXNzZXJ0JDEoYnl0ZXNbYnl0ZXMubGVuZ3RoIC0gMV0gJSAyID09PSAxKTtcblxuICAgIHZhciByZXMgPSAgdGhpcy5wb2ludChieXRlcy5zbGljZSgxLCAxICsgbGVuKSxcbiAgICAgIGJ5dGVzLnNsaWNlKDEgKyBsZW4sIDEgKyAyICogbGVuKSk7XG5cbiAgICByZXR1cm4gcmVzO1xuICB9IGVsc2UgaWYgKChieXRlc1swXSA9PT0gMHgwMiB8fCBieXRlc1swXSA9PT0gMHgwMykgJiZcbiAgICAgICAgICAgICAgYnl0ZXMubGVuZ3RoIC0gMSA9PT0gbGVuKSB7XG4gICAgcmV0dXJuIHRoaXMucG9pbnRGcm9tWChieXRlcy5zbGljZSgxLCAxICsgbGVuKSwgYnl0ZXNbMF0gPT09IDB4MDMpO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwb2ludCBmb3JtYXQnKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlQ29tcHJlc3NlZCA9IGZ1bmN0aW9uIGVuY29kZUNvbXByZXNzZWQoZW5jKSB7XG4gIHJldHVybiB0aGlzLmVuY29kZShlbmMsIHRydWUpO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5fZW5jb2RlID0gZnVuY3Rpb24gX2VuY29kZShjb21wYWN0KSB7XG4gIHZhciBsZW4gPSB0aGlzLmN1cnZlLnAuYnl0ZUxlbmd0aCgpO1xuICB2YXIgeCA9IHRoaXMuZ2V0WCgpLnRvQXJyYXkoJ2JlJywgbGVuKTtcblxuICBpZiAoY29tcGFjdClcbiAgICByZXR1cm4gWyB0aGlzLmdldFkoKS5pc0V2ZW4oKSA/IDB4MDIgOiAweDAzIF0uY29uY2F0KHgpO1xuXG4gIHJldHVybiBbIDB4MDQgXS5jb25jYXQoeCwgdGhpcy5nZXRZKCkudG9BcnJheSgnYmUnLCBsZW4pKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuZW5jb2RlID0gZnVuY3Rpb24gZW5jb2RlKGVuYywgY29tcGFjdCkge1xuICByZXR1cm4gdXRpbHNfMSQxLmVuY29kZSh0aGlzLl9lbmNvZGUoY29tcGFjdCksIGVuYyk7XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLnByZWNvbXB1dGUgPSBmdW5jdGlvbiBwcmVjb21wdXRlKHBvd2VyKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIHZhciBwcmVjb21wdXRlZCA9IHtcbiAgICBkb3VibGVzOiBudWxsLFxuICAgIG5hZjogbnVsbCxcbiAgICBiZXRhOiBudWxsLFxuICB9O1xuICBwcmVjb21wdXRlZC5uYWYgPSB0aGlzLl9nZXROQUZQb2ludHMoOCk7XG4gIHByZWNvbXB1dGVkLmRvdWJsZXMgPSB0aGlzLl9nZXREb3VibGVzKDQsIHBvd2VyKTtcbiAgcHJlY29tcHV0ZWQuYmV0YSA9IHRoaXMuX2dldEJldGEoKTtcbiAgdGhpcy5wcmVjb21wdXRlZCA9IHByZWNvbXB1dGVkO1xuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5faGFzRG91YmxlcyA9IGZ1bmN0aW9uIF9oYXNEb3VibGVzKGspIHtcbiAgaWYgKCF0aGlzLnByZWNvbXB1dGVkKVxuICAgIHJldHVybiBmYWxzZTtcblxuICB2YXIgZG91YmxlcyA9IHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcbiAgaWYgKCFkb3VibGVzKVxuICAgIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gZG91Ymxlcy5wb2ludHMubGVuZ3RoID49IE1hdGguY2VpbCgoay5iaXRMZW5ndGgoKSArIDEpIC8gZG91Ymxlcy5zdGVwKTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldERvdWJsZXMgPSBmdW5jdGlvbiBfZ2V0RG91YmxlcyhzdGVwLCBwb3dlcikge1xuICBpZiAodGhpcy5wcmVjb21wdXRlZCAmJiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMpXG4gICAgcmV0dXJuIHRoaXMucHJlY29tcHV0ZWQuZG91YmxlcztcblxuICB2YXIgZG91YmxlcyA9IFsgdGhpcyBdO1xuICB2YXIgYWNjID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb3dlcjsgaSArPSBzdGVwKSB7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBzdGVwOyBqKyspXG4gICAgICBhY2MgPSBhY2MuZGJsKCk7XG4gICAgZG91Ymxlcy5wdXNoKGFjYyk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBzdGVwOiBzdGVwLFxuICAgIHBvaW50czogZG91YmxlcyxcbiAgfTtcbn07XG5cbkJhc2VQb2ludC5wcm90b3R5cGUuX2dldE5BRlBvaW50cyA9IGZ1bmN0aW9uIF9nZXROQUZQb2ludHMod25kKSB7XG4gIGlmICh0aGlzLnByZWNvbXB1dGVkICYmIHRoaXMucHJlY29tcHV0ZWQubmFmKVxuICAgIHJldHVybiB0aGlzLnByZWNvbXB1dGVkLm5hZjtcblxuICB2YXIgcmVzID0gWyB0aGlzIF07XG4gIHZhciBtYXggPSAoMSA8PCB3bmQpIC0gMTtcbiAgdmFyIGRibCA9IG1heCA9PT0gMSA/IG51bGwgOiB0aGlzLmRibCgpO1xuICBmb3IgKHZhciBpID0gMTsgaSA8IG1heDsgaSsrKVxuICAgIHJlc1tpXSA9IHJlc1tpIC0gMV0uYWRkKGRibCk7XG4gIHJldHVybiB7XG4gICAgd25kOiB3bmQsXG4gICAgcG9pbnRzOiByZXMsXG4gIH07XG59O1xuXG5CYXNlUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gIHJldHVybiBudWxsO1xufTtcblxuQmFzZVBvaW50LnByb3RvdHlwZS5kYmxwID0gZnVuY3Rpb24gZGJscChrKSB7XG4gIHZhciByID0gdGhpcztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrOyBpKyspXG4gICAgciA9IHIuZGJsKCk7XG4gIHJldHVybiByO1xufTtcblxudmFyIGluaGVyaXRzX2Jyb3dzZXIgPSBjcmVhdGVDb21tb25qc01vZHVsZShmdW5jdGlvbiAobW9kdWxlKSB7XG5pZiAodHlwZW9mIE9iamVjdC5jcmVhdGUgPT09ICdmdW5jdGlvbicpIHtcbiAgLy8gaW1wbGVtZW50YXRpb24gZnJvbSBzdGFuZGFyZCBub2RlLmpzICd1dGlsJyBtb2R1bGVcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn0gZWxzZSB7XG4gIC8vIG9sZCBzY2hvb2wgc2hpbSBmb3Igb2xkIGJyb3dzZXJzXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGU7XG4gICAgICBjdG9yLnByb3RvdHlwZSA9IG5ldyBUZW1wQ3RvcigpO1xuICAgICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICAgIH1cbiAgfTtcbn1cbn0pO1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5cblxuXG52YXIgYXNzZXJ0JDIgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5mdW5jdGlvbiBTaG9ydEN1cnZlKGNvbmYpIHtcbiAgYmFzZS5jYWxsKHRoaXMsICdzaG9ydCcsIGNvbmYpO1xuXG4gIHRoaXMuYSA9IG5ldyBCTihjb25mLmEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMuYiA9IG5ldyBCTihjb25mLmIsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIHRoaXMudGludiA9IHRoaXMudHdvLnJlZEludm0oKTtcblxuICB0aGlzLnplcm9BID0gdGhpcy5hLmZyb21SZWQoKS5jbXBuKDApID09PSAwO1xuICB0aGlzLnRocmVlQSA9IHRoaXMuYS5mcm9tUmVkKCkuc3ViKHRoaXMucCkuY21wbigtMykgPT09IDA7XG5cbiAgLy8gSWYgdGhlIGN1cnZlIGlzIGVuZG9tb3JwaGljLCBwcmVjYWxjdWxhdGUgYmV0YSBhbmQgbGFtYmRhXG4gIHRoaXMuZW5kbyA9IHRoaXMuX2dldEVuZG9tb3JwaGlzbShjb25mKTtcbiAgdGhpcy5fZW5kb1duYWZUMSA9IG5ldyBBcnJheSg0KTtcbiAgdGhpcy5fZW5kb1duYWZUMiA9IG5ldyBBcnJheSg0KTtcbn1cbmluaGVyaXRzX2Jyb3dzZXIoU2hvcnRDdXJ2ZSwgYmFzZSk7XG52YXIgc2hvcnRfMSA9IFNob3J0Q3VydmU7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvbW9ycGhpc20gPSBmdW5jdGlvbiBfZ2V0RW5kb21vcnBoaXNtKGNvbmYpIHtcbiAgLy8gTm8gZWZmaWNpZW50IGVuZG9tb3JwaGlzbVxuICBpZiAoIXRoaXMuemVyb0EgfHwgIXRoaXMuZyB8fCAhdGhpcy5uIHx8IHRoaXMucC5tb2RuKDMpICE9PSAxKVxuICAgIHJldHVybjtcblxuICAvLyBDb21wdXRlIGJldGEgYW5kIGxhbWJkYSwgdGhhdCBsYW1iZGEgKiBQID0gKGJldGEgKiBQeDsgUHkpXG4gIHZhciBiZXRhO1xuICB2YXIgbGFtYmRhO1xuICBpZiAoY29uZi5iZXRhKSB7XG4gICAgYmV0YSA9IG5ldyBCTihjb25mLmJldGEsIDE2KS50b1JlZCh0aGlzLnJlZCk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGJldGFzID0gdGhpcy5fZ2V0RW5kb1Jvb3RzKHRoaXMucCk7XG4gICAgLy8gQ2hvb3NlIHRoZSBzbWFsbGVzdCBiZXRhXG4gICAgYmV0YSA9IGJldGFzWzBdLmNtcChiZXRhc1sxXSkgPCAwID8gYmV0YXNbMF0gOiBiZXRhc1sxXTtcbiAgICBiZXRhID0gYmV0YS50b1JlZCh0aGlzLnJlZCk7XG4gIH1cbiAgaWYgKGNvbmYubGFtYmRhKSB7XG4gICAgbGFtYmRhID0gbmV3IEJOKGNvbmYubGFtYmRhLCAxNik7XG4gIH0gZWxzZSB7XG4gICAgLy8gQ2hvb3NlIHRoZSBsYW1iZGEgdGhhdCBpcyBtYXRjaGluZyBzZWxlY3RlZCBiZXRhXG4gICAgdmFyIGxhbWJkYXMgPSB0aGlzLl9nZXRFbmRvUm9vdHModGhpcy5uKTtcbiAgICBpZiAodGhpcy5nLm11bChsYW1iZGFzWzBdKS54LmNtcCh0aGlzLmcueC5yZWRNdWwoYmV0YSkpID09PSAwKSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzBdO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYW1iZGEgPSBsYW1iZGFzWzFdO1xuICAgICAgYXNzZXJ0JDIodGhpcy5nLm11bChsYW1iZGEpLnguY21wKHRoaXMuZy54LnJlZE11bChiZXRhKSkgPT09IDApO1xuICAgIH1cbiAgfVxuXG4gIC8vIEdldCBiYXNpcyB2ZWN0b3JzLCB1c2VkIGZvciBiYWxhbmNlZCBsZW5ndGgtdHdvIHJlcHJlc2VudGF0aW9uXG4gIHZhciBiYXNpcztcbiAgaWYgKGNvbmYuYmFzaXMpIHtcbiAgICBiYXNpcyA9IGNvbmYuYmFzaXMubWFwKGZ1bmN0aW9uKHZlYykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgYTogbmV3IEJOKHZlYy5hLCAxNiksXG4gICAgICAgIGI6IG5ldyBCTih2ZWMuYiwgMTYpLFxuICAgICAgfTtcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBiYXNpcyA9IHRoaXMuX2dldEVuZG9CYXNpcyhsYW1iZGEpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBiZXRhOiBiZXRhLFxuICAgIGxhbWJkYTogbGFtYmRhLFxuICAgIGJhc2lzOiBiYXNpcyxcbiAgfTtcbn07XG5cblNob3J0Q3VydmUucHJvdG90eXBlLl9nZXRFbmRvUm9vdHMgPSBmdW5jdGlvbiBfZ2V0RW5kb1Jvb3RzKG51bSkge1xuICAvLyBGaW5kIHJvb3RzIG9mIGZvciB4XjIgKyB4ICsgMSBpbiBGXG4gIC8vIFJvb3QgPSAoLTEgKy0gU3FydCgtMykpIC8gMlxuICAvL1xuICB2YXIgcmVkID0gbnVtID09PSB0aGlzLnAgPyB0aGlzLnJlZCA6IEJOLm1vbnQobnVtKTtcbiAgdmFyIHRpbnYgPSBuZXcgQk4oMikudG9SZWQocmVkKS5yZWRJbnZtKCk7XG4gIHZhciBudGludiA9IHRpbnYucmVkTmVnKCk7XG5cbiAgdmFyIHMgPSBuZXcgQk4oMykudG9SZWQocmVkKS5yZWROZWcoKS5yZWRTcXJ0KCkucmVkTXVsKHRpbnYpO1xuXG4gIHZhciBsMSA9IG50aW52LnJlZEFkZChzKS5mcm9tUmVkKCk7XG4gIHZhciBsMiA9IG50aW52LnJlZFN1YihzKS5mcm9tUmVkKCk7XG4gIHJldHVybiBbIGwxLCBsMiBdO1xufTtcblxuU2hvcnRDdXJ2ZS5wcm90b3R5cGUuX2dldEVuZG9CYXNpcyA9IGZ1bmN0aW9uIF9nZXRFbmRvQmFzaXMobGFtYmRhKSB7XG4gIC8vIGFwcnhTcXJ0ID49IHNxcnQodGhpcy5uKVxuICB2YXIgYXByeFNxcnQgPSB0aGlzLm4udXNocm4oTWF0aC5mbG9vcih0aGlzLm4uYml0TGVuZ3RoKCkgLyAyKSk7XG5cbiAgLy8gMy43NFxuICAvLyBSdW4gRUdDRCwgdW50aWwgcihMICsgMSkgPCBhcHJ4U3FydFxuICB2YXIgdSA9IGxhbWJkYTtcbiAgdmFyIHYgPSB0aGlzLm4uY2xvbmUoKTtcbiAgdmFyIHgxID0gbmV3IEJOKDEpO1xuICB2YXIgeTEgPSBuZXcgQk4oMCk7XG4gIHZhciB4MiA9IG5ldyBCTigwKTtcbiAgdmFyIHkyID0gbmV3IEJOKDEpO1xuXG4gIC8vIE5PVEU6IGFsbCB2ZWN0b3JzIGFyZSByb290cyBvZjogYSArIGIgKiBsYW1iZGEgPSAwIChtb2QgbilcbiAgdmFyIGEwO1xuICB2YXIgYjA7XG4gIC8vIEZpcnN0IHZlY3RvclxuICB2YXIgYTE7XG4gIHZhciBiMTtcbiAgLy8gU2Vjb25kIHZlY3RvclxuICB2YXIgYTI7XG4gIHZhciBiMjtcblxuICB2YXIgcHJldlI7XG4gIHZhciBpID0gMDtcbiAgdmFyIHI7XG4gIHZhciB4O1xuICB3aGlsZSAodS5jbXBuKDApICE9PSAwKSB7XG4gICAgdmFyIHEgPSB2LmRpdih1KTtcbiAgICByID0gdi5zdWIocS5tdWwodSkpO1xuICAgIHggPSB4Mi5zdWIocS5tdWwoeDEpKTtcbiAgICB2YXIgeSA9IHkyLnN1YihxLm11bCh5MSkpO1xuXG4gICAgaWYgKCFhMSAmJiByLmNtcChhcHJ4U3FydCkgPCAwKSB7XG4gICAgICBhMCA9IHByZXZSLm5lZygpO1xuICAgICAgYjAgPSB4MTtcbiAgICAgIGExID0gci5uZWcoKTtcbiAgICAgIGIxID0geDtcbiAgICB9IGVsc2UgaWYgKGExICYmICsraSA9PT0gMikge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgIHByZXZSID0gcjtcblxuICAgIHYgPSB1O1xuICAgIHUgPSByO1xuICAgIHgyID0geDE7XG4gICAgeDEgPSB4O1xuICAgIHkyID0geTE7XG4gICAgeTEgPSB5O1xuICB9XG4gIGEyID0gci5uZWcoKTtcbiAgYjIgPSB4O1xuXG4gIHZhciBsZW4xID0gYTEuc3FyKCkuYWRkKGIxLnNxcigpKTtcbiAgdmFyIGxlbjIgPSBhMi5zcXIoKS5hZGQoYjIuc3FyKCkpO1xuICBpZiAobGVuMi5jbXAobGVuMSkgPj0gMCkge1xuICAgIGEyID0gYTA7XG4gICAgYjIgPSBiMDtcbiAgfVxuXG4gIC8vIE5vcm1hbGl6ZSBzaWduc1xuICBpZiAoYTEubmVnYXRpdmUpIHtcbiAgICBhMSA9IGExLm5lZygpO1xuICAgIGIxID0gYjEubmVnKCk7XG4gIH1cbiAgaWYgKGEyLm5lZ2F0aXZlKSB7XG4gICAgYTIgPSBhMi5uZWcoKTtcbiAgICBiMiA9IGIyLm5lZygpO1xuICB9XG5cbiAgcmV0dXJuIFtcbiAgICB7IGE6IGExLCBiOiBiMSB9LFxuICAgIHsgYTogYTIsIGI6IGIyIH0sXG4gIF07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1NwbGl0ID0gZnVuY3Rpb24gX2VuZG9TcGxpdChrKSB7XG4gIHZhciBiYXNpcyA9IHRoaXMuZW5kby5iYXNpcztcbiAgdmFyIHYxID0gYmFzaXNbMF07XG4gIHZhciB2MiA9IGJhc2lzWzFdO1xuXG4gIHZhciBjMSA9IHYyLmIubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG4gIHZhciBjMiA9IHYxLmIubmVnKCkubXVsKGspLmRpdlJvdW5kKHRoaXMubik7XG5cbiAgdmFyIHAxID0gYzEubXVsKHYxLmEpO1xuICB2YXIgcDIgPSBjMi5tdWwodjIuYSk7XG4gIHZhciBxMSA9IGMxLm11bCh2MS5iKTtcbiAgdmFyIHEyID0gYzIubXVsKHYyLmIpO1xuXG4gIC8vIENhbGN1bGF0ZSBhbnN3ZXJcbiAgdmFyIGsxID0gay5zdWIocDEpLnN1YihwMik7XG4gIHZhciBrMiA9IHExLmFkZChxMikubmVnKCk7XG4gIHJldHVybiB7IGsxOiBrMSwgazI6IGsyIH07XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21YID0gZnVuY3Rpb24gcG9pbnRGcm9tWCh4LCBvZGQpIHtcbiAgeCA9IG5ldyBCTih4LCAxNik7XG4gIGlmICgheC5yZWQpXG4gICAgeCA9IHgudG9SZWQodGhpcy5yZWQpO1xuXG4gIHZhciB5MiA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoeC5yZWRNdWwodGhpcy5hKSkucmVkSUFkZCh0aGlzLmIpO1xuICB2YXIgeSA9IHkyLnJlZFNxcnQoKTtcbiAgaWYgKHkucmVkU3FyKCkucmVkU3ViKHkyKS5jbXAodGhpcy56ZXJvKSAhPT0gMClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgcG9pbnQnKTtcblxuICAvLyBYWFggSXMgdGhlcmUgYW55IHdheSB0byB0ZWxsIGlmIHRoZSBudW1iZXIgaXMgb2RkIHdpdGhvdXQgY29udmVydGluZyBpdFxuICAvLyB0byBub24tcmVkIGZvcm0/XG4gIHZhciBpc09kZCA9IHkuZnJvbVJlZCgpLmlzT2RkKCk7XG4gIGlmIChvZGQgJiYgIWlzT2RkIHx8ICFvZGQgJiYgaXNPZGQpXG4gICAgeSA9IHkucmVkTmVnKCk7XG5cbiAgcmV0dXJuIHRoaXMucG9pbnQoeCwgeSk7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKHBvaW50KSB7XG4gIGlmIChwb2ludC5pbmYpXG4gICAgcmV0dXJuIHRydWU7XG5cbiAgdmFyIHggPSBwb2ludC54O1xuICB2YXIgeSA9IHBvaW50Lnk7XG5cbiAgdmFyIGF4ID0gdGhpcy5hLnJlZE11bCh4KTtcbiAgdmFyIHJocyA9IHgucmVkU3FyKCkucmVkTXVsKHgpLnJlZElBZGQoYXgpLnJlZElBZGQodGhpcy5iKTtcbiAgcmV0dXJuIHkucmVkU3FyKCkucmVkSVN1YihyaHMpLmNtcG4oMCkgPT09IDA7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5fZW5kb1duYWZNdWxBZGQgPVxuICAgIGZ1bmN0aW9uIF9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcywgamFjb2JpYW5SZXN1bHQpIHtcbiAgICAgIHZhciBucG9pbnRzID0gdGhpcy5fZW5kb1duYWZUMTtcbiAgICAgIHZhciBuY29lZmZzID0gdGhpcy5fZW5kb1duYWZUMjtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzcGxpdCA9IHRoaXMuX2VuZG9TcGxpdChjb2VmZnNbaV0pO1xuICAgICAgICB2YXIgcCA9IHBvaW50c1tpXTtcbiAgICAgICAgdmFyIGJldGEgPSBwLl9nZXRCZXRhKCk7XG5cbiAgICAgICAgaWYgKHNwbGl0LmsxLm5lZ2F0aXZlKSB7XG4gICAgICAgICAgc3BsaXQuazEuaW5lZygpO1xuICAgICAgICAgIHAgPSBwLm5lZyh0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3BsaXQuazIubmVnYXRpdmUpIHtcbiAgICAgICAgICBzcGxpdC5rMi5pbmVnKCk7XG4gICAgICAgICAgYmV0YSA9IGJldGEubmVnKHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgbnBvaW50c1tpICogMl0gPSBwO1xuICAgICAgICBucG9pbnRzW2kgKiAyICsgMV0gPSBiZXRhO1xuICAgICAgICBuY29lZmZzW2kgKiAyXSA9IHNwbGl0LmsxO1xuICAgICAgICBuY29lZmZzW2kgKiAyICsgMV0gPSBzcGxpdC5rMjtcbiAgICAgIH1cbiAgICAgIHZhciByZXMgPSB0aGlzLl93bmFmTXVsQWRkKDEsIG5wb2ludHMsIG5jb2VmZnMsIGkgKiAyLCBqYWNvYmlhblJlc3VsdCk7XG5cbiAgICAgIC8vIENsZWFuLXVwIHJlZmVyZW5jZXMgdG8gcG9pbnRzIGFuZCBjb2VmZmljaWVudHNcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgaSAqIDI7IGorKykge1xuICAgICAgICBucG9pbnRzW2pdID0gbnVsbDtcbiAgICAgICAgbmNvZWZmc1tqXSA9IG51bGw7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH07XG5cbmZ1bmN0aW9uIFBvaW50KGN1cnZlLCB4LCB5LCBpc1JlZCkge1xuICBiYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnYWZmaW5lJyk7XG4gIGlmICh4ID09PSBudWxsICYmIHkgPT09IG51bGwpIHtcbiAgICB0aGlzLnggPSBudWxsO1xuICAgIHRoaXMueSA9IG51bGw7XG4gICAgdGhpcy5pbmYgPSB0cnVlO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICAvLyBGb3JjZSByZWRnb21lcnkgcmVwcmVzZW50YXRpb24gd2hlbiBsb2FkaW5nIGZyb20gSlNPTlxuICAgIGlmIChpc1JlZCkge1xuICAgICAgdGhpcy54LmZvcmNlUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICAgIHRoaXMueS5mb3JjZVJlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgfVxuICAgIGlmICghdGhpcy54LnJlZClcbiAgICAgIHRoaXMueCA9IHRoaXMueC50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG4gICAgaWYgKCF0aGlzLnkucmVkKVxuICAgICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgICB0aGlzLmluZiA9IGZhbHNlO1xuICB9XG59XG5pbmhlcml0c19icm93c2VyKFBvaW50LCBiYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLnBvaW50ID0gZnVuY3Rpb24gcG9pbnQoeCwgeSwgaXNSZWQpIHtcbiAgcmV0dXJuIG5ldyBQb2ludCh0aGlzLCB4LCB5LCBpc1JlZCk7XG59O1xuXG5TaG9ydEN1cnZlLnByb3RvdHlwZS5wb2ludEZyb21KU09OID0gZnVuY3Rpb24gcG9pbnRGcm9tSlNPTihvYmosIHJlZCkge1xuICByZXR1cm4gUG9pbnQuZnJvbUpTT04odGhpcywgb2JqLCByZWQpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLl9nZXRCZXRhID0gZnVuY3Rpb24gX2dldEJldGEoKSB7XG4gIGlmICghdGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybjtcblxuICB2YXIgcHJlID0gdGhpcy5wcmVjb21wdXRlZDtcbiAgaWYgKHByZSAmJiBwcmUuYmV0YSlcbiAgICByZXR1cm4gcHJlLmJldGE7XG5cbiAgdmFyIGJldGEgPSB0aGlzLmN1cnZlLnBvaW50KHRoaXMueC5yZWRNdWwodGhpcy5jdXJ2ZS5lbmRvLmJldGEpLCB0aGlzLnkpO1xuICBpZiAocHJlKSB7XG4gICAgdmFyIGN1cnZlID0gdGhpcy5jdXJ2ZTtcbiAgICB2YXIgZW5kb011bCA9IGZ1bmN0aW9uKHApIHtcbiAgICAgIHJldHVybiBjdXJ2ZS5wb2ludChwLngucmVkTXVsKGN1cnZlLmVuZG8uYmV0YSksIHAueSk7XG4gICAgfTtcbiAgICBwcmUuYmV0YSA9IGJldGE7XG4gICAgYmV0YS5wcmVjb21wdXRlZCA9IHtcbiAgICAgIGJldGE6IG51bGwsXG4gICAgICBuYWY6IHByZS5uYWYgJiYge1xuICAgICAgICB3bmQ6IHByZS5uYWYud25kLFxuICAgICAgICBwb2ludHM6IHByZS5uYWYucG9pbnRzLm1hcChlbmRvTXVsKSxcbiAgICAgIH0sXG4gICAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICAgIHN0ZXA6IHByZS5kb3VibGVzLnN0ZXAsXG4gICAgICAgIHBvaW50czogcHJlLmRvdWJsZXMucG9pbnRzLm1hcChlbmRvTXVsKSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuICByZXR1cm4gYmV0YTtcbn07XG5cblBvaW50LnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XG4gIGlmICghdGhpcy5wcmVjb21wdXRlZClcbiAgICByZXR1cm4gWyB0aGlzLngsIHRoaXMueSBdO1xuXG4gIHJldHVybiBbIHRoaXMueCwgdGhpcy55LCB0aGlzLnByZWNvbXB1dGVkICYmIHtcbiAgICBkb3VibGVzOiB0aGlzLnByZWNvbXB1dGVkLmRvdWJsZXMgJiYge1xuICAgICAgc3RlcDogdGhpcy5wcmVjb21wdXRlZC5kb3VibGVzLnN0ZXAsXG4gICAgICBwb2ludHM6IHRoaXMucHJlY29tcHV0ZWQuZG91Ymxlcy5wb2ludHMuc2xpY2UoMSksXG4gICAgfSxcbiAgICBuYWY6IHRoaXMucHJlY29tcHV0ZWQubmFmICYmIHtcbiAgICAgIHduZDogdGhpcy5wcmVjb21wdXRlZC5uYWYud25kLFxuICAgICAgcG9pbnRzOiB0aGlzLnByZWNvbXB1dGVkLm5hZi5wb2ludHMuc2xpY2UoMSksXG4gICAgfSxcbiAgfSBdO1xufTtcblxuUG9pbnQuZnJvbUpTT04gPSBmdW5jdGlvbiBmcm9tSlNPTihjdXJ2ZSwgb2JqLCByZWQpIHtcbiAgaWYgKHR5cGVvZiBvYmogPT09ICdzdHJpbmcnKVxuICAgIG9iaiA9IEpTT04ucGFyc2Uob2JqKTtcbiAgdmFyIHJlcyA9IGN1cnZlLnBvaW50KG9ialswXSwgb2JqWzFdLCByZWQpO1xuICBpZiAoIW9ialsyXSlcbiAgICByZXR1cm4gcmVzO1xuXG4gIGZ1bmN0aW9uIG9iajJwb2ludChvYmopIHtcbiAgICByZXR1cm4gY3VydmUucG9pbnQob2JqWzBdLCBvYmpbMV0sIHJlZCk7XG4gIH1cblxuICB2YXIgcHJlID0gb2JqWzJdO1xuICByZXMucHJlY29tcHV0ZWQgPSB7XG4gICAgYmV0YTogbnVsbCxcbiAgICBkb3VibGVzOiBwcmUuZG91YmxlcyAmJiB7XG4gICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgcG9pbnRzOiBbIHJlcyBdLmNvbmNhdChwcmUuZG91Ymxlcy5wb2ludHMubWFwKG9iajJwb2ludCkpLFxuICAgIH0sXG4gICAgbmFmOiBwcmUubmFmICYmIHtcbiAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICBwb2ludHM6IFsgcmVzIF0uY29uY2F0KHByZS5uYWYucG9pbnRzLm1hcChvYmoycG9pbnQpKSxcbiAgICB9LFxuICB9O1xuICByZXR1cm4gcmVzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuICc8RUMgUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgUG9pbnQgeDogJyArIHRoaXMueC5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS5mcm9tUmVkKCkudG9TdHJpbmcoMTYsIDIpICsgJz4nO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmlzSW5maW5pdHkgPSBmdW5jdGlvbiBpc0luZmluaXR5KCkge1xuICByZXR1cm4gdGhpcy5pbmY7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkKHApIHtcbiAgLy8gTyArIFAgPSBQXG4gIGlmICh0aGlzLmluZilcbiAgICByZXR1cm4gcDtcblxuICAvLyBQICsgTyA9IFBcbiAgaWYgKHAuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIFAgKyBQID0gMlBcbiAgaWYgKHRoaXMuZXEocCkpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCk7XG5cbiAgLy8gUCArICgtUCkgPSBPXG4gIGlmICh0aGlzLm5lZygpLmVxKHApKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIC8vIFAgKyBRID0gT1xuICBpZiAodGhpcy54LmNtcChwLngpID09PSAwKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLnBvaW50KG51bGwsIG51bGwpO1xuXG4gIHZhciBjID0gdGhpcy55LnJlZFN1YihwLnkpO1xuICBpZiAoYy5jbXBuKDApICE9PSAwKVxuICAgIGMgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKHAueCkucmVkSW52bSgpKTtcbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHRoaXMueCkucmVkSVN1YihwLngpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmRibCA9IGZ1bmN0aW9uIGRibCgpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzO1xuXG4gIC8vIDJQID0gT1xuICB2YXIgeXMxID0gdGhpcy55LnJlZEFkZCh0aGlzLnkpO1xuICBpZiAoeXMxLmNtcG4oMCkgPT09IDApXG4gICAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQobnVsbCwgbnVsbCk7XG5cbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG5cbiAgdmFyIHgyID0gdGhpcy54LnJlZFNxcigpO1xuICB2YXIgZHlpbnYgPSB5czEucmVkSW52bSgpO1xuICB2YXIgYyA9IHgyLnJlZEFkZCh4MikucmVkSUFkZCh4MikucmVkSUFkZChhKS5yZWRNdWwoZHlpbnYpO1xuXG4gIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0aGlzLngucmVkQWRkKHRoaXMueCkpO1xuICB2YXIgbnkgPSBjLnJlZE11bCh0aGlzLngucmVkU3ViKG54KSkucmVkSVN1Yih0aGlzLnkpO1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChueCwgbnkpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmdldFggPSBmdW5jdGlvbiBnZXRYKCkge1xuICByZXR1cm4gdGhpcy54LmZyb21SZWQoKTtcbn07XG5cblBvaW50LnByb3RvdHlwZS5nZXRZID0gZnVuY3Rpb24gZ2V0WSgpIHtcbiAgcmV0dXJuIHRoaXMueS5mcm9tUmVkKCk7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUubXVsID0gZnVuY3Rpb24gbXVsKGspIHtcbiAgayA9IG5ldyBCTihrLCAxNik7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcbiAgZWxzZSBpZiAodGhpcy5faGFzRG91YmxlcyhrKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZml4ZWROYWZNdWwodGhpcywgayk7XG4gIGVsc2UgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQoWyB0aGlzIF0sIFsgayBdKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl93bmFmTXVsKHRoaXMsIGspO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm11bEFkZCA9IGZ1bmN0aW9uIG11bEFkZChrMSwgcDIsIGsyKSB7XG4gIHZhciBwb2ludHMgPSBbIHRoaXMsIHAyIF07XG4gIHZhciBjb2VmZnMgPSBbIGsxLCBrMiBdO1xuICBpZiAodGhpcy5jdXJ2ZS5lbmRvKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLl9lbmRvV25hZk11bEFkZChwb2ludHMsIGNvZWZmcyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fd25hZk11bEFkZCgxLCBwb2ludHMsIGNvZWZmcywgMik7XG59O1xuXG5Qb2ludC5wcm90b3R5cGUuam11bEFkZCA9IGZ1bmN0aW9uIGptdWxBZGQoazEsIHAyLCBrMikge1xuICB2YXIgcG9pbnRzID0gWyB0aGlzLCBwMiBdO1xuICB2YXIgY29lZmZzID0gWyBrMSwgazIgXTtcbiAgaWYgKHRoaXMuY3VydmUuZW5kbylcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5fZW5kb1duYWZNdWxBZGQocG9pbnRzLCBjb2VmZnMsIHRydWUpO1xuICBlbHNlXG4gICAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWxBZGQoMSwgcG9pbnRzLCBjb2VmZnMsIDIsIHRydWUpO1xufTtcblxuUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuICByZXR1cm4gdGhpcyA9PT0gcCB8fFxuICAgICAgICAgdGhpcy5pbmYgPT09IHAuaW5mICYmXG4gICAgICAgICAgICAgKHRoaXMuaW5mIHx8IHRoaXMueC5jbXAocC54KSA9PT0gMCAmJiB0aGlzLnkuY21wKHAueSkgPT09IDApO1xufTtcblxuUG9pbnQucHJvdG90eXBlLm5lZyA9IGZ1bmN0aW9uIG5lZyhfcHJlY29tcHV0ZSkge1xuICBpZiAodGhpcy5pbmYpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgdmFyIHJlcyA9IHRoaXMuY3VydmUucG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCkpO1xuICBpZiAoX3ByZWNvbXB1dGUgJiYgdGhpcy5wcmVjb21wdXRlZCkge1xuICAgIHZhciBwcmUgPSB0aGlzLnByZWNvbXB1dGVkO1xuICAgIHZhciBuZWdhdGUgPSBmdW5jdGlvbihwKSB7XG4gICAgICByZXR1cm4gcC5uZWcoKTtcbiAgICB9O1xuICAgIHJlcy5wcmVjb21wdXRlZCA9IHtcbiAgICAgIG5hZjogcHJlLm5hZiAmJiB7XG4gICAgICAgIHduZDogcHJlLm5hZi53bmQsXG4gICAgICAgIHBvaW50czogcHJlLm5hZi5wb2ludHMubWFwKG5lZ2F0ZSksXG4gICAgICB9LFxuICAgICAgZG91YmxlczogcHJlLmRvdWJsZXMgJiYge1xuICAgICAgICBzdGVwOiBwcmUuZG91Ymxlcy5zdGVwLFxuICAgICAgICBwb2ludHM6IHByZS5kb3VibGVzLnBvaW50cy5tYXAobmVnYXRlKSxcbiAgICAgIH0sXG4gICAgfTtcbiAgfVxuICByZXR1cm4gcmVzO1xufTtcblxuUG9pbnQucHJvdG90eXBlLnRvSiA9IGZ1bmN0aW9uIHRvSigpIHtcbiAgaWYgKHRoaXMuaW5mKVxuICAgIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChudWxsLCBudWxsLCBudWxsKTtcblxuICB2YXIgcmVzID0gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnksIHRoaXMuY3VydmUub25lKTtcbiAgcmV0dXJuIHJlcztcbn07XG5cbmZ1bmN0aW9uIEpQb2ludChjdXJ2ZSwgeCwgeSwgeikge1xuICBiYXNlLkJhc2VQb2ludC5jYWxsKHRoaXMsIGN1cnZlLCAnamFjb2JpYW4nKTtcbiAgaWYgKHggPT09IG51bGwgJiYgeSA9PT0gbnVsbCAmJiB6ID09PSBudWxsKSB7XG4gICAgdGhpcy54ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy55ID0gdGhpcy5jdXJ2ZS5vbmU7XG4gICAgdGhpcy56ID0gbmV3IEJOKDApO1xuICB9IGVsc2Uge1xuICAgIHRoaXMueCA9IG5ldyBCTih4LCAxNik7XG4gICAgdGhpcy55ID0gbmV3IEJOKHksIDE2KTtcbiAgICB0aGlzLnogPSBuZXcgQk4oeiwgMTYpO1xuICB9XG4gIGlmICghdGhpcy54LnJlZClcbiAgICB0aGlzLnggPSB0aGlzLngudG9SZWQodGhpcy5jdXJ2ZS5yZWQpO1xuICBpZiAoIXRoaXMueS5yZWQpXG4gICAgdGhpcy55ID0gdGhpcy55LnRvUmVkKHRoaXMuY3VydmUucmVkKTtcbiAgaWYgKCF0aGlzLnoucmVkKVxuICAgIHRoaXMueiA9IHRoaXMuei50b1JlZCh0aGlzLmN1cnZlLnJlZCk7XG5cbiAgdGhpcy56T25lID0gdGhpcy56ID09PSB0aGlzLmN1cnZlLm9uZTtcbn1cbmluaGVyaXRzX2Jyb3dzZXIoSlBvaW50LCBiYXNlLkJhc2VQb2ludCk7XG5cblNob3J0Q3VydmUucHJvdG90eXBlLmpwb2ludCA9IGZ1bmN0aW9uIGpwb2ludCh4LCB5LCB6KSB7XG4gIHJldHVybiBuZXcgSlBvaW50KHRoaXMsIHgsIHksIHopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS50b1AgPSBmdW5jdGlvbiB0b1AoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcy5jdXJ2ZS5wb2ludChudWxsLCBudWxsKTtcblxuICB2YXIgemludiA9IHRoaXMuei5yZWRJbnZtKCk7XG4gIHZhciB6aW52MiA9IHppbnYucmVkU3FyKCk7XG4gIHZhciBheCA9IHRoaXMueC5yZWRNdWwoemludjIpO1xuICB2YXIgYXkgPSB0aGlzLnkucmVkTXVsKHppbnYyKS5yZWRNdWwoemludik7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUucG9pbnQoYXgsIGF5KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUubmVnID0gZnVuY3Rpb24gbmVnKCkge1xuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQodGhpcy54LCB0aGlzLnkucmVkTmVnKCksIHRoaXMueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmFkZCA9IGZ1bmN0aW9uIGFkZChwKSB7XG4gIC8vIE8gKyBQID0gUFxuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHA7XG5cbiAgLy8gUCArIE8gPSBQXG4gIGlmIChwLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICAvLyAxMk0gKyA0UyArIDdBXG4gIHZhciBwejIgPSBwLnoucmVkU3FyKCk7XG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54LnJlZE11bChwejIpO1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55LnJlZE11bChwejIucmVkTXVsKHAueikpO1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyLnJlZE11bCh0aGlzLnopKTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChwLnopLnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLm1peGVkQWRkID0gZnVuY3Rpb24gbWl4ZWRBZGQocCkge1xuICAvLyBPICsgUCA9IFBcbiAgaWYgKHRoaXMuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiBwLnRvSigpO1xuXG4gIC8vIFAgKyBPID0gUFxuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG5cbiAgLy8gOE0gKyAzUyArIDdBXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHUxID0gdGhpcy54O1xuICB2YXIgdTIgPSBwLngucmVkTXVsKHoyKTtcbiAgdmFyIHMxID0gdGhpcy55O1xuICB2YXIgczIgPSBwLnkucmVkTXVsKHoyKS5yZWRNdWwodGhpcy56KTtcblxuICB2YXIgaCA9IHUxLnJlZFN1Yih1Mik7XG4gIHZhciByID0gczEucmVkU3ViKHMyKTtcbiAgaWYgKGguY21wbigwKSA9PT0gMCkge1xuICAgIGlmIChyLmNtcG4oMCkgIT09IDApXG4gICAgICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobnVsbCwgbnVsbCwgbnVsbCk7XG4gICAgZWxzZVxuICAgICAgcmV0dXJuIHRoaXMuZGJsKCk7XG4gIH1cblxuICB2YXIgaDIgPSBoLnJlZFNxcigpO1xuICB2YXIgaDMgPSBoMi5yZWRNdWwoaCk7XG4gIHZhciB2ID0gdTEucmVkTXVsKGgyKTtcblxuICB2YXIgbnggPSByLnJlZFNxcigpLnJlZElBZGQoaDMpLnJlZElTdWIodikucmVkSVN1Yih2KTtcbiAgdmFyIG55ID0gci5yZWRNdWwodi5yZWRJU3ViKG54KSkucmVkSVN1YihzMS5yZWRNdWwoaDMpKTtcbiAgdmFyIG56ID0gdGhpcy56LnJlZE11bChoKTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmRibHAgPSBmdW5jdGlvbiBkYmxwKHBvdykge1xuICBpZiAocG93ID09PSAwKVxuICAgIHJldHVybiB0aGlzO1xuICBpZiAodGhpcy5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIHRoaXM7XG4gIGlmICghcG93KVxuICAgIHJldHVybiB0aGlzLmRibCgpO1xuXG4gIHZhciBpO1xuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSB8fCB0aGlzLmN1cnZlLnRocmVlQSkge1xuICAgIHZhciByID0gdGhpcztcbiAgICBmb3IgKGkgPSAwOyBpIDwgcG93OyBpKyspXG4gICAgICByID0gci5kYmwoKTtcbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIC8vIDFNICsgMlMgKyAxQSArIE4gKiAoNFMgKyA1TSArIDhBKVxuICAvLyBOID0gMSA9PiA2TSArIDZTICsgOUFcbiAgdmFyIGEgPSB0aGlzLmN1cnZlLmE7XG4gIHZhciB0aW52ID0gdGhpcy5jdXJ2ZS50aW52O1xuXG4gIHZhciBqeCA9IHRoaXMueDtcbiAgdmFyIGp5ID0gdGhpcy55O1xuICB2YXIganogPSB0aGlzLno7XG4gIHZhciBqejQgPSBqei5yZWRTcXIoKS5yZWRTcXIoKTtcblxuICAvLyBSZXVzZSByZXN1bHRzXG4gIHZhciBqeWQgPSBqeS5yZWRBZGQoankpO1xuICBmb3IgKGkgPSAwOyBpIDwgcG93OyBpKyspIHtcbiAgICB2YXIgangyID0gangucmVkU3FyKCk7XG4gICAgdmFyIGp5ZDIgPSBqeWQucmVkU3FyKCk7XG4gICAgdmFyIGp5ZDQgPSBqeWQyLnJlZFNxcigpO1xuICAgIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG4gICAgdmFyIHQxID0gangucmVkTXVsKGp5ZDIpO1xuICAgIHZhciBueCA9IGMucmVkU3FyKCkucmVkSVN1Yih0MS5yZWRBZGQodDEpKTtcbiAgICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcbiAgICB2YXIgZG55ID0gYy5yZWRNdWwodDIpO1xuICAgIGRueSA9IGRueS5yZWRJQWRkKGRueSkucmVkSVN1YihqeWQ0KTtcbiAgICB2YXIgbnogPSBqeWQucmVkTXVsKGp6KTtcbiAgICBpZiAoaSArIDEgPCBwb3cpXG4gICAgICBqejQgPSBqejQucmVkTXVsKGp5ZDQpO1xuXG4gICAganggPSBueDtcbiAgICBqeiA9IG56O1xuICAgIGp5ZCA9IGRueTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChqeCwganlkLnJlZE11bCh0aW52KSwganopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5kYmwgPSBmdW5jdGlvbiBkYmwoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gdGhpcztcblxuICBpZiAodGhpcy5jdXJ2ZS56ZXJvQSlcbiAgICByZXR1cm4gdGhpcy5femVyb0RibCgpO1xuICBlbHNlIGlmICh0aGlzLmN1cnZlLnRocmVlQSlcbiAgICByZXR1cm4gdGhpcy5fdGhyZWVEYmwoKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLl9kYmwoKTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX3plcm9EYmwgPSBmdW5jdGlvbiBfemVyb0RibCgpIHtcbiAgdmFyIG54O1xuICB2YXIgbnk7XG4gIHZhciBuejtcbiAgLy8gWiA9IDFcbiAgaWYgKHRoaXMuek9uZSkge1xuICAgIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sXG4gICAgLy8gICAgICNkb3VibGluZy1tZGJsLTIwMDctYmxcbiAgICAvLyAxTSArIDVTICsgMTRBXG5cbiAgICAvLyBYWCA9IFgxXjJcbiAgICB2YXIgeHggPSB0aGlzLngucmVkU3FyKCk7XG4gICAgLy8gWVkgPSBZMV4yXG4gICAgdmFyIHl5ID0gdGhpcy55LnJlZFNxcigpO1xuICAgIC8vIFlZWVkgPSBZWV4yXG4gICAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgICAvLyBTID0gMiAqICgoWDEgKyBZWSleMiAtIFhYIC0gWVlZWSlcbiAgICB2YXIgcyA9IHRoaXMueC5yZWRBZGQoeXkpLnJlZFNxcigpLnJlZElTdWIoeHgpLnJlZElTdWIoeXl5eSk7XG4gICAgcyA9IHMucmVkSUFkZChzKTtcbiAgICAvLyBNID0gMyAqIFhYICsgYTsgYSA9IDBcbiAgICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCk7XG4gICAgLy8gVCA9IE0gXiAyIC0gMipTXG4gICAgdmFyIHQgPSBtLnJlZFNxcigpLnJlZElTdWIocykucmVkSVN1YihzKTtcblxuICAgIC8vIDggKiBZWVlZXG4gICAgdmFyIHl5eXk4ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgeXl5eTggPSB5eXl5OC5yZWRJQWRkKHl5eXk4KTtcblxuICAgIC8vIFgzID0gVFxuICAgIG54ID0gdDtcbiAgICAvLyBZMyA9IE0gKiAoUyAtIFQpIC0gOCAqIFlZWVlcbiAgICBueSA9IG0ucmVkTXVsKHMucmVkSVN1Yih0KSkucmVkSVN1Yih5eXl5OCk7XG4gICAgLy8gWjMgPSAyKlkxXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0wLmh0bWxcbiAgICAvLyAgICAgI2RvdWJsaW5nLWRibC0yMDA5LWxcbiAgICAvLyAyTSArIDVTICsgMTNBXG5cbiAgICAvLyBBID0gWDFeMlxuICAgIHZhciBhID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIEIgPSBZMV4yXG4gICAgdmFyIGIgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gQyA9IEJeMlxuICAgIHZhciBjID0gYi5yZWRTcXIoKTtcbiAgICAvLyBEID0gMiAqICgoWDEgKyBCKV4yIC0gQSAtIEMpXG4gICAgdmFyIGQgPSB0aGlzLngucmVkQWRkKGIpLnJlZFNxcigpLnJlZElTdWIoYSkucmVkSVN1YihjKTtcbiAgICBkID0gZC5yZWRJQWRkKGQpO1xuICAgIC8vIEUgPSAzICogQVxuICAgIHZhciBlID0gYS5yZWRBZGQoYSkucmVkSUFkZChhKTtcbiAgICAvLyBGID0gRV4yXG4gICAgdmFyIGYgPSBlLnJlZFNxcigpO1xuXG4gICAgLy8gOCAqIENcbiAgICB2YXIgYzggPSBjLnJlZElBZGQoYyk7XG4gICAgYzggPSBjOC5yZWRJQWRkKGM4KTtcbiAgICBjOCA9IGM4LnJlZElBZGQoYzgpO1xuXG4gICAgLy8gWDMgPSBGIC0gMiAqIERcbiAgICBueCA9IGYucmVkSVN1YihkKS5yZWRJU3ViKGQpO1xuICAgIC8vIFkzID0gRSAqIChEIC0gWDMpIC0gOCAqIENcbiAgICBueSA9IGUucmVkTXVsKGQucmVkSVN1YihueCkpLnJlZElTdWIoYzgpO1xuICAgIC8vIFozID0gMiAqIFkxICogWjFcbiAgICBueiA9IHRoaXMueS5yZWRNdWwodGhpcy56KTtcbiAgICBueiA9IG56LnJlZElBZGQobnopO1xuICB9XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5fdGhyZWVEYmwgPSBmdW5jdGlvbiBfdGhyZWVEYmwoKSB7XG4gIHZhciBueDtcbiAgdmFyIG55O1xuICB2YXIgbno7XG4gIC8vIFogPSAxXG4gIGlmICh0aGlzLnpPbmUpIHtcbiAgICAvLyBoeXBlcmVsbGlwdGljLm9yZy9FRkQvZzFwL2F1dG8tc2hvcnR3LWphY29iaWFuLTMuaHRtbFxuICAgIC8vICAgICAjZG91YmxpbmctbWRibC0yMDA3LWJsXG4gICAgLy8gMU0gKyA1UyArIDE1QVxuXG4gICAgLy8gWFggPSBYMV4yXG4gICAgdmFyIHh4ID0gdGhpcy54LnJlZFNxcigpO1xuICAgIC8vIFlZID0gWTFeMlxuICAgIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgICAvLyBZWVlZID0gWVleMlxuICAgIHZhciB5eXl5ID0geXkucmVkU3FyKCk7XG4gICAgLy8gUyA9IDIgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpXG4gICAgdmFyIHMgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICAgIHMgPSBzLnJlZElBZGQocyk7XG4gICAgLy8gTSA9IDMgKiBYWCArIGFcbiAgICB2YXIgbSA9IHh4LnJlZEFkZCh4eCkucmVkSUFkZCh4eCkucmVkSUFkZCh0aGlzLmN1cnZlLmEpO1xuICAgIC8vIFQgPSBNXjIgLSAyICogU1xuICAgIHZhciB0ID0gbS5yZWRTcXIoKS5yZWRJU3ViKHMpLnJlZElTdWIocyk7XG4gICAgLy8gWDMgPSBUXG4gICAgbnggPSB0O1xuICAgIC8vIFkzID0gTSAqIChTIC0gVCkgLSA4ICogWVlZWVxuICAgIHZhciB5eXl5OCA9IHl5eXkucmVkSUFkZCh5eXl5KTtcbiAgICB5eXl5OCA9IHl5eXk4LnJlZElBZGQoeXl5eTgpO1xuICAgIHl5eXk4ID0geXl5eTgucmVkSUFkZCh5eXl5OCk7XG4gICAgbnkgPSBtLnJlZE11bChzLnJlZElTdWIodCkpLnJlZElTdWIoeXl5eTgpO1xuICAgIC8vIFozID0gMiAqIFkxXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueSk7XG4gIH0gZWxzZSB7XG4gICAgLy8gaHlwZXJlbGxpcHRpYy5vcmcvRUZEL2cxcC9hdXRvLXNob3J0dy1qYWNvYmlhbi0zLmh0bWwjZG91YmxpbmctZGJsLTIwMDEtYlxuICAgIC8vIDNNICsgNVNcblxuICAgIC8vIGRlbHRhID0gWjFeMlxuICAgIHZhciBkZWx0YSA9IHRoaXMuei5yZWRTcXIoKTtcbiAgICAvLyBnYW1tYSA9IFkxXjJcbiAgICB2YXIgZ2FtbWEgPSB0aGlzLnkucmVkU3FyKCk7XG4gICAgLy8gYmV0YSA9IFgxICogZ2FtbWFcbiAgICB2YXIgYmV0YSA9IHRoaXMueC5yZWRNdWwoZ2FtbWEpO1xuICAgIC8vIGFscGhhID0gMyAqIChYMSAtIGRlbHRhKSAqIChYMSArIGRlbHRhKVxuICAgIHZhciBhbHBoYSA9IHRoaXMueC5yZWRTdWIoZGVsdGEpLnJlZE11bCh0aGlzLngucmVkQWRkKGRlbHRhKSk7XG4gICAgYWxwaGEgPSBhbHBoYS5yZWRBZGQoYWxwaGEpLnJlZElBZGQoYWxwaGEpO1xuICAgIC8vIFgzID0gYWxwaGFeMiAtIDggKiBiZXRhXG4gICAgdmFyIGJldGE0ID0gYmV0YS5yZWRJQWRkKGJldGEpO1xuICAgIGJldGE0ID0gYmV0YTQucmVkSUFkZChiZXRhNCk7XG4gICAgdmFyIGJldGE4ID0gYmV0YTQucmVkQWRkKGJldGE0KTtcbiAgICBueCA9IGFscGhhLnJlZFNxcigpLnJlZElTdWIoYmV0YTgpO1xuICAgIC8vIFozID0gKFkxICsgWjEpXjIgLSBnYW1tYSAtIGRlbHRhXG4gICAgbnogPSB0aGlzLnkucmVkQWRkKHRoaXMueikucmVkU3FyKCkucmVkSVN1YihnYW1tYSkucmVkSVN1YihkZWx0YSk7XG4gICAgLy8gWTMgPSBhbHBoYSAqICg0ICogYmV0YSAtIFgzKSAtIDggKiBnYW1tYV4yXG4gICAgdmFyIGdnYW1tYTggPSBnYW1tYS5yZWRTcXIoKTtcbiAgICBnZ2FtbWE4ID0gZ2dhbW1hOC5yZWRJQWRkKGdnYW1tYTgpO1xuICAgIGdnYW1tYTggPSBnZ2FtbWE4LnJlZElBZGQoZ2dhbW1hOCk7XG4gICAgZ2dhbW1hOCA9IGdnYW1tYTgucmVkSUFkZChnZ2FtbWE4KTtcbiAgICBueSA9IGFscGhhLnJlZE11bChiZXRhNC5yZWRJU3ViKG54KSkucmVkSVN1YihnZ2FtbWE4KTtcbiAgfVxuXG4gIHJldHVybiB0aGlzLmN1cnZlLmpwb2ludChueCwgbnksIG56KTtcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuX2RibCA9IGZ1bmN0aW9uIF9kYmwoKSB7XG4gIHZhciBhID0gdGhpcy5jdXJ2ZS5hO1xuXG4gIC8vIDRNICsgNlMgKyAxMEFcbiAgdmFyIGp4ID0gdGhpcy54O1xuICB2YXIgankgPSB0aGlzLnk7XG4gIHZhciBqeiA9IHRoaXMuejtcbiAgdmFyIGp6NCA9IGp6LnJlZFNxcigpLnJlZFNxcigpO1xuXG4gIHZhciBqeDIgPSBqeC5yZWRTcXIoKTtcbiAgdmFyIGp5MiA9IGp5LnJlZFNxcigpO1xuXG4gIHZhciBjID0gangyLnJlZEFkZChqeDIpLnJlZElBZGQoangyKS5yZWRJQWRkKGEucmVkTXVsKGp6NCkpO1xuXG4gIHZhciBqeGQ0ID0gangucmVkQWRkKGp4KTtcbiAganhkNCA9IGp4ZDQucmVkSUFkZChqeGQ0KTtcbiAgdmFyIHQxID0ganhkNC5yZWRNdWwoankyKTtcbiAgdmFyIG54ID0gYy5yZWRTcXIoKS5yZWRJU3ViKHQxLnJlZEFkZCh0MSkpO1xuICB2YXIgdDIgPSB0MS5yZWRJU3ViKG54KTtcblxuICB2YXIganlkOCA9IGp5Mi5yZWRTcXIoKTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAganlkOCA9IGp5ZDgucmVkSUFkZChqeWQ4KTtcbiAgdmFyIG55ID0gYy5yZWRNdWwodDIpLnJlZElTdWIoanlkOCk7XG4gIHZhciBueiA9IGp5LnJlZEFkZChqeSkucmVkTXVsKGp6KTtcblxuICByZXR1cm4gdGhpcy5jdXJ2ZS5qcG9pbnQobngsIG55LCBueik7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLnRycGwgPSBmdW5jdGlvbiB0cnBsKCkge1xuICBpZiAoIXRoaXMuY3VydmUuemVyb0EpXG4gICAgcmV0dXJuIHRoaXMuZGJsKCkuYWRkKHRoaXMpO1xuXG4gIC8vIGh5cGVyZWxsaXB0aWMub3JnL0VGRC9nMXAvYXV0by1zaG9ydHctamFjb2JpYW4tMC5odG1sI3RyaXBsaW5nLXRwbC0yMDA3LWJsXG4gIC8vIDVNICsgMTBTICsgLi4uXG5cbiAgLy8gWFggPSBYMV4yXG4gIHZhciB4eCA9IHRoaXMueC5yZWRTcXIoKTtcbiAgLy8gWVkgPSBZMV4yXG4gIHZhciB5eSA9IHRoaXMueS5yZWRTcXIoKTtcbiAgLy8gWlogPSBaMV4yXG4gIHZhciB6eiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgLy8gWVlZWSA9IFlZXjJcbiAgdmFyIHl5eXkgPSB5eS5yZWRTcXIoKTtcbiAgLy8gTSA9IDMgKiBYWCArIGEgKiBaWjI7IGEgPSAwXG4gIHZhciBtID0geHgucmVkQWRkKHh4KS5yZWRJQWRkKHh4KTtcbiAgLy8gTU0gPSBNXjJcbiAgdmFyIG1tID0gbS5yZWRTcXIoKTtcbiAgLy8gRSA9IDYgKiAoKFgxICsgWVkpXjIgLSBYWCAtIFlZWVkpIC0gTU1cbiAgdmFyIGUgPSB0aGlzLngucmVkQWRkKHl5KS5yZWRTcXIoKS5yZWRJU3ViKHh4KS5yZWRJU3ViKHl5eXkpO1xuICBlID0gZS5yZWRJQWRkKGUpO1xuICBlID0gZS5yZWRBZGQoZSkucmVkSUFkZChlKTtcbiAgZSA9IGUucmVkSVN1YihtbSk7XG4gIC8vIEVFID0gRV4yXG4gIHZhciBlZSA9IGUucmVkU3FyKCk7XG4gIC8vIFQgPSAxNipZWVlZXG4gIHZhciB0ID0geXl5eS5yZWRJQWRkKHl5eXkpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICB0ID0gdC5yZWRJQWRkKHQpO1xuICAvLyBVID0gKE0gKyBFKV4yIC0gTU0gLSBFRSAtIFRcbiAgdmFyIHUgPSBtLnJlZElBZGQoZSkucmVkU3FyKCkucmVkSVN1YihtbSkucmVkSVN1YihlZSkucmVkSVN1Yih0KTtcbiAgLy8gWDMgPSA0ICogKFgxICogRUUgLSA0ICogWVkgKiBVKVxuICB2YXIgeXl1NCA9IHl5LnJlZE11bCh1KTtcbiAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcbiAgeXl1NCA9IHl5dTQucmVkSUFkZCh5eXU0KTtcbiAgdmFyIG54ID0gdGhpcy54LnJlZE11bChlZSkucmVkSVN1Yih5eXU0KTtcbiAgbnggPSBueC5yZWRJQWRkKG54KTtcbiAgbnggPSBueC5yZWRJQWRkKG54KTtcbiAgLy8gWTMgPSA4ICogWTEgKiAoVSAqIChUIC0gVSkgLSBFICogRUUpXG4gIHZhciBueSA9IHRoaXMueS5yZWRNdWwodS5yZWRNdWwodC5yZWRJU3ViKHUpKS5yZWRJU3ViKGUucmVkTXVsKGVlKSkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICBueSA9IG55LnJlZElBZGQobnkpO1xuICAvLyBaMyA9IChaMSArIEUpXjIgLSBaWiAtIEVFXG4gIHZhciBueiA9IHRoaXMuei5yZWRBZGQoZSkucmVkU3FyKCkucmVkSVN1Yih6eikucmVkSVN1YihlZSk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuanBvaW50KG54LCBueSwgbnopO1xufTtcblxuSlBvaW50LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwoaywga2Jhc2UpIHtcbiAgayA9IG5ldyBCTihrLCBrYmFzZSk7XG5cbiAgcmV0dXJuIHRoaXMuY3VydmUuX3duYWZNdWwodGhpcywgayk7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmVxID0gZnVuY3Rpb24gZXEocCkge1xuICBpZiAocC50eXBlID09PSAnYWZmaW5lJylcbiAgICByZXR1cm4gdGhpcy5lcShwLnRvSigpKTtcblxuICBpZiAodGhpcyA9PT0gcClcbiAgICByZXR1cm4gdHJ1ZTtcblxuICAvLyB4MSAqIHoyXjIgPT0geDIgKiB6MV4yXG4gIHZhciB6MiA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHB6MiA9IHAuei5yZWRTcXIoKTtcbiAgaWYgKHRoaXMueC5yZWRNdWwocHoyKS5yZWRJU3ViKHAueC5yZWRNdWwoejIpKS5jbXBuKDApICE9PSAwKVxuICAgIHJldHVybiBmYWxzZTtcblxuICAvLyB5MSAqIHoyXjMgPT0geTIgKiB6MV4zXG4gIHZhciB6MyA9IHoyLnJlZE11bCh0aGlzLnopO1xuICB2YXIgcHozID0gcHoyLnJlZE11bChwLnopO1xuICByZXR1cm4gdGhpcy55LnJlZE11bChwejMpLnJlZElTdWIocC55LnJlZE11bCh6MykpLmNtcG4oMCkgPT09IDA7XG59O1xuXG5KUG9pbnQucHJvdG90eXBlLmVxWFRvUCA9IGZ1bmN0aW9uIGVxWFRvUCh4KSB7XG4gIHZhciB6cyA9IHRoaXMuei5yZWRTcXIoKTtcbiAgdmFyIHJ4ID0geC50b1JlZCh0aGlzLmN1cnZlLnJlZCkucmVkTXVsKHpzKTtcbiAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgIHJldHVybiB0cnVlO1xuXG4gIHZhciB4YyA9IHguY2xvbmUoKTtcbiAgdmFyIHQgPSB0aGlzLmN1cnZlLnJlZE4ucmVkTXVsKHpzKTtcbiAgZm9yICg7Oykge1xuICAgIHhjLmlhZGQodGhpcy5jdXJ2ZS5uKTtcbiAgICBpZiAoeGMuY21wKHRoaXMuY3VydmUucCkgPj0gMClcbiAgICAgIHJldHVybiBmYWxzZTtcblxuICAgIHJ4LnJlZElBZGQodCk7XG4gICAgaWYgKHRoaXMueC5jbXAocngpID09PSAwKVxuICAgICAgcmV0dXJuIHRydWU7XG4gIH1cbn07XG5cbkpQb2ludC5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QoKSB7XG4gIGlmICh0aGlzLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4gJzxFQyBKUG9pbnQgSW5maW5pdHk+JztcbiAgcmV0dXJuICc8RUMgSlBvaW50IHg6ICcgKyB0aGlzLngudG9TdHJpbmcoMTYsIDIpICtcbiAgICAgICcgeTogJyArIHRoaXMueS50b1N0cmluZygxNiwgMikgK1xuICAgICAgJyB6OiAnICsgdGhpcy56LnRvU3RyaW5nKDE2LCAyKSArICc+Jztcbn07XG5cbkpQb2ludC5wcm90b3R5cGUuaXNJbmZpbml0eSA9IGZ1bmN0aW9uIGlzSW5maW5pdHkoKSB7XG4gIC8vIFhYWCBUaGlzIGNvZGUgYXNzdW1lcyB0aGF0IHplcm8gaXMgYWx3YXlzIHplcm8gaW4gcmVkXG4gIHJldHVybiB0aGlzLnouY21wbigwKSA9PT0gMDtcbn07XG5cbnZhciBjdXJ2ZV8xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgY3VydmUgPSBleHBvcnRzO1xuXG5jdXJ2ZS5iYXNlID0gYmFzZTtcbmN1cnZlLnNob3J0ID0gc2hvcnRfMTtcbmN1cnZlLm1vbnQgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZSguL21vbnQpKi8obnVsbCk7XG5jdXJ2ZS5lZHdhcmRzID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoLi9lZHdhcmRzKSovKG51bGwpO1xufSk7XG5cbnZhciBjdXJ2ZXNfMSA9IGNyZWF0ZUNvbW1vbmpzTW9kdWxlKGZ1bmN0aW9uIChtb2R1bGUsIGV4cG9ydHMpIHtcbid1c2Ugc3RyaWN0JztcblxudmFyIGN1cnZlcyA9IGV4cG9ydHM7XG5cblxuXG5cblxudmFyIGFzc2VydCA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFByZXNldEN1cnZlKG9wdGlvbnMpIHtcbiAgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ3Nob3J0JylcbiAgICB0aGlzLmN1cnZlID0gbmV3IGN1cnZlXzEuc2hvcnQob3B0aW9ucyk7XG4gIGVsc2UgaWYgKG9wdGlvbnMudHlwZSA9PT0gJ2Vkd2FyZHMnKVxuICAgIHRoaXMuY3VydmUgPSBuZXcgY3VydmVfMS5lZHdhcmRzKG9wdGlvbnMpO1xuICBlbHNlXG4gICAgdGhpcy5jdXJ2ZSA9IG5ldyBjdXJ2ZV8xLm1vbnQob3B0aW9ucyk7XG4gIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcbiAgdGhpcy5uID0gdGhpcy5jdXJ2ZS5uO1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG5cbiAgYXNzZXJ0KHRoaXMuZy52YWxpZGF0ZSgpLCAnSW52YWxpZCBjdXJ2ZScpO1xuICBhc3NlcnQodGhpcy5nLm11bCh0aGlzLm4pLmlzSW5maW5pdHkoKSwgJ0ludmFsaWQgY3VydmUsIEcqTiAhPSBPJyk7XG59XG5jdXJ2ZXMuUHJlc2V0Q3VydmUgPSBQcmVzZXRDdXJ2ZTtcblxuZnVuY3Rpb24gZGVmaW5lQ3VydmUobmFtZSwgb3B0aW9ucykge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoY3VydmVzLCBuYW1lLCB7XG4gICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdXJ2ZSA9IG5ldyBQcmVzZXRDdXJ2ZShvcHRpb25zKTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjdXJ2ZXMsIG5hbWUsIHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogY3VydmUsXG4gICAgICB9KTtcbiAgICAgIHJldHVybiBjdXJ2ZTtcbiAgICB9LFxuICB9KTtcbn1cblxuZGVmaW5lQ3VydmUoJ3AxOTInLCB7XG4gIHR5cGU6ICdzaG9ydCcsXG4gIHByaW1lOiAncDE5MicsXG4gIHA6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicsXG4gIGE6ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmYycsXG4gIGI6ICc2NDIxMDUxOSBlNTljODBlNyAwZmE3ZTlhYiA3MjI0MzA0OSBmZWI4ZGVlYyBjMTQ2YjliMScsXG4gIG46ICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiA5OWRlZjgzNiAxNDZiYzliMSBiNGQyMjgzMScsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcxODhkYTgwZSBiMDMwOTBmNiA3Y2JmMjBlYiA0M2ExODgwMCBmNGZmMGFmZCA4MmZmMTAxMicsXG4gICAgJzA3MTkyYjk1IGZmYzhkYTc4IDYzMTAxMWVkIDZiMjRjZGQ1IDczZjk3N2ExIDFlNzk0ODExJyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDIyNCcsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6ICdwMjI0JyxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAxJyxcbiAgYTogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlJyxcbiAgYjogJ2I0MDUwYTg1IDBjMDRiM2FiIGY1NDEzMjU2IDUwNDRiMGI3IGQ3YmZkOGJhIDI3MGIzOTQzIDIzNTVmZmI0JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmYxNmEyIGUwYjhmMDNlIDEzZGQyOTQ1IDVjNWMyYTNkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJ2I3MGUwY2JkIDZiYjRiZjdmIDMyMTM5MGI5IDRhMDNjMWQzIDU2YzIxMTIyIDM0MzI4MGQ2IDExNWMxZDIxJyxcbiAgICAnYmQzNzYzODggYjVmNzIzZmIgNGMyMmRmZTYgY2Q0Mzc1YTAgNWEwNzQ3NjQgNDRkNTgxOTkgODUwMDdlMzQnLFxuICBdLFxufSk7XG5cbmRlZmluZUN1cnZlKCdwMjU2Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmJyxcbiAgYTogJ2ZmZmZmZmZmIDAwMDAwMDAxIDAwMDAwMDAwIDAwMDAwMDAwIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzVhYzYzNWQ4IGFhM2E5M2U3IGIzZWJiZDU1IDc2OTg4NmJjIDY1MWQwNmIwIGNjNTNiMGY2IDNiY2UzYzNlIDI3ZDI2MDRiJyxcbiAgbjogJ2ZmZmZmZmZmIDAwMDAwMDAwIGZmZmZmZmZmIGZmZmZmZmZmIGJjZTZmYWFkIGE3MTc5ZTg0IGYzYjljYWMyIGZjNjMyNTUxJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzZiMTdkMWYyIGUxMmM0MjQ3IGY4YmNlNmU1IDYzYTQ0MGYyIDc3MDM3ZDgxIDJkZWIzM2EwIGY0YTEzOTQ1IGQ4OThjMjk2JyxcbiAgICAnNGZlMzQyZTIgZmUxYTdmOWIgOGVlN2ViNGEgN2MwZjllMTYgMmJjZTMzNTcgNmIzMTVlY2UgY2JiNjQwNjggMzdiZjUxZjUnLFxuICBdLFxufSk7XG5cbmRlZmluZUN1cnZlKCdwMzg0Jywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogbnVsbCxcbiAgcDogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmUgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgZmZmZmZmZmYnLFxuICBhOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZSBmZmZmZmZmZiAwMDAwMDAwMCAwMDAwMDAwMCBmZmZmZmZmYycsXG4gIGI6ICdiMzMxMmZhNyBlMjNlZTdlNCA5ODhlMDU2YiBlM2Y4MmQxOSAxODFkOWM2ZSBmZTgxNDExMiAwMzE0MDg4ZiAnICtcbiAgICAgJzUwMTM4NzVhIGM2NTYzOThkIDhhMmVkMTlkIDJhODVjOGVkIGQzZWMyYWVmJyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGM3NjM0ZDgxICcgK1xuICAgICAnZjQzNzJkZGYgNTgxYTBkYjIgNDhiMGE3N2EgZWNlYzE5NmEgY2NjNTI5NzMnLFxuICBoYXNoOiBoYXNoLnNoYTM4NCxcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnYWE4N2NhMjIgYmU4YjA1MzcgOGViMWM3MWUgZjMyMGFkNzQgNmUxZDNiNjIgOGJhNzliOTggNTlmNzQxZTAgODI1NDJhMzggJyArXG4gICAgJzU1MDJmMjVkIGJmNTUyOTZjIDNhNTQ1ZTM4IDcyNzYwYWI3JyxcbiAgICAnMzYxN2RlNGEgOTYyNjJjNmYgNWQ5ZTk4YmYgOTI5MmRjMjkgZjhmNDFkYmQgMjg5YTE0N2MgZTlkYTMxMTMgYjVmMGI4YzAgJyArXG4gICAgJzBhNjBiMWNlIDFkN2U4MTlkIDdhNDMxZDdjIDkwZWEwZTVmJyxcbiAgXSxcbn0pO1xuXG5kZWZpbmVDdXJ2ZSgncDUyMScsIHtcbiAgdHlwZTogJ3Nob3J0JyxcbiAgcHJpbWU6IG51bGwsXG4gIHA6ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmICcgK1xuICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYnLFxuICBhOiAnMDAwMDAxZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgJyArXG4gICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZjJyxcbiAgYjogJzAwMDAwMDUxIDk1M2ViOTYxIDhlMWM5YTFmIDkyOWEyMWEwIGI2ODU0MGVlIGEyZGE3MjViICcgK1xuICAgICAnOTliMzE1ZjMgYjhiNDg5OTEgOGVmMTA5ZTEgNTYxOTM5NTEgZWM3ZTkzN2IgMTY1MmMwYmQgJyArXG4gICAgICczYmIxYmYwNyAzNTczZGY4OCAzZDJjMzRmMSBlZjQ1MWZkNCA2YjUwM2YwMCcsXG4gIG46ICcwMDAwMDFmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiAnICtcbiAgICAgJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZhIDUxODY4NzgzIGJmMmY5NjZiIDdmY2MwMTQ4ICcgK1xuICAgICAnZjcwOWE1ZDAgM2JiNWM5YjggODk5YzQ3YWUgYmI2ZmI3MWUgOTEzODY0MDknLFxuICBoYXNoOiBoYXNoLnNoYTUxMixcbiAgZ1JlZDogZmFsc2UsXG4gIGc6IFtcbiAgICAnMDAwMDAwYzYgODU4ZTA2YjcgMDQwNGU5Y2QgOWUzZWNiNjYgMjM5NWI0NDIgOWM2NDgxMzkgJyArXG4gICAgJzA1M2ZiNTIxIGY4MjhhZjYwIDZiNGQzZGJhIGExNGI1ZTc3IGVmZTc1OTI4IGZlMWRjMTI3ICcgK1xuICAgICdhMmZmYThkZSAzMzQ4YjNjMSA4NTZhNDI5YiBmOTdlN2UzMSBjMmU1YmQ2NicsXG4gICAgJzAwMDAwMTE4IDM5Mjk2YTc4IDlhM2JjMDA0IDVjOGE1ZmI0IDJjN2QxYmQ5IDk4ZjU0NDQ5ICcgK1xuICAgICc1NzliNDQ2OCAxN2FmYmQxNyAyNzNlNjYyYyA5N2VlNzI5OSA1ZWY0MjY0MCBjNTUwYjkwMSAnICtcbiAgICAnM2ZhZDA3NjEgMzUzYzcwODYgYTI3MmMyNDAgODhiZTk0NzYgOWZkMTY2NTAnLFxuICBdLFxufSk7XG5cbmRlZmluZUN1cnZlKCdjdXJ2ZTI1NTE5Jywge1xuICB0eXBlOiAnbW9udCcsXG4gIHByaW1lOiAncDI1NTE5JyxcbiAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuICBhOiAnNzZkMDYnLFxuICBiOiAnMScsXG4gIG46ICcxMDAwMDAwMDAwMDAwMDAwIDAwMDAwMDAwMDAwMDAwMDAgMTRkZWY5ZGVhMmY3OWNkNiA1ODEyNjMxYTVjZjVkM2VkJyxcbiAgaGFzaDogaGFzaC5zaGEyNTYsXG4gIGdSZWQ6IGZhbHNlLFxuICBnOiBbXG4gICAgJzknLFxuICBdLFxufSk7XG5cbmRlZmluZUN1cnZlKCdlZDI1NTE5Jywge1xuICB0eXBlOiAnZWR3YXJkcycsXG4gIHByaW1lOiAncDI1NTE5JyxcbiAgcDogJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnLFxuICBhOiAnLTEnLFxuICBjOiAnMScsXG4gIC8vIC0xMjE2NjUgKiAoMTIxNjY2XigtMSkpIChtb2QgUClcbiAgZDogJzUyMDM2Y2VlMmI2ZmZlNzMgOGNjNzQwNzk3Nzc5ZTg5OCAwMDcwMGE0ZDQxNDFkOGFiIDc1ZWI0ZGNhMTM1OTc4YTMnLFxuICBuOiAnMTAwMDAwMDAwMDAwMDAwMCAwMDAwMDAwMDAwMDAwMDAwIDE0ZGVmOWRlYTJmNzljZDYgNTgxMjYzMWE1Y2Y1ZDNlZCcsXG4gIGhhc2g6IGhhc2guc2hhMjU2LFxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICcyMTY5MzZkM2NkNmU1M2ZlYzBhNGUyMzFmZGQ2ZGM1YzY5MmNjNzYwOTUyNWE3YjJjOTU2MmQ2MDhmMjVkNTFhJyxcblxuICAgIC8vIDQvNVxuICAgICc2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjU4JyxcbiAgXSxcbn0pO1xuXG52YXIgcHJlO1xudHJ5IHtcbiAgcHJlID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoLi9wcmVjb21wdXRlZC9zZWNwMjU2azEpKi8obnVsbCkuY3Jhc2goKTtcbn0gY2F0Y2ggKGUpIHtcbiAgcHJlID0gdW5kZWZpbmVkO1xufVxuXG5kZWZpbmVDdXJ2ZSgnc2VjcDI1NmsxJywge1xuICB0eXBlOiAnc2hvcnQnLFxuICBwcmltZTogJ2syNTYnLFxuICBwOiAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnLFxuICBhOiAnMCcsXG4gIGI6ICc3JyxcbiAgbjogJ2ZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZmIGZmZmZmZmZlIGJhYWVkY2U2IGFmNDhhMDNiIGJmZDI1ZThjIGQwMzY0MTQxJyxcbiAgaDogJzEnLFxuICBoYXNoOiBoYXNoLnNoYTI1NixcblxuICAvLyBQcmVjb21wdXRlZCBlbmRvbW9ycGhpc21cbiAgYmV0YTogJzdhZTk2YTJiNjU3YzA3MTA2ZTY0NDc5ZWFjMzQzNGU5OWNmMDQ5NzUxMmY1ODk5NWMxMzk2YzI4NzE5NTAxZWUnLFxuICBsYW1iZGE6ICc1MzYzYWQ0Y2MwNWMzMGUwYTUyNjFjMDI4ODEyNjQ1YTEyMmUyMmVhMjA4MTY2NzhkZjAyOTY3YzFiMjNiZDcyJyxcbiAgYmFzaXM6IFtcbiAgICB7XG4gICAgICBhOiAnMzA4NmQyMjFhN2Q0NmJjZGU4NmM5MGU0OTI4NGViMTUnLFxuICAgICAgYjogJy1lNDQzN2VkNjAxMGU4ODI4NmY1NDdmYTkwYWJmZTRjMycsXG4gICAgfSxcbiAgICB7XG4gICAgICBhOiAnMTE0Y2E1MGY3YThlMmYzZjY1N2MxMTA4ZDlkNDRjZmQ4JyxcbiAgICAgIGI6ICczMDg2ZDIyMWE3ZDQ2YmNkZTg2YzkwZTQ5Mjg0ZWIxNScsXG4gICAgfSxcbiAgXSxcblxuICBnUmVkOiBmYWxzZSxcbiAgZzogW1xuICAgICc3OWJlNjY3ZWY5ZGNiYmFjNTVhMDYyOTVjZTg3MGIwNzAyOWJmY2RiMmRjZTI4ZDk1OWYyODE1YjE2ZjgxNzk4JyxcbiAgICAnNDgzYWRhNzcyNmEzYzQ2NTVkYTRmYmZjMGUxMTA4YThmZDE3YjQ0OGE2ODU1NDE5OWM0N2QwOGZmYjEwZDRiOCcsXG4gICAgcHJlLFxuICBdLFxufSk7XG59KTtcblxuJ3VzZSBzdHJpY3QnO1xuXG5cblxuXG5cbmZ1bmN0aW9uIEhtYWNEUkJHKG9wdGlvbnMpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEhtYWNEUkJHKSlcbiAgICByZXR1cm4gbmV3IEhtYWNEUkJHKG9wdGlvbnMpO1xuICB0aGlzLmhhc2ggPSBvcHRpb25zLmhhc2g7XG4gIHRoaXMucHJlZFJlc2lzdCA9ICEhb3B0aW9ucy5wcmVkUmVzaXN0O1xuXG4gIHRoaXMub3V0TGVuID0gdGhpcy5oYXNoLm91dFNpemU7XG4gIHRoaXMubWluRW50cm9weSA9IG9wdGlvbnMubWluRW50cm9weSB8fCB0aGlzLmhhc2guaG1hY1N0cmVuZ3RoO1xuXG4gIHRoaXMuX3Jlc2VlZCA9IG51bGw7XG4gIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSBudWxsO1xuICB0aGlzLksgPSBudWxsO1xuICB0aGlzLlYgPSBudWxsO1xuXG4gIHZhciBlbnRyb3B5ID0gdXRpbHNfMS50b0FycmF5KG9wdGlvbnMuZW50cm9weSwgb3B0aW9ucy5lbnRyb3B5RW5jIHx8ICdoZXgnKTtcbiAgdmFyIG5vbmNlID0gdXRpbHNfMS50b0FycmF5KG9wdGlvbnMubm9uY2UsIG9wdGlvbnMubm9uY2VFbmMgfHwgJ2hleCcpO1xuICB2YXIgcGVycyA9IHV0aWxzXzEudG9BcnJheShvcHRpb25zLnBlcnMsIG9wdGlvbnMucGVyc0VuYyB8fCAnaGV4Jyk7XG4gIG1pbmltYWxpc3RpY0Fzc2VydChlbnRyb3B5Lmxlbmd0aCA+PSAodGhpcy5taW5FbnRyb3B5IC8gOCksXG4gICAgICAgICAnTm90IGVub3VnaCBlbnRyb3B5LiBNaW5pbXVtIGlzOiAnICsgdGhpcy5taW5FbnRyb3B5ICsgJyBiaXRzJyk7XG4gIHRoaXMuX2luaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpO1xufVxudmFyIGhtYWNEcmJnID0gSG1hY0RSQkc7XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5faW5pdCA9IGZ1bmN0aW9uIGluaXQoZW50cm9weSwgbm9uY2UsIHBlcnMpIHtcbiAgdmFyIHNlZWQgPSBlbnRyb3B5LmNvbmNhdChub25jZSkuY29uY2F0KHBlcnMpO1xuXG4gIHRoaXMuSyA9IG5ldyBBcnJheSh0aGlzLm91dExlbiAvIDgpO1xuICB0aGlzLlYgPSBuZXcgQXJyYXkodGhpcy5vdXRMZW4gLyA4KTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLlYubGVuZ3RoOyBpKyspIHtcbiAgICB0aGlzLktbaV0gPSAweDAwO1xuICAgIHRoaXMuVltpXSA9IDB4MDE7XG4gIH1cblxuICB0aGlzLl91cGRhdGUoc2VlZCk7XG4gIHRoaXMuX3Jlc2VlZCA9IDE7XG4gIHRoaXMucmVzZWVkSW50ZXJ2YWwgPSAweDEwMDAwMDAwMDAwMDA7ICAvLyAyXjQ4XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX2htYWMgPSBmdW5jdGlvbiBobWFjKCkge1xuICByZXR1cm4gbmV3IGhhc2guaG1hYyh0aGlzLmhhc2gsIHRoaXMuSyk7XG59O1xuXG5IbWFjRFJCRy5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShzZWVkKSB7XG4gIHZhciBrbWFjID0gdGhpcy5faG1hYygpXG4gICAgICAgICAgICAgICAgIC51cGRhdGUodGhpcy5WKVxuICAgICAgICAgICAgICAgICAudXBkYXRlKFsgMHgwMCBdKTtcbiAgaWYgKHNlZWQpXG4gICAga21hYyA9IGttYWMudXBkYXRlKHNlZWQpO1xuICB0aGlzLksgPSBrbWFjLmRpZ2VzdCgpO1xuICB0aGlzLlYgPSB0aGlzLl9obWFjKCkudXBkYXRlKHRoaXMuVikuZGlnZXN0KCk7XG4gIGlmICghc2VlZClcbiAgICByZXR1cm47XG5cbiAgdGhpcy5LID0gdGhpcy5faG1hYygpXG4gICAgICAgICAgICAgICAudXBkYXRlKHRoaXMuVilcbiAgICAgICAgICAgICAgIC51cGRhdGUoWyAweDAxIF0pXG4gICAgICAgICAgICAgICAudXBkYXRlKHNlZWQpXG4gICAgICAgICAgICAgICAuZGlnZXN0KCk7XG4gIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5yZXNlZWQgPSBmdW5jdGlvbiByZXNlZWQoZW50cm9weSwgZW50cm9weUVuYywgYWRkLCBhZGRFbmMpIHtcbiAgLy8gT3B0aW9uYWwgZW50cm9weSBlbmNcbiAgaWYgKHR5cGVvZiBlbnRyb3B5RW5jICE9PSAnc3RyaW5nJykge1xuICAgIGFkZEVuYyA9IGFkZDtcbiAgICBhZGQgPSBlbnRyb3B5RW5jO1xuICAgIGVudHJvcHlFbmMgPSBudWxsO1xuICB9XG5cbiAgZW50cm9weSA9IHV0aWxzXzEudG9BcnJheShlbnRyb3B5LCBlbnRyb3B5RW5jKTtcbiAgYWRkID0gdXRpbHNfMS50b0FycmF5KGFkZCwgYWRkRW5jKTtcblxuICBtaW5pbWFsaXN0aWNBc3NlcnQoZW50cm9weS5sZW5ndGggPj0gKHRoaXMubWluRW50cm9weSAvIDgpLFxuICAgICAgICAgJ05vdCBlbm91Z2ggZW50cm9weS4gTWluaW11bSBpczogJyArIHRoaXMubWluRW50cm9weSArICcgYml0cycpO1xuXG4gIHRoaXMuX3VwZGF0ZShlbnRyb3B5LmNvbmNhdChhZGQgfHwgW10pKTtcbiAgdGhpcy5fcmVzZWVkID0gMTtcbn07XG5cbkhtYWNEUkJHLnByb3RvdHlwZS5nZW5lcmF0ZSA9IGZ1bmN0aW9uIGdlbmVyYXRlKGxlbiwgZW5jLCBhZGQsIGFkZEVuYykge1xuICBpZiAodGhpcy5fcmVzZWVkID4gdGhpcy5yZXNlZWRJbnRlcnZhbClcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Jlc2VlZCBpcyByZXF1aXJlZCcpO1xuXG4gIC8vIE9wdGlvbmFsIGVuY29kaW5nXG4gIGlmICh0eXBlb2YgZW5jICE9PSAnc3RyaW5nJykge1xuICAgIGFkZEVuYyA9IGFkZDtcbiAgICBhZGQgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuXG4gIC8vIE9wdGlvbmFsIGFkZGl0aW9uYWwgZGF0YVxuICBpZiAoYWRkKSB7XG4gICAgYWRkID0gdXRpbHNfMS50b0FycmF5KGFkZCwgYWRkRW5jIHx8ICdoZXgnKTtcbiAgICB0aGlzLl91cGRhdGUoYWRkKTtcbiAgfVxuXG4gIHZhciB0ZW1wID0gW107XG4gIHdoaWxlICh0ZW1wLmxlbmd0aCA8IGxlbikge1xuICAgIHRoaXMuViA9IHRoaXMuX2htYWMoKS51cGRhdGUodGhpcy5WKS5kaWdlc3QoKTtcbiAgICB0ZW1wID0gdGVtcC5jb25jYXQodGhpcy5WKTtcbiAgfVxuXG4gIHZhciByZXMgPSB0ZW1wLnNsaWNlKDAsIGxlbik7XG4gIHRoaXMuX3VwZGF0ZShhZGQpO1xuICB0aGlzLl9yZXNlZWQrKztcbiAgcmV0dXJuIHV0aWxzXzEuZW5jb2RlKHJlcywgZW5jKTtcbn07XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cbnZhciBhc3NlcnQkMyA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cbmZ1bmN0aW9uIEtleVBhaXIoZWMsIG9wdGlvbnMpIHtcbiAgdGhpcy5lYyA9IGVjO1xuICB0aGlzLnByaXYgPSBudWxsO1xuICB0aGlzLnB1YiA9IG51bGw7XG5cbiAgLy8gS2V5UGFpcihlYywgeyBwcml2OiAuLi4sIHB1YjogLi4uIH0pXG4gIGlmIChvcHRpb25zLnByaXYpXG4gICAgdGhpcy5faW1wb3J0UHJpdmF0ZShvcHRpb25zLnByaXYsIG9wdGlvbnMucHJpdkVuYyk7XG4gIGlmIChvcHRpb25zLnB1YilcbiAgICB0aGlzLl9pbXBvcnRQdWJsaWMob3B0aW9ucy5wdWIsIG9wdGlvbnMucHViRW5jKTtcbn1cbnZhciBrZXkgPSBLZXlQYWlyO1xuXG5LZXlQYWlyLmZyb21QdWJsaWMgPSBmdW5jdGlvbiBmcm9tUHVibGljKGVjLCBwdWIsIGVuYykge1xuICBpZiAocHViIGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHViO1xuXG4gIHJldHVybiBuZXcgS2V5UGFpcihlYywge1xuICAgIHB1YjogcHViLFxuICAgIHB1YkVuYzogZW5jLFxuICB9KTtcbn07XG5cbktleVBhaXIuZnJvbVByaXZhdGUgPSBmdW5jdGlvbiBmcm9tUHJpdmF0ZShlYywgcHJpdiwgZW5jKSB7XG4gIGlmIChwcml2IGluc3RhbmNlb2YgS2V5UGFpcilcbiAgICByZXR1cm4gcHJpdjtcblxuICByZXR1cm4gbmV3IEtleVBhaXIoZWMsIHtcbiAgICBwcml2OiBwcml2LFxuICAgIHByaXZFbmM6IGVuYyxcbiAgfSk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52YWxpZGF0ZSA9IGZ1bmN0aW9uIHZhbGlkYXRlKCkge1xuICB2YXIgcHViID0gdGhpcy5nZXRQdWJsaWMoKTtcblxuICBpZiAocHViLmlzSW5maW5pdHkoKSlcbiAgICByZXR1cm4geyByZXN1bHQ6IGZhbHNlLCByZWFzb246ICdJbnZhbGlkIHB1YmxpYyBrZXknIH07XG4gIGlmICghcHViLnZhbGlkYXRlKCkpXG4gICAgcmV0dXJuIHsgcmVzdWx0OiBmYWxzZSwgcmVhc29uOiAnUHVibGljIGtleSBpcyBub3QgYSBwb2ludCcgfTtcbiAgaWYgKCFwdWIubXVsKHRoaXMuZWMuY3VydmUubikuaXNJbmZpbml0eSgpKVxuICAgIHJldHVybiB7IHJlc3VsdDogZmFsc2UsIHJlYXNvbjogJ1B1YmxpYyBrZXkgKiBOICE9IE8nIH07XG5cbiAgcmV0dXJuIHsgcmVzdWx0OiB0cnVlLCByZWFzb246IG51bGwgfTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFB1YmxpYyA9IGZ1bmN0aW9uIGdldFB1YmxpYyhjb21wYWN0LCBlbmMpIHtcbiAgLy8gY29tcGFjdCBpcyBvcHRpb25hbCBhcmd1bWVudFxuICBpZiAodHlwZW9mIGNvbXBhY3QgPT09ICdzdHJpbmcnKSB7XG4gICAgZW5jID0gY29tcGFjdDtcbiAgICBjb21wYWN0ID0gbnVsbDtcbiAgfVxuXG4gIGlmICghdGhpcy5wdWIpXG4gICAgdGhpcy5wdWIgPSB0aGlzLmVjLmcubXVsKHRoaXMucHJpdik7XG5cbiAgaWYgKCFlbmMpXG4gICAgcmV0dXJuIHRoaXMucHViO1xuXG4gIHJldHVybiB0aGlzLnB1Yi5lbmNvZGUoZW5jLCBjb21wYWN0KTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmdldFByaXZhdGUgPSBmdW5jdGlvbiBnZXRQcml2YXRlKGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKTtcbiAgZWxzZVxuICAgIHJldHVybiB0aGlzLnByaXY7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS5faW1wb3J0UHJpdmF0ZSA9IGZ1bmN0aW9uIF9pbXBvcnRQcml2YXRlKGtleSwgZW5jKSB7XG4gIHRoaXMucHJpdiA9IG5ldyBCTihrZXksIGVuYyB8fCAxNik7XG5cbiAgLy8gRW5zdXJlIHRoYXQgdGhlIHByaXYgd29uJ3QgYmUgYmlnZ2VyIHRoYW4gbiwgb3RoZXJ3aXNlIHdlIG1heSBmYWlsXG4gIC8vIGluIGZpeGVkIG11bHRpcGxpY2F0aW9uIG1ldGhvZFxuICB0aGlzLnByaXYgPSB0aGlzLnByaXYudW1vZCh0aGlzLmVjLmN1cnZlLm4pO1xufTtcblxuS2V5UGFpci5wcm90b3R5cGUuX2ltcG9ydFB1YmxpYyA9IGZ1bmN0aW9uIF9pbXBvcnRQdWJsaWMoa2V5LCBlbmMpIHtcbiAgaWYgKGtleS54IHx8IGtleS55KSB7XG4gICAgLy8gTW9udGdvbWVyeSBwb2ludHMgb25seSBoYXZlIGFuIGB4YCBjb29yZGluYXRlLlxuICAgIC8vIFdlaWVyc3RyYXNzL0Vkd2FyZHMgcG9pbnRzIG9uIHRoZSBvdGhlciBoYW5kIGhhdmUgYm90aCBgeGAgYW5kXG4gICAgLy8gYHlgIGNvb3JkaW5hdGVzLlxuICAgIGlmICh0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdtb250Jykge1xuICAgICAgYXNzZXJ0JDMoa2V5LngsICdOZWVkIHggY29vcmRpbmF0ZScpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5lYy5jdXJ2ZS50eXBlID09PSAnc2hvcnQnIHx8XG4gICAgICAgICAgICAgICB0aGlzLmVjLmN1cnZlLnR5cGUgPT09ICdlZHdhcmRzJykge1xuICAgICAgYXNzZXJ0JDMoa2V5LnggJiYga2V5LnksICdOZWVkIGJvdGggeCBhbmQgeSBjb29yZGluYXRlJyk7XG4gICAgfVxuICAgIHRoaXMucHViID0gdGhpcy5lYy5jdXJ2ZS5wb2ludChrZXkueCwga2V5LnkpO1xuICAgIHJldHVybjtcbiAgfVxuICB0aGlzLnB1YiA9IHRoaXMuZWMuY3VydmUuZGVjb2RlUG9pbnQoa2V5LCBlbmMpO1xufTtcblxuLy8gRUNESFxuS2V5UGFpci5wcm90b3R5cGUuZGVyaXZlID0gZnVuY3Rpb24gZGVyaXZlKHB1Yikge1xuICBpZighcHViLnZhbGlkYXRlKCkpIHtcbiAgICBhc3NlcnQkMyhwdWIudmFsaWRhdGUoKSwgJ3B1YmxpYyBwb2ludCBub3QgdmFsaWRhdGVkJyk7XG4gIH1cbiAgcmV0dXJuIHB1Yi5tdWwodGhpcy5wcml2KS5nZXRYKCk7XG59O1xuXG4vLyBFQ0RTQVxuS2V5UGFpci5wcm90b3R5cGUuc2lnbiA9IGZ1bmN0aW9uIHNpZ24obXNnLCBlbmMsIG9wdGlvbnMpIHtcbiAgcmV0dXJuIHRoaXMuZWMuc2lnbihtc2csIHRoaXMsIGVuYywgb3B0aW9ucyk7XG59O1xuXG5LZXlQYWlyLnByb3RvdHlwZS52ZXJpZnkgPSBmdW5jdGlvbiB2ZXJpZnkobXNnLCBzaWduYXR1cmUpIHtcbiAgcmV0dXJuIHRoaXMuZWMudmVyaWZ5KG1zZywgc2lnbmF0dXJlLCB0aGlzKTtcbn07XG5cbktleVBhaXIucHJvdG90eXBlLmluc3BlY3QgPSBmdW5jdGlvbiBpbnNwZWN0KCkge1xuICByZXR1cm4gJzxLZXkgcHJpdjogJyArICh0aGlzLnByaXYgJiYgdGhpcy5wcml2LnRvU3RyaW5nKDE2LCAyKSkgK1xuICAgICAgICAgJyBwdWI6ICcgKyAodGhpcy5wdWIgJiYgdGhpcy5wdWIuaW5zcGVjdCgpKSArICcgPic7XG59O1xuXG4ndXNlIHN0cmljdCc7XG5cblxuXG5cbnZhciBhc3NlcnQkNCA9IHV0aWxzXzEkMS5hc3NlcnQ7XG5cbmZ1bmN0aW9uIFNpZ25hdHVyZShvcHRpb25zLCBlbmMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBTaWduYXR1cmUpXG4gICAgcmV0dXJuIG9wdGlvbnM7XG5cbiAgaWYgKHRoaXMuX2ltcG9ydERFUihvcHRpb25zLCBlbmMpKVxuICAgIHJldHVybjtcblxuICBhc3NlcnQkNChvcHRpb25zLnIgJiYgb3B0aW9ucy5zLCAnU2lnbmF0dXJlIHdpdGhvdXQgciBvciBzJyk7XG4gIHRoaXMuciA9IG5ldyBCTihvcHRpb25zLnIsIDE2KTtcbiAgdGhpcy5zID0gbmV3IEJOKG9wdGlvbnMucywgMTYpO1xuICBpZiAob3B0aW9ucy5yZWNvdmVyeVBhcmFtID09PSB1bmRlZmluZWQpXG4gICAgdGhpcy5yZWNvdmVyeVBhcmFtID0gbnVsbDtcbiAgZWxzZVxuICAgIHRoaXMucmVjb3ZlcnlQYXJhbSA9IG9wdGlvbnMucmVjb3ZlcnlQYXJhbTtcbn1cbnZhciBzaWduYXR1cmUgPSBTaWduYXR1cmU7XG5cbmZ1bmN0aW9uIFBvc2l0aW9uKCkge1xuICB0aGlzLnBsYWNlID0gMDtcbn1cblxuZnVuY3Rpb24gZ2V0TGVuZ3RoKGJ1ZiwgcCkge1xuICB2YXIgaW5pdGlhbCA9IGJ1ZltwLnBsYWNlKytdO1xuICBpZiAoIShpbml0aWFsICYgMHg4MCkpIHtcbiAgICByZXR1cm4gaW5pdGlhbDtcbiAgfVxuICB2YXIgb2N0ZXRMZW4gPSBpbml0aWFsICYgMHhmO1xuXG4gIC8vIEluZGVmaW5pdGUgbGVuZ3RoIG9yIG92ZXJmbG93XG4gIGlmIChvY3RldExlbiA9PT0gMCB8fCBvY3RldExlbiA+IDQpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICB2YXIgdmFsID0gMDtcbiAgZm9yICh2YXIgaSA9IDAsIG9mZiA9IHAucGxhY2U7IGkgPCBvY3RldExlbjsgaSsrLCBvZmYrKykge1xuICAgIHZhbCA8PD0gODtcbiAgICB2YWwgfD0gYnVmW29mZl07XG4gICAgdmFsID4+Pj0gMDtcbiAgfVxuXG4gIC8vIExlYWRpbmcgemVyb2VzXG4gIGlmICh2YWwgPD0gMHg3Zikge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHAucGxhY2UgPSBvZmY7XG4gIHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIHJtUGFkZGluZyhidWYpIHtcbiAgdmFyIGkgPSAwO1xuICB2YXIgbGVuID0gYnVmLmxlbmd0aCAtIDE7XG4gIHdoaWxlICghYnVmW2ldICYmICEoYnVmW2kgKyAxXSAmIDB4ODApICYmIGkgPCBsZW4pIHtcbiAgICBpKys7XG4gIH1cbiAgaWYgKGkgPT09IDApIHtcbiAgICByZXR1cm4gYnVmO1xuICB9XG4gIHJldHVybiBidWYuc2xpY2UoaSk7XG59XG5cblNpZ25hdHVyZS5wcm90b3R5cGUuX2ltcG9ydERFUiA9IGZ1bmN0aW9uIF9pbXBvcnRERVIoZGF0YSwgZW5jKSB7XG4gIGRhdGEgPSB1dGlsc18xJDEudG9BcnJheShkYXRhLCBlbmMpO1xuICB2YXIgcCA9IG5ldyBQb3NpdGlvbigpO1xuICBpZiAoZGF0YVtwLnBsYWNlKytdICE9PSAweDMwKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmIChsZW4gPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICgobGVuICsgcC5wbGFjZSkgIT09IGRhdGEubGVuZ3RoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHJsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmIChybGVuID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICB2YXIgciA9IGRhdGEuc2xpY2UocC5wbGFjZSwgcmxlbiArIHAucGxhY2UpO1xuICBwLnBsYWNlICs9IHJsZW47XG4gIGlmIChkYXRhW3AucGxhY2UrK10gIT09IDB4MDIpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgdmFyIHNsZW4gPSBnZXRMZW5ndGgoZGF0YSwgcCk7XG4gIGlmIChzbGVuID09PSBmYWxzZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZGF0YS5sZW5ndGggIT09IHNsZW4gKyBwLnBsYWNlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBzID0gZGF0YS5zbGljZShwLnBsYWNlLCBzbGVuICsgcC5wbGFjZSk7XG4gIGlmIChyWzBdID09PSAwKSB7XG4gICAgaWYgKHJbMV0gJiAweDgwKSB7XG4gICAgICByID0gci5zbGljZSgxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gTGVhZGluZyB6ZXJvZXNcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgaWYgKHNbMF0gPT09IDApIHtcbiAgICBpZiAoc1sxXSAmIDB4ODApIHtcbiAgICAgIHMgPSBzLnNsaWNlKDEpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBMZWFkaW5nIHplcm9lc1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIHRoaXMuciA9IG5ldyBCTihyKTtcbiAgdGhpcy5zID0gbmV3IEJOKHMpO1xuICB0aGlzLnJlY292ZXJ5UGFyYW0gPSBudWxsO1xuXG4gIHJldHVybiB0cnVlO1xufTtcblxuZnVuY3Rpb24gY29uc3RydWN0TGVuZ3RoKGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPCAweDgwKSB7XG4gICAgYXJyLnB1c2gobGVuKTtcbiAgICByZXR1cm47XG4gIH1cbiAgdmFyIG9jdGV0cyA9IDEgKyAoTWF0aC5sb2cobGVuKSAvIE1hdGguTE4yID4+PiAzKTtcbiAgYXJyLnB1c2gob2N0ZXRzIHwgMHg4MCk7XG4gIHdoaWxlICgtLW9jdGV0cykge1xuICAgIGFyci5wdXNoKChsZW4gPj4+IChvY3RldHMgPDwgMykpICYgMHhmZik7XG4gIH1cbiAgYXJyLnB1c2gobGVuKTtcbn1cblxuU2lnbmF0dXJlLnByb3RvdHlwZS50b0RFUiA9IGZ1bmN0aW9uIHRvREVSKGVuYykge1xuICB2YXIgciA9IHRoaXMuci50b0FycmF5KCk7XG4gIHZhciBzID0gdGhpcy5zLnRvQXJyYXkoKTtcblxuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChyWzBdICYgMHg4MClcbiAgICByID0gWyAwIF0uY29uY2F0KHIpO1xuICAvLyBQYWQgdmFsdWVzXG4gIGlmIChzWzBdICYgMHg4MClcbiAgICBzID0gWyAwIF0uY29uY2F0KHMpO1xuXG4gIHIgPSBybVBhZGRpbmcocik7XG4gIHMgPSBybVBhZGRpbmcocyk7XG5cbiAgd2hpbGUgKCFzWzBdICYmICEoc1sxXSAmIDB4ODApKSB7XG4gICAgcyA9IHMuc2xpY2UoMSk7XG4gIH1cbiAgdmFyIGFyciA9IFsgMHgwMiBdO1xuICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCByLmxlbmd0aCk7XG4gIGFyciA9IGFyci5jb25jYXQocik7XG4gIGFyci5wdXNoKDB4MDIpO1xuICBjb25zdHJ1Y3RMZW5ndGgoYXJyLCBzLmxlbmd0aCk7XG4gIHZhciBiYWNrSGFsZiA9IGFyci5jb25jYXQocyk7XG4gIHZhciByZXMgPSBbIDB4MzAgXTtcbiAgY29uc3RydWN0TGVuZ3RoKHJlcywgYmFja0hhbGYubGVuZ3RoKTtcbiAgcmVzID0gcmVzLmNvbmNhdChiYWNrSGFsZik7XG4gIHJldHVybiB1dGlsc18xJDEuZW5jb2RlKHJlcywgZW5jKTtcbn07XG5cbid1c2Ugc3RyaWN0JztcblxuXG5cblxuXG52YXIgcmFuZCA9IC8qUmljTW9vOmV0aGVyczpyZXF1aXJlKGJyb3JhbmQpKi8oZnVuY3Rpb24oKSB7IHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQnKTsgfSk7XG52YXIgYXNzZXJ0JDUgPSB1dGlsc18xJDEuYXNzZXJ0O1xuXG5cblxuXG5mdW5jdGlvbiBFQyhvcHRpb25zKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBFQykpXG4gICAgcmV0dXJuIG5ldyBFQyhvcHRpb25zKTtcblxuICAvLyBTaG9ydGN1dCBgZWxsaXB0aWMuZWMoY3VydmUtbmFtZSlgXG4gIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ3N0cmluZycpIHtcbiAgICBhc3NlcnQkNShPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoY3VydmVzXzEsIG9wdGlvbnMpLFxuICAgICAgJ1Vua25vd24gY3VydmUgJyArIG9wdGlvbnMpO1xuXG4gICAgb3B0aW9ucyA9IGN1cnZlc18xW29wdGlvbnNdO1xuICB9XG5cbiAgLy8gU2hvcnRjdXQgZm9yIGBlbGxpcHRpYy5lYyhlbGxpcHRpYy5jdXJ2ZXMuY3VydmVOYW1lKWBcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBjdXJ2ZXNfMS5QcmVzZXRDdXJ2ZSlcbiAgICBvcHRpb25zID0geyBjdXJ2ZTogb3B0aW9ucyB9O1xuXG4gIHRoaXMuY3VydmUgPSBvcHRpb25zLmN1cnZlLmN1cnZlO1xuICB0aGlzLm4gPSB0aGlzLmN1cnZlLm47XG4gIHRoaXMubmggPSB0aGlzLm4udXNocm4oMSk7XG4gIHRoaXMuZyA9IHRoaXMuY3VydmUuZztcblxuICAvLyBQb2ludCBvbiBjdXJ2ZVxuICB0aGlzLmcgPSBvcHRpb25zLmN1cnZlLmc7XG4gIHRoaXMuZy5wcmVjb21wdXRlKG9wdGlvbnMuY3VydmUubi5iaXRMZW5ndGgoKSArIDEpO1xuXG4gIC8vIEhhc2ggZm9yIGZ1bmN0aW9uIGZvciBEUkJHXG4gIHRoaXMuaGFzaCA9IG9wdGlvbnMuaGFzaCB8fCBvcHRpb25zLmN1cnZlLmhhc2g7XG59XG52YXIgZWMgPSBFQztcblxuRUMucHJvdG90eXBlLmtleVBhaXIgPSBmdW5jdGlvbiBrZXlQYWlyKG9wdGlvbnMpIHtcbiAgcmV0dXJuIG5ldyBrZXkodGhpcywgb3B0aW9ucyk7XG59O1xuXG5FQy5wcm90b3R5cGUua2V5RnJvbVByaXZhdGUgPSBmdW5jdGlvbiBrZXlGcm9tUHJpdmF0ZShwcml2LCBlbmMpIHtcbiAgcmV0dXJuIGtleS5mcm9tUHJpdmF0ZSh0aGlzLCBwcml2LCBlbmMpO1xufTtcblxuRUMucHJvdG90eXBlLmtleUZyb21QdWJsaWMgPSBmdW5jdGlvbiBrZXlGcm9tUHVibGljKHB1YiwgZW5jKSB7XG4gIHJldHVybiBrZXkuZnJvbVB1YmxpYyh0aGlzLCBwdWIsIGVuYyk7XG59O1xuXG5FQy5wcm90b3R5cGUuZ2VuS2V5UGFpciA9IGZ1bmN0aW9uIGdlbktleVBhaXIob3B0aW9ucykge1xuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIC8vIEluc3RhbnRpYXRlIEhtYWNfRFJCR1xuICB2YXIgZHJiZyA9IG5ldyBobWFjRHJiZyh7XG4gICAgaGFzaDogdGhpcy5oYXNoLFxuICAgIHBlcnM6IG9wdGlvbnMucGVycyxcbiAgICBwZXJzRW5jOiBvcHRpb25zLnBlcnNFbmMgfHwgJ3V0ZjgnLFxuICAgIGVudHJvcHk6IG9wdGlvbnMuZW50cm9weSB8fCByYW5kKHRoaXMuaGFzaC5obWFjU3RyZW5ndGgpLFxuICAgIGVudHJvcHlFbmM6IG9wdGlvbnMuZW50cm9weSAmJiBvcHRpb25zLmVudHJvcHlFbmMgfHwgJ3V0ZjgnLFxuICAgIG5vbmNlOiB0aGlzLm4udG9BcnJheSgpLFxuICB9KTtcblxuICB2YXIgYnl0ZXMgPSB0aGlzLm4uYnl0ZUxlbmd0aCgpO1xuICB2YXIgbnMyID0gdGhpcy5uLnN1YihuZXcgQk4oMikpO1xuICBmb3IgKDs7KSB7XG4gICAgdmFyIHByaXYgPSBuZXcgQk4oZHJiZy5nZW5lcmF0ZShieXRlcykpO1xuICAgIGlmIChwcml2LmNtcChuczIpID4gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgcHJpdi5pYWRkbigxKTtcbiAgICByZXR1cm4gdGhpcy5rZXlGcm9tUHJpdmF0ZShwcml2KTtcbiAgfVxufTtcblxuRUMucHJvdG90eXBlLl90cnVuY2F0ZVRvTiA9IGZ1bmN0aW9uIF90cnVuY2F0ZVRvTihtc2csIHRydW5jT25seSkge1xuICB2YXIgZGVsdGEgPSBtc2cuYnl0ZUxlbmd0aCgpICogOCAtIHRoaXMubi5iaXRMZW5ndGgoKTtcbiAgaWYgKGRlbHRhID4gMClcbiAgICBtc2cgPSBtc2cudXNocm4oZGVsdGEpO1xuICBpZiAoIXRydW5jT25seSAmJiBtc2cuY21wKHRoaXMubikgPj0gMClcbiAgICByZXR1cm4gbXNnLnN1Yih0aGlzLm4pO1xuICBlbHNlXG4gICAgcmV0dXJuIG1zZztcbn07XG5cbkVDLnByb3RvdHlwZS5zaWduID0gZnVuY3Rpb24gc2lnbihtc2csIGtleSwgZW5jLCBvcHRpb25zKSB7XG4gIGlmICh0eXBlb2YgZW5jID09PSAnb2JqZWN0Jykge1xuICAgIG9wdGlvbnMgPSBlbmM7XG4gICAgZW5jID0gbnVsbDtcbiAgfVxuICBpZiAoIW9wdGlvbnMpXG4gICAgb3B0aW9ucyA9IHt9O1xuXG4gIGtleSA9IHRoaXMua2V5RnJvbVByaXZhdGUoa2V5LCBlbmMpO1xuICBtc2cgPSB0aGlzLl90cnVuY2F0ZVRvTihuZXcgQk4obXNnLCAxNikpO1xuXG4gIC8vIFplcm8tZXh0ZW5kIGtleSB0byBwcm92aWRlIGVub3VnaCBlbnRyb3B5XG4gIHZhciBieXRlcyA9IHRoaXMubi5ieXRlTGVuZ3RoKCk7XG4gIHZhciBia2V5ID0ga2V5LmdldFByaXZhdGUoKS50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBaZXJvLWV4dGVuZCBub25jZSB0byBoYXZlIHRoZSBzYW1lIGJ5dGUgc2l6ZSBhcyBOXG4gIHZhciBub25jZSA9IG1zZy50b0FycmF5KCdiZScsIGJ5dGVzKTtcblxuICAvLyBJbnN0YW50aWF0ZSBIbWFjX0RSQkdcbiAgdmFyIGRyYmcgPSBuZXcgaG1hY0RyYmcoe1xuICAgIGhhc2g6IHRoaXMuaGFzaCxcbiAgICBlbnRyb3B5OiBia2V5LFxuICAgIG5vbmNlOiBub25jZSxcbiAgICBwZXJzOiBvcHRpb25zLnBlcnMsXG4gICAgcGVyc0VuYzogb3B0aW9ucy5wZXJzRW5jIHx8ICd1dGY4JyxcbiAgfSk7XG5cbiAgLy8gTnVtYmVyIG9mIGJ5dGVzIHRvIGdlbmVyYXRlXG4gIHZhciBuczEgPSB0aGlzLm4uc3ViKG5ldyBCTigxKSk7XG5cbiAgZm9yICh2YXIgaXRlciA9IDA7IDsgaXRlcisrKSB7XG4gICAgdmFyIGsgPSBvcHRpb25zLmsgP1xuICAgICAgb3B0aW9ucy5rKGl0ZXIpIDpcbiAgICAgIG5ldyBCTihkcmJnLmdlbmVyYXRlKHRoaXMubi5ieXRlTGVuZ3RoKCkpKTtcbiAgICBrID0gdGhpcy5fdHJ1bmNhdGVUb04oaywgdHJ1ZSk7XG4gICAgaWYgKGsuY21wbigxKSA8PSAwIHx8IGsuY21wKG5zMSkgPj0gMClcbiAgICAgIGNvbnRpbnVlO1xuXG4gICAgdmFyIGtwID0gdGhpcy5nLm11bChrKTtcbiAgICBpZiAoa3AuaXNJbmZpbml0eSgpKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIga3BYID0ga3AuZ2V0WCgpO1xuICAgIHZhciByID0ga3BYLnVtb2QodGhpcy5uKTtcbiAgICBpZiAoci5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcyA9IGsuaW52bSh0aGlzLm4pLm11bChyLm11bChrZXkuZ2V0UHJpdmF0ZSgpKS5pYWRkKG1zZykpO1xuICAgIHMgPSBzLnVtb2QodGhpcy5uKTtcbiAgICBpZiAocy5jbXBuKDApID09PSAwKVxuICAgICAgY29udGludWU7XG5cbiAgICB2YXIgcmVjb3ZlcnlQYXJhbSA9IChrcC5nZXRZKCkuaXNPZGQoKSA/IDEgOiAwKSB8XG4gICAgICAgICAgICAgICAgICAgICAgICAoa3BYLmNtcChyKSAhPT0gMCA/IDIgOiAwKTtcblxuICAgIC8vIFVzZSBjb21wbGVtZW50IG9mIGBzYCwgaWYgaXQgaXMgPiBgbiAvIDJgXG4gICAgaWYgKG9wdGlvbnMuY2Fub25pY2FsICYmIHMuY21wKHRoaXMubmgpID4gMCkge1xuICAgICAgcyA9IHRoaXMubi5zdWIocyk7XG4gICAgICByZWNvdmVyeVBhcmFtIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ldyBzaWduYXR1cmUoeyByOiByLCBzOiBzLCByZWNvdmVyeVBhcmFtOiByZWNvdmVyeVBhcmFtIH0pO1xuICB9XG59O1xuXG5FQy5wcm90b3R5cGUudmVyaWZ5ID0gZnVuY3Rpb24gdmVyaWZ5KG1zZywgc2lnbmF0dXJlJDEsIGtleSwgZW5jKSB7XG4gIG1zZyA9IHRoaXMuX3RydW5jYXRlVG9OKG5ldyBCTihtc2csIDE2KSk7XG4gIGtleSA9IHRoaXMua2V5RnJvbVB1YmxpYyhrZXksIGVuYyk7XG4gIHNpZ25hdHVyZSQxID0gbmV3IHNpZ25hdHVyZShzaWduYXR1cmUkMSwgJ2hleCcpO1xuXG4gIC8vIFBlcmZvcm0gcHJpbWl0aXZlIHZhbHVlcyB2YWxpZGF0aW9uXG4gIHZhciByID0gc2lnbmF0dXJlJDEucjtcbiAgdmFyIHMgPSBzaWduYXR1cmUkMS5zO1xuICBpZiAoci5jbXBuKDEpIDwgMCB8fCByLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAocy5jbXBuKDEpIDwgMCB8fCBzLmNtcCh0aGlzLm4pID49IDApXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIFZhbGlkYXRlIHNpZ25hdHVyZVxuICB2YXIgc2ludiA9IHMuaW52bSh0aGlzLm4pO1xuICB2YXIgdTEgPSBzaW52Lm11bChtc2cpLnVtb2QodGhpcy5uKTtcbiAgdmFyIHUyID0gc2ludi5tdWwocikudW1vZCh0aGlzLm4pO1xuICB2YXIgcDtcblxuICBpZiAoIXRoaXMuY3VydmUuX21heHdlbGxUcmljaykge1xuICAgIHAgPSB0aGlzLmcubXVsQWRkKHUxLCBrZXkuZ2V0UHVibGljKCksIHUyKTtcbiAgICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgICByZXR1cm4gZmFsc2U7XG5cbiAgICByZXR1cm4gcC5nZXRYKCkudW1vZCh0aGlzLm4pLmNtcChyKSA9PT0gMDtcbiAgfVxuXG4gIC8vIE5PVEU6IEdyZWcgTWF4d2VsbCdzIHRyaWNrLCBpbnNwaXJlZCBieTpcbiAgLy8gaHR0cHM6Ly9naXQuaW8vdmFkM0tcblxuICBwID0gdGhpcy5nLmptdWxBZGQodTEsIGtleS5nZXRQdWJsaWMoKSwgdTIpO1xuICBpZiAocC5pc0luZmluaXR5KCkpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIENvbXBhcmUgYHAueGAgb2YgSmFjb2JpYW4gcG9pbnQgd2l0aCBgcmAsXG4gIC8vIHRoaXMgd2lsbCBkbyBgcC54ID09IHIgKiBwLnpeMmAgaW5zdGVhZCBvZiBtdWx0aXBseWluZyBgcC54YCBieSB0aGVcbiAgLy8gaW52ZXJzZSBvZiBgcC56XjJgXG4gIHJldHVybiBwLmVxWFRvUChyKTtcbn07XG5cbkVDLnByb3RvdHlwZS5yZWNvdmVyUHViS2V5ID0gZnVuY3Rpb24obXNnLCBzaWduYXR1cmUkMSwgaiwgZW5jKSB7XG4gIGFzc2VydCQ1KCgzICYgaikgPT09IGosICdUaGUgcmVjb3ZlcnkgcGFyYW0gaXMgbW9yZSB0aGFuIHR3byBiaXRzJyk7XG4gIHNpZ25hdHVyZSQxID0gbmV3IHNpZ25hdHVyZShzaWduYXR1cmUkMSwgZW5jKTtcblxuICB2YXIgbiA9IHRoaXMubjtcbiAgdmFyIGUgPSBuZXcgQk4obXNnKTtcbiAgdmFyIHIgPSBzaWduYXR1cmUkMS5yO1xuICB2YXIgcyA9IHNpZ25hdHVyZSQxLnM7XG5cbiAgLy8gQSBzZXQgTFNCIHNpZ25pZmllcyB0aGF0IHRoZSB5LWNvb3JkaW5hdGUgaXMgb2RkXG4gIHZhciBpc1lPZGQgPSBqICYgMTtcbiAgdmFyIGlzU2Vjb25kS2V5ID0gaiA+PiAxO1xuICBpZiAoci5jbXAodGhpcy5jdXJ2ZS5wLnVtb2QodGhpcy5jdXJ2ZS5uKSkgPj0gMCAmJiBpc1NlY29uZEtleSlcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIHNlbmNvbmQga2V5IGNhbmRpbmF0ZScpO1xuXG4gIC8vIDEuMS4gTGV0IHggPSByICsgam4uXG4gIGlmIChpc1NlY29uZEtleSlcbiAgICByID0gdGhpcy5jdXJ2ZS5wb2ludEZyb21YKHIuYWRkKHRoaXMuY3VydmUubiksIGlzWU9kZCk7XG4gIGVsc2VcbiAgICByID0gdGhpcy5jdXJ2ZS5wb2ludEZyb21YKHIsIGlzWU9kZCk7XG5cbiAgdmFyIHJJbnYgPSBzaWduYXR1cmUkMS5yLmludm0obik7XG4gIHZhciBzMSA9IG4uc3ViKGUpLm11bChySW52KS51bW9kKG4pO1xuICB2YXIgczIgPSBzLm11bChySW52KS51bW9kKG4pO1xuXG4gIC8vIDEuNi4xIENvbXB1dGUgUSA9IHJeLTEgKHNSIC0gIGVHKVxuICAvLyAgICAgICAgICAgICAgIFEgPSByXi0xIChzUiArIC1lRylcbiAgcmV0dXJuIHRoaXMuZy5tdWxBZGQoczEsIHIsIHMyKTtcbn07XG5cbkVDLnByb3RvdHlwZS5nZXRLZXlSZWNvdmVyeVBhcmFtID0gZnVuY3Rpb24oZSwgc2lnbmF0dXJlJDEsIFEsIGVuYykge1xuICBzaWduYXR1cmUkMSA9IG5ldyBzaWduYXR1cmUoc2lnbmF0dXJlJDEsIGVuYyk7XG4gIGlmIChzaWduYXR1cmUkMS5yZWNvdmVyeVBhcmFtICE9PSBudWxsKVxuICAgIHJldHVybiBzaWduYXR1cmUkMS5yZWNvdmVyeVBhcmFtO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgdmFyIFFwcmltZTtcbiAgICB0cnkge1xuICAgICAgUXByaW1lID0gdGhpcy5yZWNvdmVyUHViS2V5KGUsIHNpZ25hdHVyZSQxLCBpKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICBpZiAoUXByaW1lLmVxKFEpKVxuICAgICAgcmV0dXJuIGk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCB2YWxpZCByZWNvdmVyeSBmYWN0b3InKTtcbn07XG5cbnZhciBlbGxpcHRpY18xID0gY3JlYXRlQ29tbW9uanNNb2R1bGUoZnVuY3Rpb24gKG1vZHVsZSwgZXhwb3J0cykge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZWxsaXB0aWMgPSBleHBvcnRzO1xuXG5lbGxpcHRpYy52ZXJzaW9uID0gLypSaWNNb286ZXRoZXJzKi97IHZlcnNpb246IFwiNi41LjRcIiB9LnZlcnNpb247XG5lbGxpcHRpYy51dGlscyA9IHV0aWxzXzEkMTtcbmVsbGlwdGljLnJhbmQgPSAvKlJpY01vbzpldGhlcnM6cmVxdWlyZShicm9yYW5kKSovKGZ1bmN0aW9uKCkgeyB0aHJvdyBuZXcgRXJyb3IoJ3Vuc3VwcG9ydGVkJyk7IH0pO1xuZWxsaXB0aWMuY3VydmUgPSBjdXJ2ZV8xO1xuZWxsaXB0aWMuY3VydmVzID0gY3VydmVzXzE7XG5cbi8vIFByb3RvY29sc1xuZWxsaXB0aWMuZWMgPSBlYztcbmVsbGlwdGljLmVkZHNhID0gLypSaWNNb286ZXRoZXJzOnJlcXVpcmUoLi9lbGxpcHRpYy9lZGRzYSkqLyhudWxsKTtcbn0pO1xuXG52YXIgRUMkMSA9IGVsbGlwdGljXzEuZWM7XG5cbmV4cG9ydCB7IEVDJDEgYXMgRUMgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWVsbGlwdGljLmpzLm1hcFxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBFQyB9IGZyb20gXCIuL2VsbGlwdGljXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4bGlmeSwgaGV4WmVyb1BhZCwgc3BsaXRTaWduYXR1cmUgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3Byb3BlcnRpZXNcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmxldCBfY3VydmUgPSBudWxsO1xuZnVuY3Rpb24gZ2V0Q3VydmUoKSB7XG4gICAgaWYgKCFfY3VydmUpIHtcbiAgICAgICAgX2N1cnZlID0gbmV3IEVDKFwic2VjcDI1NmsxXCIpO1xuICAgIH1cbiAgICByZXR1cm4gX2N1cnZlO1xufVxuZXhwb3J0IGNsYXNzIFNpZ25pbmdLZXkge1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXkpIHtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjdXJ2ZVwiLCBcInNlY3AyNTZrMVwiKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcml2YXRlS2V5XCIsIGhleGxpZnkocHJpdmF0ZUtleSkpO1xuICAgICAgICBjb25zdCBrZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShhcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwdWJsaWNLZXlcIiwgXCIweFwiICsga2V5UGFpci5nZXRQdWJsaWMoZmFsc2UsIFwiaGV4XCIpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJjb21wcmVzc2VkUHVibGljS2V5XCIsIFwiMHhcIiArIGtleVBhaXIuZ2V0UHVibGljKHRydWUsIFwiaGV4XCIpKTtcbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfaXNTaWduaW5nS2V5XCIsIHRydWUpO1xuICAgIH1cbiAgICBfYWRkUG9pbnQob3RoZXIpIHtcbiAgICAgICAgY29uc3QgcDAgPSBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYXJyYXlpZnkodGhpcy5wdWJsaWNLZXkpKTtcbiAgICAgICAgY29uc3QgcDEgPSBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYXJyYXlpZnkob3RoZXIpKTtcbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIHAwLnB1Yi5hZGQocDEucHViKS5lbmNvZGVDb21wcmVzc2VkKFwiaGV4XCIpO1xuICAgIH1cbiAgICBzaWduRGlnZXN0KGRpZ2VzdCkge1xuICAgICAgICBjb25zdCBrZXlQYWlyID0gZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShhcnJheWlmeSh0aGlzLnByaXZhdGVLZXkpKTtcbiAgICAgICAgY29uc3QgZGlnZXN0Qnl0ZXMgPSBhcnJheWlmeShkaWdlc3QpO1xuICAgICAgICBpZiAoZGlnZXN0Qnl0ZXMubGVuZ3RoICE9PSAzMikge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImJhZCBkaWdlc3QgbGVuZ3RoXCIsIFwiZGlnZXN0XCIsIGRpZ2VzdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2lnbmF0dXJlID0ga2V5UGFpci5zaWduKGRpZ2VzdEJ5dGVzLCB7IGNhbm9uaWNhbDogdHJ1ZSB9KTtcbiAgICAgICAgcmV0dXJuIHNwbGl0U2lnbmF0dXJlKHtcbiAgICAgICAgICAgIHJlY292ZXJ5UGFyYW06IHNpZ25hdHVyZS5yZWNvdmVyeVBhcmFtLFxuICAgICAgICAgICAgcjogaGV4WmVyb1BhZChcIjB4XCIgKyBzaWduYXR1cmUuci50b1N0cmluZygxNiksIDMyKSxcbiAgICAgICAgICAgIHM6IGhleFplcm9QYWQoXCIweFwiICsgc2lnbmF0dXJlLnMudG9TdHJpbmcoMTYpLCAzMiksXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjb21wdXRlU2hhcmVkU2VjcmV0KG90aGVyS2V5KSB7XG4gICAgICAgIGNvbnN0IGtleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21Qcml2YXRlKGFycmF5aWZ5KHRoaXMucHJpdmF0ZUtleSkpO1xuICAgICAgICBjb25zdCBvdGhlcktleVBhaXIgPSBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYXJyYXlpZnkoY29tcHV0ZVB1YmxpY0tleShvdGhlcktleSkpKTtcbiAgICAgICAgcmV0dXJuIGhleFplcm9QYWQoXCIweFwiICsga2V5UGFpci5kZXJpdmUob3RoZXJLZXlQYWlyLmdldFB1YmxpYygpKS50b1N0cmluZygxNiksIDMyKTtcbiAgICB9XG4gICAgc3RhdGljIGlzU2lnbmluZ0tleSh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gISEodmFsdWUgJiYgdmFsdWUuX2lzU2lnbmluZ0tleSk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJQdWJsaWNLZXkoZGlnZXN0LCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBzaWcgPSBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgIGNvbnN0IHJzID0geyByOiBhcnJheWlmeShzaWcuciksIHM6IGFycmF5aWZ5KHNpZy5zKSB9O1xuICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLnJlY292ZXJQdWJLZXkoYXJyYXlpZnkoZGlnZXN0KSwgcnMsIHNpZy5yZWNvdmVyeVBhcmFtKS5lbmNvZGUoXCJoZXhcIiwgZmFsc2UpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVQdWJsaWNLZXkoa2V5LCBjb21wcmVzc2VkKSB7XG4gICAgY29uc3QgYnl0ZXMgPSBhcnJheWlmeShrZXkpO1xuICAgIGlmIChieXRlcy5sZW5ndGggPT09IDMyKSB7XG4gICAgICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBuZXcgU2lnbmluZ0tleShieXRlcyk7XG4gICAgICAgIGlmIChjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gXCIweFwiICsgZ2V0Q3VydmUoKS5rZXlGcm9tUHJpdmF0ZShieXRlcykuZ2V0UHVibGljKHRydWUsIFwiaGV4XCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaWduaW5nS2V5LnB1YmxpY0tleTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnl0ZXMubGVuZ3RoID09PSAzMykge1xuICAgICAgICBpZiAoY29tcHJlc3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGhleGxpZnkoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBcIjB4XCIgKyBnZXRDdXJ2ZSgpLmtleUZyb21QdWJsaWMoYnl0ZXMpLmdldFB1YmxpYyhmYWxzZSwgXCJoZXhcIik7XG4gICAgfVxuICAgIGVsc2UgaWYgKGJ5dGVzLmxlbmd0aCA9PT0gNjUpIHtcbiAgICAgICAgaWYgKCFjb21wcmVzc2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gaGV4bGlmeShieXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFwiMHhcIiArIGdldEN1cnZlKCkua2V5RnJvbVB1YmxpYyhieXRlcykuZ2V0UHVibGljKHRydWUsIFwiaGV4XCIpO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcHVibGljIG9yIHByaXZhdGUga2V5XCIsIFwia2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJzb2xpZGl0eS81LjUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgY29uY2F0LCBoZXhsaWZ5LCB6ZXJvUGFkIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgYXMgaGFzaEtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IHNoYTI1NiBhcyBoYXNoU2hhMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3NoYTJcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmNvbnN0IHJlZ2V4Qnl0ZXMgPSBuZXcgUmVnRXhwKFwiXmJ5dGVzKFswLTldKykkXCIpO1xuY29uc3QgcmVnZXhOdW1iZXIgPSBuZXcgUmVnRXhwKFwiXih1P2ludCkoWzAtOV0qKSRcIik7XG5jb25zdCByZWdleEFycmF5ID0gbmV3IFJlZ0V4cChcIl4oLiopXFxcXFsoWzAtOV0qKVxcXFxdJFwiKTtcbmNvbnN0IFplcm9zID0gXCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG5mdW5jdGlvbiBfcGFjayh0eXBlLCB2YWx1ZSwgaXNBcnJheSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiYWRkcmVzc1wiOlxuICAgICAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gemVyb1BhZCh2YWx1ZSwgMzIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFycmF5aWZ5KHZhbHVlKTtcbiAgICAgICAgY2FzZSBcInN0cmluZ1wiOlxuICAgICAgICAgICAgcmV0dXJuIHRvVXRmOEJ5dGVzKHZhbHVlKTtcbiAgICAgICAgY2FzZSBcImJ5dGVzXCI6XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlpZnkodmFsdWUpO1xuICAgICAgICBjYXNlIFwiYm9vbFwiOlxuICAgICAgICAgICAgdmFsdWUgPSAodmFsdWUgPyBcIjB4MDFcIiA6IFwiMHgwMFwiKTtcbiAgICAgICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHplcm9QYWQodmFsdWUsIDMyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBhcnJheWlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIGxldCBtYXRjaCA9IHR5cGUubWF0Y2gocmVnZXhOdW1iZXIpO1xuICAgIGlmIChtYXRjaCkge1xuICAgICAgICAvL2xldCBzaWduZWQgPSAobWF0Y2hbMV0gPT09IFwiaW50XCIpXG4gICAgICAgIGxldCBzaXplID0gcGFyc2VJbnQobWF0Y2hbMl0gfHwgXCIyNTZcIik7XG4gICAgICAgIGlmICgobWF0Y2hbMl0gJiYgU3RyaW5nKHNpemUpICE9PSBtYXRjaFsyXSkgfHwgKHNpemUgJSA4ICE9PSAwKSB8fCBzaXplID09PSAwIHx8IHNpemUgPiAyNTYpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIG51bWJlciB0eXBlXCIsIFwidHlwZVwiLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgc2l6ZSA9IDI1NjtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IEJpZ051bWJlci5mcm9tKHZhbHVlKS50b1R3b3Moc2l6ZSk7XG4gICAgICAgIHJldHVybiB6ZXJvUGFkKHZhbHVlLCBzaXplIC8gOCk7XG4gICAgfVxuICAgIG1hdGNoID0gdHlwZS5tYXRjaChyZWdleEJ5dGVzKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgY29uc3Qgc2l6ZSA9IHBhcnNlSW50KG1hdGNoWzFdKTtcbiAgICAgICAgaWYgKFN0cmluZyhzaXplKSAhPT0gbWF0Y2hbMV0gfHwgc2l6ZSA9PT0gMCB8fCBzaXplID4gMzIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGJ5dGVzIHR5cGVcIiwgXCJ0eXBlXCIsIHR5cGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcnJheWlmeSh2YWx1ZSkuYnl0ZUxlbmd0aCAhPT0gc2l6ZSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCB2YWx1ZSBmb3IgJHt0eXBlfWAsIFwidmFsdWVcIiwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc0FycmF5KSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXlpZnkoKHZhbHVlICsgWmVyb3MpLnN1YnN0cmluZygwLCA2NikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbWF0Y2ggPSB0eXBlLm1hdGNoKHJlZ2V4QXJyYXkpO1xuICAgIGlmIChtYXRjaCAmJiBBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICBjb25zdCBiYXNlVHlwZSA9IG1hdGNoWzFdO1xuICAgICAgICBjb25zdCBjb3VudCA9IHBhcnNlSW50KG1hdGNoWzJdIHx8IFN0cmluZyh2YWx1ZS5sZW5ndGgpKTtcbiAgICAgICAgaWYgKGNvdW50ICE9IHZhbHVlLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihgaW52YWxpZCBhcnJheSBsZW5ndGggZm9yICR7dHlwZX1gLCBcInZhbHVlXCIsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICAgICAgdmFsdWUuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKF9wYWNrKGJhc2VUeXBlLCB2YWx1ZSwgdHJ1ZSkpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNvbmNhdChyZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdHlwZVwiLCBcInR5cGVcIiwgdHlwZSk7XG59XG4vLyBAVE9ETzogQXJyYXkgRW51bVxuZXhwb3J0IGZ1bmN0aW9uIHBhY2sodHlwZXMsIHZhbHVlcykge1xuICAgIGlmICh0eXBlcy5sZW5ndGggIT0gdmFsdWVzLmxlbmd0aCkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwid3JvbmcgbnVtYmVyIG9mIHZhbHVlczsgZXhwZWN0ZWQgJHsgdHlwZXMubGVuZ3RoIH1cIiwgXCJ2YWx1ZXNcIiwgdmFsdWVzKTtcbiAgICB9XG4gICAgY29uc3QgdGlnaHQgPSBbXTtcbiAgICB0eXBlcy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlLCBpbmRleCkge1xuICAgICAgICB0aWdodC5wdXNoKF9wYWNrKHR5cGUsIHZhbHVlc1tpbmRleF0pKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaGV4bGlmeShjb25jYXQodGlnaHQpKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBrZWNjYWsyNTYodHlwZXMsIHZhbHVlcykge1xuICAgIHJldHVybiBoYXNoS2VjY2FrMjU2KHBhY2sodHlwZXMsIHZhbHVlcykpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNoYTI1Nih0eXBlcywgdmFsdWVzKSB7XG4gICAgcmV0dXJuIGhhc2hTaGEyNTYocGFjayh0eXBlcywgdmFsdWVzKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwic3RyaW5ncy81LjUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBIYXNoWmVybyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb25zdGFudHNcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleGxpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IHRvVXRmOEJ5dGVzLCB0b1V0ZjhTdHJpbmcgfSBmcm9tIFwiLi91dGY4XCI7XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0Qnl0ZXMzMlN0cmluZyh0ZXh0KSB7XG4gICAgLy8gR2V0IHRoZSBieXRlc1xuICAgIGNvbnN0IGJ5dGVzID0gdG9VdGY4Qnl0ZXModGV4dCk7XG4gICAgLy8gQ2hlY2sgd2UgaGF2ZSByb29tIGZvciBudWxsLXRlcm1pbmF0aW9uXG4gICAgaWYgKGJ5dGVzLmxlbmd0aCA+IDMxKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJ5dGVzMzIgc3RyaW5nIG11c3QgYmUgbGVzcyB0aGFuIDMyIGJ5dGVzXCIpO1xuICAgIH1cbiAgICAvLyBaZXJvLXBhZCAoaW1wbGljaXRseSBudWxsLXRlcm1pbmF0ZXMpXG4gICAgcmV0dXJuIGhleGxpZnkoY29uY2F0KFtieXRlcywgSGFzaFplcm9dKS5zbGljZSgwLCAzMikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlQnl0ZXMzMlN0cmluZyhieXRlcykge1xuICAgIGNvbnN0IGRhdGEgPSBhcnJheWlmeShieXRlcyk7XG4gICAgLy8gTXVzdCBiZSAzMiBieXRlcyB3aXRoIGEgbnVsbC10ZXJtaW5hdGlvblxuICAgIGlmIChkYXRhLmxlbmd0aCAhPT0gMzIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCBieXRlczMyIC0gbm90IDMyIGJ5dGVzIGxvbmdcIik7XG4gICAgfVxuICAgIGlmIChkYXRhWzMxXSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGJ5dGVzMzIgc3RyaW5nIC0gbm8gbnVsbCB0ZXJtaW5hdG9yXCIpO1xuICAgIH1cbiAgICAvLyBGaW5kIHRoZSBudWxsIHRlcm1pbmF0aW9uXG4gICAgbGV0IGxlbmd0aCA9IDMxO1xuICAgIHdoaWxlIChkYXRhW2xlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIGxlbmd0aC0tO1xuICAgIH1cbiAgICAvLyBEZXRlcm1pbmUgdGhlIHN0cmluZyB2YWx1ZVxuICAgIHJldHVybiB0b1V0ZjhTdHJpbmcoZGF0YS5zbGljZSgwLCBsZW5ndGgpKTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWJ5dGVzMzIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyB0b1V0ZjhDb2RlUG9pbnRzLCBfdG9VdGY4U3RyaW5nLCBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gfSBmcm9tIFwiLi91dGY4XCI7XG5mdW5jdGlvbiBieXRlczIoZGF0YSkge1xuICAgIGlmICgoZGF0YS5sZW5ndGggJSA0KSAhPT0gMCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYWQgZGF0YVwiKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICByZXN1bHQucHVzaChwYXJzZUludChkYXRhLnN1YnN0cmluZyhpLCBpICsgNCksIDE2KSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVUYWJsZShkYXRhLCBmdW5jKSB7XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICAgIGZ1bmMgPSBmdW5jdGlvbiAodmFsdWUpIHsgcmV0dXJuIFtwYXJzZUludCh2YWx1ZSwgMTYpXTsgfTtcbiAgICB9XG4gICAgbGV0IGxvID0gMDtcbiAgICBsZXQgcmVzdWx0ID0ge307XG4gICAgZGF0YS5zcGxpdChcIixcIikuZm9yRWFjaCgocGFpcikgPT4ge1xuICAgICAgICBsZXQgY29tcHMgPSBwYWlyLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgbG8gKz0gcGFyc2VJbnQoY29tcHNbMF0sIDE2KTtcbiAgICAgICAgcmVzdWx0W2xvXSA9IGZ1bmMoY29tcHNbMV0pO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBjcmVhdGVSYW5nZVRhYmxlKGRhdGEpIHtcbiAgICBsZXQgaGkgPSAwO1xuICAgIHJldHVybiBkYXRhLnNwbGl0KFwiLFwiKS5tYXAoKHYpID0+IHtcbiAgICAgICAgbGV0IGNvbXBzID0gdi5zcGxpdChcIi1cIik7XG4gICAgICAgIGlmIChjb21wcy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbXBzWzFdID0gXCIwXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29tcHNbMV0gPT09IFwiXCIpIHtcbiAgICAgICAgICAgIGNvbXBzWzFdID0gXCIxXCI7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGxvID0gaGkgKyBwYXJzZUludChjb21wc1swXSwgMTYpO1xuICAgICAgICBoaSA9IHBhcnNlSW50KGNvbXBzWzFdLCAxNik7XG4gICAgICAgIHJldHVybiB7IGw6IGxvLCBoOiBoaSB9O1xuICAgIH0pO1xufVxuZnVuY3Rpb24gbWF0Y2hNYXAodmFsdWUsIHJhbmdlcykge1xuICAgIGxldCBsbyA9IDA7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCByYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgbGV0IHJhbmdlID0gcmFuZ2VzW2ldO1xuICAgICAgICBsbyArPSByYW5nZS5sO1xuICAgICAgICBpZiAodmFsdWUgPj0gbG8gJiYgdmFsdWUgPD0gbG8gKyByYW5nZS5oICYmICgodmFsdWUgLSBsbykgJSAocmFuZ2UuZCB8fCAxKSkgPT09IDApIHtcbiAgICAgICAgICAgIGlmIChyYW5nZS5lICYmIHJhbmdlLmUuaW5kZXhPZih2YWx1ZSAtIGxvKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByYW5nZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmNvbnN0IFRhYmxlX0FfMV9yYW5nZXMgPSBjcmVhdGVSYW5nZVRhYmxlKFwiMjIxLDEzLTFiLDVmLSw0MC0xMCw1MS1mLDExLTMsMy0zLDItMiwyLTQsOCwyLDE1LDJkLDI4LTgsODgsNDgsMjctLDMtNSwxMS0yMCwyNy0sOCwyOCwzLTUsMTIsMTgsYi1hLDFjLTQsNi0xNiwyLWQsMi0yLDIsMWItNCwxNy05LDhmLSwxMCxmLDFmLTIsMWMtMzQsMzMtMTRlLDQsMzYtLDEzLSw2LTIsMWEtZiw0LDktLDMtLDE3LDgsMi0yLDUtLDIsOC0sMy0sNC04LDItMywzLDYtLDE2LTYsMi0sNy0zLDMtLDE3LDgsMywzLDMtLDIsNi0zLDMtLDQtYSw1LDItNiwxMC1iLDQsOCwyLDQsMTcsOCwzLDYtLGIsNCw0LSwyLWUsMi00LGItMTAsNCw5LSwzLSwxNyw4LDMtLDUtLDktMiwzLSw0LTcsMy0zLDMsNC0zLGMtMTAsMyw3LTIsNCw1LTIsMywyLDMtMiwzLTIsNC0yLDksNC0zLDYtMiw0LDUtOCwyLWUsZC1kLDQsOSw0LDE4LGIsNi0zLDgsNCw1LTYsMy04LDMtMyxiLTExLDMsOSw0LDE4LGIsNi0zLDgsNCw1LTYsMy02LDIsMy0zLGItMTEsMyw5LDQsMTgsMTEtMyw3LSw0LDUtOCwyLTcsMy0zLGItMTEsMywxMy0yLDE5LGEsMi0sOC0yLDItMyw3LDIsOS0xMSw0LWIsM2ItMywxZS0yNCwzLDItLDMsMi0sMi01LDUsOCw0LDIsMi0sMyxlLDQtLDYsMiw3LSxiLSwzLTIxLDQ5LDIzLTUsMWMtMyw5LDI1LDEwLSwyLTJmLDIzLDYsMyw4LTIsNS01LDFiLTQ1LDI3LTksMmEtLDItMyw1Yi00LDQ1LTQsNTMtNSw4LDQwLDIsNS0sOCwyLDUtLDI4LDIsNS0sMjAsMiw1LSw4LDIsNS0sOCw4LDE4LDIwLDIsNS0sOCwyOCwxNC01LDFkLTIyLDU2LWIsMjc3LTgsMWUtMiw1Mi1lLGUsOC1hLDE4LTgsMTUtYixlLDQsMy1iLDVlLTIsYi0xNSwxMCxiLTUsNTktNywyYi01NTUsOWQtMyw1Yi01LDE3LSw3LSwyNy0sNy0sOSwyLDIsMiwyMC0sMzYsMTAsZi0sNywxNC0sNCxhLDU0LTMsMi02LDYtNSw5LSwxYy0xMCwxMy0xZCwxYy0xNCwzYy0sMTAtNiwzMi1iLDI0MC0zMCwyOC0xOCxjLTE0LGEwLDExNS0sMyw2Ni0sYi03Niw1LDUtLDFkLDI0LDIsNS0yLDIsOC0sMzUtMiwxOSxmLTEwLDFkLTMsMzExLTM3ZiwxYiw1YS1iLGQ3LTE5LGQtMyw0MSw1Ny0sNjgtNCwyOS0zLDVmLDI5LTM3LDJlLTIsMjUtYywyYy0yLDRlLTMsMzAsNzgtMyw2NC0sMjAsMTliNy00OSw1MWE3LTU5LDQ4ZS0yLDM4LTczOCwyYmE1LTViLDIyMmYtLDNjLTk0LDgtYiw2LTQsMWIsNiwyLDMsMyw2ZC0yMCwxNmUtZiw0MS0sMzctNywyZS0yLDExLWYsNS1iLDE4LSxiLDE0LDUtMyw2LDg4LSwyLGJmLTIsNy0sNy0sNy0sNC0yLDgsOC05LDgtMmZmLDIwLDUtYiwxYy1iNCwyNy0sMjctY2JiMSxmNy05LDI4LTIsYjUtMjIxLDU2LDQ4LDMtLDItLDMtLDUsZCwyLDUsMyw0Miw1LSw5LDgsMWQsNSw2LDItMiw4LDE1My0zLDEyMy0zLDMzLTI3ZmQsYTZkYS01MTI4LDIxZi01ZGYsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLWZmZmQsMy1mZmZkLDMtZmZmZCwzLDItMWQsNjEtZmY3ZFwiKTtcbi8vIEBUT0RPOiBNYWtlIHRoaXMgcmVsYXRpdmUuLi5cbmNvbnN0IFRhYmxlX0JfMV9mbGFncyA9IFwiYWQsMzRmLDE4MDYsMTgwYiwxODBjLDE4MGQsMjAwYiwyMDBjLDIwMGQsMjA2MCxmZWZmXCIuc3BsaXQoXCIsXCIpLm1hcCgodikgPT4gcGFyc2VJbnQodiwgMTYpKTtcbmNvbnN0IFRhYmxlX0JfMl9yYW5nZXMgPSBbXG4gICAgeyBoOiAyNSwgczogMzIsIGw6IDY1IH0sXG4gICAgeyBoOiAzMCwgczogMzIsIGU6IFsyM10sIGw6IDEyNyB9LFxuICAgIHsgaDogNTQsIHM6IDEsIGU6IFs0OF0sIGw6IDY0LCBkOiAyIH0sXG4gICAgeyBoOiAxNCwgczogMSwgbDogNTcsIGQ6IDIgfSxcbiAgICB7IGg6IDQ0LCBzOiAxLCBsOiAxNywgZDogMiB9LFxuICAgIHsgaDogMTAsIHM6IDEsIGU6IFsyLCA2LCA4XSwgbDogNjEsIGQ6IDIgfSxcbiAgICB7IGg6IDE2LCBzOiAxLCBsOiA2OCwgZDogMiB9LFxuICAgIHsgaDogODQsIHM6IDEsIGU6IFsxOCwgMjQsIDY2XSwgbDogMTksIGQ6IDIgfSxcbiAgICB7IGg6IDI2LCBzOiAzMiwgZTogWzE3XSwgbDogNDM1IH0sXG4gICAgeyBoOiAyMiwgczogMSwgbDogNzEsIGQ6IDIgfSxcbiAgICB7IGg6IDE1LCBzOiA4MCwgbDogNDAgfSxcbiAgICB7IGg6IDMxLCBzOiAzMiwgbDogMTYgfSxcbiAgICB7IGg6IDMyLCBzOiAxLCBsOiA4MCwgZDogMiB9LFxuICAgIHsgaDogNTIsIHM6IDEsIGw6IDQyLCBkOiAyIH0sXG4gICAgeyBoOiAxMiwgczogMSwgbDogNTUsIGQ6IDIgfSxcbiAgICB7IGg6IDQwLCBzOiAxLCBlOiBbMzhdLCBsOiAxNSwgZDogMiB9LFxuICAgIHsgaDogMTQsIHM6IDEsIGw6IDQ4LCBkOiAyIH0sXG4gICAgeyBoOiAzNywgczogNDgsIGw6IDQ5IH0sXG4gICAgeyBoOiAxNDgsIHM6IDEsIGw6IDYzNTEsIGQ6IDIgfSxcbiAgICB7IGg6IDg4LCBzOiAxLCBsOiAxNjAsIGQ6IDIgfSxcbiAgICB7IGg6IDE1LCBzOiAxNiwgbDogNzA0IH0sXG4gICAgeyBoOiAyNSwgczogMjYsIGw6IDg1NCB9LFxuICAgIHsgaDogMjUsIHM6IDMyLCBsOiA1NTkxNSB9LFxuICAgIHsgaDogMzcsIHM6IDQwLCBsOiAxMjQ3IH0sXG4gICAgeyBoOiAyNSwgczogLTExOTcxMSwgbDogNTMyNDggfSxcbiAgICB7IGg6IDI1LCBzOiAtMTE5NzYzLCBsOiA1MiB9LFxuICAgIHsgaDogMjUsIHM6IC0xMTk4MTUsIGw6IDUyIH0sXG4gICAgeyBoOiAyNSwgczogLTExOTg2NywgZTogWzEsIDQsIDUsIDcsIDgsIDExLCAxMiwgMTddLCBsOiA1MiB9LFxuICAgIHsgaDogMjUsIHM6IC0xMTk5MTksIGw6IDUyIH0sXG4gICAgeyBoOiAyNCwgczogLTExOTk3MSwgZTogWzIsIDcsIDgsIDE3XSwgbDogNTIgfSxcbiAgICB7IGg6IDI0LCBzOiAtMTIwMDIzLCBlOiBbMiwgNywgMTMsIDE1LCAxNiwgMTddLCBsOiA1MiB9LFxuICAgIHsgaDogMjUsIHM6IC0xMjAwNzUsIGw6IDUyIH0sXG4gICAgeyBoOiAyNSwgczogLTEyMDEyNywgbDogNTIgfSxcbiAgICB7IGg6IDI1LCBzOiAtMTIwMTc5LCBsOiA1MiB9LFxuICAgIHsgaDogMjUsIHM6IC0xMjAyMzEsIGw6IDUyIH0sXG4gICAgeyBoOiAyNSwgczogLTEyMDI4MywgbDogNTIgfSxcbiAgICB7IGg6IDI1LCBzOiAtMTIwMzM1LCBsOiA1MiB9LFxuICAgIHsgaDogMjQsIHM6IC0xMTk1NDMsIGU6IFsxN10sIGw6IDU2IH0sXG4gICAgeyBoOiAyNCwgczogLTExOTYwMSwgZTogWzE3XSwgbDogNTggfSxcbiAgICB7IGg6IDI0LCBzOiAtMTE5NjU5LCBlOiBbMTddLCBsOiA1OCB9LFxuICAgIHsgaDogMjQsIHM6IC0xMTk3MTcsIGU6IFsxN10sIGw6IDU4IH0sXG4gICAgeyBoOiAyNCwgczogLTExOTc3NSwgZTogWzE3XSwgbDogNTggfVxuXTtcbmNvbnN0IFRhYmxlX0JfMl9sdXRfYWJzID0gY3JlYXRlVGFibGUoXCJiNTozYmMsYzM6ZmYsNzo3MywyOjI1Myw1OjI1NCwzOjI1NiwxOjI1Nyw1OjI1OSwxOjI1YiwzOjI2MCwxOjI2MywyOjI2OSwxOjI2OCw1OjI2ZiwxOjI3MiwyOjI3NSw3OjI4MCwzOjI4Myw1OjI4OCwzOjI4YSwxOjI4Yiw1OjI5MiwzZjoxOTUsMToxYmYsMjk6MTllLDEyNTozYjksOGI6M2IyLDE6M2I4LDE6M2M1LDM6M2M2LDE6M2MwLDFhOjNiYSwxOjNjMSwxOjNjMywyOjNiOCwxOjNiNSwxYmM5OjNiOSwxYzoxZjc2LDE6MWY3NyxmOjFmN2EsMToxZjdiLGQ6MWY3OCwxOjFmNzksMToxZjdjLDE6MWY3ZCwxMDc6NjMsNToyNWIsNDo2OCwxOjY4LDE6NjgsMzo2OSwxOjY5LDE6NmMsMzo2ZSw0OjcwLDE6NzEsMTo3MiwxOjcyLDE6NzIsNzo3YSwyOjNjOSwyOjdhLDI6NmIsMTplNSwxOjYyLDE6NjMsMzo2NSwxOjY2LDI6NmQsYjozYjMsMTozYzAsNjo2NCwxYjU3NDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzMsMjA6M2I4LDFhOjNjMywyMDozYjgsMWE6M2MzLDIwOjNiOCwxYTozYzNcIik7XG5jb25zdCBUYWJsZV9CXzJfbHV0X3JlbCA9IGNyZWF0ZVRhYmxlKFwiMTc5OjEsMjoxLDI6MSw1OjEsMjoxLGE6NGYsYToxLDg6MSwyOjEsMjoxLDM6MSw1OjEsMzoxLDQ6MSwyOjEsMzoxLDQ6MSw4OjIsMToxLDI6MiwxOjEsMjoyLDI3OjIsMTk1OjI2LDI6MjUsMToyNSwxOjI1LDI6NDAsMjozZiwxOjNmLDMzOjEsMTE6LTYsMTotOSwxYWM3Oi0zYSw2ZDotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDk6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LGI6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsOTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsYzotOCwyOi04LDI6LTgsMjotOCw5Oi04LDE6LTgsMTotOCwxOi04LDE6LTgsMTotOCwxOi04LDE6LTgsNDk6LTgsMTotOCwxOi00YSwxOi00YSxkOi01NiwxOi01NiwxOi01NiwxOi01NixkOi04LDE6LTgsZjotOCwxOi04LDM6LTdcIik7XG5jb25zdCBUYWJsZV9CXzJfY29tcGxleCA9IGNyZWF0ZVRhYmxlKFwiZGY6MDA3MzAwNzMsNTE6MDA2OTAzMDcsMTk6MDJCQzAwNkUsYTc6MDA2QTAzMEMsMThhOjAwMjAwM0I5LDE2OjAzQjkwMzA4MDMwMSwyMDowM0M1MDMwODAzMDEsMWQ3OjA1NjUwNTgyLDE5MGY6MDA2ODAzMzEsMTowMDc0MDMwOCwxOjAwNzcwMzBBLDE6MDA3OTAzMEEsMTowMDYxMDJCRSxiNjowM0M1MDMxMywyOjAzQzUwMzEzMDMwMCwyOjAzQzUwMzEzMDMwMSwyOjAzQzUwMzEzMDM0MiwyYToxRjAwMDNCOSwxOjFGMDEwM0I5LDE6MUYwMjAzQjksMToxRjAzMDNCOSwxOjFGMDQwM0I5LDE6MUYwNTAzQjksMToxRjA2MDNCOSwxOjFGMDcwM0I5LDE6MUYwMDAzQjksMToxRjAxMDNCOSwxOjFGMDIwM0I5LDE6MUYwMzAzQjksMToxRjA0MDNCOSwxOjFGMDUwM0I5LDE6MUYwNjAzQjksMToxRjA3MDNCOSwxOjFGMjAwM0I5LDE6MUYyMTAzQjksMToxRjIyMDNCOSwxOjFGMjMwM0I5LDE6MUYyNDAzQjksMToxRjI1MDNCOSwxOjFGMjYwM0I5LDE6MUYyNzAzQjksMToxRjIwMDNCOSwxOjFGMjEwM0I5LDE6MUYyMjAzQjksMToxRjIzMDNCOSwxOjFGMjQwM0I5LDE6MUYyNTAzQjksMToxRjI2MDNCOSwxOjFGMjcwM0I5LDE6MUY2MDAzQjksMToxRjYxMDNCOSwxOjFGNjIwM0I5LDE6MUY2MzAzQjksMToxRjY0MDNCOSwxOjFGNjUwM0I5LDE6MUY2NjAzQjksMToxRjY3MDNCOSwxOjFGNjAwM0I5LDE6MUY2MTAzQjksMToxRjYyMDNCOSwxOjFGNjMwM0I5LDE6MUY2NDAzQjksMToxRjY1MDNCOSwxOjFGNjYwM0I5LDE6MUY2NzAzQjksMzoxRjcwMDNCOSwxOjAzQjEwM0I5LDE6MDNBQzAzQjksMjowM0IxMDM0MiwxOjAzQjEwMzQyMDNCOSw1OjAzQjEwM0I5LDY6MUY3NDAzQjksMTowM0I3MDNCOSwxOjAzQUUwM0I5LDI6MDNCNzAzNDIsMTowM0I3MDM0MjAzQjksNTowM0I3MDNCOSw2OjAzQjkwMzA4MDMwMCwxOjAzQjkwMzA4MDMwMSwzOjAzQjkwMzQyLDE6MDNCOTAzMDgwMzQyLGI6MDNDNTAzMDgwMzAwLDE6MDNDNTAzMDgwMzAxLDE6MDNDMTAzMTMsMjowM0M1MDM0MiwxOjAzQzUwMzA4MDM0MixiOjFGN0MwM0I5LDE6MDNDOTAzQjksMTowM0NFMDNCOSwyOjAzQzkwMzQyLDE6MDNDOTAzNDIwM0I5LDU6MDNDOTAzQjksYWM6MDA3MjAwNzMsNWI6MDBCMDAwNjMsNjowMEIwMDA2NixkOjAwNkUwMDZGLGE6MDA3MzAwNkQsMTowMDc0MDA2NTAwNkMsMTowMDc0MDA2RCwxMjRmOjAwNjgwMDcwMDA2MSwyOjAwNjEwMDc1LDI6MDA2RjAwNzYsYjowMDcwMDA2MSwxOjAwNkUwMDYxLDE6MDNCQzAwNjEsMTowMDZEMDA2MSwxOjAwNkIwMDYxLDE6MDA2QjAwNjIsMTowMDZEMDA2MiwxOjAwNjcwMDYyLDM6MDA3MDAwNjYsMTowMDZFMDA2NiwxOjAzQkMwMDY2LDQ6MDA2ODAwN0EsMTowMDZCMDA2ODAwN0EsMTowMDZEMDA2ODAwN0EsMTowMDY3MDA2ODAwN0EsMTowMDc0MDA2ODAwN0EsMTU6MDA3MDAwNjEsMTowMDZCMDA3MDAwNjEsMTowMDZEMDA3MDAwNjEsMTowMDY3MDA3MDAwNjEsODowMDcwMDA3NiwxOjAwNkUwMDc2LDE6MDNCQzAwNzYsMTowMDZEMDA3NiwxOjAwNkIwMDc2LDE6MDA2RDAwNzYsMTowMDcwMDA3NywxOjAwNkUwMDc3LDE6MDNCQzAwNzcsMTowMDZEMDA3NywxOjAwNkIwMDc3LDE6MDA2RDAwNzcsMTowMDZCMDNDOSwxOjAwNkQwM0M5LDI6MDA2MjAwNzEsMzowMDYzMjIxNTAwNkIwMDY3LDE6MDA2MzAwNkYwMDJFLDE6MDA2NDAwNjIsMTowMDY3MDA3OSwyOjAwNjgwMDcwLDI6MDA2QjAwNkIsMTowMDZCMDA2RCw5OjAwNzAwMDY4LDI6MDA3MDAwNzAwMDZELDE6MDA3MDAwNzIsMjowMDczMDA3NiwxOjAwNzcwMDYyLGM3MjM6MDA2NjAwNjYsMTowMDY2MDA2OSwxOjAwNjYwMDZDLDE6MDA2NjAwNjYwMDY5LDE6MDA2NjAwNjYwMDZDLDE6MDA3MzAwNzQsMTowMDczMDA3NCxkOjA1NzQwNTc2LDE6MDU3NDA1NjUsMTowNTc0MDU2QiwxOjA1N0UwNTc2LDE6MDU3NDA1NkRcIiwgYnl0ZXMyKTtcbmNvbnN0IFRhYmxlX0NfcmFuZ2VzID0gY3JlYXRlUmFuZ2VUYWJsZShcIjgwLTIwLDJhMC0sMzljLDMyLGY3MSwxOGUsN2YyLWYsMTktNywzMC00LDctNSxmODEtYiw1LGE4MDAtMjBmZiw0ZDEtMWYsMTEwLGZhLTYsZDE3NC03LDJlODQtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLGZmZmYtLDIsMWYtNWYsZmY3Zi0yMDAwMVwiKTtcbmZ1bmN0aW9uIGZsYXR0ZW4odmFsdWVzKSB7XG4gICAgcmV0dXJuIHZhbHVlcy5yZWR1Y2UoKGFjY3VtLCB2YWx1ZSkgPT4ge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKCh2YWx1ZSkgPT4geyBhY2N1bS5wdXNoKHZhbHVlKTsgfSk7XG4gICAgICAgIHJldHVybiBhY2N1bTtcbiAgICB9LCBbXSk7XG59XG5leHBvcnQgZnVuY3Rpb24gX25hbWVwcmVwVGFibGVBMShjb2RlcG9pbnQpIHtcbiAgICByZXR1cm4gISFtYXRjaE1hcChjb2RlcG9pbnQsIFRhYmxlX0FfMV9yYW5nZXMpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIF9uYW1lcHJlcFRhYmxlQjIoY29kZXBvaW50KSB7XG4gICAgbGV0IHJhbmdlID0gbWF0Y2hNYXAoY29kZXBvaW50LCBUYWJsZV9CXzJfcmFuZ2VzKTtcbiAgICBpZiAocmFuZ2UpIHtcbiAgICAgICAgcmV0dXJuIFtjb2RlcG9pbnQgKyByYW5nZS5zXTtcbiAgICB9XG4gICAgbGV0IGNvZGVzID0gVGFibGVfQl8yX2x1dF9hYnNbY29kZXBvaW50XTtcbiAgICBpZiAoY29kZXMpIHtcbiAgICAgICAgcmV0dXJuIGNvZGVzO1xuICAgIH1cbiAgICBsZXQgc2hpZnQgPSBUYWJsZV9CXzJfbHV0X3JlbFtjb2RlcG9pbnRdO1xuICAgIGlmIChzaGlmdCkge1xuICAgICAgICByZXR1cm4gW2NvZGVwb2ludCArIHNoaWZ0WzBdXTtcbiAgICB9XG4gICAgbGV0IGNvbXBsZXggPSBUYWJsZV9CXzJfY29tcGxleFtjb2RlcG9pbnRdO1xuICAgIGlmIChjb21wbGV4KSB7XG4gICAgICAgIHJldHVybiBjb21wbGV4O1xuICAgIH1cbiAgICByZXR1cm4gbnVsbDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfbmFtZXByZXBUYWJsZUMoY29kZXBvaW50KSB7XG4gICAgcmV0dXJuICEhbWF0Y2hNYXAoY29kZXBvaW50LCBUYWJsZV9DX3Jhbmdlcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gbmFtZXByZXAodmFsdWUpIHtcbiAgICAvLyBUaGlzIGFsbG93cyBwbGF0Zm9ybXMgd2l0aCBpbmNvbXBsZXRlIG5vcm1hbGl6ZSB0byBieXBhc3NcbiAgICAvLyBpdCBmb3IgdmVyeSBiYXNpYyBuYW1lcyB3aGljaCB0aGUgYnVpbHQtaW4gdG9Mb3dlckNhc2VcbiAgICAvLyB3aWxsIGNlcnRhaW5seSBoYW5kbGUgY29ycmVjdGx5XG4gICAgaWYgKHZhbHVlLm1hdGNoKC9eW2EtejAtOS1dKiQvaSkgJiYgdmFsdWUubGVuZ3RoIDw9IDU5KSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cbiAgICAvLyBHZXQgdGhlIGNvZGUgcG9pbnRzIChrZWVwaW5nIHRoZSBjdXJyZW50IG5vcm1hbGl6YXRpb24pXG4gICAgbGV0IGNvZGVzID0gdG9VdGY4Q29kZVBvaW50cyh2YWx1ZSk7XG4gICAgY29kZXMgPSBmbGF0dGVuKGNvZGVzLm1hcCgoY29kZSkgPT4ge1xuICAgICAgICAvLyBTdWJzdGl0dXRlIFRhYmxlIEIuMSAoTWFwcyB0byBOb3RoaW5nKVxuICAgICAgICBpZiAoVGFibGVfQl8xX2ZsYWdzLmluZGV4T2YoY29kZSkgPj0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlID49IDB4ZmUwMCAmJiBjb2RlIDw9IDB4ZmUwZikge1xuICAgICAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgICB9XG4gICAgICAgIC8vIFN1YnN0aXR1dGUgVGFibGUgQi4yIChDYXNlIEZvbGRpbmcpXG4gICAgICAgIGxldCBjb2Rlc1RhYmxlQjIgPSBfbmFtZXByZXBUYWJsZUIyKGNvZGUpO1xuICAgICAgICBpZiAoY29kZXNUYWJsZUIyKSB7XG4gICAgICAgICAgICByZXR1cm4gY29kZXNUYWJsZUIyO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIFN1YnN0aXR1dGlvblxuICAgICAgICByZXR1cm4gW2NvZGVdO1xuICAgIH0pKTtcbiAgICAvLyBOb3JtYWxpemUgdXNpbmcgZm9ybSBLQ1xuICAgIGNvZGVzID0gdG9VdGY4Q29kZVBvaW50cyhfdG9VdGY4U3RyaW5nKGNvZGVzKSwgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLk5GS0MpO1xuICAgIC8vIFByb2hpYml0IFRhYmxlcyBDLjEuMiwgQy4yLjIsIEMuMywgQy40LCBDLjUsIEMuNiwgQy43LCBDLjgsIEMuOVxuICAgIGNvZGVzLmZvckVhY2goKGNvZGUpID0+IHtcbiAgICAgICAgaWYgKF9uYW1lcHJlcFRhYmxlQyhjb2RlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU1RSSU5HUFJFUF9DT05UQUlOU19QUk9ISUJJVEVEXCIpO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gUHJvaGliaXQgVW5hc3NpZ25lZCBDb2RlIFBvaW50cyAoVGFibGUgQS4xKVxuICAgIGNvZGVzLmZvckVhY2goKGNvZGUpID0+IHtcbiAgICAgICAgaWYgKF9uYW1lcHJlcFRhYmxlQTEoY29kZSkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlNUUklOR1BSRVBfQ09OVEFJTlNfVU5BU1NJR05FRFwiKTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIC8vIElETkEgZXh0cmFzXG4gICAgbGV0IG5hbWUgPSBfdG9VdGY4U3RyaW5nKGNvZGVzKTtcbiAgICAvLyBJRE5BOiA0LjIuMy4xXG4gICAgaWYgKG5hbWUuc3Vic3RyaW5nKDAsIDEpID09PSBcIi1cIiB8fCBuYW1lLnN1YnN0cmluZygyLCA0KSA9PT0gXCItLVwiIHx8IG5hbWUuc3Vic3RyaW5nKG5hbWUubGVuZ3RoIC0gMSkgPT09IFwiLVwiKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgaHlwaGVuXCIpO1xuICAgIH1cbiAgICAvLyBJRE5BOiA0LjIuNFxuICAgIGlmIChuYW1lLmxlbmd0aCA+IDYzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvbyBsb25nXCIpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWlkbmEuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBmb3JtYXRCeXRlczMyU3RyaW5nLCBwYXJzZUJ5dGVzMzJTdHJpbmcgfSBmcm9tIFwiLi9ieXRlczMyXCI7XG5pbXBvcnQgeyBuYW1lcHJlcCB9IGZyb20gXCIuL2lkbmFcIjtcbmltcG9ydCB7IF90b0VzY2FwZWRVdGY4U3RyaW5nLCB0b1V0ZjhCeXRlcywgdG9VdGY4Q29kZVBvaW50cywgdG9VdGY4U3RyaW5nLCBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0sIFV0ZjhFcnJvckZ1bmNzLCBVdGY4RXJyb3JSZWFzb24gfSBmcm9tIFwiLi91dGY4XCI7XG5leHBvcnQgeyBfdG9Fc2NhcGVkVXRmOFN0cmluZywgdG9VdGY4Qnl0ZXMsIHRvVXRmOENvZGVQb2ludHMsIHRvVXRmOFN0cmluZywgVXRmOEVycm9yRnVuY3MsIFV0ZjhFcnJvclJlYXNvbiwgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLCBmb3JtYXRCeXRlczMyU3RyaW5nLCBwYXJzZUJ5dGVzMzJTdHJpbmcsIG5hbWVwcmVwIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IGFycmF5aWZ5IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG5leHBvcnQgdmFyIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybTtcbihmdW5jdGlvbiAoVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtKSB7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiY3VycmVudFwiXSA9IFwiXCI7XG4gICAgVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtW1wiTkZDXCJdID0gXCJORkNcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORkRcIl0gPSBcIk5GRFwiO1xuICAgIFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybVtcIk5GS0NcIl0gPSBcIk5GS0NcIjtcbiAgICBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm1bXCJORktEXCJdID0gXCJORktEXCI7XG59KShVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0gfHwgKFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSA9IHt9KSk7XG47XG5leHBvcnQgdmFyIFV0ZjhFcnJvclJlYXNvbjtcbihmdW5jdGlvbiAoVXRmOEVycm9yUmVhc29uKSB7XG4gICAgLy8gQSBjb250aW51YXRpb24gYnl0ZSB3YXMgcHJlc2VudCB3aGVyZSB0aGVyZSB3YXMgbm90aGluZyB0byBjb250aW51ZVxuICAgIC8vIC0gb2Zmc2V0ID0gdGhlIGluZGV4IHRoZSBjb2RlcG9pbnQgYmVnYW4gaW5cbiAgICBVdGY4RXJyb3JSZWFzb25bXCJVTkVYUEVDVEVEX0NPTlRJTlVFXCJdID0gXCJ1bmV4cGVjdGVkIGNvbnRpbnVhdGlvbiBieXRlXCI7XG4gICAgLy8gQW4gaW52YWxpZCAobm9uLWNvbnRpbnVhdGlvbikgYnl0ZSB0byBzdGFydCBhIFVURi04IGNvZGVwb2ludCB3YXMgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiQkFEX1BSRUZJWFwiXSA9IFwiYmFkIGNvZGVwb2ludCBwcmVmaXhcIjtcbiAgICAvLyBUaGUgc3RyaW5nIGlzIHRvbyBzaG9ydCB0byBwcm9jZXNzIHRoZSBleHBlY3RlZCBjb2RlcG9pbnRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29kZXBvaW50IGJlZ2FuIGluXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1ZFUlJVTlwiXSA9IFwic3RyaW5nIG92ZXJydW5cIjtcbiAgICAvLyBBIG1pc3NpbmcgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGJ1dCBub3QgZm91bmRcbiAgICAvLyAtIG9mZnNldCA9IHRoZSBpbmRleCB0aGUgY29udGludWF0aW9uIGJ5dGUgd2FzIGV4cGVjdGVkIGF0XG4gICAgVXRmOEVycm9yUmVhc29uW1wiTUlTU0lOR19DT05USU5VRVwiXSA9IFwibWlzc2luZyBjb250aW51YXRpb24gYnl0ZVwiO1xuICAgIC8vIFRoZSBjb21wdXRlZCBjb2RlIHBvaW50IGlzIG91dHNpZGUgdGhlIHJhbmdlIGZvciBVVEYtOFxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IG91dHNpZGUgdGhlIFVURi04IHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiT1VUX09GX1JBTkdFXCJdID0gXCJvdXQgb2YgVVRGLTggcmFuZ2VcIjtcbiAgICAvLyBVVEYtOCBzdHJpbmdzIG1heSBub3QgY29udGFpbiBVVEYtMTYgc3Vycm9nYXRlIHBhaXJzXG4gICAgLy8gLSBvZmZzZXQgICAgICAgPSBzdGFydCBvZiB0aGlzIGNvZGVwb2ludFxuICAgIC8vIC0gYmFkQ29kZXBvaW50ID0gdGhlIGNvbXB1dGVkIGNvZGVwb2ludDsgaW5zaWRlIHRoZSBVVEYtMTYgc3Vycm9nYXRlIHJhbmdlXG4gICAgVXRmOEVycm9yUmVhc29uW1wiVVRGMTZfU1VSUk9HQVRFXCJdID0gXCJVVEYtMTYgc3Vycm9nYXRlXCI7XG4gICAgLy8gVGhlIHN0cmluZyBpcyBhbiBvdmVybG9uZyByZXByZXNlbnRhdGlvblxuICAgIC8vIC0gb2Zmc2V0ICAgICAgID0gc3RhcnQgb2YgdGhpcyBjb2RlcG9pbnRcbiAgICAvLyAtIGJhZENvZGVwb2ludCA9IHRoZSBjb21wdXRlZCBjb2RlcG9pbnQ7IGFscmVhZHkgYm91bmRzIGNoZWNrZWRcbiAgICBVdGY4RXJyb3JSZWFzb25bXCJPVkVSTE9OR1wiXSA9IFwib3ZlcmxvbmcgcmVwcmVzZW50YXRpb25cIjtcbn0pKFV0ZjhFcnJvclJlYXNvbiB8fCAoVXRmOEVycm9yUmVhc29uID0ge30pKTtcbjtcbmZ1bmN0aW9uIGVycm9yRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgcmV0dXJuIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoYGludmFsaWQgY29kZXBvaW50IGF0IG9mZnNldCAke29mZnNldH07ICR7cmVhc29ufWAsIFwiYnl0ZXNcIiwgYnl0ZXMpO1xufVxuZnVuY3Rpb24gaWdub3JlRnVuYyhyZWFzb24sIG9mZnNldCwgYnl0ZXMsIG91dHB1dCwgYmFkQ29kZXBvaW50KSB7XG4gICAgLy8gSWYgdGhlcmUgaXMgYW4gaW52YWxpZCBwcmVmaXggKGluY2x1ZGluZyBzdHJheSBjb250aW51YXRpb24pLCBza2lwIGFueSBhZGRpdGlvbmFsIGNvbnRpbnVhdGlvbiBieXRlc1xuICAgIGlmIChyZWFzb24gPT09IFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYIHx8IHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLlVORVhQRUNURURfQ09OVElOVUUpIHtcbiAgICAgICAgbGV0IGkgPSAwO1xuICAgICAgICBmb3IgKGxldCBvID0gb2Zmc2V0ICsgMTsgbyA8IGJ5dGVzLmxlbmd0aDsgbysrKSB7XG4gICAgICAgICAgICBpZiAoYnl0ZXNbb10gPj4gNiAhPT0gMHgwMikge1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBpO1xuICAgIH1cbiAgICAvLyBUaGlzIGJ5dGUgcnVucyB1cyBwYXN0IHRoZSBlbmQgb2YgdGhlIHN0cmluZywgc28ganVzdCBqdW1wIHRvIHRoZSBlbmRcbiAgICAvLyAoYnV0IHRoZSBmaXJzdCBieXRlIHdhcyByZWFkIGFscmVhZHkgcmVhZCBhbmQgdGhlcmVmb3JlIHNraXBwZWQpXG4gICAgaWYgKHJlYXNvbiA9PT0gVXRmOEVycm9yUmVhc29uLk9WRVJSVU4pIHtcbiAgICAgICAgcmV0dXJuIGJ5dGVzLmxlbmd0aCAtIG9mZnNldCAtIDE7XG4gICAgfVxuICAgIC8vIE5vdGhpbmcgdG8gc2tpcFxuICAgIHJldHVybiAwO1xufVxuZnVuY3Rpb24gcmVwbGFjZUZ1bmMocmVhc29uLCBvZmZzZXQsIGJ5dGVzLCBvdXRwdXQsIGJhZENvZGVwb2ludCkge1xuICAgIC8vIE92ZXJsb25nIHJlcHJlc2VudGF0aW9ucyBhcmUgb3RoZXJ3aXNlIFwidmFsaWRcIiBjb2RlIHBvaW50czsganVzdCBub24tZGVpc3Rpbmd0aXNoZWRcbiAgICBpZiAocmVhc29uID09PSBVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcpIHtcbiAgICAgICAgb3V0cHV0LnB1c2goYmFkQ29kZXBvaW50KTtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgfVxuICAgIC8vIFB1dCB0aGUgcmVwbGFjZW1lbnQgY2hhcmFjdGVyIGludG8gdGhlIG91dHB1dFxuICAgIG91dHB1dC5wdXNoKDB4ZmZmZCk7XG4gICAgLy8gT3RoZXJ3aXNlLCBwcm9jZXNzIGFzIGlmIGlnbm9yaW5nIGVycm9yc1xuICAgIHJldHVybiBpZ25vcmVGdW5jKHJlYXNvbiwgb2Zmc2V0LCBieXRlcywgb3V0cHV0LCBiYWRDb2RlcG9pbnQpO1xufVxuLy8gQ29tbW9uIGVycm9yIGhhbmRpbmcgc3RyYXRlZ2llc1xuZXhwb3J0IGNvbnN0IFV0ZjhFcnJvckZ1bmNzID0gT2JqZWN0LmZyZWV6ZSh7XG4gICAgZXJyb3I6IGVycm9yRnVuYyxcbiAgICBpZ25vcmU6IGlnbm9yZUZ1bmMsXG4gICAgcmVwbGFjZTogcmVwbGFjZUZ1bmNcbn0pO1xuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xMzM1NjQ5My9kZWNvZGUtdXRmLTgtd2l0aC1qYXZhc2NyaXB0IzEzNjkxNDk5XG5mdW5jdGlvbiBnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikge1xuICAgIGlmIChvbkVycm9yID09IG51bGwpIHtcbiAgICAgICAgb25FcnJvciA9IFV0ZjhFcnJvckZ1bmNzLmVycm9yO1xuICAgIH1cbiAgICBieXRlcyA9IGFycmF5aWZ5KGJ5dGVzKTtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgaSA9IDA7XG4gICAgLy8gSW52YWxpZCBieXRlcyBhcmUgaWdub3JlZFxuICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgIGNvbnN0IGMgPSBieXRlc1tpKytdO1xuICAgICAgICAvLyAweHh4IHh4eHhcbiAgICAgICAgaWYgKGMgPj4gNyA9PT0gMCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBNdWx0aWJ5dGU7IGhvdyBtYW55IGJ5dGVzIGxlZnQgZm9yIHRoaXMgY2hhcmFjdGVyP1xuICAgICAgICBsZXQgZXh0cmFMZW5ndGggPSBudWxsO1xuICAgICAgICBsZXQgb3ZlcmxvbmdNYXNrID0gbnVsbDtcbiAgICAgICAgLy8gMTEweCB4eHh4IDEweHggeHh4eFxuICAgICAgICBpZiAoKGMgJiAweGUwKSA9PT0gMHhjMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAxO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZjtcbiAgICAgICAgICAgIC8vIDExMTAgeHh4eCAxMHh4IHh4eHggMTB4eCB4eHh4XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGYwKSA9PT0gMHhlMCkge1xuICAgICAgICAgICAgZXh0cmFMZW5ndGggPSAyO1xuICAgICAgICAgICAgb3ZlcmxvbmdNYXNrID0gMHg3ZmY7XG4gICAgICAgICAgICAvLyAxMTExIDB4eHggMTB4eCB4eHh4IDEweHggeHh4eCAxMHh4IHh4eHhcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICgoYyAmIDB4ZjgpID09PSAweGYwKSB7XG4gICAgICAgICAgICBleHRyYUxlbmd0aCA9IDM7XG4gICAgICAgICAgICBvdmVybG9uZ01hc2sgPSAweGZmZmY7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoKGMgJiAweGMwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVU5FWFBFQ1RFRF9DT05USU5VRSwgaSAtIDEsIGJ5dGVzLCByZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5CQURfUFJFRklYLCBpIC0gMSwgYnl0ZXMsIHJlc3VsdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEbyB3ZSBoYXZlIGVub3VnaCBieXRlcyBpbiBvdXIgZGF0YT9cbiAgICAgICAgaWYgKGkgLSAxICsgZXh0cmFMZW5ndGggPj0gYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBpICs9IG9uRXJyb3IoVXRmOEVycm9yUmVhc29uLk9WRVJSVU4sIGkgLSAxLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlbW92ZSB0aGUgbGVuZ3RoIHByZWZpeCBmcm9tIHRoZSBjaGFyXG4gICAgICAgIGxldCByZXMgPSBjICYgKCgxIDw8ICg4IC0gZXh0cmFMZW5ndGggLSAxKSkgLSAxKTtcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBleHRyYUxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBsZXQgbmV4dENoYXIgPSBieXRlc1tpXTtcbiAgICAgICAgICAgIC8vIEludmFsaWQgY29udGludWF0aW9uIGJ5dGVcbiAgICAgICAgICAgIGlmICgobmV4dENoYXIgJiAweGMwKSAhPSAweDgwKSB7XG4gICAgICAgICAgICAgICAgaSArPSBvbkVycm9yKFV0ZjhFcnJvclJlYXNvbi5NSVNTSU5HX0NPTlRJTlVFLCBpLCBieXRlcywgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICByZXMgPSBudWxsO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgO1xuICAgICAgICAgICAgcmVzID0gKHJlcyA8PCA2KSB8IChuZXh0Q2hhciAmIDB4M2YpO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNlZSBhYm92ZSBsb29wIGZvciBpbnZhbGlkIGNvbnRpbnVhdGlvbiBieXRlXG4gICAgICAgIGlmIChyZXMgPT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1heGltdW0gY29kZSBwb2ludFxuICAgICAgICBpZiAocmVzID4gMHgxMGZmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1VUX09GX1JBTkdFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVzZXJ2ZWQgZm9yIFVURi0xNiBzdXJyb2dhdGUgaGFsdmVzXG4gICAgICAgIGlmIChyZXMgPj0gMHhkODAwICYmIHJlcyA8PSAweGRmZmYpIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uVVRGMTZfU1VSUk9HQVRFLCBpIC0gMSAtIGV4dHJhTGVuZ3RoLCBieXRlcywgcmVzdWx0LCByZXMpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2hlY2sgZm9yIG92ZXJsb25nIHNlcXVlbmNlcyAobW9yZSBieXRlcyB0aGFuIG5lZWRlZClcbiAgICAgICAgaWYgKHJlcyA8PSBvdmVybG9uZ01hc2spIHtcbiAgICAgICAgICAgIGkgKz0gb25FcnJvcihVdGY4RXJyb3JSZWFzb24uT1ZFUkxPTkcsIGkgLSAxIC0gZXh0cmFMZW5ndGgsIGJ5dGVzLCByZXN1bHQsIHJlcyk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQucHVzaChyZXMpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8xODcyOTQwNS9ob3ctdG8tY29udmVydC11dGY4LXN0cmluZy10by1ieXRlLWFycmF5XG5leHBvcnQgZnVuY3Rpb24gdG9VdGY4Qnl0ZXMoc3RyLCBmb3JtID0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICBpZiAoZm9ybSAhPSBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0uY3VycmVudCkge1xuICAgICAgICBsb2dnZXIuY2hlY2tOb3JtYWxpemUoKTtcbiAgICAgICAgc3RyID0gc3RyLm5vcm1hbGl6ZShmb3JtKTtcbiAgICB9XG4gICAgbGV0IHJlc3VsdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNvbnN0IGMgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGMgPCAweDgwKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjIDwgMHg4MDApIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDYpIHwgMHhjMCk7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgoYyAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoKGMgJiAweGZjMDApID09IDB4ZDgwMCkge1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgY29uc3QgYzIgPSBzdHIuY2hhckNvZGVBdChpKTtcbiAgICAgICAgICAgIGlmIChpID49IHN0ci5sZW5ndGggfHwgKGMyICYgMHhmYzAwKSAhPT0gMHhkYzAwKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW52YWxpZCB1dGYtOCBzdHJpbmdcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBTdXJyb2dhdGUgUGFpclxuICAgICAgICAgICAgY29uc3QgcGFpciA9IDB4MTAwMDAgKyAoKGMgJiAweDAzZmYpIDw8IDEwKSArIChjMiAmIDB4MDNmZik7XG4gICAgICAgICAgICByZXN1bHQucHVzaCgocGFpciA+PiAxOCkgfCAweGYwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKCgocGFpciA+PiAxMikgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChwYWlyID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChwYWlyICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjID4+IDEyKSB8IDB4ZTApO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goKChjID4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKChjICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXlpZnkocmVzdWx0KTtcbn1cbjtcbmZ1bmN0aW9uIGVzY2FwZUNoYXIodmFsdWUpIHtcbiAgICBjb25zdCBoZXggPSAoXCIwMDAwXCIgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgIHJldHVybiBcIlxcXFx1XCIgKyBoZXguc3Vic3RyaW5nKGhleC5sZW5ndGggLSA0KTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdG9Fc2NhcGVkVXRmOFN0cmluZyhieXRlcywgb25FcnJvcikge1xuICAgIHJldHVybiAnXCInICsgZ2V0VXRmOENvZGVQb2ludHMoYnl0ZXMsIG9uRXJyb3IpLm1hcCgoY29kZVBvaW50KSA9PiB7XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAyNTYpIHtcbiAgICAgICAgICAgIHN3aXRjaCAoY29kZVBvaW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSA4OiByZXR1cm4gXCJcXFxcYlwiO1xuICAgICAgICAgICAgICAgIGNhc2UgOTogcmV0dXJuIFwiXFxcXHRcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDEwOiByZXR1cm4gXCJcXFxcblwiO1xuICAgICAgICAgICAgICAgIGNhc2UgMTM6IHJldHVybiBcIlxcXFxyXCI7XG4gICAgICAgICAgICAgICAgY2FzZSAzNDogcmV0dXJuIFwiXFxcXFxcXCJcIjtcbiAgICAgICAgICAgICAgICBjYXNlIDkyOiByZXR1cm4gXCJcXFxcXFxcXFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvZGVQb2ludCA+PSAzMiAmJiBjb2RlUG9pbnQgPCAxMjcpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPD0gMHhmZmZmKSB7XG4gICAgICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcihjb2RlUG9pbnQpO1xuICAgICAgICB9XG4gICAgICAgIGNvZGVQb2ludCAtPSAweDEwMDAwO1xuICAgICAgICByZXR1cm4gZXNjYXBlQ2hhcigoKGNvZGVQb2ludCA+PiAxMCkgJiAweDNmZikgKyAweGQ4MDApICsgZXNjYXBlQ2hhcigoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKTtcbiAgICB9KS5qb2luKFwiXCIpICsgJ1wiJztcbn1cbmV4cG9ydCBmdW5jdGlvbiBfdG9VdGY4U3RyaW5nKGNvZGVQb2ludHMpIHtcbiAgICByZXR1cm4gY29kZVBvaW50cy5tYXAoKGNvZGVQb2ludCkgPT4ge1xuICAgICAgICBpZiAoY29kZVBvaW50IDw9IDB4ZmZmZikge1xuICAgICAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoY29kZVBvaW50KTtcbiAgICAgICAgfVxuICAgICAgICBjb2RlUG9pbnQgLT0gMHgxMDAwMDtcbiAgICAgICAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUoKCgoY29kZVBvaW50ID4+IDEwKSAmIDB4M2ZmKSArIDB4ZDgwMCksICgoY29kZVBvaW50ICYgMHgzZmYpICsgMHhkYzAwKSk7XG4gICAgfSkuam9pbihcIlwiKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiB0b1V0ZjhTdHJpbmcoYnl0ZXMsIG9uRXJyb3IpIHtcbiAgICByZXR1cm4gX3RvVXRmOFN0cmluZyhnZXRVdGY4Q29kZVBvaW50cyhieXRlcywgb25FcnJvcikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHRvVXRmOENvZGVQb2ludHMoc3RyLCBmb3JtID0gVW5pY29kZU5vcm1hbGl6YXRpb25Gb3JtLmN1cnJlbnQpIHtcbiAgICByZXR1cm4gZ2V0VXRmOENvZGVQb2ludHModG9VdGY4Qnl0ZXMoc3RyLCBmb3JtKSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11dGY4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJ0cmFuc2FjdGlvbnMvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBhcnJheWlmeSwgaGV4Q29uY2F0LCBoZXhEYXRhTGVuZ3RoLCBoZXhEYXRhU2xpY2UsIGhleGxpZnksIGhleFplcm9QYWQsIGlzQnl0ZXNMaWtlLCBzcGxpdFNpZ25hdHVyZSwgc3RyaXBaZXJvcywgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IFplcm8gfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvY29uc3RhbnRzXCI7XG5pbXBvcnQgeyBrZWNjYWsyNTYgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qva2VjY2FrMjU2XCI7XG5pbXBvcnQgeyBjaGVja1Byb3BlcnRpZXMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUkxQIGZyb20gXCJAZXRoZXJzcHJvamVjdC9ybHBcIjtcbmltcG9ydCB7IGNvbXB1dGVQdWJsaWNLZXksIHJlY292ZXJQdWJsaWNLZXkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXlcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmV4cG9ydCB2YXIgVHJhbnNhY3Rpb25UeXBlcztcbihmdW5jdGlvbiAoVHJhbnNhY3Rpb25UeXBlcykge1xuICAgIFRyYW5zYWN0aW9uVHlwZXNbVHJhbnNhY3Rpb25UeXBlc1tcImxlZ2FjeVwiXSA9IDBdID0gXCJsZWdhY3lcIjtcbiAgICBUcmFuc2FjdGlvblR5cGVzW1RyYW5zYWN0aW9uVHlwZXNbXCJlaXAyOTMwXCJdID0gMV0gPSBcImVpcDI5MzBcIjtcbiAgICBUcmFuc2FjdGlvblR5cGVzW1RyYW5zYWN0aW9uVHlwZXNbXCJlaXAxNTU5XCJdID0gMl0gPSBcImVpcDE1NTlcIjtcbn0pKFRyYW5zYWN0aW9uVHlwZXMgfHwgKFRyYW5zYWN0aW9uVHlwZXMgPSB7fSkpO1xuO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuZnVuY3Rpb24gaGFuZGxlQWRkcmVzcyh2YWx1ZSkge1xuICAgIGlmICh2YWx1ZSA9PT0gXCIweFwiKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZ2V0QWRkcmVzcyh2YWx1ZSk7XG59XG5mdW5jdGlvbiBoYW5kbGVOdW1iZXIodmFsdWUpIHtcbiAgICBpZiAodmFsdWUgPT09IFwiMHhcIikge1xuICAgICAgICByZXR1cm4gWmVybztcbiAgICB9XG4gICAgcmV0dXJuIEJpZ051bWJlci5mcm9tKHZhbHVlKTtcbn1cbi8vIExlZ2FjeSBUcmFuc2FjdGlvbiBGaWVsZHNcbmNvbnN0IHRyYW5zYWN0aW9uRmllbGRzID0gW1xuICAgIHsgbmFtZTogXCJub25jZVwiLCBtYXhMZW5ndGg6IDMyLCBudW1lcmljOiB0cnVlIH0sXG4gICAgeyBuYW1lOiBcImdhc1ByaWNlXCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcbiAgICB7IG5hbWU6IFwiZ2FzTGltaXRcIiwgbWF4TGVuZ3RoOiAzMiwgbnVtZXJpYzogdHJ1ZSB9LFxuICAgIHsgbmFtZTogXCJ0b1wiLCBsZW5ndGg6IDIwIH0sXG4gICAgeyBuYW1lOiBcInZhbHVlXCIsIG1heExlbmd0aDogMzIsIG51bWVyaWM6IHRydWUgfSxcbiAgICB7IG5hbWU6IFwiZGF0YVwiIH0sXG5dO1xuY29uc3QgYWxsb3dlZFRyYW5zYWN0aW9uS2V5cyA9IHtcbiAgICBjaGFpbklkOiB0cnVlLCBkYXRhOiB0cnVlLCBnYXNMaW1pdDogdHJ1ZSwgZ2FzUHJpY2U6IHRydWUsIG5vbmNlOiB0cnVlLCB0bzogdHJ1ZSwgdHlwZTogdHJ1ZSwgdmFsdWU6IHRydWVcbn07XG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZUFkZHJlc3Moa2V5KSB7XG4gICAgY29uc3QgcHVibGljS2V5ID0gY29tcHV0ZVB1YmxpY0tleShrZXkpO1xuICAgIHJldHVybiBnZXRBZGRyZXNzKGhleERhdGFTbGljZShrZWNjYWsyNTYoaGV4RGF0YVNsaWNlKHB1YmxpY0tleSwgMSkpLCAxMikpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHJlY292ZXJBZGRyZXNzKGRpZ2VzdCwgc2lnbmF0dXJlKSB7XG4gICAgcmV0dXJuIGNvbXB1dGVBZGRyZXNzKHJlY292ZXJQdWJsaWNLZXkoYXJyYXlpZnkoZGlnZXN0KSwgc2lnbmF0dXJlKSk7XG59XG5mdW5jdGlvbiBmb3JtYXROdW1iZXIodmFsdWUsIG5hbWUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBzdHJpcFplcm9zKEJpZ051bWJlci5mcm9tKHZhbHVlKS50b0hleFN0cmluZygpKTtcbiAgICBpZiAocmVzdWx0Lmxlbmd0aCA+IDMyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGxlbmd0aCBmb3IgXCIgKyBuYW1lLCAoXCJ0cmFuc2FjdGlvbjpcIiArIG5hbWUpLCB2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBhY2Nlc3NTZXRpZnkoYWRkciwgc3RvcmFnZUtleXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBhZGRyZXNzOiBnZXRBZGRyZXNzKGFkZHIpLFxuICAgICAgICBzdG9yYWdlS2V5czogKHN0b3JhZ2VLZXlzIHx8IFtdKS5tYXAoKHN0b3JhZ2VLZXksIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaGV4RGF0YUxlbmd0aChzdG9yYWdlS2V5KSAhPT0gMzIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBhY2Nlc3MgbGlzdCBzdG9yYWdlS2V5XCIsIGBhY2Nlc3NMaXN0WyR7YWRkcn06JHtpbmRleH1dYCwgc3RvcmFnZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gc3RvcmFnZUtleS50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB9KVxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gYWNjZXNzTGlzdGlmeSh2YWx1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubWFwKChzZXQsIGluZGV4KSA9PiB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShzZXQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKHNldC5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJhY2Nlc3MgbGlzdCBleHBlY3RlZCB0byBiZSBbIGFkZHJlc3MsIHN0b3JhZ2VLZXlzW10gXVwiLCBgdmFsdWVbJHtpbmRleH1dYCwgc2V0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGFjY2Vzc1NldGlmeShzZXRbMF0sIHNldFsxXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KHNldC5hZGRyZXNzLCBzZXQuc3RvcmFnZUtleXMpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gT2JqZWN0LmtleXModmFsdWUpLm1hcCgoYWRkcikgPT4ge1xuICAgICAgICBjb25zdCBzdG9yYWdlS2V5cyA9IHZhbHVlW2FkZHJdLnJlZHVjZSgoYWNjdW0sIHN0b3JhZ2VLZXkpID0+IHtcbiAgICAgICAgICAgIGFjY3VtW3N0b3JhZ2VLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIHJldHVybiBhY2N1bTtcbiAgICAgICAgfSwge30pO1xuICAgICAgICByZXR1cm4gYWNjZXNzU2V0aWZ5KGFkZHIsIE9iamVjdC5rZXlzKHN0b3JhZ2VLZXlzKS5zb3J0KCkpO1xuICAgIH0pO1xuICAgIHJlc3VsdC5zb3J0KChhLCBiKSA9PiAoYS5hZGRyZXNzLmxvY2FsZUNvbXBhcmUoYi5hZGRyZXNzKSkpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBmb3JtYXRBY2Nlc3NMaXN0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGFjY2Vzc0xpc3RpZnkodmFsdWUpLm1hcCgoc2V0KSA9PiBbc2V0LmFkZHJlc3MsIHNldC5zdG9yYWdlS2V5c10pO1xufVxuZnVuY3Rpb24gX3NlcmlhbGl6ZUVpcDE1NTkodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSkge1xuICAgIC8vIElmIHRoZXJlIGlzIGFuIGV4cGxpY2l0IGdhc1ByaWNlLCBtYWtlIHN1cmUgaXQgbWF0Y2hlcyB0aGVcbiAgICAvLyBFSVAtMTU1OSBmZWVzOyBvdGhlcndpc2UgdGhleSBtYXkgbm90IHVuZGVyc3RhbmQgd2hhdCB0aGV5XG4gICAgLy8gdGhpbmsgdGhleSBhcmUgc2V0dGluZyBpbiB0ZXJtcyBvZiBmZWUuXG4gICAgaWYgKHRyYW5zYWN0aW9uLmdhc1ByaWNlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgZ2FzUHJpY2UgPSBCaWdOdW1iZXIuZnJvbSh0cmFuc2FjdGlvbi5nYXNQcmljZSk7XG4gICAgICAgIGNvbnN0IG1heEZlZVBlckdhcyA9IEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uLm1heEZlZVBlckdhcyB8fCAwKTtcbiAgICAgICAgaWYgKCFnYXNQcmljZS5lcShtYXhGZWVQZXJHYXMpKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwibWlzbWF0Y2ggRUlQLTE1NTkgZ2FzUHJpY2UgIT0gbWF4RmVlUGVyR2FzXCIsIFwidHhcIiwge1xuICAgICAgICAgICAgICAgIGdhc1ByaWNlLCBtYXhGZWVQZXJHYXNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGZpZWxkcyA9IFtcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLmNoYWluSWQgfHwgMCwgXCJjaGFpbklkXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24ubm9uY2UgfHwgMCwgXCJub25jZVwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm1heFByaW9yaXR5RmVlUGVyR2FzIHx8IDAsIFwibWF4UHJpb3JpdHlGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5tYXhGZWVQZXJHYXMgfHwgMCwgXCJtYXhGZWVQZXJHYXNcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5nYXNMaW1pdCB8fCAwLCBcImdhc0xpbWl0XCIpLFxuICAgICAgICAoKHRyYW5zYWN0aW9uLnRvICE9IG51bGwpID8gZ2V0QWRkcmVzcyh0cmFuc2FjdGlvbi50bykgOiBcIjB4XCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24udmFsdWUgfHwgMCwgXCJ2YWx1ZVwiKSxcbiAgICAgICAgKHRyYW5zYWN0aW9uLmRhdGEgfHwgXCIweFwiKSxcbiAgICAgICAgKGZvcm1hdEFjY2Vzc0xpc3QodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCB8fCBbXSkpXG4gICAgXTtcbiAgICBpZiAoc2lnbmF0dXJlKSB7XG4gICAgICAgIGNvbnN0IHNpZyA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKGZvcm1hdE51bWJlcihzaWcucmVjb3ZlcnlQYXJhbSwgXCJyZWNvdmVyeVBhcmFtXCIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goc3RyaXBaZXJvcyhzaWcucikpO1xuICAgICAgICBmaWVsZHMucHVzaChzdHJpcFplcm9zKHNpZy5zKSk7XG4gICAgfVxuICAgIHJldHVybiBoZXhDb25jYXQoW1wiMHgwMlwiLCBSTFAuZW5jb2RlKGZpZWxkcyldKTtcbn1cbmZ1bmN0aW9uIF9zZXJpYWxpemVFaXAyOTMwKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5jaGFpbklkIHx8IDAsIFwiY2hhaW5JZFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLm5vbmNlIHx8IDAsIFwibm9uY2VcIiksXG4gICAgICAgIGZvcm1hdE51bWJlcih0cmFuc2FjdGlvbi5nYXNQcmljZSB8fCAwLCBcImdhc1ByaWNlXCIpLFxuICAgICAgICBmb3JtYXROdW1iZXIodHJhbnNhY3Rpb24uZ2FzTGltaXQgfHwgMCwgXCJnYXNMaW1pdFwiKSxcbiAgICAgICAgKCh0cmFuc2FjdGlvbi50byAhPSBudWxsKSA/IGdldEFkZHJlc3ModHJhbnNhY3Rpb24udG8pIDogXCIweFwiKSxcbiAgICAgICAgZm9ybWF0TnVtYmVyKHRyYW5zYWN0aW9uLnZhbHVlIHx8IDAsIFwidmFsdWVcIiksXG4gICAgICAgICh0cmFuc2FjdGlvbi5kYXRhIHx8IFwiMHhcIiksXG4gICAgICAgIChmb3JtYXRBY2Nlc3NMaXN0KHRyYW5zYWN0aW9uLmFjY2Vzc0xpc3QgfHwgW10pKVxuICAgIF07XG4gICAgaWYgKHNpZ25hdHVyZSkge1xuICAgICAgICBjb25zdCBzaWcgPSBzcGxpdFNpZ25hdHVyZShzaWduYXR1cmUpO1xuICAgICAgICBmaWVsZHMucHVzaChmb3JtYXROdW1iZXIoc2lnLnJlY292ZXJ5UGFyYW0sIFwicmVjb3ZlcnlQYXJhbVwiKSk7XG4gICAgICAgIGZpZWxkcy5wdXNoKHN0cmlwWmVyb3Moc2lnLnIpKTtcbiAgICAgICAgZmllbGRzLnB1c2goc3RyaXBaZXJvcyhzaWcucykpO1xuICAgIH1cbiAgICByZXR1cm4gaGV4Q29uY2F0KFtcIjB4MDFcIiwgUkxQLmVuY29kZShmaWVsZHMpXSk7XG59XG4vLyBMZWdhY3kgVHJhbnNhY3Rpb25zIGFuZCBFSVAtMTU1XG5mdW5jdGlvbiBfc2VyaWFsaXplKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpIHtcbiAgICBjaGVja1Byb3BlcnRpZXModHJhbnNhY3Rpb24sIGFsbG93ZWRUcmFuc2FjdGlvbktleXMpO1xuICAgIGNvbnN0IHJhdyA9IFtdO1xuICAgIHRyYW5zYWN0aW9uRmllbGRzLmZvckVhY2goZnVuY3Rpb24gKGZpZWxkSW5mbykge1xuICAgICAgICBsZXQgdmFsdWUgPSB0cmFuc2FjdGlvbltmaWVsZEluZm8ubmFtZV0gfHwgKFtdKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHt9O1xuICAgICAgICBpZiAoZmllbGRJbmZvLm51bWVyaWMpIHtcbiAgICAgICAgICAgIG9wdGlvbnMuaGV4UGFkID0gXCJsZWZ0XCI7XG4gICAgICAgIH1cbiAgICAgICAgdmFsdWUgPSBhcnJheWlmeShoZXhsaWZ5KHZhbHVlLCBvcHRpb25zKSk7XG4gICAgICAgIC8vIEZpeGVkLXdpZHRoIGZpZWxkXG4gICAgICAgIGlmIChmaWVsZEluZm8ubGVuZ3RoICYmIHZhbHVlLmxlbmd0aCAhPT0gZmllbGRJbmZvLmxlbmd0aCAmJiB2YWx1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBsZW5ndGggZm9yIFwiICsgZmllbGRJbmZvLm5hbWUsIChcInRyYW5zYWN0aW9uOlwiICsgZmllbGRJbmZvLm5hbWUpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVmFyaWFibGUtd2lkdGggKHdpdGggYSBtYXhpbXVtKVxuICAgICAgICBpZiAoZmllbGRJbmZvLm1heExlbmd0aCkge1xuICAgICAgICAgICAgdmFsdWUgPSBzdHJpcFplcm9zKHZhbHVlKTtcbiAgICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiBmaWVsZEluZm8ubWF4TGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgbGVuZ3RoIGZvciBcIiArIGZpZWxkSW5mby5uYW1lLCAoXCJ0cmFuc2FjdGlvbjpcIiArIGZpZWxkSW5mby5uYW1lKSwgdmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJhdy5wdXNoKGhleGxpZnkodmFsdWUpKTtcbiAgICB9KTtcbiAgICBsZXQgY2hhaW5JZCA9IDA7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmNoYWluSWQgIT0gbnVsbCkge1xuICAgICAgICAvLyBBIGNoYWluSWQgd2FzIHByb3ZpZGVkOyBpZiBub24temVybyB3ZSdsbCB1c2UgRUlQLTE1NVxuICAgICAgICBjaGFpbklkID0gdHJhbnNhY3Rpb24uY2hhaW5JZDtcbiAgICAgICAgaWYgKHR5cGVvZiAoY2hhaW5JZCkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIHRyYW5zYWN0aW9uLmNoYWluSWRcIiwgXCJ0cmFuc2FjdGlvblwiLCB0cmFuc2FjdGlvbik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAoc2lnbmF0dXJlICYmICFpc0J5dGVzTGlrZShzaWduYXR1cmUpICYmIHNpZ25hdHVyZS52ID4gMjgpIHtcbiAgICAgICAgLy8gTm8gY2hhaW5JZCBwcm92aWRlZCwgYnV0IHRoZSBzaWduYXR1cmUgaXMgc2lnbmluZyB3aXRoIEVJUC0xNTU7IGRlcml2ZSBjaGFpbklkXG4gICAgICAgIGNoYWluSWQgPSBNYXRoLmZsb29yKChzaWduYXR1cmUudiAtIDM1KSAvIDIpO1xuICAgIH1cbiAgICAvLyBXZSBoYXZlIGFuIEVJUC0xNTUgdHJhbnNhY3Rpb24gKGNoYWluSWQgd2FzIHNwZWNpZmllZCBhbmQgbm9uLXplcm8pXG4gICAgaWYgKGNoYWluSWQgIT09IDApIHtcbiAgICAgICAgcmF3LnB1c2goaGV4bGlmeShjaGFpbklkKSk7IC8vIEBUT0RPOiBoZXhWYWx1ZT9cbiAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcbiAgICAgICAgcmF3LnB1c2goXCIweFwiKTtcbiAgICB9XG4gICAgLy8gUmVxdWVzdGluZyBhbiB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgIGlmICghc2lnbmF0dXJlKSB7XG4gICAgICAgIHJldHVybiBSTFAuZW5jb2RlKHJhdyk7XG4gICAgfVxuICAgIC8vIFRoZSBzcGxpdFNpZ25hdHVyZSB3aWxsIGVuc3VyZSB0aGUgdHJhbnNhY3Rpb24gaGFzIGEgcmVjb3ZlcnlQYXJhbSBpbiB0aGVcbiAgICAvLyBjYXNlIHRoYXQgdGhlIHNpZ25UcmFuc2FjdGlvbiBmdW5jdGlvbiBvbmx5IGFkZHMgYSB2LlxuICAgIGNvbnN0IHNpZyA9IHNwbGl0U2lnbmF0dXJlKHNpZ25hdHVyZSk7XG4gICAgLy8gV2UgcHVzaGVkIGEgY2hhaW5JZCBhbmQgbnVsbCByLCBzIG9uIGZvciBoYXNoaW5nIG9ubHk7IHJlbW92ZSB0aG9zZVxuICAgIGxldCB2ID0gMjcgKyBzaWcucmVjb3ZlcnlQYXJhbTtcbiAgICBpZiAoY2hhaW5JZCAhPT0gMCkge1xuICAgICAgICByYXcucG9wKCk7XG4gICAgICAgIHJhdy5wb3AoKTtcbiAgICAgICAgcmF3LnBvcCgpO1xuICAgICAgICB2ICs9IGNoYWluSWQgKiAyICsgODtcbiAgICAgICAgLy8gSWYgYW4gRUlQLTE1NSB2IChkaXJlY3RseSBvciBpbmRpcmVjdGx5OyBtYXliZSBfdnMpIHdhcyBwcm92aWRlZCwgY2hlY2sgaXQhXG4gICAgICAgIGlmIChzaWcudiA+IDI4ICYmIHNpZy52ICE9PSB2KSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidHJhbnNhY3Rpb24uY2hhaW5JZC9zaWduYXR1cmUudiBtaXNtYXRjaFwiLCBcInNpZ25hdHVyZVwiLCBzaWduYXR1cmUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGVsc2UgaWYgKHNpZy52ICE9PSB2KSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJ0cmFuc2FjdGlvbi5jaGFpbklkL3NpZ25hdHVyZS52IG1pc21hdGNoXCIsIFwic2lnbmF0dXJlXCIsIHNpZ25hdHVyZSk7XG4gICAgfVxuICAgIHJhdy5wdXNoKGhleGxpZnkodikpO1xuICAgIHJhdy5wdXNoKHN0cmlwWmVyb3MoYXJyYXlpZnkoc2lnLnIpKSk7XG4gICAgcmF3LnB1c2goc3RyaXBaZXJvcyhhcnJheWlmeShzaWcucykpKTtcbiAgICByZXR1cm4gUkxQLmVuY29kZShyYXcpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNlcmlhbGl6ZSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKSB7XG4gICAgLy8gTGVnYWN5IGFuZCBFSVAtMTU1IFRyYW5zYWN0aW9uc1xuICAgIGlmICh0cmFuc2FjdGlvbi50eXBlID09IG51bGwgfHwgdHJhbnNhY3Rpb24udHlwZSA9PT0gMCkge1xuICAgICAgICBpZiAodHJhbnNhY3Rpb24uYWNjZXNzTGlzdCAhPSBudWxsKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW50eXBlZCB0cmFuc2FjdGlvbnMgZG8gbm90IHN1cHBvcnQgYWNjZXNzTGlzdDsgaW5jbHVkZSB0eXBlOiAxXCIsIFwidHJhbnNhY3Rpb25cIiwgdHJhbnNhY3Rpb24pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBfc2VyaWFsaXplKHRyYW5zYWN0aW9uLCBzaWduYXR1cmUpO1xuICAgIH1cbiAgICAvLyBUeXBlZCBUcmFuc2FjdGlvbnMgKEVJUC0yNzE4KVxuICAgIHN3aXRjaCAodHJhbnNhY3Rpb24udHlwZSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICByZXR1cm4gX3NlcmlhbGl6ZUVpcDI5MzAodHJhbnNhY3Rpb24sIHNpZ25hdHVyZSk7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIHJldHVybiBfc2VyaWFsaXplRWlwMTU1OSh0cmFuc2FjdGlvbiwgc2lnbmF0dXJlKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYHVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGU6ICR7dHJhbnNhY3Rpb24udHlwZX1gLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICBvcGVyYXRpb246IFwic2VyaWFsaXplVHJhbnNhY3Rpb25cIixcbiAgICAgICAgdHJhbnNhY3Rpb25UeXBlOiB0cmFuc2FjdGlvbi50eXBlXG4gICAgfSk7XG59XG5mdW5jdGlvbiBfcGFyc2VFaXBTaWduYXR1cmUodHgsIGZpZWxkcywgc2VyaWFsaXplKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgY29uc3QgcmVjaWQgPSBoYW5kbGVOdW1iZXIoZmllbGRzWzBdKS50b051bWJlcigpO1xuICAgICAgICBpZiAocmVjaWQgIT09IDAgJiYgcmVjaWQgIT09IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImJhZCByZWNpZFwiKTtcbiAgICAgICAgfVxuICAgICAgICB0eC52ID0gcmVjaWQ7XG4gICAgfVxuICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCB2IGZvciB0cmFuc2FjdGlvbiB0eXBlOiAxXCIsIFwidlwiLCBmaWVsZHNbMF0pO1xuICAgIH1cbiAgICB0eC5yID0gaGV4WmVyb1BhZChmaWVsZHNbMV0sIDMyKTtcbiAgICB0eC5zID0gaGV4WmVyb1BhZChmaWVsZHNbMl0sIDMyKTtcbiAgICB0cnkge1xuICAgICAgICBjb25zdCBkaWdlc3QgPSBrZWNjYWsyNTYoc2VyaWFsaXplKHR4KSk7XG4gICAgICAgIHR4LmZyb20gPSByZWNvdmVyQWRkcmVzcyhkaWdlc3QsIHsgcjogdHguciwgczogdHgucywgcmVjb3ZlcnlQYXJhbTogdHgudiB9KTtcbiAgICB9XG4gICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKGVycm9yKTtcbiAgICB9XG59XG5mdW5jdGlvbiBfcGFyc2VFaXAxNTU5KHBheWxvYWQpIHtcbiAgICBjb25zdCB0cmFuc2FjdGlvbiA9IFJMUC5kZWNvZGUocGF5bG9hZC5zbGljZSgxKSk7XG4gICAgaWYgKHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gOSAmJiB0cmFuc2FjdGlvbi5sZW5ndGggIT09IDEyKSB7XG4gICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJpbnZhbGlkIGNvbXBvbmVudCBjb3VudCBmb3IgdHJhbnNhY3Rpb24gdHlwZTogMlwiLCBcInBheWxvYWRcIiwgaGV4bGlmeShwYXlsb2FkKSk7XG4gICAgfVxuICAgIGNvbnN0IG1heFByaW9yaXR5RmVlUGVyR2FzID0gaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzJdKTtcbiAgICBjb25zdCBtYXhGZWVQZXJHYXMgPSBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bM10pO1xuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICB0eXBlOiAyLFxuICAgICAgICBjaGFpbklkOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMF0pLnRvTnVtYmVyKCksXG4gICAgICAgIG5vbmNlOiBoYW5kbGVOdW1iZXIodHJhbnNhY3Rpb25bMV0pLnRvTnVtYmVyKCksXG4gICAgICAgIG1heFByaW9yaXR5RmVlUGVyR2FzOiBtYXhQcmlvcml0eUZlZVBlckdhcyxcbiAgICAgICAgbWF4RmVlUGVyR2FzOiBtYXhGZWVQZXJHYXMsXG4gICAgICAgIGdhc1ByaWNlOiBudWxsLFxuICAgICAgICBnYXNMaW1pdDogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzRdKSxcbiAgICAgICAgdG86IGhhbmRsZUFkZHJlc3ModHJhbnNhY3Rpb25bNV0pLFxuICAgICAgICB2YWx1ZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzZdKSxcbiAgICAgICAgZGF0YTogdHJhbnNhY3Rpb25bN10sXG4gICAgICAgIGFjY2Vzc0xpc3Q6IGFjY2Vzc0xpc3RpZnkodHJhbnNhY3Rpb25bOF0pLFxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTE1NTkgVHJhbnNhY3Rpb25cbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoID09PSA5KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguaGFzaCA9IGtlY2NhazI1NihwYXlsb2FkKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIHRyYW5zYWN0aW9uLnNsaWNlKDkpLCBfc2VyaWFsaXplRWlwMTU1OSk7XG4gICAgcmV0dXJuIHR4O1xufVxuZnVuY3Rpb24gX3BhcnNlRWlwMjkzMChwYXlsb2FkKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHBheWxvYWQuc2xpY2UoMSkpO1xuICAgIGlmICh0cmFuc2FjdGlvbi5sZW5ndGggIT09IDggJiYgdHJhbnNhY3Rpb24ubGVuZ3RoICE9PSAxMSkge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCBjb21wb25lbnQgY291bnQgZm9yIHRyYW5zYWN0aW9uIHR5cGU6IDFcIiwgXCJwYXlsb2FkXCIsIGhleGxpZnkocGF5bG9hZCkpO1xuICAgIH1cbiAgICBjb25zdCB0eCA9IHtcbiAgICAgICAgdHlwZTogMSxcbiAgICAgICAgY2hhaW5JZDogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzBdKS50b051bWJlcigpLFxuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKS50b051bWJlcigpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzJdKSxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblszXSksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzRdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls1XSksXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzZdLFxuICAgICAgICBhY2Nlc3NMaXN0OiBhY2Nlc3NMaXN0aWZ5KHRyYW5zYWN0aW9uWzddKVxuICAgIH07XG4gICAgLy8gVW5zaWduZWQgRUlQLTI5MzAgVHJhbnNhY3Rpb25cbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoID09PSA4KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHguaGFzaCA9IGtlY2NhazI1NihwYXlsb2FkKTtcbiAgICBfcGFyc2VFaXBTaWduYXR1cmUodHgsIHRyYW5zYWN0aW9uLnNsaWNlKDgpLCBfc2VyaWFsaXplRWlwMjkzMCk7XG4gICAgcmV0dXJuIHR4O1xufVxuLy8gTGVnYWN5IFRyYW5zYWN0aW9ucyBhbmQgRUlQLTE1NVxuZnVuY3Rpb24gX3BhcnNlKHJhd1RyYW5zYWN0aW9uKSB7XG4gICAgY29uc3QgdHJhbnNhY3Rpb24gPSBSTFAuZGVjb2RlKHJhd1RyYW5zYWN0aW9uKTtcbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoICE9PSA5ICYmIHRyYW5zYWN0aW9uLmxlbmd0aCAhPT0gNikge1xuICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwiaW52YWxpZCByYXcgdHJhbnNhY3Rpb25cIiwgXCJyYXdUcmFuc2FjdGlvblwiLCByYXdUcmFuc2FjdGlvbik7XG4gICAgfVxuICAgIGNvbnN0IHR4ID0ge1xuICAgICAgICBub25jZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzBdKS50b051bWJlcigpLFxuICAgICAgICBnYXNQcmljZTogaGFuZGxlTnVtYmVyKHRyYW5zYWN0aW9uWzFdKSxcbiAgICAgICAgZ2FzTGltaXQ6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvblsyXSksXG4gICAgICAgIHRvOiBoYW5kbGVBZGRyZXNzKHRyYW5zYWN0aW9uWzNdKSxcbiAgICAgICAgdmFsdWU6IGhhbmRsZU51bWJlcih0cmFuc2FjdGlvbls0XSksXG4gICAgICAgIGRhdGE6IHRyYW5zYWN0aW9uWzVdLFxuICAgICAgICBjaGFpbklkOiAwXG4gICAgfTtcbiAgICAvLyBMZWdhY3kgdW5zaWduZWQgdHJhbnNhY3Rpb25cbiAgICBpZiAodHJhbnNhY3Rpb24ubGVuZ3RoID09PSA2KSB7XG4gICAgICAgIHJldHVybiB0eDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgdHgudiA9IEJpZ051bWJlci5mcm9tKHRyYW5zYWN0aW9uWzZdKS50b051bWJlcigpO1xuICAgIH1cbiAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29uc29sZS5sb2coZXJyb3IpO1xuICAgICAgICByZXR1cm4gdHg7XG4gICAgfVxuICAgIHR4LnIgPSBoZXhaZXJvUGFkKHRyYW5zYWN0aW9uWzddLCAzMik7XG4gICAgdHgucyA9IGhleFplcm9QYWQodHJhbnNhY3Rpb25bOF0sIDMyKTtcbiAgICBpZiAoQmlnTnVtYmVyLmZyb20odHgucikuaXNaZXJvKCkgJiYgQmlnTnVtYmVyLmZyb20odHgucykuaXNaZXJvKCkpIHtcbiAgICAgICAgLy8gRUlQLTE1NSB1bnNpZ25lZCB0cmFuc2FjdGlvblxuICAgICAgICB0eC5jaGFpbklkID0gdHgudjtcbiAgICAgICAgdHgudiA9IDA7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICAvLyBTaWduZWQgVHJhbnNhY3Rpb25cbiAgICAgICAgdHguY2hhaW5JZCA9IE1hdGguZmxvb3IoKHR4LnYgLSAzNSkgLyAyKTtcbiAgICAgICAgaWYgKHR4LmNoYWluSWQgPCAwKSB7XG4gICAgICAgICAgICB0eC5jaGFpbklkID0gMDtcbiAgICAgICAgfVxuICAgICAgICBsZXQgcmVjb3ZlcnlQYXJhbSA9IHR4LnYgLSAyNztcbiAgICAgICAgY29uc3QgcmF3ID0gdHJhbnNhY3Rpb24uc2xpY2UoMCwgNik7XG4gICAgICAgIGlmICh0eC5jaGFpbklkICE9PSAwKSB7XG4gICAgICAgICAgICByYXcucHVzaChoZXhsaWZ5KHR4LmNoYWluSWQpKTtcbiAgICAgICAgICAgIHJhdy5wdXNoKFwiMHhcIik7XG4gICAgICAgICAgICByYXcucHVzaChcIjB4XCIpO1xuICAgICAgICAgICAgcmVjb3ZlcnlQYXJhbSAtPSB0eC5jaGFpbklkICogMiArIDg7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGlnZXN0ID0ga2VjY2FrMjU2KFJMUC5lbmNvZGUocmF3KSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0eC5mcm9tID0gcmVjb3ZlckFkZHJlc3MoZGlnZXN0LCB7IHI6IGhleGxpZnkodHguciksIHM6IGhleGxpZnkodHgucyksIHJlY292ZXJ5UGFyYW06IHJlY292ZXJ5UGFyYW0gfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmxvZyhlcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgdHguaGFzaCA9IGtlY2NhazI1NihyYXdUcmFuc2FjdGlvbik7XG4gICAgfVxuICAgIHR4LnR5cGUgPSBudWxsO1xuICAgIHJldHVybiB0eDtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwYXJzZShyYXdUcmFuc2FjdGlvbikge1xuICAgIGNvbnN0IHBheWxvYWQgPSBhcnJheWlmeShyYXdUcmFuc2FjdGlvbik7XG4gICAgLy8gTGVnYWN5IGFuZCBFSVAtMTU1IFRyYW5zYWN0aW9uc1xuICAgIGlmIChwYXlsb2FkWzBdID4gMHg3Zikge1xuICAgICAgICByZXR1cm4gX3BhcnNlKHBheWxvYWQpO1xuICAgIH1cbiAgICAvLyBUeXBlZCBUcmFuc2FjdGlvbiAoRUlQLTI3MTgpXG4gICAgc3dpdGNoIChwYXlsb2FkWzBdKSB7XG4gICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIHJldHVybiBfcGFyc2VFaXAyOTMwKHBheWxvYWQpO1xuICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICByZXR1cm4gX3BhcnNlRWlwMTU1OShwYXlsb2FkKTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gbG9nZ2VyLnRocm93RXJyb3IoYHVuc3VwcG9ydGVkIHRyYW5zYWN0aW9uIHR5cGU6ICR7cGF5bG9hZFswXX1gLCBMb2dnZXIuZXJyb3JzLlVOU1VQUE9SVEVEX09QRVJBVElPTiwge1xuICAgICAgICBvcGVyYXRpb246IFwicGFyc2VUcmFuc2FjdGlvblwiLFxuICAgICAgICB0cmFuc2FjdGlvblR5cGU6IHBheWxvYWRbMF1cbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJ1bml0cy81LjUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5pbXBvcnQgeyBmb3JtYXRGaXhlZCwgcGFyc2VGaXhlZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iaWdudW1iZXJcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmNvbnN0IG5hbWVzID0gW1xuICAgIFwid2VpXCIsXG4gICAgXCJrd2VpXCIsXG4gICAgXCJtd2VpXCIsXG4gICAgXCJnd2VpXCIsXG4gICAgXCJzemFib1wiLFxuICAgIFwiZmlubmV5XCIsXG4gICAgXCJldGhlclwiLFxuXTtcbi8vIFNvbWUgZW52aXJvbm1lbnRzIGhhdmUgaXNzdWVzIHdpdGggUmVnRXggdGhhdCBjb250YWluIGJhY2stdHJhY2tpbmcsIHNvIHdlIGNhbm5vdFxuLy8gdXNlIHRoZW0uXG5leHBvcnQgZnVuY3Rpb24gY29tbWlmeSh2YWx1ZSkge1xuICAgIGNvbnN0IGNvbXBzID0gU3RyaW5nKHZhbHVlKS5zcGxpdChcIi5cIik7XG4gICAgaWYgKGNvbXBzLmxlbmd0aCA+IDIgfHwgIWNvbXBzWzBdLm1hdGNoKC9eLT9bMC05XSokLykgfHwgKGNvbXBzWzFdICYmICFjb21wc1sxXS5tYXRjaCgvXlswLTldKiQvKSkgfHwgdmFsdWUgPT09IFwiLlwiIHx8IHZhbHVlID09PSBcIi0uXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgdmFsdWVcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IG9uZSB3aG9sZSBkaWdpdCAoMCBpZiBub25lKVxuICAgIGxldCB3aG9sZSA9IGNvbXBzWzBdO1xuICAgIGxldCBuZWdhdGl2ZSA9IFwiXCI7XG4gICAgaWYgKHdob2xlLnN1YnN0cmluZygwLCAxKSA9PT0gXCItXCIpIHtcbiAgICAgICAgbmVnYXRpdmUgPSBcIi1cIjtcbiAgICAgICAgd2hvbGUgPSB3aG9sZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSB3ZSBoYXZlIGF0IGxlYXN0IDEgd2hvbGUgZGlnaXQgd2l0aCBubyBsZWFkaW5nIHplcm9zXG4gICAgd2hpbGUgKHdob2xlLnN1YnN0cmluZygwLCAxKSA9PT0gXCIwXCIpIHtcbiAgICAgICAgd2hvbGUgPSB3aG9sZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuICAgIGlmICh3aG9sZSA9PT0gXCJcIikge1xuICAgICAgICB3aG9sZSA9IFwiMFwiO1xuICAgIH1cbiAgICBsZXQgc3VmZml4ID0gXCJcIjtcbiAgICBpZiAoY29tcHMubGVuZ3RoID09PSAyKSB7XG4gICAgICAgIHN1ZmZpeCA9IFwiLlwiICsgKGNvbXBzWzFdIHx8IFwiMFwiKTtcbiAgICB9XG4gICAgd2hpbGUgKHN1ZmZpeC5sZW5ndGggPiAyICYmIHN1ZmZpeFtzdWZmaXgubGVuZ3RoIC0gMV0gPT09IFwiMFwiKSB7XG4gICAgICAgIHN1ZmZpeCA9IHN1ZmZpeC5zdWJzdHJpbmcoMCwgc3VmZml4Lmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBjb25zdCBmb3JtYXR0ZWQgPSBbXTtcbiAgICB3aGlsZSAod2hvbGUubGVuZ3RoKSB7XG4gICAgICAgIGlmICh3aG9sZS5sZW5ndGggPD0gMykge1xuICAgICAgICAgICAgZm9ybWF0dGVkLnVuc2hpZnQod2hvbGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IHdob2xlLmxlbmd0aCAtIDM7XG4gICAgICAgICAgICBmb3JtYXR0ZWQudW5zaGlmdCh3aG9sZS5zdWJzdHJpbmcoaW5kZXgpKTtcbiAgICAgICAgICAgIHdob2xlID0gd2hvbGUuc3Vic3RyaW5nKDAsIGluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmVnYXRpdmUgKyBmb3JtYXR0ZWQuam9pbihcIixcIikgKyBzdWZmaXg7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0VW5pdHModmFsdWUsIHVuaXROYW1lKSB7XG4gICAgaWYgKHR5cGVvZiAodW5pdE5hbWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIGNvbnN0IGluZGV4ID0gbmFtZXMuaW5kZXhPZih1bml0TmFtZSk7XG4gICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgIHVuaXROYW1lID0gMyAqIGluZGV4O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBmb3JtYXRGaXhlZCh2YWx1ZSwgKHVuaXROYW1lICE9IG51bGwpID8gdW5pdE5hbWUgOiAxOCk7XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VVbml0cyh2YWx1ZSwgdW5pdE5hbWUpIHtcbiAgICBpZiAodHlwZW9mICh2YWx1ZSkgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcInZhbHVlIG11c3QgYmUgYSBzdHJpbmdcIiwgXCJ2YWx1ZVwiLCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgKHVuaXROYW1lKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBpbmRleCA9IG5hbWVzLmluZGV4T2YodW5pdE5hbWUpO1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICB1bml0TmFtZSA9IDMgKiBpbmRleDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcGFyc2VGaXhlZCh2YWx1ZSwgKHVuaXROYW1lICE9IG51bGwpID8gdW5pdE5hbWUgOiAxOCk7XG59XG5leHBvcnQgZnVuY3Rpb24gZm9ybWF0RXRoZXIod2VpKSB7XG4gICAgcmV0dXJuIGZvcm1hdFVuaXRzKHdlaSwgMTgpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBhcnNlRXRoZXIoZXRoZXIpIHtcbiAgICByZXR1cm4gcGFyc2VVbml0cyhldGhlciwgMTgpO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiZXhwb3J0IGNvbnN0IHZlcnNpb24gPSBcIndhbGxldC81LjUuMFwiO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9X3ZlcnNpb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19hd2FpdGVyID0gKHRoaXMgJiYgdGhpcy5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcbmltcG9ydCB7IGdldEFkZHJlc3MgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWRkcmVzc1wiO1xuaW1wb3J0IHsgUHJvdmlkZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3QtcHJvdmlkZXJcIjtcbmltcG9ydCB7IFNpZ25lciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hYnN0cmFjdC1zaWduZXJcIjtcbmltcG9ydCB7IGFycmF5aWZ5LCBjb25jYXQsIGhleERhdGFTbGljZSwgaXNIZXhTdHJpbmcsIGpvaW5TaWduYXR1cmUgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmltcG9ydCB7IGhhc2hNZXNzYWdlLCBfVHlwZWREYXRhRW5jb2RlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oYXNoXCI7XG5pbXBvcnQgeyBkZWZhdWx0UGF0aCwgSEROb2RlLCBlbnRyb3B5VG9NbmVtb25pYyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oZG5vZGVcIjtcbmltcG9ydCB7IGtlY2NhazI1NiB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9rZWNjYWsyNTZcIjtcbmltcG9ydCB7IGRlZmluZVJlYWRPbmx5LCByZXNvbHZlUHJvcGVydGllcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyByYW5kb21CeXRlcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9yYW5kb21cIjtcbmltcG9ydCB7IFNpZ25pbmdLZXkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXlcIjtcbmltcG9ydCB7IGRlY3J5cHRKc29uV2FsbGV0LCBkZWNyeXB0SnNvbldhbGxldFN5bmMsIGVuY3J5cHRLZXlzdG9yZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9qc29uLXdhbGxldHNcIjtcbmltcG9ydCB7IGNvbXB1dGVBZGRyZXNzLCByZWNvdmVyQWRkcmVzcywgc2VyaWFsaXplIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3RyYW5zYWN0aW9uc1wiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgdmVyc2lvbiB9IGZyb20gXCIuL192ZXJzaW9uXCI7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZnVuY3Rpb24gaXNBY2NvdW50KHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSAhPSBudWxsICYmIGlzSGV4U3RyaW5nKHZhbHVlLnByaXZhdGVLZXksIDMyKSAmJiB2YWx1ZS5hZGRyZXNzICE9IG51bGwpO1xufVxuZnVuY3Rpb24gaGFzTW5lbW9uaWModmFsdWUpIHtcbiAgICBjb25zdCBtbmVtb25pYyA9IHZhbHVlLm1uZW1vbmljO1xuICAgIHJldHVybiAobW5lbW9uaWMgJiYgbW5lbW9uaWMucGhyYXNlKTtcbn1cbmV4cG9ydCBjbGFzcyBXYWxsZXQgZXh0ZW5kcyBTaWduZXIge1xuICAgIGNvbnN0cnVjdG9yKHByaXZhdGVLZXksIHByb3ZpZGVyKSB7XG4gICAgICAgIGxvZ2dlci5jaGVja05ldyhuZXcudGFyZ2V0LCBXYWxsZXQpO1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICBpZiAoaXNBY2NvdW50KHByaXZhdGVLZXkpKSB7XG4gICAgICAgICAgICBjb25zdCBzaWduaW5nS2V5ID0gbmV3IFNpZ25pbmdLZXkocHJpdmF0ZUtleS5wcml2YXRlS2V5KTtcbiAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3NpZ25pbmdLZXlcIiwgKCkgPT4gc2lnbmluZ0tleSk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgY29tcHV0ZUFkZHJlc3ModGhpcy5wdWJsaWNLZXkpKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmFkZHJlc3MgIT09IGdldEFkZHJlc3MocHJpdmF0ZUtleS5hZGRyZXNzKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJwcml2YXRlS2V5L2FkZHJlc3MgbWlzbWF0Y2hcIiwgXCJwcml2YXRlS2V5XCIsIFwiW1JFREFDVEVEXVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChoYXNNbmVtb25pYyhwcml2YXRlS2V5KSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNyY01uZW1vbmljID0gcHJpdmF0ZUtleS5tbmVtb25pYztcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9tbmVtb25pY1wiLCAoKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICBwaHJhc2U6IHNyY01uZW1vbmljLnBocmFzZSxcbiAgICAgICAgICAgICAgICAgICAgcGF0aDogc3JjTW5lbW9uaWMucGF0aCB8fCBkZWZhdWx0UGF0aCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxlOiBzcmNNbmVtb25pYy5sb2NhbGUgfHwgXCJlblwiXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG1uZW1vbmljID0gdGhpcy5tbmVtb25pYztcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gSEROb2RlLmZyb21NbmVtb25pYyhtbmVtb25pYy5waHJhc2UsIG51bGwsIG1uZW1vbmljLmxvY2FsZSkuZGVyaXZlUGF0aChtbmVtb25pYy5wYXRoKTtcbiAgICAgICAgICAgICAgICBpZiAoY29tcHV0ZUFkZHJlc3Mobm9kZS5wcml2YXRlS2V5KSAhPT0gdGhpcy5hZGRyZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0FyZ3VtZW50RXJyb3IoXCJtbmVtb25pYy9hZGRyZXNzIG1pc21hdGNoXCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbW5lbW9uaWNcIiwgKCkgPT4gbnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoU2lnbmluZ0tleS5pc1NpZ25pbmdLZXkocHJpdmF0ZUtleSkpIHtcbiAgICAgICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgICAgICBpZiAocHJpdmF0ZUtleS5jdXJ2ZSAhPT0gXCJzZWNwMjU2azFcIikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidW5zdXBwb3J0ZWQgY3VydmU7IG11c3QgYmUgc2VjcDI1NmsxXCIsIFwicHJpdmF0ZUtleVwiLCBcIltSRURBQ1RFRF1cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlZmluZVJlYWRPbmx5KHRoaXMsIFwiX3NpZ25pbmdLZXlcIiwgKCkgPT4gcHJpdmF0ZUtleSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvLyBBIGxvdCBvZiBjb21tb24gdG9vbHMgZG8gbm90IHByZWZpeCBwcml2YXRlIGtleXMgd2l0aCBhIDB4IChzZWU6ICMxMTY2KVxuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgKHByaXZhdGVLZXkpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwcml2YXRlS2V5Lm1hdGNoKC9eWzAtOWEtZl0qJC9pKSAmJiBwcml2YXRlS2V5Lmxlbmd0aCA9PT0gNjQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHByaXZhdGVLZXkgPSBcIjB4XCIgKyBwcml2YXRlS2V5O1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNpZ25pbmdLZXkgPSBuZXcgU2lnbmluZ0tleShwcml2YXRlS2V5KTtcbiAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcIl9zaWduaW5nS2V5XCIsICgpID0+IHNpZ25pbmdLZXkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJfbW5lbW9uaWNcIiwgKCkgPT4gbnVsbCk7XG4gICAgICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImFkZHJlc3NcIiwgY29tcHV0ZUFkZHJlc3ModGhpcy5wdWJsaWNLZXkpKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKHByb3ZpZGVyICYmICFQcm92aWRlci5pc1Byb3ZpZGVyKHByb3ZpZGVyKSkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcImludmFsaWQgcHJvdmlkZXJcIiwgXCJwcm92aWRlclwiLCBwcm92aWRlcik7XG4gICAgICAgIH1cbiAgICAgICAgZGVmaW5lUmVhZE9ubHkodGhpcywgXCJwcm92aWRlclwiLCBwcm92aWRlciB8fCBudWxsKTtcbiAgICB9XG4gICAgZ2V0IG1uZW1vbmljKCkgeyByZXR1cm4gdGhpcy5fbW5lbW9uaWMoKTsgfVxuICAgIGdldCBwcml2YXRlS2V5KCkgeyByZXR1cm4gdGhpcy5fc2lnbmluZ0tleSgpLnByaXZhdGVLZXk7IH1cbiAgICBnZXQgcHVibGljS2V5KCkgeyByZXR1cm4gdGhpcy5fc2lnbmluZ0tleSgpLnB1YmxpY0tleTsgfVxuICAgIGdldEFkZHJlc3MoKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUodGhpcy5hZGRyZXNzKTtcbiAgICB9XG4gICAgY29ubmVjdChwcm92aWRlcikge1xuICAgICAgICByZXR1cm4gbmV3IFdhbGxldCh0aGlzLCBwcm92aWRlcik7XG4gICAgfVxuICAgIHNpZ25UcmFuc2FjdGlvbih0cmFuc2FjdGlvbikge1xuICAgICAgICByZXR1cm4gcmVzb2x2ZVByb3BlcnRpZXModHJhbnNhY3Rpb24pLnRoZW4oKHR4KSA9PiB7XG4gICAgICAgICAgICBpZiAodHguZnJvbSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGdldEFkZHJlc3ModHguZnJvbSkgIT09IHRoaXMuYWRkcmVzcykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIudGhyb3dBcmd1bWVudEVycm9yKFwidHJhbnNhY3Rpb24gZnJvbSBhZGRyZXNzIG1pc21hdGNoXCIsIFwidHJhbnNhY3Rpb24uZnJvbVwiLCB0cmFuc2FjdGlvbi5mcm9tKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVsZXRlIHR4LmZyb207XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBzaWduYXR1cmUgPSB0aGlzLl9zaWduaW5nS2V5KCkuc2lnbkRpZ2VzdChrZWNjYWsyNTYoc2VyaWFsaXplKHR4KSkpO1xuICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZSh0eCwgc2lnbmF0dXJlKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHNpZ25NZXNzYWdlKG1lc3NhZ2UpIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIHJldHVybiBqb2luU2lnbmF0dXJlKHRoaXMuX3NpZ25pbmdLZXkoKS5zaWduRGlnZXN0KGhhc2hNZXNzYWdlKG1lc3NhZ2UpKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBfc2lnblR5cGVkRGF0YShkb21haW4sIHR5cGVzLCB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gUG9wdWxhdGUgYW55IEVOUyBuYW1lc1xuICAgICAgICAgICAgY29uc3QgcG9wdWxhdGVkID0geWllbGQgX1R5cGVkRGF0YUVuY29kZXIucmVzb2x2ZU5hbWVzKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCAobmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3ZpZGVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJjYW5ub3QgcmVzb2x2ZSBFTlMgbmFtZXMgd2l0aG91dCBhIHByb3ZpZGVyXCIsIExvZ2dlci5lcnJvcnMuVU5TVVBQT1JURURfT1BFUkFUSU9OLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb246IFwicmVzb2x2ZU5hbWVcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBuYW1lXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm92aWRlci5yZXNvbHZlTmFtZShuYW1lKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGpvaW5TaWduYXR1cmUodGhpcy5fc2lnbmluZ0tleSgpLnNpZ25EaWdlc3QoX1R5cGVkRGF0YUVuY29kZXIuaGFzaChwb3B1bGF0ZWQuZG9tYWluLCB0eXBlcywgcG9wdWxhdGVkLnZhbHVlKSkpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZW5jcnlwdChwYXNzd29yZCwgb3B0aW9ucywgcHJvZ3Jlc3NDYWxsYmFjaykge1xuICAgICAgICBpZiAodHlwZW9mIChvcHRpb25zKSA9PT0gXCJmdW5jdGlvblwiICYmICFwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrID0gb3B0aW9ucztcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjayAmJiB0eXBlb2YgKHByb2dyZXNzQ2FsbGJhY2spICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgY2FsbGJhY2tcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGVuY3J5cHRLZXlzdG9yZSh0aGlzLCBwYXNzd29yZCwgb3B0aW9ucywgcHJvZ3Jlc3NDYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqICBTdGF0aWMgbWV0aG9kcyB0byBjcmVhdGUgV2FsbGV0IGluc3RhbmNlcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlUmFuZG9tKG9wdGlvbnMpIHtcbiAgICAgICAgbGV0IGVudHJvcHkgPSByYW5kb21CeXRlcygxNik7XG4gICAgICAgIGlmICghb3B0aW9ucykge1xuICAgICAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmV4dHJhRW50cm9weSkge1xuICAgICAgICAgICAgZW50cm9weSA9IGFycmF5aWZ5KGhleERhdGFTbGljZShrZWNjYWsyNTYoY29uY2F0KFtlbnRyb3B5LCBvcHRpb25zLmV4dHJhRW50cm9weV0pKSwgMCwgMTYpKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtbmVtb25pYyA9IGVudHJvcHlUb01uZW1vbmljKGVudHJvcHksIG9wdGlvbnMubG9jYWxlKTtcbiAgICAgICAgcmV0dXJuIFdhbGxldC5mcm9tTW5lbW9uaWMobW5lbW9uaWMsIG9wdGlvbnMucGF0aCwgb3B0aW9ucy5sb2NhbGUpO1xuICAgIH1cbiAgICBzdGF0aWMgZnJvbUVuY3J5cHRlZEpzb24oanNvbiwgcGFzc3dvcmQsIHByb2dyZXNzQ2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIGRlY3J5cHRKc29uV2FsbGV0KGpzb24sIHBhc3N3b3JkLCBwcm9ncmVzc0NhbGxiYWNrKS50aGVuKChhY2NvdW50KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFdhbGxldChhY2NvdW50KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tRW5jcnlwdGVkSnNvblN5bmMoanNvbiwgcGFzc3dvcmQpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBXYWxsZXQoZGVjcnlwdEpzb25XYWxsZXRTeW5jKGpzb24sIHBhc3N3b3JkKSk7XG4gICAgfVxuICAgIHN0YXRpYyBmcm9tTW5lbW9uaWMobW5lbW9uaWMsIHBhdGgsIHdvcmRsaXN0KSB7XG4gICAgICAgIGlmICghcGF0aCkge1xuICAgICAgICAgICAgcGF0aCA9IGRlZmF1bHRQYXRoO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2FsbGV0KEhETm9kZS5mcm9tTW5lbW9uaWMobW5lbW9uaWMsIG51bGwsIHdvcmRsaXN0KS5kZXJpdmVQYXRoKHBhdGgpKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5TWVzc2FnZShtZXNzYWdlLCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3MoaGFzaE1lc3NhZ2UobWVzc2FnZSksIHNpZ25hdHVyZSk7XG59XG5leHBvcnQgZnVuY3Rpb24gdmVyaWZ5VHlwZWREYXRhKGRvbWFpbiwgdHlwZXMsIHZhbHVlLCBzaWduYXR1cmUpIHtcbiAgICByZXR1cm4gcmVjb3ZlckFkZHJlc3MoX1R5cGVkRGF0YUVuY29kZXIuaGFzaChkb21haW4sIHR5cGVzLCB2YWx1ZSksIHNpZ25hdHVyZSk7XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwid2ViLzUuNS4xXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgYXJyYXlpZnkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYnl0ZXNcIjtcbmV4cG9ydCBmdW5jdGlvbiBnZXRVcmwoaHJlZiwgb3B0aW9ucykge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGlmIChvcHRpb25zID09IG51bGwpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgICAgICAgbWV0aG9kOiAob3B0aW9ucy5tZXRob2QgfHwgXCJHRVRcIiksXG4gICAgICAgICAgICBoZWFkZXJzOiAob3B0aW9ucy5oZWFkZXJzIHx8IHt9KSxcbiAgICAgICAgICAgIGJvZHk6IChvcHRpb25zLmJvZHkgfHwgdW5kZWZpbmVkKSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcEZldGNoU2V0dXAgIT09IHRydWUpIHtcbiAgICAgICAgICAgIHJlcXVlc3QubW9kZSA9IFwiY29yc1wiOyAvLyBuby1jb3JzLCBjb3JzLCAqc2FtZS1vcmlnaW5cbiAgICAgICAgICAgIHJlcXVlc3QuY2FjaGUgPSBcIm5vLWNhY2hlXCI7IC8vICpkZWZhdWx0LCBuby1jYWNoZSwgcmVsb2FkLCBmb3JjZS1jYWNoZSwgb25seS1pZi1jYWNoZWRcbiAgICAgICAgICAgIHJlcXVlc3QuY3JlZGVudGlhbHMgPSBcInNhbWUtb3JpZ2luXCI7IC8vIGluY2x1ZGUsICpzYW1lLW9yaWdpbiwgb21pdFxuICAgICAgICAgICAgcmVxdWVzdC5yZWRpcmVjdCA9IFwiZm9sbG93XCI7IC8vIG1hbnVhbCwgKmZvbGxvdywgZXJyb3JcbiAgICAgICAgICAgIHJlcXVlc3QucmVmZXJyZXIgPSBcImNsaWVudFwiOyAvLyBuby1yZWZlcnJlciwgKmNsaWVudFxuICAgICAgICB9XG4gICAgICAgIDtcbiAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB5aWVsZCBmZXRjaChocmVmLCByZXF1ZXN0KTtcbiAgICAgICAgY29uc3QgYm9keSA9IHlpZWxkIHJlc3BvbnNlLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIGNvbnN0IGhlYWRlcnMgPSB7fTtcbiAgICAgICAgaWYgKHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCkge1xuICAgICAgICAgICAgcmVzcG9uc2UuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaGVhZGVyc1trZXkudG9Mb3dlckNhc2UoKV0gPSB2YWx1ZTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgKChyZXNwb25zZS5oZWFkZXJzKS5rZXlzKSgpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGhlYWRlcnNba2V5LnRvTG93ZXJDYXNlKCldID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoa2V5KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBoZWFkZXJzOiBoZWFkZXJzLFxuICAgICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgICAgc3RhdHVzTWVzc2FnZTogcmVzcG9uc2Uuc3RhdHVzVGV4dCxcbiAgICAgICAgICAgIGJvZHk6IGFycmF5aWZ5KG5ldyBVaW50OEFycmF5KGJvZHkpKSxcbiAgICAgICAgfTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldHVybC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgZGVjb2RlIGFzIGJhc2U2NERlY29kZSwgZW5jb2RlIGFzIGJhc2U2NEVuY29kZSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iYXNlNjRcIjtcbmltcG9ydCB7IGhleGxpZnksIGlzQnl0ZXNMaWtlIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBzaGFsbG93Q29weSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyB0b1V0ZjhCeXRlcywgdG9VdGY4U3RyaW5nIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbmltcG9ydCB7IExvZ2dlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9sb2dnZXJcIjtcbmltcG9ydCB7IHZlcnNpb24gfSBmcm9tIFwiLi9fdmVyc2lvblwiO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcih2ZXJzaW9uKTtcbmltcG9ydCB7IGdldFVybCB9IGZyb20gXCIuL2dldHVybFwiO1xuZnVuY3Rpb24gc3RhbGxlcihkdXJhdGlvbikge1xuICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KHJlc29sdmUsIGR1cmF0aW9uKTtcbiAgICB9KTtcbn1cbmZ1bmN0aW9uIGJvZHlpZnkodmFsdWUsIHR5cGUpIHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiAodmFsdWUpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzQnl0ZXNMaWtlKHZhbHVlKSkge1xuICAgICAgICBpZiAodHlwZSAmJiAodHlwZS5zcGxpdChcIi9cIilbMF0gPT09IFwidGV4dFwiIHx8IHR5cGUuc3BsaXQoXCI7XCIpWzBdLnRyaW0oKSA9PT0gXCJhcHBsaWNhdGlvbi9qc29uXCIpKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b1V0ZjhTdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGV4bGlmeSh2YWx1ZSk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbn1cbi8vIFRoaXMgQVBJIGlzIHN0aWxsIGEgd29yayBpbiBwcm9ncmVzczsgdGhlIGZ1dHVyZSBjaGFuZ2VzIHdpbGwgbGlrZWx5IGJlOlxuLy8gLSBDb25uZWN0aW9uSW5mbyA9PiBGZXRjaERhdGFSZXF1ZXN0PFQgPSBhbnk+XG4vLyAtIEZldGNoRGF0YVJlcXVlc3QuYm9keT8gPSBzdHJpbmcgfCBVaW50OEFycmF5IHwgeyBjb250ZW50VHlwZTogc3RyaW5nLCBkYXRhOiBzdHJpbmcgfCBVaW50OEFycmF5IH1cbi8vICAgLSBJZiBzdHJpbmcgPT4gdGV4dC9wbGFpbiwgVWludDhBcnJheSA9PiBhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW0gKGlmIGNvbnRlbnQtdHlwZSB1bnNwZWNpZmllZClcbi8vIC0gRmV0Y2hEYXRhUmVxdWVzdC5wcm9jZXNzRnVuYyA9IChib2R5OiBVaW50OEFycmF5LCByZXNwb25zZTogRmV0Y2hEYXRhUmVzcG9uc2UpID0+IFRcbi8vIEZvciB0aGlzIHJlYXNvbiwgaXQgc2hvdWxkIGJlIGNvbnNpZGVyZWQgaW50ZXJuYWwgdW50aWwgdGhlIEFQSSBpcyBmaW5hbGl6ZWRcbmV4cG9ydCBmdW5jdGlvbiBfZmV0Y2hEYXRhKGNvbm5lY3Rpb24sIGJvZHksIHByb2Nlc3NGdW5jKSB7XG4gICAgLy8gSG93IG1hbnkgdGltZXMgdG8gcmV0cnkgaW4gdGhlIGV2ZW50IG9mIGEgdGhyb3R0bGVcbiAgICBjb25zdCBhdHRlbXB0TGltaXQgPSAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJvYmplY3RcIiAmJiBjb25uZWN0aW9uLnRocm90dGxlTGltaXQgIT0gbnVsbCkgPyBjb25uZWN0aW9uLnRocm90dGxlTGltaXQgOiAxMjtcbiAgICBsb2dnZXIuYXNzZXJ0QXJndW1lbnQoKGF0dGVtcHRMaW1pdCA+IDAgJiYgKGF0dGVtcHRMaW1pdCAlIDEpID09PSAwKSwgXCJpbnZhbGlkIGNvbm5lY3Rpb24gdGhyb3R0bGUgbGltaXRcIiwgXCJjb25uZWN0aW9uLnRocm90dGxlTGltaXRcIiwgYXR0ZW1wdExpbWl0KTtcbiAgICBjb25zdCB0aHJvdHRsZUNhbGxiYWNrID0gKCh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiKSA/IGNvbm5lY3Rpb24udGhyb3R0bGVDYWxsYmFjayA6IG51bGwpO1xuICAgIGNvbnN0IHRocm90dGxlU2xvdEludGVydmFsID0gKCh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiAoY29ubmVjdGlvbi50aHJvdHRsZVNsb3RJbnRlcnZhbCkgPT09IFwibnVtYmVyXCIpID8gY29ubmVjdGlvbi50aHJvdHRsZVNsb3RJbnRlcnZhbCA6IDEwMCk7XG4gICAgbG9nZ2VyLmFzc2VydEFyZ3VtZW50KCh0aHJvdHRsZVNsb3RJbnRlcnZhbCA+IDAgJiYgKHRocm90dGxlU2xvdEludGVydmFsICUgMSkgPT09IDApLCBcImludmFsaWQgY29ubmVjdGlvbiB0aHJvdHRsZSBzbG90IGludGVydmFsXCIsIFwiY29ubmVjdGlvbi50aHJvdHRsZVNsb3RJbnRlcnZhbFwiLCB0aHJvdHRsZVNsb3RJbnRlcnZhbCk7XG4gICAgY29uc3QgaGVhZGVycyA9IHt9O1xuICAgIGxldCB1cmwgPSBudWxsO1xuICAgIC8vIEBUT0RPOiBBbGxvdyBDb25uZWN0aW9uSW5mbyB0byBvdmVycmlkZSBzb21lIG9mIHRoZXNlIHZhbHVlc1xuICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICB9O1xuICAgIGxldCBhbGxvdzMwNCA9IGZhbHNlO1xuICAgIGxldCB0aW1lb3V0ID0gMiAqIDYwICogMTAwMDtcbiAgICBpZiAodHlwZW9mIChjb25uZWN0aW9uKSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICB1cmwgPSBjb25uZWN0aW9uO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIGlmIChjb25uZWN0aW9uID09IG51bGwgfHwgY29ubmVjdGlvbi51cmwgPT0gbnVsbCkge1xuICAgICAgICAgICAgbG9nZ2VyLnRocm93QXJndW1lbnRFcnJvcihcIm1pc3NpbmcgVVJMXCIsIFwiY29ubmVjdGlvbi51cmxcIiwgY29ubmVjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgdXJsID0gY29ubmVjdGlvbi51cmw7XG4gICAgICAgIGlmICh0eXBlb2YgKGNvbm5lY3Rpb24udGltZW91dCkgPT09IFwibnVtYmVyXCIgJiYgY29ubmVjdGlvbi50aW1lb3V0ID4gMCkge1xuICAgICAgICAgICAgdGltZW91dCA9IGNvbm5lY3Rpb24udGltZW91dDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29ubmVjdGlvbi5oZWFkZXJzKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBjb25uZWN0aW9uLmhlYWRlcnMpIHtcbiAgICAgICAgICAgICAgICBoZWFkZXJzW2tleS50b0xvd2VyQ2FzZSgpXSA9IHsga2V5OiBrZXksIHZhbHVlOiBTdHJpbmcoY29ubmVjdGlvbi5oZWFkZXJzW2tleV0pIH07XG4gICAgICAgICAgICAgICAgaWYgKFtcImlmLW5vbmUtbWF0Y2hcIiwgXCJpZi1tb2RpZmllZC1zaW5jZVwiXS5pbmRleE9mKGtleS50b0xvd2VyQ2FzZSgpKSA+PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGFsbG93MzA0ID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5hbGxvd0d6aXAgPSAhIWNvbm5lY3Rpb24uYWxsb3dHemlwO1xuICAgICAgICBpZiAoY29ubmVjdGlvbi51c2VyICE9IG51bGwgJiYgY29ubmVjdGlvbi5wYXNzd29yZCAhPSBudWxsKSB7XG4gICAgICAgICAgICBpZiAodXJsLnN1YnN0cmluZygwLCA2KSAhPT0gXCJodHRwczpcIiAmJiBjb25uZWN0aW9uLmFsbG93SW5zZWN1cmVBdXRoZW50aWNhdGlvbiAhPT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci50aHJvd0Vycm9yKFwiYmFzaWMgYXV0aGVudGljYXRpb24gcmVxdWlyZXMgYSBzZWN1cmUgaHR0cHMgdXJsXCIsIExvZ2dlci5lcnJvcnMuSU5WQUxJRF9BUkdVTUVOVCwgeyBhcmd1bWVudDogXCJ1cmxcIiwgdXJsOiB1cmwsIHVzZXI6IGNvbm5lY3Rpb24udXNlciwgcGFzc3dvcmQ6IFwiW1JFREFDVEVEXVwiIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgYXV0aG9yaXphdGlvbiA9IGNvbm5lY3Rpb24udXNlciArIFwiOlwiICsgY29ubmVjdGlvbi5wYXNzd29yZDtcbiAgICAgICAgICAgIGhlYWRlcnNbXCJhdXRob3JpemF0aW9uXCJdID0ge1xuICAgICAgICAgICAgICAgIGtleTogXCJBdXRob3JpemF0aW9uXCIsXG4gICAgICAgICAgICAgICAgdmFsdWU6IFwiQmFzaWMgXCIgKyBiYXNlNjRFbmNvZGUodG9VdGY4Qnl0ZXMoYXV0aG9yaXphdGlvbikpXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJlRGF0YSA9IG5ldyBSZWdFeHAoXCJeZGF0YTooW2EtejAtOS1dKy9bYS16MC05LV0rKTtiYXNlNjQsKC4qKSRcIiwgXCJpXCIpO1xuICAgIGNvbnN0IGRhdGFNYXRjaCA9ICgodXJsKSA/IHVybC5tYXRjaChyZURhdGEpIDogbnVsbCk7XG4gICAgaWYgKGRhdGFNYXRjaCkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZTogMjAwLFxuICAgICAgICAgICAgICAgIHN0YXR1c01lc3NhZ2U6IFwiT0tcIixcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiB7IFwiY29udGVudC10eXBlXCI6IGRhdGFNYXRjaFsxXSB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IGJhc2U2NERlY29kZShkYXRhTWF0Y2hbMl0pXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgbGV0IHJlc3VsdCA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICBpZiAocHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBwcm9jZXNzRnVuYyhyZXNwb25zZS5ib2R5LCByZXNwb25zZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZXNvbHZlKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIudGhyb3dFcnJvcihcInByb2Nlc3NpbmcgcmVzcG9uc2UgZXJyb3JcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICBib2R5OiBib2R5aWZ5KGRhdGFNYXRjaFsxXSwgZGF0YU1hdGNoWzJdKSxcbiAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IG51bGwsXG4gICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogXCJHRVRcIixcbiAgICAgICAgICAgICAgICB1cmw6IHVybFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKGJvZHkpIHtcbiAgICAgICAgb3B0aW9ucy5tZXRob2QgPSBcIlBPU1RcIjtcbiAgICAgICAgb3B0aW9ucy5ib2R5ID0gYm9keTtcbiAgICAgICAgaWYgKGhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA9IHsga2V5OiBcIkNvbnRlbnQtVHlwZVwiLCB2YWx1ZTogXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIiB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChoZWFkZXJzW1wiY29udGVudC1sZW5ndGhcIl0gPT0gbnVsbCkge1xuICAgICAgICAgICAgaGVhZGVyc1tcImNvbnRlbnQtbGVuZ3RoXCJdID0geyBrZXk6IFwiQ29udGVudC1MZW5ndGhcIiwgdmFsdWU6IFN0cmluZyhib2R5Lmxlbmd0aCkgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBmbGF0SGVhZGVycyA9IHt9O1xuICAgIE9iamVjdC5rZXlzKGhlYWRlcnMpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICBjb25zdCBoZWFkZXIgPSBoZWFkZXJzW2tleV07XG4gICAgICAgIGZsYXRIZWFkZXJzW2hlYWRlci5rZXldID0gaGVhZGVyLnZhbHVlO1xuICAgIH0pO1xuICAgIG9wdGlvbnMuaGVhZGVycyA9IGZsYXRIZWFkZXJzO1xuICAgIGNvbnN0IHJ1bm5pbmdUaW1lb3V0ID0gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgdGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChsb2dnZXIubWFrZUVycm9yKFwidGltZW91dFwiLCBMb2dnZXIuZXJyb3JzLlRJTUVPVVQsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RCb2R5OiBib2R5aWZ5KG9wdGlvbnMuYm9keSwgZmxhdEhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0pLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgY2FuY2VsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKHRpbWVyID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgdGltZXIgPSBudWxsO1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBwcm9taXNlLCBjYW5jZWwgfTtcbiAgICB9KSgpO1xuICAgIGNvbnN0IHJ1bm5pbmdGZXRjaCA9IChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBhdHRlbXB0ID0gMDsgYXR0ZW1wdCA8IGF0dGVtcHRMaW1pdDsgYXR0ZW1wdCsrKSB7XG4gICAgICAgICAgICAgICAgbGV0IHJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICByZXNwb25zZSA9IHlpZWxkIGdldFVybCh1cmwsIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA8IGF0dGVtcHRMaW1pdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwMSB8fCByZXNwb25zZS5zdGF0dXNDb2RlID09PSAzMDIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBSZWRpcmVjdGlvbjsgZm9yIG5vdyB3ZSBvbmx5IHN1cHBvcnQgYWJzb2x1dGUgbG9jYXRhaW9uc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxvY2F0aW9uID0gcmVzcG9uc2UuaGVhZGVycy5sb2NhdGlvbiB8fCBcIlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLm1ldGhvZCA9PT0gXCJHRVRcIiAmJiBsb2NhdGlvbi5tYXRjaCgvXmh0dHBzOi8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IHJlc3BvbnNlLmhlYWRlcnMubG9jYXRpb247XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQyOSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEV4cG9uZW50aWFsIGJhY2stb2ZmIHRocm90dGxpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJ5QWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHJvdHRsZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFnYWluID0geWllbGQgdGhyb3R0bGVDYWxsYmFjayhhdHRlbXB0LCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJ5QWdhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGV0IHN0YWxsID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmV0cnlBZnRlciA9IHJlc3BvbnNlLmhlYWRlcnNbXCJyZXRyeS1hZnRlclwiXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiAocmV0cnlBZnRlcikgPT09IFwic3RyaW5nXCIgJiYgcmV0cnlBZnRlci5tYXRjaCgvXlsxLTldWzAtOV0qJC8pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGFsbCA9IHBhcnNlSW50KHJldHJ5QWZ0ZXIpICogMTAwMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0YWxsID0gdGhyb3R0bGVTbG90SW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9jb25zb2xlLmxvZyhcIlN0YWxsaW5nIDQyOVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWllbGQgc3RhbGxlcihzdGFsbCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBlcnJvci5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3BvbnNlID09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJtaXNzaW5nIHJlc3BvbnNlXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VydmVyRXJyb3I6IGVycm9yLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgYm9keSA9IHJlc3BvbnNlLmJvZHk7XG4gICAgICAgICAgICAgICAgaWYgKGFsbG93MzA0ICYmIHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDMwNCkge1xuICAgICAgICAgICAgICAgICAgICBib2R5ID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA8IDIwMCB8fCByZXNwb25zZS5zdGF0dXNDb2RlID49IDMwMCkge1xuICAgICAgICAgICAgICAgICAgICBydW5uaW5nVGltZW91dC5jYW5jZWwoKTtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJiYWQgcmVzcG9uc2VcIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXR1czogcmVzcG9uc2Uuc3RhdHVzQ29kZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJlc3BvbnNlLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5OiBib2R5aWZ5KGJvZHksICgocmVzcG9uc2UuaGVhZGVycykgPyByZXNwb25zZS5oZWFkZXJzW1wiY29udGVudC10eXBlXCJdIDogbnVsbCkpLFxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICByZXF1ZXN0TWV0aG9kOiBvcHRpb25zLm1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocHJvY2Vzc0Z1bmMpIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJlc3VsdCA9IHlpZWxkIHByb2Nlc3NGdW5jKGJvZHksIHJlc3BvbnNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IHRoZSBwcm9jZXNzRnVuYyB0byB0cmlnZ2VyIGEgdGhyb3R0bGVcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnJvci50aHJvdHRsZVJldHJ5ICYmIGF0dGVtcHQgPCBhdHRlbXB0TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgdHJ5QWdhaW4gPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aHJvdHRsZUNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRyeUFnYWluID0geWllbGQgdGhyb3R0bGVDYWxsYmFjayhhdHRlbXB0LCB1cmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJ5QWdhaW4pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgdGltZW91dCA9IHRocm90dGxlU2xvdEludGVydmFsICogcGFyc2VJbnQoU3RyaW5nKE1hdGgucmFuZG9tKCkgKiBNYXRoLnBvdygyLCBhdHRlbXB0KSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvL2NvbnNvbGUubG9nKFwiU3RhbGxpbmcgY2FsbGJhY2tcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHlpZWxkIHN0YWxsZXIodGltZW91dCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJwcm9jZXNzaW5nIHJlc3BvbnNlIGVycm9yXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogYm9keWlmeShib2R5LCAoKHJlc3BvbnNlLmhlYWRlcnMpID8gcmVzcG9uc2UuaGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSA6IG51bGwpKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcjogZXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJ1bm5pbmdUaW1lb3V0LmNhbmNlbCgpO1xuICAgICAgICAgICAgICAgIC8vIElmIHdlIGhhZCBhIHByb2Nlc3NGdW5jLCBpdCBlaXRoZXIgcmV0dXJuZWQgYSBUIG9yIHRocmV3IGFib3ZlLlxuICAgICAgICAgICAgICAgIC8vIFRoZSBcImJvZHlcIiBpcyBub3cgYSBVaW50OEFycmF5LlxuICAgICAgICAgICAgICAgIHJldHVybiBib2R5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGxvZ2dlci50aHJvd0Vycm9yKFwiZmFpbGVkIHJlc3BvbnNlXCIsIExvZ2dlci5lcnJvcnMuU0VSVkVSX0VSUk9SLCB7XG4gICAgICAgICAgICAgICAgcmVxdWVzdEJvZHk6IGJvZHlpZnkob3B0aW9ucy5ib2R5LCBmbGF0SGVhZGVyc1tcImNvbnRlbnQtdHlwZVwiXSksXG4gICAgICAgICAgICAgICAgcmVxdWVzdE1ldGhvZDogb3B0aW9ucy5tZXRob2QsXG4gICAgICAgICAgICAgICAgdXJsOiB1cmxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9KSgpO1xuICAgIHJldHVybiBQcm9taXNlLnJhY2UoW3J1bm5pbmdUaW1lb3V0LnByb21pc2UsIHJ1bm5pbmdGZXRjaF0pO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGZldGNoSnNvbihjb25uZWN0aW9uLCBqc29uLCBwcm9jZXNzRnVuYykge1xuICAgIGxldCBwcm9jZXNzSnNvbkZ1bmMgPSAodmFsdWUsIHJlc3BvbnNlKSA9PiB7XG4gICAgICAgIGxldCByZXN1bHQgPSBudWxsO1xuICAgICAgICBpZiAodmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXN1bHQgPSBKU09OLnBhcnNlKHRvVXRmOFN0cmluZyh2YWx1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLnRocm93RXJyb3IoXCJpbnZhbGlkIEpTT05cIiwgTG9nZ2VyLmVycm9ycy5TRVJWRVJfRVJST1IsIHtcbiAgICAgICAgICAgICAgICAgICAgYm9keTogdmFsdWUsXG4gICAgICAgICAgICAgICAgICAgIGVycm9yOiBlcnJvclxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9jZXNzRnVuYykge1xuICAgICAgICAgICAgcmVzdWx0ID0gcHJvY2Vzc0Z1bmMocmVzdWx0LCByZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIC8vIElmIHdlIGhhdmUganNvbiB0byBzZW5kLCB3ZSBtdXN0XG4gICAgLy8gLSBhZGQgY29udGVudC10eXBlIG9mIGFwcGxpY2F0aW9uL2pzb24gKHVubGVzcyBhbHJlYWR5IG92ZXJyaWRkZW4pXG4gICAgLy8gLSBjb252ZXJ0IHRoZSBqc29uIHRvIGJ5dGVzXG4gICAgbGV0IGJvZHkgPSBudWxsO1xuICAgIGlmIChqc29uICE9IG51bGwpIHtcbiAgICAgICAgYm9keSA9IHRvVXRmOEJ5dGVzKGpzb24pO1xuICAgICAgICAvLyBDcmVhdGUgYSBjb25uZWN0aW9uIHdpdGggdGhlIGNvbnRlbnQtdHlwZSBzZXQgZm9yIEpTT05cbiAgICAgICAgY29uc3QgdXBkYXRlZCA9ICh0eXBlb2YgKGNvbm5lY3Rpb24pID09PSBcInN0cmluZ1wiKSA/ICh7IHVybDogY29ubmVjdGlvbiB9KSA6IHNoYWxsb3dDb3B5KGNvbm5lY3Rpb24pO1xuICAgICAgICBpZiAodXBkYXRlZC5oZWFkZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBoYXNDb250ZW50VHlwZSA9IChPYmplY3Qua2V5cyh1cGRhdGVkLmhlYWRlcnMpLmZpbHRlcigoaykgPT4gKGsudG9Mb3dlckNhc2UoKSA9PT0gXCJjb250ZW50LXR5cGVcIikpLmxlbmd0aCkgIT09IDA7XG4gICAgICAgICAgICBpZiAoIWhhc0NvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgdXBkYXRlZC5oZWFkZXJzID0gc2hhbGxvd0NvcHkodXBkYXRlZC5oZWFkZXJzKTtcbiAgICAgICAgICAgICAgICB1cGRhdGVkLmhlYWRlcnNbXCJjb250ZW50LXR5cGVcIl0gPSBcImFwcGxpY2F0aW9uL2pzb25cIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZWQuaGVhZGVycyA9IHsgXCJjb250ZW50LXR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIgfTtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uID0gdXBkYXRlZDtcbiAgICB9XG4gICAgcmV0dXJuIF9mZXRjaERhdGEoY29ubmVjdGlvbiwgYm9keSwgcHJvY2Vzc0pzb25GdW5jKTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb2xsKGZ1bmMsIG9wdGlvbnMpIHtcbiAgICBpZiAoIW9wdGlvbnMpIHtcbiAgICAgICAgb3B0aW9ucyA9IHt9O1xuICAgIH1cbiAgICBvcHRpb25zID0gc2hhbGxvd0NvcHkob3B0aW9ucyk7XG4gICAgaWYgKG9wdGlvbnMuZmxvb3IgPT0gbnVsbCkge1xuICAgICAgICBvcHRpb25zLmZsb29yID0gMDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuY2VpbGluZyA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuY2VpbGluZyA9IDEwMDAwO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5pbnRlcnZhbCA9PSBudWxsKSB7XG4gICAgICAgIG9wdGlvbnMuaW50ZXJ2YWwgPSAyNTA7XG4gICAgfVxuICAgIHJldHVybiBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGxldCB0aW1lciA9IG51bGw7XG4gICAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICAgIC8vIFJldHVybnMgdHJ1ZSBpZiBjYW5jZWwgd2FzIHN1Y2Nlc3NmdWwuIFVuc3VjY2Vzc2Z1bCBjYW5jZWwgbWVhbnMgd2UncmUgYWxyZWFkeSBkb25lLlxuICAgICAgICBjb25zdCBjYW5jZWwgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRvbmUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRpbWVyKSB7XG4gICAgICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9O1xuICAgICAgICBpZiAob3B0aW9ucy50aW1lb3V0KSB7XG4gICAgICAgICAgICB0aW1lciA9IHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwidGltZW91dFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXRyeUxpbWl0ID0gb3B0aW9ucy5yZXRyeUxpbWl0O1xuICAgICAgICBsZXQgYXR0ZW1wdCA9IDA7XG4gICAgICAgIGZ1bmN0aW9uIGNoZWNrKCkge1xuICAgICAgICAgICAgcmV0dXJuIGZ1bmMoKS50aGVuKGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICAgICAgICAgICAgICAvLyBJZiB3ZSBoYXZlIGEgcmVzdWx0LCBvciBhcmUgYWxsb3dlZCBudWxsIHRoZW4gd2UncmUgZG9uZVxuICAgICAgICAgICAgICAgIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FuY2VsKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2VQb2xsKSB7XG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMub25jZVBvbGwub25jZShcInBvbGxcIiwgY2hlY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChvcHRpb25zLm9uY2VCbG9jaykge1xuICAgICAgICAgICAgICAgICAgICBvcHRpb25zLm9uY2VCbG9jay5vbmNlKFwiYmxvY2tcIiwgY2hlY2spO1xuICAgICAgICAgICAgICAgICAgICAvLyBPdGhlcndpc2UsIGV4cG9uZW50aWFsIGJhY2stb2ZmICh1cCB0byAxMHMpIG91ciBuZXh0IHJlcXVlc3RcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoIWRvbmUpIHtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXR0ZW1wdCA+IHJldHJ5TGltaXQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYW5jZWwoKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoXCJyZXRyeSBsaW1pdCByZWFjaGVkXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBsZXQgdGltZW91dCA9IG9wdGlvbnMuaW50ZXJ2YWwgKiBwYXJzZUludChTdHJpbmcoTWF0aC5yYW5kb20oKSAqIE1hdGgucG93KDIsIGF0dGVtcHQpKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0IDwgb3B0aW9ucy5mbG9vcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGltZW91dCA9IG9wdGlvbnMuZmxvb3I7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRpbWVvdXQgPiBvcHRpb25zLmNlaWxpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVvdXQgPSBvcHRpb25zLmNlaWxpbmc7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2V0VGltZW91dChjaGVjaywgdGltZW91dCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbmNlbCgpKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hlY2soKTtcbiAgICB9KTtcbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsImV4cG9ydCBjb25zdCB2ZXJzaW9uID0gXCJ3b3JkbGlzdHMvNS41LjBcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPV92ZXJzaW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuLy8gV29yZGxpc3RzXG4vLyBTZWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9iaXRjb2luL2JpcHMvYmxvYi9tYXN0ZXIvYmlwLTAwMzkvYmlwLTAwMzktd29yZGxpc3RzLm1kXG5pbXBvcnQgeyBsb2dnZXIsIFdvcmRsaXN0IH0gZnJvbSBcIi4vd29yZGxpc3RcIjtcbmltcG9ydCB7IHdvcmRsaXN0cyB9IGZyb20gXCIuL3dvcmRsaXN0c1wiO1xuZXhwb3J0IHsgbG9nZ2VyLCBXb3JkbGlzdCwgd29yZGxpc3RzIH07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IFdvcmRsaXN0IH0gZnJvbSBcIi4vd29yZGxpc3RcIjtcbmNvbnN0IHdvcmRzID0gXCJBYmFuZG9uQWJpbGl0eUFibGVBYm91dEFib3ZlQWJzZW50QWJzb3JiQWJzdHJhY3RBYnN1cmRBYnVzZUFjY2Vzc0FjY2lkZW50QWNjb3VudEFjY3VzZUFjaGlldmVBY2lkQWNvdXN0aWNBY3F1aXJlQWNyb3NzQWN0QWN0aW9uQWN0b3JBY3RyZXNzQWN0dWFsQWRhcHRBZGRBZGRpY3RBZGRyZXNzQWRqdXN0QWRtaXRBZHVsdEFkdmFuY2VBZHZpY2VBZXJvYmljQWZmYWlyQWZmb3JkQWZyYWlkQWdhaW5BZ2VBZ2VudEFncmVlQWhlYWRBaW1BaXJBaXJwb3J0QWlzbGVBbGFybUFsYnVtQWxjb2hvbEFsZXJ0QWxpZW5BbGxBbGxleUFsbG93QWxtb3N0QWxvbmVBbHBoYUFscmVhZHlBbHNvQWx0ZXJBbHdheXNBbWF0ZXVyQW1hemluZ0Ftb25nQW1vdW50QW11c2VkQW5hbHlzdEFuY2hvckFuY2llbnRBbmdlckFuZ2xlQW5ncnlBbmltYWxBbmtsZUFubm91bmNlQW5udWFsQW5vdGhlckFuc3dlckFudGVubmFBbnRpcXVlQW54aWV0eUFueUFwYXJ0QXBvbG9neUFwcGVhckFwcGxlQXBwcm92ZUFwcmlsQXJjaEFyY3RpY0FyZWFBcmVuYUFyZ3VlQXJtQXJtZWRBcm1vckFybXlBcm91bmRBcnJhbmdlQXJyZXN0QXJyaXZlQXJyb3dBcnRBcnRlZmFjdEFydGlzdEFydHdvcmtBc2tBc3BlY3RBc3NhdWx0QXNzZXRBc3Npc3RBc3N1bWVBc3RobWFBdGhsZXRlQXRvbUF0dGFja0F0dGVuZEF0dGl0dWRlQXR0cmFjdEF1Y3Rpb25BdWRpdEF1Z3VzdEF1bnRBdXRob3JBdXRvQXV0dW1uQXZlcmFnZUF2b2NhZG9Bdm9pZEF3YWtlQXdhcmVBd2F5QXdlc29tZUF3ZnVsQXdrd2FyZEF4aXNCYWJ5QmFjaGVsb3JCYWNvbkJhZGdlQmFnQmFsYW5jZUJhbGNvbnlCYWxsQmFtYm9vQmFuYW5hQmFubmVyQmFyQmFyZWx5QmFyZ2FpbkJhcnJlbEJhc2VCYXNpY0Jhc2tldEJhdHRsZUJlYWNoQmVhbkJlYXV0eUJlY2F1c2VCZWNvbWVCZWVmQmVmb3JlQmVnaW5CZWhhdmVCZWhpbmRCZWxpZXZlQmVsb3dCZWx0QmVuY2hCZW5lZml0QmVzdEJldHJheUJldHRlckJldHdlZW5CZXlvbmRCaWN5Y2xlQmlkQmlrZUJpbmRCaW9sb2d5QmlyZEJpcnRoQml0dGVyQmxhY2tCbGFkZUJsYW1lQmxhbmtldEJsYXN0QmxlYWtCbGVzc0JsaW5kQmxvb2RCbG9zc29tQmxvdXNlQmx1ZUJsdXJCbHVzaEJvYXJkQm9hdEJvZHlCb2lsQm9tYkJvbmVCb251c0Jvb2tCb29zdEJvcmRlckJvcmluZ0JvcnJvd0Jvc3NCb3R0b21Cb3VuY2VCb3hCb3lCcmFja2V0QnJhaW5CcmFuZEJyYXNzQnJhdmVCcmVhZEJyZWV6ZUJyaWNrQnJpZGdlQnJpZWZCcmlnaHRCcmluZ0JyaXNrQnJvY2NvbGlCcm9rZW5Ccm9uemVCcm9vbUJyb3RoZXJCcm93bkJydXNoQnViYmxlQnVkZHlCdWRnZXRCdWZmYWxvQnVpbGRCdWxiQnVsa0J1bGxldEJ1bmRsZUJ1bmtlckJ1cmRlbkJ1cmdlckJ1cnN0QnVzQnVzaW5lc3NCdXN5QnV0dGVyQnV5ZXJCdXp6Q2FiYmFnZUNhYmluQ2FibGVDYWN0dXNDYWdlQ2FrZUNhbGxDYWxtQ2FtZXJhQ2FtcENhbkNhbmFsQ2FuY2VsQ2FuZHlDYW5ub25DYW5vZUNhbnZhc0NhbnlvbkNhcGFibGVDYXBpdGFsQ2FwdGFpbkNhckNhcmJvbkNhcmRDYXJnb0NhcnBldENhcnJ5Q2FydENhc2VDYXNoQ2FzaW5vQ2FzdGxlQ2FzdWFsQ2F0Q2F0YWxvZ0NhdGNoQ2F0ZWdvcnlDYXR0bGVDYXVnaHRDYXVzZUNhdXRpb25DYXZlQ2VpbGluZ0NlbGVyeUNlbWVudENlbnN1c0NlbnR1cnlDZXJlYWxDZXJ0YWluQ2hhaXJDaGFsa0NoYW1waW9uQ2hhbmdlQ2hhb3NDaGFwdGVyQ2hhcmdlQ2hhc2VDaGF0Q2hlYXBDaGVja0NoZWVzZUNoZWZDaGVycnlDaGVzdENoaWNrZW5DaGllZkNoaWxkQ2hpbW5leUNob2ljZUNob29zZUNocm9uaWNDaHVja2xlQ2h1bmtDaHVybkNpZ2FyQ2lubmFtb25DaXJjbGVDaXRpemVuQ2l0eUNpdmlsQ2xhaW1DbGFwQ2xhcmlmeUNsYXdDbGF5Q2xlYW5DbGVya0NsZXZlckNsaWNrQ2xpZW50Q2xpZmZDbGltYkNsaW5pY0NsaXBDbG9ja0Nsb2dDbG9zZUNsb3RoQ2xvdWRDbG93bkNsdWJDbHVtcENsdXN0ZXJDbHV0Y2hDb2FjaENvYXN0Q29jb251dENvZGVDb2ZmZWVDb2lsQ29pbkNvbGxlY3RDb2xvckNvbHVtbkNvbWJpbmVDb21lQ29tZm9ydENvbWljQ29tbW9uQ29tcGFueUNvbmNlcnRDb25kdWN0Q29uZmlybUNvbmdyZXNzQ29ubmVjdENvbnNpZGVyQ29udHJvbENvbnZpbmNlQ29va0Nvb2xDb3BwZXJDb3B5Q29yYWxDb3JlQ29ybkNvcnJlY3RDb3N0Q290dG9uQ291Y2hDb3VudHJ5Q291cGxlQ291cnNlQ291c2luQ292ZXJDb3lvdGVDcmFja0NyYWRsZUNyYWZ0Q3JhbUNyYW5lQ3Jhc2hDcmF0ZXJDcmF3bENyYXp5Q3JlYW1DcmVkaXRDcmVla0NyZXdDcmlja2V0Q3JpbWVDcmlzcENyaXRpY0Nyb3BDcm9zc0Nyb3VjaENyb3dkQ3J1Y2lhbENydWVsQ3J1aXNlQ3J1bWJsZUNydW5jaENydXNoQ3J5Q3J5c3RhbEN1YmVDdWx0dXJlQ3VwQ3VwYm9hcmRDdXJpb3VzQ3VycmVudEN1cnRhaW5DdXJ2ZUN1c2hpb25DdXN0b21DdXRlQ3ljbGVEYWREYW1hZ2VEYW1wRGFuY2VEYW5nZXJEYXJpbmdEYXNoRGF1Z2h0ZXJEYXduRGF5RGVhbERlYmF0ZURlYnJpc0RlY2FkZURlY2VtYmVyRGVjaWRlRGVjbGluZURlY29yYXRlRGVjcmVhc2VEZWVyRGVmZW5zZURlZmluZURlZnlEZWdyZWVEZWxheURlbGl2ZXJEZW1hbmREZW1pc2VEZW5pYWxEZW50aXN0RGVueURlcGFydERlcGVuZERlcG9zaXREZXB0aERlcHV0eURlcml2ZURlc2NyaWJlRGVzZXJ0RGVzaWduRGVza0Rlc3BhaXJEZXN0cm95RGV0YWlsRGV0ZWN0RGV2ZWxvcERldmljZURldm90ZURpYWdyYW1EaWFsRGlhbW9uZERpYXJ5RGljZURpZXNlbERpZXREaWZmZXJEaWdpdGFsRGlnbml0eURpbGVtbWFEaW5uZXJEaW5vc2F1ckRpcmVjdERpcnREaXNhZ3JlZURpc2NvdmVyRGlzZWFzZURpc2hEaXNtaXNzRGlzb3JkZXJEaXNwbGF5RGlzdGFuY2VEaXZlcnREaXZpZGVEaXZvcmNlRGl6enlEb2N0b3JEb2N1bWVudERvZ0RvbGxEb2xwaGluRG9tYWluRG9uYXRlRG9ua2V5RG9ub3JEb29yRG9zZURvdWJsZURvdmVEcmFmdERyYWdvbkRyYW1hRHJhc3RpY0RyYXdEcmVhbURyZXNzRHJpZnREcmlsbERyaW5rRHJpcERyaXZlRHJvcERydW1EcnlEdWNrRHVtYkR1bmVEdXJpbmdEdXN0RHV0Y2hEdXR5RHdhcmZEeW5hbWljRWFnZXJFYWdsZUVhcmx5RWFybkVhcnRoRWFzaWx5RWFzdEVhc3lFY2hvRWNvbG9neUVjb25vbXlFZGdlRWRpdEVkdWNhdGVFZmZvcnRFZ2dFaWdodEVpdGhlckVsYm93RWxkZXJFbGVjdHJpY0VsZWdhbnRFbGVtZW50RWxlcGhhbnRFbGV2YXRvckVsaXRlRWxzZUVtYmFya0VtYm9keUVtYnJhY2VFbWVyZ2VFbW90aW9uRW1wbG95RW1wb3dlckVtcHR5RW5hYmxlRW5hY3RFbmRFbmRsZXNzRW5kb3JzZUVuZW15RW5lcmd5RW5mb3JjZUVuZ2FnZUVuZ2luZUVuaGFuY2VFbmpveUVubGlzdEVub3VnaEVucmljaEVucm9sbEVuc3VyZUVudGVyRW50aXJlRW50cnlFbnZlbG9wZUVwaXNvZGVFcXVhbEVxdWlwRXJhRXJhc2VFcm9kZUVyb3Npb25FcnJvckVydXB0RXNjYXBlRXNzYXlFc3NlbmNlRXN0YXRlRXRlcm5hbEV0aGljc0V2aWRlbmNlRXZpbEV2b2tlRXZvbHZlRXhhY3RFeGFtcGxlRXhjZXNzRXhjaGFuZ2VFeGNpdGVFeGNsdWRlRXhjdXNlRXhlY3V0ZUV4ZXJjaXNlRXhoYXVzdEV4aGliaXRFeGlsZUV4aXN0RXhpdEV4b3RpY0V4cGFuZEV4cGVjdEV4cGlyZUV4cGxhaW5FeHBvc2VFeHByZXNzRXh0ZW5kRXh0cmFFeWVFeWVicm93RmFicmljRmFjZUZhY3VsdHlGYWRlRmFpbnRGYWl0aEZhbGxGYWxzZUZhbWVGYW1pbHlGYW1vdXNGYW5GYW5jeUZhbnRhc3lGYXJtRmFzaGlvbkZhdEZhdGFsRmF0aGVyRmF0aWd1ZUZhdWx0RmF2b3JpdGVGZWF0dXJlRmVicnVhcnlGZWRlcmFsRmVlRmVlZEZlZWxGZW1hbGVGZW5jZUZlc3RpdmFsRmV0Y2hGZXZlckZld0ZpYmVyRmljdGlvbkZpZWxkRmlndXJlRmlsZUZpbG1GaWx0ZXJGaW5hbEZpbmRGaW5lRmluZ2VyRmluaXNoRmlyZUZpcm1GaXJzdEZpc2NhbEZpc2hGaXRGaXRuZXNzRml4RmxhZ0ZsYW1lRmxhc2hGbGF0Rmxhdm9yRmxlZUZsaWdodEZsaXBGbG9hdEZsb2NrRmxvb3JGbG93ZXJGbHVpZEZsdXNoRmx5Rm9hbUZvY3VzRm9nRm9pbEZvbGRGb2xsb3dGb29kRm9vdEZvcmNlRm9yZXN0Rm9yZ2V0Rm9ya0ZvcnR1bmVGb3J1bUZvcndhcmRGb3NzaWxGb3N0ZXJGb3VuZEZveEZyYWdpbGVGcmFtZUZyZXF1ZW50RnJlc2hGcmllbmRGcmluZ2VGcm9nRnJvbnRGcm9zdEZyb3duRnJvemVuRnJ1aXRGdWVsRnVuRnVubnlGdXJuYWNlRnVyeUZ1dHVyZUdhZGdldEdhaW5HYWxheHlHYWxsZXJ5R2FtZUdhcEdhcmFnZUdhcmJhZ2VHYXJkZW5HYXJsaWNHYXJtZW50R2FzR2FzcEdhdGVHYXRoZXJHYXVnZUdhemVHZW5lcmFsR2VuaXVzR2VucmVHZW50bGVHZW51aW5lR2VzdHVyZUdob3N0R2lhbnRHaWZ0R2lnZ2xlR2luZ2VyR2lyYWZmZUdpcmxHaXZlR2xhZEdsYW5jZUdsYXJlR2xhc3NHbGlkZUdsaW1wc2VHbG9iZUdsb29tR2xvcnlHbG92ZUdsb3dHbHVlR29hdEdvZGRlc3NHb2xkR29vZEdvb3NlR29yaWxsYUdvc3BlbEdvc3NpcEdvdmVybkdvd25HcmFiR3JhY2VHcmFpbkdyYW50R3JhcGVHcmFzc0dyYXZpdHlHcmVhdEdyZWVuR3JpZEdyaWVmR3JpdEdyb2NlcnlHcm91cEdyb3dHcnVudEd1YXJkR3Vlc3NHdWlkZUd1aWx0R3VpdGFyR3VuR3ltSGFiaXRIYWlySGFsZkhhbW1lckhhbXN0ZXJIYW5kSGFwcHlIYXJib3JIYXJkSGFyc2hIYXJ2ZXN0SGF0SGF2ZUhhd2tIYXphcmRIZWFkSGVhbHRoSGVhcnRIZWF2eUhlZGdlaG9nSGVpZ2h0SGVsbG9IZWxtZXRIZWxwSGVuSGVyb0hpZGRlbkhpZ2hIaWxsSGludEhpcEhpcmVIaXN0b3J5SG9iYnlIb2NrZXlIb2xkSG9sZUhvbGlkYXlIb2xsb3dIb21lSG9uZXlIb29kSG9wZUhvcm5Ib3Jyb3JIb3JzZUhvc3BpdGFsSG9zdEhvdGVsSG91ckhvdmVySHViSHVnZUh1bWFuSHVtYmxlSHVtb3JIdW5kcmVkSHVuZ3J5SHVudEh1cmRsZUh1cnJ5SHVydEh1c2JhbmRIeWJyaWRJY2VJY29uSWRlYUlkZW50aWZ5SWRsZUlnbm9yZUlsbElsbGVnYWxJbGxuZXNzSW1hZ2VJbWl0YXRlSW1tZW5zZUltbXVuZUltcGFjdEltcG9zZUltcHJvdmVJbXB1bHNlSW5jaEluY2x1ZGVJbmNvbWVJbmNyZWFzZUluZGV4SW5kaWNhdGVJbmRvb3JJbmR1c3RyeUluZmFudEluZmxpY3RJbmZvcm1JbmhhbGVJbmhlcml0SW5pdGlhbEluamVjdEluanVyeUlubWF0ZUlubmVySW5ub2NlbnRJbnB1dElucXVpcnlJbnNhbmVJbnNlY3RJbnNpZGVJbnNwaXJlSW5zdGFsbEludGFjdEludGVyZXN0SW50b0ludmVzdEludml0ZUludm9sdmVJcm9uSXNsYW5kSXNvbGF0ZUlzc3VlSXRlbUl2b3J5SmFja2V0SmFndWFySmFySmF6ekplYWxvdXNKZWFuc0plbGx5SmV3ZWxKb2JKb2luSm9rZUpvdXJuZXlKb3lKdWRnZUp1aWNlSnVtcEp1bmdsZUp1bmlvckp1bmtKdXN0S2FuZ2Fyb29LZWVuS2VlcEtldGNodXBLZXlLaWNrS2lkS2lkbmV5S2luZEtpbmdkb21LaXNzS2l0S2l0Y2hlbktpdGVLaXR0ZW5LaXdpS25lZUtuaWZlS25vY2tLbm93TGFiTGFiZWxMYWJvckxhZGRlckxhZHlMYWtlTGFtcExhbmd1YWdlTGFwdG9wTGFyZ2VMYXRlckxhdGluTGF1Z2hMYXVuZHJ5TGF2YUxhd0xhd25MYXdzdWl0TGF5ZXJMYXp5TGVhZGVyTGVhZkxlYXJuTGVhdmVMZWN0dXJlTGVmdExlZ0xlZ2FsTGVnZW5kTGVpc3VyZUxlbW9uTGVuZExlbmd0aExlbnNMZW9wYXJkTGVzc29uTGV0dGVyTGV2ZWxMaWFyTGliZXJ0eUxpYnJhcnlMaWNlbnNlTGlmZUxpZnRMaWdodExpa2VMaW1iTGltaXRMaW5rTGlvbkxpcXVpZExpc3RMaXR0bGVMaXZlTGl6YXJkTG9hZExvYW5Mb2JzdGVyTG9jYWxMb2NrTG9naWNMb25lbHlMb25nTG9vcExvdHRlcnlMb3VkTG91bmdlTG92ZUxveWFsTHVja3lMdWdnYWdlTHVtYmVyTHVuYXJMdW5jaEx1eHVyeUx5cmljc01hY2hpbmVNYWRNYWdpY01hZ25ldE1haWRNYWlsTWFpbk1ham9yTWFrZU1hbW1hbE1hbk1hbmFnZU1hbmRhdGVNYW5nb01hbnNpb25NYW51YWxNYXBsZU1hcmJsZU1hcmNoTWFyZ2luTWFyaW5lTWFya2V0TWFycmlhZ2VNYXNrTWFzc01hc3Rlck1hdGNoTWF0ZXJpYWxNYXRoTWF0cml4TWF0dGVyTWF4aW11bU1hemVNZWFkb3dNZWFuTWVhc3VyZU1lYXRNZWNoYW5pY01lZGFsTWVkaWFNZWxvZHlNZWx0TWVtYmVyTWVtb3J5TWVudGlvbk1lbnVNZXJjeU1lcmdlTWVyaXRNZXJyeU1lc2hNZXNzYWdlTWV0YWxNZXRob2RNaWRkbGVNaWRuaWdodE1pbGtNaWxsaW9uTWltaWNNaW5kTWluaW11bU1pbm9yTWludXRlTWlyYWNsZU1pcnJvck1pc2VyeU1pc3NNaXN0YWtlTWl4TWl4ZWRNaXh0dXJlTW9iaWxlTW9kZWxNb2RpZnlNb21Nb21lbnRNb25pdG9yTW9ua2V5TW9uc3Rlck1vbnRoTW9vbk1vcmFsTW9yZU1vcm5pbmdNb3NxdWl0b01vdGhlck1vdGlvbk1vdG9yTW91bnRhaW5Nb3VzZU1vdmVNb3ZpZU11Y2hNdWZmaW5NdWxlTXVsdGlwbHlNdXNjbGVNdXNldW1NdXNocm9vbU11c2ljTXVzdE11dHVhbE15c2VsZk15c3RlcnlNeXRoTmFpdmVOYW1lTmFwa2luTmFycm93TmFzdHlOYXRpb25OYXR1cmVOZWFyTmVja05lZWROZWdhdGl2ZU5lZ2xlY3ROZWl0aGVyTmVwaGV3TmVydmVOZXN0TmV0TmV0d29ya05ldXRyYWxOZXZlck5ld3NOZXh0TmljZU5pZ2h0Tm9ibGVOb2lzZU5vbWluZWVOb29kbGVOb3JtYWxOb3J0aE5vc2VOb3RhYmxlTm90ZU5vdGhpbmdOb3RpY2VOb3ZlbE5vd051Y2xlYXJOdW1iZXJOdXJzZU51dE9ha09iZXlPYmplY3RPYmxpZ2VPYnNjdXJlT2JzZXJ2ZU9idGFpbk9idmlvdXNPY2N1ck9jZWFuT2N0b2Jlck9kb3JPZmZPZmZlck9mZmljZU9mdGVuT2lsT2theU9sZE9saXZlT2x5bXBpY09taXRPbmNlT25lT25pb25PbmxpbmVPbmx5T3Blbk9wZXJhT3Bpbmlvbk9wcG9zZU9wdGlvbk9yYW5nZU9yYml0T3JjaGFyZE9yZGVyT3JkaW5hcnlPcmdhbk9yaWVudE9yaWdpbmFsT3JwaGFuT3N0cmljaE90aGVyT3V0ZG9vck91dGVyT3V0cHV0T3V0c2lkZU92YWxPdmVuT3Zlck93bk93bmVyT3h5Z2VuT3lzdGVyT3pvbmVQYWN0UGFkZGxlUGFnZVBhaXJQYWxhY2VQYWxtUGFuZGFQYW5lbFBhbmljUGFudGhlclBhcGVyUGFyYWRlUGFyZW50UGFya1BhcnJvdFBhcnR5UGFzc1BhdGNoUGF0aFBhdGllbnRQYXRyb2xQYXR0ZXJuUGF1c2VQYXZlUGF5bWVudFBlYWNlUGVhbnV0UGVhclBlYXNhbnRQZWxpY2FuUGVuUGVuYWx0eVBlbmNpbFBlb3BsZVBlcHBlclBlcmZlY3RQZXJtaXRQZXJzb25QZXRQaG9uZVBob3RvUGhyYXNlUGh5c2ljYWxQaWFub1BpY25pY1BpY3R1cmVQaWVjZVBpZ1BpZ2VvblBpbGxQaWxvdFBpbmtQaW9uZWVyUGlwZVBpc3RvbFBpdGNoUGl6emFQbGFjZVBsYW5ldFBsYXN0aWNQbGF0ZVBsYXlQbGVhc2VQbGVkZ2VQbHVja1BsdWdQbHVuZ2VQb2VtUG9ldFBvaW50UG9sYXJQb2xlUG9saWNlUG9uZFBvbnlQb29sUG9wdWxhclBvcnRpb25Qb3NpdGlvblBvc3NpYmxlUG9zdFBvdGF0b1BvdHRlcnlQb3ZlcnR5UG93ZGVyUG93ZXJQcmFjdGljZVByYWlzZVByZWRpY3RQcmVmZXJQcmVwYXJlUHJlc2VudFByZXR0eVByZXZlbnRQcmljZVByaWRlUHJpbWFyeVByaW50UHJpb3JpdHlQcmlzb25Qcml2YXRlUHJpemVQcm9ibGVtUHJvY2Vzc1Byb2R1Y2VQcm9maXRQcm9ncmFtUHJvamVjdFByb21vdGVQcm9vZlByb3BlcnR5UHJvc3BlclByb3RlY3RQcm91ZFByb3ZpZGVQdWJsaWNQdWRkaW5nUHVsbFB1bHBQdWxzZVB1bXBraW5QdW5jaFB1cGlsUHVwcHlQdXJjaGFzZVB1cml0eVB1cnBvc2VQdXJzZVB1c2hQdXRQdXp6bGVQeXJhbWlkUXVhbGl0eVF1YW50dW1RdWFydGVyUXVlc3Rpb25RdWlja1F1aXRRdWl6UXVvdGVSYWJiaXRSYWNjb29uUmFjZVJhY2tSYWRhclJhZGlvUmFpbFJhaW5SYWlzZVJhbGx5UmFtcFJhbmNoUmFuZG9tUmFuZ2VSYXBpZFJhcmVSYXRlUmF0aGVyUmF2ZW5SYXdSYXpvclJlYWR5UmVhbFJlYXNvblJlYmVsUmVidWlsZFJlY2FsbFJlY2VpdmVSZWNpcGVSZWNvcmRSZWN5Y2xlUmVkdWNlUmVmbGVjdFJlZm9ybVJlZnVzZVJlZ2lvblJlZ3JldFJlZ3VsYXJSZWplY3RSZWxheFJlbGVhc2VSZWxpZWZSZWx5UmVtYWluUmVtZW1iZXJSZW1pbmRSZW1vdmVSZW5kZXJSZW5ld1JlbnRSZW9wZW5SZXBhaXJSZXBlYXRSZXBsYWNlUmVwb3J0UmVxdWlyZVJlc2N1ZVJlc2VtYmxlUmVzaXN0UmVzb3VyY2VSZXNwb25zZVJlc3VsdFJldGlyZVJldHJlYXRSZXR1cm5SZXVuaW9uUmV2ZWFsUmV2aWV3UmV3YXJkUmh5dGhtUmliUmliYm9uUmljZVJpY2hSaWRlUmlkZ2VSaWZsZVJpZ2h0UmlnaWRSaW5nUmlvdFJpcHBsZVJpc2tSaXR1YWxSaXZhbFJpdmVyUm9hZFJvYXN0Um9ib3RSb2J1c3RSb2NrZXRSb21hbmNlUm9vZlJvb2tpZVJvb21Sb3NlUm90YXRlUm91Z2hSb3VuZFJvdXRlUm95YWxSdWJiZXJSdWRlUnVnUnVsZVJ1blJ1bndheVJ1cmFsU2FkU2FkZGxlU2FkbmVzc1NhZmVTYWlsU2FsYWRTYWxtb25TYWxvblNhbHRTYWx1dGVTYW1lU2FtcGxlU2FuZFNhdGlzZnlTYXRvc2hpU2F1Y2VTYXVzYWdlU2F2ZVNheVNjYWxlU2NhblNjYXJlU2NhdHRlclNjZW5lU2NoZW1lU2Nob29sU2NpZW5jZVNjaXNzb3JzU2NvcnBpb25TY291dFNjcmFwU2NyZWVuU2NyaXB0U2NydWJTZWFTZWFyY2hTZWFzb25TZWF0U2Vjb25kU2VjcmV0U2VjdGlvblNlY3VyaXR5U2VlZFNlZWtTZWdtZW50U2VsZWN0U2VsbFNlbWluYXJTZW5pb3JTZW5zZVNlbnRlbmNlU2VyaWVzU2VydmljZVNlc3Npb25TZXR0bGVTZXR1cFNldmVuU2hhZG93U2hhZnRTaGFsbG93U2hhcmVTaGVkU2hlbGxTaGVyaWZmU2hpZWxkU2hpZnRTaGluZVNoaXBTaGl2ZXJTaG9ja1Nob2VTaG9vdFNob3BTaG9ydFNob3VsZGVyU2hvdmVTaHJpbXBTaHJ1Z1NodWZmbGVTaHlTaWJsaW5nU2lja1NpZGVTaWVnZVNpZ2h0U2lnblNpbGVudFNpbGtTaWxseVNpbHZlclNpbWlsYXJTaW1wbGVTaW5jZVNpbmdTaXJlblNpc3RlclNpdHVhdGVTaXhTaXplU2thdGVTa2V0Y2hTa2lTa2lsbFNraW5Ta2lydFNrdWxsU2xhYlNsYW1TbGVlcFNsZW5kZXJTbGljZVNsaWRlU2xpZ2h0U2xpbVNsb2dhblNsb3RTbG93U2x1c2hTbWFsbFNtYXJ0U21pbGVTbW9rZVNtb290aFNuYWNrU25ha2VTbmFwU25pZmZTbm93U29hcFNvY2NlclNvY2lhbFNvY2tTb2RhU29mdFNvbGFyU29sZGllclNvbGlkU29sdXRpb25Tb2x2ZVNvbWVvbmVTb25nU29vblNvcnJ5U29ydFNvdWxTb3VuZFNvdXBTb3VyY2VTb3V0aFNwYWNlU3BhcmVTcGF0aWFsU3Bhd25TcGVha1NwZWNpYWxTcGVlZFNwZWxsU3BlbmRTcGhlcmVTcGljZVNwaWRlclNwaWtlU3BpblNwaXJpdFNwbGl0U3BvaWxTcG9uc29yU3Bvb25TcG9ydFNwb3RTcHJheVNwcmVhZFNwcmluZ1NweVNxdWFyZVNxdWVlemVTcXVpcnJlbFN0YWJsZVN0YWRpdW1TdGFmZlN0YWdlU3RhaXJzU3RhbXBTdGFuZFN0YXJ0U3RhdGVTdGF5U3RlYWtTdGVlbFN0ZW1TdGVwU3RlcmVvU3RpY2tTdGlsbFN0aW5nU3RvY2tTdG9tYWNoU3RvbmVTdG9vbFN0b3J5U3RvdmVTdHJhdGVneVN0cmVldFN0cmlrZVN0cm9uZ1N0cnVnZ2xlU3R1ZGVudFN0dWZmU3R1bWJsZVN0eWxlU3ViamVjdFN1Ym1pdFN1YndheVN1Y2Nlc3NTdWNoU3VkZGVuU3VmZmVyU3VnYXJTdWdnZXN0U3VpdFN1bW1lclN1blN1bm55U3Vuc2V0U3VwZXJTdXBwbHlTdXByZW1lU3VyZVN1cmZhY2VTdXJnZVN1cnByaXNlU3Vycm91bmRTdXJ2ZXlTdXNwZWN0U3VzdGFpblN3YWxsb3dTd2FtcFN3YXBTd2FybVN3ZWFyU3dlZXRTd2lmdFN3aW1Td2luZ1N3aXRjaFN3b3JkU3ltYm9sU3ltcHRvbVN5cnVwU3lzdGVtVGFibGVUYWNrbGVUYWdUYWlsVGFsZW50VGFsa1RhbmtUYXBlVGFyZ2V0VGFza1Rhc3RlVGF0dG9vVGF4aVRlYWNoVGVhbVRlbGxUZW5UZW5hbnRUZW5uaXNUZW50VGVybVRlc3RUZXh0VGhhbmtUaGF0VGhlbWVUaGVuVGhlb3J5VGhlcmVUaGV5VGhpbmdUaGlzVGhvdWdodFRocmVlVGhyaXZlVGhyb3dUaHVtYlRodW5kZXJUaWNrZXRUaWRlVGlnZXJUaWx0VGltYmVyVGltZVRpbnlUaXBUaXJlZFRpc3N1ZVRpdGxlVG9hc3RUb2JhY2NvVG9kYXlUb2RkbGVyVG9lVG9nZXRoZXJUb2lsZXRUb2tlblRvbWF0b1RvbW9ycm93VG9uZVRvbmd1ZVRvbmlnaHRUb29sVG9vdGhUb3BUb3BpY1RvcHBsZVRvcmNoVG9ybmFkb1RvcnRvaXNlVG9zc1RvdGFsVG91cmlzdFRvd2FyZFRvd2VyVG93blRveVRyYWNrVHJhZGVUcmFmZmljVHJhZ2ljVHJhaW5UcmFuc2ZlclRyYXBUcmFzaFRyYXZlbFRyYXlUcmVhdFRyZWVUcmVuZFRyaWFsVHJpYmVUcmlja1RyaWdnZXJUcmltVHJpcFRyb3BoeVRyb3VibGVUcnVja1RydWVUcnVseVRydW1wZXRUcnVzdFRydXRoVHJ5VHViZVR1aXRpb25UdW1ibGVUdW5hVHVubmVsVHVya2V5VHVyblR1cnRsZVR3ZWx2ZVR3ZW50eVR3aWNlVHdpblR3aXN0VHdvVHlwZVR5cGljYWxVZ2x5VW1icmVsbGFVbmFibGVVbmF3YXJlVW5jbGVVbmNvdmVyVW5kZXJVbmRvVW5mYWlyVW5mb2xkVW5oYXBweVVuaWZvcm1VbmlxdWVVbml0VW5pdmVyc2VVbmtub3duVW5sb2NrVW50aWxVbnVzdWFsVW52ZWlsVXBkYXRlVXBncmFkZVVwaG9sZFVwb25VcHBlclVwc2V0VXJiYW5VcmdlVXNhZ2VVc2VVc2VkVXNlZnVsVXNlbGVzc1VzdWFsVXRpbGl0eVZhY2FudFZhY3V1bVZhZ3VlVmFsaWRWYWxsZXlWYWx2ZVZhblZhbmlzaFZhcG9yVmFyaW91c1Zhc3RWYXVsdFZlaGljbGVWZWx2ZXRWZW5kb3JWZW50dXJlVmVudWVWZXJiVmVyaWZ5VmVyc2lvblZlcnlWZXNzZWxWZXRlcmFuVmlhYmxlVmlicmFudFZpY2lvdXNWaWN0b3J5VmlkZW9WaWV3VmlsbGFnZVZpbnRhZ2VWaW9saW5WaXJ0dWFsVmlydXNWaXNhVmlzaXRWaXN1YWxWaXRhbFZpdmlkVm9jYWxWb2ljZVZvaWRWb2xjYW5vVm9sdW1lVm90ZVZveWFnZVdhZ2VXYWdvbldhaXRXYWxrV2FsbFdhbG51dFdhbnRXYXJmYXJlV2FybVdhcnJpb3JXYXNoV2FzcFdhc3RlV2F0ZXJXYXZlV2F5V2VhbHRoV2VhcG9uV2VhcldlYXNlbFdlYXRoZXJXZWJXZWRkaW5nV2Vla2VuZFdlaXJkV2VsY29tZVdlc3RXZXRXaGFsZVdoYXRXaGVhdFdoZWVsV2hlbldoZXJlV2hpcFdoaXNwZXJXaWRlV2lkdGhXaWZlV2lsZFdpbGxXaW5XaW5kb3dXaW5lV2luZ1dpbmtXaW5uZXJXaW50ZXJXaXJlV2lzZG9tV2lzZVdpc2hXaXRuZXNzV29sZldvbWFuV29uZGVyV29vZFdvb2xXb3JkV29ya1dvcmxkV29ycnlXb3J0aFdyYXBXcmVja1dyZXN0bGVXcmlzdFdyaXRlV3JvbmdZYXJkWWVhclllbGxvd1lvdVlvdW5nWW91dGhaZWJyYVplcm9ab25lWm9vXCI7XG5sZXQgd29yZGxpc3QgPSBudWxsO1xuZnVuY3Rpb24gbG9hZFdvcmRzKGxhbmcpIHtcbiAgICBpZiAod29yZGxpc3QgIT0gbnVsbCkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHdvcmRsaXN0ID0gd29yZHMucmVwbGFjZSgvKFtBLVpdKS9nLCBcIiAkMVwiKS50b0xvd2VyQ2FzZSgpLnN1YnN0cmluZygxKS5zcGxpdChcIiBcIik7XG4gICAgLy8gVmVyaWZ5IHRoZSBjb21wdXRlZCBsaXN0IG1hdGNoZXMgdGhlIG9mZmljaWFsIGxpc3RcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoV29yZGxpc3QuY2hlY2sobGFuZykgIT09IFwiMHgzYzhhY2MxZTdiMDhkOGU3NmY5ZmRhMDE1ZWY0OGRjOGM3MTBhNzNjYjdlMGY3N2IyYzE4YTliNWE3YWRkZTYwXCIpIHtcbiAgICAgICAgd29yZGxpc3QgPSBudWxsO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJCSVAzOSBXb3JkbGlzdCBmb3IgZW4gKEVuZ2xpc2gpIEZBSUxFRFwiKTtcbiAgICB9XG59XG5jbGFzcyBMYW5nRW4gZXh0ZW5kcyBXb3JkbGlzdCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKFwiZW5cIik7XG4gICAgfVxuICAgIGdldFdvcmQoaW5kZXgpIHtcbiAgICAgICAgbG9hZFdvcmRzKHRoaXMpO1xuICAgICAgICByZXR1cm4gd29yZGxpc3RbaW5kZXhdO1xuICAgIH1cbiAgICBnZXRXb3JkSW5kZXgod29yZCkge1xuICAgICAgICBsb2FkV29yZHModGhpcyk7XG4gICAgICAgIHJldHVybiB3b3JkbGlzdC5pbmRleE9mKHdvcmQpO1xuICAgIH1cbn1cbmNvbnN0IGxhbmdFbiA9IG5ldyBMYW5nRW4oKTtcbldvcmRsaXN0LnJlZ2lzdGVyKGxhbmdFbik7XG5leHBvcnQgeyBsYW5nRW4gfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmctZW4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG4vLyBUaGlzIGdldHMgb3ZlcnJpZGRlbiBieSByb2xsdXBcbmNvbnN0IGV4cG9ydFdvcmRsaXN0ID0gZmFsc2U7XG5pbXBvcnQgeyBpZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oYXNoXCI7XG5pbXBvcnQgeyBkZWZpbmVSZWFkT25seSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm9wZXJ0aWVzXCI7XG5pbXBvcnQgeyBMb2dnZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvbG9nZ2VyXCI7XG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmV4cG9ydCBjb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKHZlcnNpb24pO1xuZXhwb3J0IGNsYXNzIFdvcmRsaXN0IHtcbiAgICBjb25zdHJ1Y3Rvcihsb2NhbGUpIHtcbiAgICAgICAgbG9nZ2VyLmNoZWNrQWJzdHJhY3QobmV3LnRhcmdldCwgV29yZGxpc3QpO1xuICAgICAgICBkZWZpbmVSZWFkT25seSh0aGlzLCBcImxvY2FsZVwiLCBsb2NhbGUpO1xuICAgIH1cbiAgICAvLyBTdWJjbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzXG4gICAgc3BsaXQobW5lbW9uaWMpIHtcbiAgICAgICAgcmV0dXJuIG1uZW1vbmljLnRvTG93ZXJDYXNlKCkuc3BsaXQoLyArL2cpO1xuICAgIH1cbiAgICAvLyBTdWJjbGFzc2VzIG1heSBvdmVycmlkZSB0aGlzXG4gICAgam9pbih3b3Jkcykge1xuICAgICAgICByZXR1cm4gd29yZHMuam9pbihcIiBcIik7XG4gICAgfVxuICAgIHN0YXRpYyBjaGVjayh3b3JkbGlzdCkge1xuICAgICAgICBjb25zdCB3b3JkcyA9IFtdO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDIwNDg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qgd29yZCA9IHdvcmRsaXN0LmdldFdvcmQoaSk7XG4gICAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICAgIGlmIChpICE9PSB3b3JkbGlzdC5nZXRXb3JkSW5kZXgod29yZCkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gXCIweFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgd29yZHMucHVzaCh3b3JkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaWQod29yZHMuam9pbihcIlxcblwiKSArIFwiXFxuXCIpO1xuICAgIH1cbiAgICBzdGF0aWMgcmVnaXN0ZXIobGFuZywgbmFtZSkge1xuICAgICAgICBpZiAoIW5hbWUpIHtcbiAgICAgICAgICAgIG5hbWUgPSBsYW5nLmxvY2FsZTtcbiAgICAgICAgfVxuICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgaWYgKGV4cG9ydFdvcmRsaXN0KSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFueUdsb2JhbCA9IHdpbmRvdztcbiAgICAgICAgICAgICAgICBpZiAoYW55R2xvYmFsLl9ldGhlcnMgJiYgYW55R2xvYmFsLl9ldGhlcnMud29yZGxpc3RzKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghYW55R2xvYmFsLl9ldGhlcnMud29yZGxpc3RzW25hbWVdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVSZWFkT25seShhbnlHbG9iYWwuX2V0aGVycy53b3JkbGlzdHMsIG5hbWUsIGxhbmcpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgIH1cbn1cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdvcmRsaXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgbGFuZ0VuIGFzIGVuIH0gZnJvbSBcIi4vbGFuZy1lblwiO1xuZXhwb3J0IGNvbnN0IHdvcmRsaXN0cyA9IHtcbiAgICBlbjogZW5cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD13b3JkbGlzdHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbihmdW5jdGlvbihyb290KSB7XG5cbiAgICBmdW5jdGlvbiBjaGVja0ludCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gKHBhcnNlSW50KHZhbHVlKSA9PT0gdmFsdWUpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrSW50cyhhcnJheWlzaCkge1xuICAgICAgICBpZiAoIWNoZWNrSW50KGFycmF5aXNoLmxlbmd0aCkpIHsgcmV0dXJuIGZhbHNlOyB9XG5cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheWlzaC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKCFjaGVja0ludChhcnJheWlzaFtpXSkgfHwgYXJyYXlpc2hbaV0gPCAwIHx8IGFycmF5aXNoW2ldID4gMjU1KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29lcmNlQXJyYXkoYXJnLCBjb3B5KSB7XG5cbiAgICAgICAgLy8gQXJyYXlCdWZmZXIgdmlld1xuICAgICAgICBpZiAoYXJnLmJ1ZmZlciAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcoYXJnKSAmJiBhcmcubmFtZSA9PT0gJ1VpbnQ4QXJyYXknKSB7XG5cbiAgICAgICAgICAgIGlmIChjb3B5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5zbGljZSkge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBhcmcuc2xpY2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBhcmcgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEl0J3MgYW4gYXJyYXk7IGNoZWNrIGl0IGlzIGEgdmFsaWQgcmVwcmVzZW50YXRpb24gb2YgYSBieXRlXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcbiAgICAgICAgICAgIGlmICghY2hlY2tJbnRzKGFyZykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FycmF5IGNvbnRhaW5zIGludmFsaWQgdmFsdWU6ICcgKyBhcmcpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFNvbWV0aGluZyBlbHNlLCBidXQgYmVoYXZlcyBsaWtlIGFuIGFycmF5IChtYXliZSBhIEJ1ZmZlcj8gQXJndW1lbnRzPylcbiAgICAgICAgaWYgKGNoZWNrSW50KGFyZy5sZW5ndGgpICYmIGNoZWNrSW50cyhhcmcpKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoYXJnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRocm93IG5ldyBFcnJvcigndW5zdXBwb3J0ZWQgYXJyYXktbGlrZSBvYmplY3QnKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjcmVhdGVBcnJheShsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGxlbmd0aCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY29weUFycmF5KHNvdXJjZUFycmF5LCB0YXJnZXRBcnJheSwgdGFyZ2V0U3RhcnQsIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpIHtcbiAgICAgICAgaWYgKHNvdXJjZVN0YXJ0ICE9IG51bGwgfHwgc291cmNlRW5kICE9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChzb3VyY2VBcnJheS5zbGljZSkge1xuICAgICAgICAgICAgICAgIHNvdXJjZUFycmF5ID0gc291cmNlQXJyYXkuc2xpY2Uoc291cmNlU3RhcnQsIHNvdXJjZUVuZCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHNvdXJjZUFycmF5ID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoc291cmNlQXJyYXksIHNvdXJjZVN0YXJ0LCBzb3VyY2VFbmQpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRhcmdldEFycmF5LnNldChzb3VyY2VBcnJheSwgdGFyZ2V0U3RhcnQpO1xuICAgIH1cblxuXG5cbiAgICB2YXIgY29udmVydFV0ZjggPSAoZnVuY3Rpb24oKSB7XG4gICAgICAgIGZ1bmN0aW9uIHRvQnl0ZXModGV4dCkge1xuICAgICAgICAgICAgdmFyIHJlc3VsdCA9IFtdLCBpID0gMDtcbiAgICAgICAgICAgIHRleHQgPSBlbmNvZGVVUkkodGV4dCk7XG4gICAgICAgICAgICB3aGlsZSAoaSA8IHRleHQubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSB0ZXh0LmNoYXJDb2RlQXQoaSsrKTtcblxuICAgICAgICAgICAgICAgIC8vIGlmIGl0IGlzIGEgJSBzaWduLCBlbmNvZGUgdGhlIGZvbGxvd2luZyAyIGJ5dGVzIGFzIGEgaGV4IHZhbHVlXG4gICAgICAgICAgICAgICAgaWYgKGMgPT09IDM3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHRleHQuc3Vic3RyKGksIDIpLCAxNikpXG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMjtcblxuICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSwganVzdCB0aGUgYWN0dWFsIGJ5dGVcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChjKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIGNvZXJjZUFycmF5KHJlc3VsdCk7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXSwgaSA9IDA7XG5cbiAgICAgICAgICAgIHdoaWxlIChpIDwgYnl0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgdmFyIGMgPSBieXRlc1tpXTtcblxuICAgICAgICAgICAgICAgIGlmIChjIDwgMTI4KSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKFN0cmluZy5mcm9tQ2hhckNvZGUoYykpO1xuICAgICAgICAgICAgICAgICAgICBpKys7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChjID4gMTkxICYmIGMgPCAyMjQpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDFmKSA8PCA2KSB8IChieXRlc1tpICsgMV0gJiAweDNmKSkpO1xuICAgICAgICAgICAgICAgICAgICBpICs9IDI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmVzdWx0LnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZSgoKGMgJiAweDBmKSA8PCAxMikgfCAoKGJ5dGVzW2kgKyAxXSAmIDB4M2YpIDw8IDYpIHwgKGJ5dGVzW2kgKyAyXSAmIDB4M2YpKSk7XG4gICAgICAgICAgICAgICAgICAgIGkgKz0gMztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHJldHVybiByZXN1bHQuam9pbignJyk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdG9CeXRlczogdG9CeXRlcyxcbiAgICAgICAgICAgIGZyb21CeXRlczogZnJvbUJ5dGVzLFxuICAgICAgICB9XG4gICAgfSkoKTtcblxuICAgIHZhciBjb252ZXJ0SGV4ID0gKGZ1bmN0aW9uKCkge1xuICAgICAgICBmdW5jdGlvbiB0b0J5dGVzKHRleHQpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGV4dC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHBhcnNlSW50KHRleHQuc3Vic3RyKGksIDIpLCAxNikpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2l4dGkubmV0L2RldmVsb3BtZW50L2phdmFzY3JpcHQvMjAxMS8xMS8xMS9iYXNlNjQtZW5jb2RlZGVjb2RlLW9mLXV0ZjgtaW4tYnJvd3Nlci13aXRoLWpzLmh0bWxcbiAgICAgICAgdmFyIEhleCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcblxuICAgICAgICBmdW5jdGlvbiBmcm9tQnl0ZXMoYnl0ZXMpIHtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgdiA9IGJ5dGVzW2ldO1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQucHVzaChIZXhbKHYgJiAweGYwKSA+PiA0XSArIEhleFt2ICYgMHgwZl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0LmpvaW4oJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHRvQnl0ZXM6IHRvQnl0ZXMsXG4gICAgICAgICAgICBmcm9tQnl0ZXM6IGZyb21CeXRlcyxcbiAgICAgICAgfVxuICAgIH0pKCk7XG5cblxuICAgIC8vIE51bWJlciBvZiByb3VuZHMgYnkga2V5c2l6ZVxuICAgIHZhciBudW1iZXJPZlJvdW5kcyA9IHsxNjogMTAsIDI0OiAxMiwgMzI6IDE0fVxuXG4gICAgLy8gUm91bmQgY29uc3RhbnQgd29yZHNcbiAgICB2YXIgcmNvbiA9IFsweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2LCAweDZjLCAweGQ4LCAweGFiLCAweDRkLCAweDlhLCAweDJmLCAweDVlLCAweGJjLCAweDYzLCAweGM2LCAweDk3LCAweDM1LCAweDZhLCAweGQ0LCAweGIzLCAweDdkLCAweGZhLCAweGVmLCAweGM1LCAweDkxXTtcblxuICAgIC8vIFMtYm94IGFuZCBJbnZlcnNlIFMtYm94IChTIGlzIGZvciBTdWJzdGl0dXRpb24pXG4gICAgdmFyIFMgPSBbMHg2MywgMHg3YywgMHg3NywgMHg3YiwgMHhmMiwgMHg2YiwgMHg2ZiwgMHhjNSwgMHgzMCwgMHgwMSwgMHg2NywgMHgyYiwgMHhmZSwgMHhkNywgMHhhYiwgMHg3NiwgMHhjYSwgMHg4MiwgMHhjOSwgMHg3ZCwgMHhmYSwgMHg1OSwgMHg0NywgMHhmMCwgMHhhZCwgMHhkNCwgMHhhMiwgMHhhZiwgMHg5YywgMHhhNCwgMHg3MiwgMHhjMCwgMHhiNywgMHhmZCwgMHg5MywgMHgyNiwgMHgzNiwgMHgzZiwgMHhmNywgMHhjYywgMHgzNCwgMHhhNSwgMHhlNSwgMHhmMSwgMHg3MSwgMHhkOCwgMHgzMSwgMHgxNSwgMHgwNCwgMHhjNywgMHgyMywgMHhjMywgMHgxOCwgMHg5NiwgMHgwNSwgMHg5YSwgMHgwNywgMHgxMiwgMHg4MCwgMHhlMiwgMHhlYiwgMHgyNywgMHhiMiwgMHg3NSwgMHgwOSwgMHg4MywgMHgyYywgMHgxYSwgMHgxYiwgMHg2ZSwgMHg1YSwgMHhhMCwgMHg1MiwgMHgzYiwgMHhkNiwgMHhiMywgMHgyOSwgMHhlMywgMHgyZiwgMHg4NCwgMHg1MywgMHhkMSwgMHgwMCwgMHhlZCwgMHgyMCwgMHhmYywgMHhiMSwgMHg1YiwgMHg2YSwgMHhjYiwgMHhiZSwgMHgzOSwgMHg0YSwgMHg0YywgMHg1OCwgMHhjZiwgMHhkMCwgMHhlZiwgMHhhYSwgMHhmYiwgMHg0MywgMHg0ZCwgMHgzMywgMHg4NSwgMHg0NSwgMHhmOSwgMHgwMiwgMHg3ZiwgMHg1MCwgMHgzYywgMHg5ZiwgMHhhOCwgMHg1MSwgMHhhMywgMHg0MCwgMHg4ZiwgMHg5MiwgMHg5ZCwgMHgzOCwgMHhmNSwgMHhiYywgMHhiNiwgMHhkYSwgMHgyMSwgMHgxMCwgMHhmZiwgMHhmMywgMHhkMiwgMHhjZCwgMHgwYywgMHgxMywgMHhlYywgMHg1ZiwgMHg5NywgMHg0NCwgMHgxNywgMHhjNCwgMHhhNywgMHg3ZSwgMHgzZCwgMHg2NCwgMHg1ZCwgMHgxOSwgMHg3MywgMHg2MCwgMHg4MSwgMHg0ZiwgMHhkYywgMHgyMiwgMHgyYSwgMHg5MCwgMHg4OCwgMHg0NiwgMHhlZSwgMHhiOCwgMHgxNCwgMHhkZSwgMHg1ZSwgMHgwYiwgMHhkYiwgMHhlMCwgMHgzMiwgMHgzYSwgMHgwYSwgMHg0OSwgMHgwNiwgMHgyNCwgMHg1YywgMHhjMiwgMHhkMywgMHhhYywgMHg2MiwgMHg5MSwgMHg5NSwgMHhlNCwgMHg3OSwgMHhlNywgMHhjOCwgMHgzNywgMHg2ZCwgMHg4ZCwgMHhkNSwgMHg0ZSwgMHhhOSwgMHg2YywgMHg1NiwgMHhmNCwgMHhlYSwgMHg2NSwgMHg3YSwgMHhhZSwgMHgwOCwgMHhiYSwgMHg3OCwgMHgyNSwgMHgyZSwgMHgxYywgMHhhNiwgMHhiNCwgMHhjNiwgMHhlOCwgMHhkZCwgMHg3NCwgMHgxZiwgMHg0YiwgMHhiZCwgMHg4YiwgMHg4YSwgMHg3MCwgMHgzZSwgMHhiNSwgMHg2NiwgMHg0OCwgMHgwMywgMHhmNiwgMHgwZSwgMHg2MSwgMHgzNSwgMHg1NywgMHhiOSwgMHg4NiwgMHhjMSwgMHgxZCwgMHg5ZSwgMHhlMSwgMHhmOCwgMHg5OCwgMHgxMSwgMHg2OSwgMHhkOSwgMHg4ZSwgMHg5NCwgMHg5YiwgMHgxZSwgMHg4NywgMHhlOSwgMHhjZSwgMHg1NSwgMHgyOCwgMHhkZiwgMHg4YywgMHhhMSwgMHg4OSwgMHgwZCwgMHhiZiwgMHhlNiwgMHg0MiwgMHg2OCwgMHg0MSwgMHg5OSwgMHgyZCwgMHgwZiwgMHhiMCwgMHg1NCwgMHhiYiwgMHgxNl07XG4gICAgdmFyIFNpID1bMHg1MiwgMHgwOSwgMHg2YSwgMHhkNSwgMHgzMCwgMHgzNiwgMHhhNSwgMHgzOCwgMHhiZiwgMHg0MCwgMHhhMywgMHg5ZSwgMHg4MSwgMHhmMywgMHhkNywgMHhmYiwgMHg3YywgMHhlMywgMHgzOSwgMHg4MiwgMHg5YiwgMHgyZiwgMHhmZiwgMHg4NywgMHgzNCwgMHg4ZSwgMHg0MywgMHg0NCwgMHhjNCwgMHhkZSwgMHhlOSwgMHhjYiwgMHg1NCwgMHg3YiwgMHg5NCwgMHgzMiwgMHhhNiwgMHhjMiwgMHgyMywgMHgzZCwgMHhlZSwgMHg0YywgMHg5NSwgMHgwYiwgMHg0MiwgMHhmYSwgMHhjMywgMHg0ZSwgMHgwOCwgMHgyZSwgMHhhMSwgMHg2NiwgMHgyOCwgMHhkOSwgMHgyNCwgMHhiMiwgMHg3NiwgMHg1YiwgMHhhMiwgMHg0OSwgMHg2ZCwgMHg4YiwgMHhkMSwgMHgyNSwgMHg3MiwgMHhmOCwgMHhmNiwgMHg2NCwgMHg4NiwgMHg2OCwgMHg5OCwgMHgxNiwgMHhkNCwgMHhhNCwgMHg1YywgMHhjYywgMHg1ZCwgMHg2NSwgMHhiNiwgMHg5MiwgMHg2YywgMHg3MCwgMHg0OCwgMHg1MCwgMHhmZCwgMHhlZCwgMHhiOSwgMHhkYSwgMHg1ZSwgMHgxNSwgMHg0NiwgMHg1NywgMHhhNywgMHg4ZCwgMHg5ZCwgMHg4NCwgMHg5MCwgMHhkOCwgMHhhYiwgMHgwMCwgMHg4YywgMHhiYywgMHhkMywgMHgwYSwgMHhmNywgMHhlNCwgMHg1OCwgMHgwNSwgMHhiOCwgMHhiMywgMHg0NSwgMHgwNiwgMHhkMCwgMHgyYywgMHgxZSwgMHg4ZiwgMHhjYSwgMHgzZiwgMHgwZiwgMHgwMiwgMHhjMSwgMHhhZiwgMHhiZCwgMHgwMywgMHgwMSwgMHgxMywgMHg4YSwgMHg2YiwgMHgzYSwgMHg5MSwgMHgxMSwgMHg0MSwgMHg0ZiwgMHg2NywgMHhkYywgMHhlYSwgMHg5NywgMHhmMiwgMHhjZiwgMHhjZSwgMHhmMCwgMHhiNCwgMHhlNiwgMHg3MywgMHg5NiwgMHhhYywgMHg3NCwgMHgyMiwgMHhlNywgMHhhZCwgMHgzNSwgMHg4NSwgMHhlMiwgMHhmOSwgMHgzNywgMHhlOCwgMHgxYywgMHg3NSwgMHhkZiwgMHg2ZSwgMHg0NywgMHhmMSwgMHgxYSwgMHg3MSwgMHgxZCwgMHgyOSwgMHhjNSwgMHg4OSwgMHg2ZiwgMHhiNywgMHg2MiwgMHgwZSwgMHhhYSwgMHgxOCwgMHhiZSwgMHgxYiwgMHhmYywgMHg1NiwgMHgzZSwgMHg0YiwgMHhjNiwgMHhkMiwgMHg3OSwgMHgyMCwgMHg5YSwgMHhkYiwgMHhjMCwgMHhmZSwgMHg3OCwgMHhjZCwgMHg1YSwgMHhmNCwgMHgxZiwgMHhkZCwgMHhhOCwgMHgzMywgMHg4OCwgMHgwNywgMHhjNywgMHgzMSwgMHhiMSwgMHgxMiwgMHgxMCwgMHg1OSwgMHgyNywgMHg4MCwgMHhlYywgMHg1ZiwgMHg2MCwgMHg1MSwgMHg3ZiwgMHhhOSwgMHgxOSwgMHhiNSwgMHg0YSwgMHgwZCwgMHgyZCwgMHhlNSwgMHg3YSwgMHg5ZiwgMHg5MywgMHhjOSwgMHg5YywgMHhlZiwgMHhhMCwgMHhlMCwgMHgzYiwgMHg0ZCwgMHhhZSwgMHgyYSwgMHhmNSwgMHhiMCwgMHhjOCwgMHhlYiwgMHhiYiwgMHgzYywgMHg4MywgMHg1MywgMHg5OSwgMHg2MSwgMHgxNywgMHgyYiwgMHgwNCwgMHg3ZSwgMHhiYSwgMHg3NywgMHhkNiwgMHgyNiwgMHhlMSwgMHg2OSwgMHgxNCwgMHg2MywgMHg1NSwgMHgyMSwgMHgwYywgMHg3ZF07XG5cbiAgICAvLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGVuY3J5cHRpb25cbiAgICB2YXIgVDEgPSBbMHhjNjYzNjNhNSwgMHhmODdjN2M4NCwgMHhlZTc3Nzc5OSwgMHhmNjdiN2I4ZCwgMHhmZmYyZjIwZCwgMHhkNjZiNmJiZCwgMHhkZTZmNmZiMSwgMHg5MWM1YzU1NCwgMHg2MDMwMzA1MCwgMHgwMjAxMDEwMywgMHhjZTY3NjdhOSwgMHg1NjJiMmI3ZCwgMHhlN2ZlZmUxOSwgMHhiNWQ3ZDc2MiwgMHg0ZGFiYWJlNiwgMHhlYzc2NzY5YSwgMHg4ZmNhY2E0NSwgMHgxZjgyODI5ZCwgMHg4OWM5Yzk0MCwgMHhmYTdkN2Q4NywgMHhlZmZhZmExNSwgMHhiMjU5NTllYiwgMHg4ZTQ3NDdjOSwgMHhmYmYwZjAwYiwgMHg0MWFkYWRlYywgMHhiM2Q0ZDQ2NywgMHg1ZmEyYTJmZCwgMHg0NWFmYWZlYSwgMHgyMzljOWNiZiwgMHg1M2E0YTRmNywgMHhlNDcyNzI5NiwgMHg5YmMwYzA1YiwgMHg3NWI3YjdjMiwgMHhlMWZkZmQxYywgMHgzZDkzOTNhZSwgMHg0YzI2MjY2YSwgMHg2YzM2MzY1YSwgMHg3ZTNmM2Y0MSwgMHhmNWY3ZjcwMiwgMHg4M2NjY2M0ZiwgMHg2ODM0MzQ1YywgMHg1MWE1YTVmNCwgMHhkMWU1ZTUzNCwgMHhmOWYxZjEwOCwgMHhlMjcxNzE5MywgMHhhYmQ4ZDg3MywgMHg2MjMxMzE1MywgMHgyYTE1MTUzZiwgMHgwODA0MDQwYywgMHg5NWM3Yzc1MiwgMHg0NjIzMjM2NSwgMHg5ZGMzYzM1ZSwgMHgzMDE4MTgyOCwgMHgzNzk2OTZhMSwgMHgwYTA1MDUwZiwgMHgyZjlhOWFiNSwgMHgwZTA3MDcwOSwgMHgyNDEyMTIzNiwgMHgxYjgwODA5YiwgMHhkZmUyZTIzZCwgMHhjZGViZWIyNiwgMHg0ZTI3Mjc2OSwgMHg3ZmIyYjJjZCwgMHhlYTc1NzU5ZiwgMHgxMjA5MDkxYiwgMHgxZDgzODM5ZSwgMHg1ODJjMmM3NCwgMHgzNDFhMWEyZSwgMHgzNjFiMWIyZCwgMHhkYzZlNmViMiwgMHhiNDVhNWFlZSwgMHg1YmEwYTBmYiwgMHhhNDUyNTJmNiwgMHg3NjNiM2I0ZCwgMHhiN2Q2ZDY2MSwgMHg3ZGIzYjNjZSwgMHg1MjI5Mjk3YiwgMHhkZGUzZTMzZSwgMHg1ZTJmMmY3MSwgMHgxMzg0ODQ5NywgMHhhNjUzNTNmNSwgMHhiOWQxZDE2OCwgMHgwMDAwMDAwMCwgMHhjMWVkZWQyYywgMHg0MDIwMjA2MCwgMHhlM2ZjZmMxZiwgMHg3OWIxYjFjOCwgMHhiNjViNWJlZCwgMHhkNDZhNmFiZSwgMHg4ZGNiY2I0NiwgMHg2N2JlYmVkOSwgMHg3MjM5Mzk0YiwgMHg5NDRhNGFkZSwgMHg5ODRjNGNkNCwgMHhiMDU4NThlOCwgMHg4NWNmY2Y0YSwgMHhiYmQwZDA2YiwgMHhjNWVmZWYyYSwgMHg0ZmFhYWFlNSwgMHhlZGZiZmIxNiwgMHg4NjQzNDNjNSwgMHg5YTRkNGRkNywgMHg2NjMzMzM1NSwgMHgxMTg1ODU5NCwgMHg4YTQ1NDVjZiwgMHhlOWY5ZjkxMCwgMHgwNDAyMDIwNiwgMHhmZTdmN2Y4MSwgMHhhMDUwNTBmMCwgMHg3ODNjM2M0NCwgMHgyNTlmOWZiYSwgMHg0YmE4YThlMywgMHhhMjUxNTFmMywgMHg1ZGEzYTNmZSwgMHg4MDQwNDBjMCwgMHgwNThmOGY4YSwgMHgzZjkyOTJhZCwgMHgyMTlkOWRiYywgMHg3MDM4Mzg0OCwgMHhmMWY1ZjUwNCwgMHg2M2JjYmNkZiwgMHg3N2I2YjZjMSwgMHhhZmRhZGE3NSwgMHg0MjIxMjE2MywgMHgyMDEwMTAzMCwgMHhlNWZmZmYxYSwgMHhmZGYzZjMwZSwgMHhiZmQyZDI2ZCwgMHg4MWNkY2Q0YywgMHgxODBjMGMxNCwgMHgyNjEzMTMzNSwgMHhjM2VjZWMyZiwgMHhiZTVmNWZlMSwgMHgzNTk3OTdhMiwgMHg4ODQ0NDRjYywgMHgyZTE3MTczOSwgMHg5M2M0YzQ1NywgMHg1NWE3YTdmMiwgMHhmYzdlN2U4MiwgMHg3YTNkM2Q0NywgMHhjODY0NjRhYywgMHhiYTVkNWRlNywgMHgzMjE5MTkyYiwgMHhlNjczNzM5NSwgMHhjMDYwNjBhMCwgMHgxOTgxODE5OCwgMHg5ZTRmNGZkMSwgMHhhM2RjZGM3ZiwgMHg0NDIyMjI2NiwgMHg1NDJhMmE3ZSwgMHgzYjkwOTBhYiwgMHgwYjg4ODg4MywgMHg4YzQ2NDZjYSwgMHhjN2VlZWUyOSwgMHg2YmI4YjhkMywgMHgyODE0MTQzYywgMHhhN2RlZGU3OSwgMHhiYzVlNWVlMiwgMHgxNjBiMGIxZCwgMHhhZGRiZGI3NiwgMHhkYmUwZTAzYiwgMHg2NDMyMzI1NiwgMHg3NDNhM2E0ZSwgMHgxNDBhMGExZSwgMHg5MjQ5NDlkYiwgMHgwYzA2MDYwYSwgMHg0ODI0MjQ2YywgMHhiODVjNWNlNCwgMHg5ZmMyYzI1ZCwgMHhiZGQzZDM2ZSwgMHg0M2FjYWNlZiwgMHhjNDYyNjJhNiwgMHgzOTkxOTFhOCwgMHgzMTk1OTVhNCwgMHhkM2U0ZTQzNywgMHhmMjc5Nzk4YiwgMHhkNWU3ZTczMiwgMHg4YmM4Yzg0MywgMHg2ZTM3Mzc1OSwgMHhkYTZkNmRiNywgMHgwMThkOGQ4YywgMHhiMWQ1ZDU2NCwgMHg5YzRlNGVkMiwgMHg0OWE5YTllMCwgMHhkODZjNmNiNCwgMHhhYzU2NTZmYSwgMHhmM2Y0ZjQwNywgMHhjZmVhZWEyNSwgMHhjYTY1NjVhZiwgMHhmNDdhN2E4ZSwgMHg0N2FlYWVlOSwgMHgxMDA4MDgxOCwgMHg2ZmJhYmFkNSwgMHhmMDc4Nzg4OCwgMHg0YTI1MjU2ZiwgMHg1YzJlMmU3MiwgMHgzODFjMWMyNCwgMHg1N2E2YTZmMSwgMHg3M2I0YjRjNywgMHg5N2M2YzY1MSwgMHhjYmU4ZTgyMywgMHhhMWRkZGQ3YywgMHhlODc0NzQ5YywgMHgzZTFmMWYyMSwgMHg5NjRiNGJkZCwgMHg2MWJkYmRkYywgMHgwZDhiOGI4NiwgMHgwZjhhOGE4NSwgMHhlMDcwNzA5MCwgMHg3YzNlM2U0MiwgMHg3MWI1YjVjNCwgMHhjYzY2NjZhYSwgMHg5MDQ4NDhkOCwgMHgwNjAzMDMwNSwgMHhmN2Y2ZjYwMSwgMHgxYzBlMGUxMiwgMHhjMjYxNjFhMywgMHg2YTM1MzU1ZiwgMHhhZTU3NTdmOSwgMHg2OWI5YjlkMCwgMHgxNzg2ODY5MSwgMHg5OWMxYzE1OCwgMHgzYTFkMWQyNywgMHgyNzllOWViOSwgMHhkOWUxZTEzOCwgMHhlYmY4ZjgxMywgMHgyYjk4OThiMywgMHgyMjExMTEzMywgMHhkMjY5NjliYiwgMHhhOWQ5ZDk3MCwgMHgwNzhlOGU4OSwgMHgzMzk0OTRhNywgMHgyZDliOWJiNiwgMHgzYzFlMWUyMiwgMHgxNTg3ODc5MiwgMHhjOWU5ZTkyMCwgMHg4N2NlY2U0OSwgMHhhYTU1NTVmZiwgMHg1MDI4Mjg3OCwgMHhhNWRmZGY3YSwgMHgwMzhjOGM4ZiwgMHg1OWExYTFmOCwgMHgwOTg5ODk4MCwgMHgxYTBkMGQxNywgMHg2NWJmYmZkYSwgMHhkN2U2ZTYzMSwgMHg4NDQyNDJjNiwgMHhkMDY4NjhiOCwgMHg4MjQxNDFjMywgMHgyOTk5OTliMCwgMHg1YTJkMmQ3NywgMHgxZTBmMGYxMSwgMHg3YmIwYjBjYiwgMHhhODU0NTRmYywgMHg2ZGJiYmJkNiwgMHgyYzE2MTYzYV07XG4gICAgdmFyIFQyID0gWzB4YTVjNjYzNjMsIDB4ODRmODdjN2MsIDB4OTllZTc3NzcsIDB4OGRmNjdiN2IsIDB4MGRmZmYyZjIsIDB4YmRkNjZiNmIsIDB4YjFkZTZmNmYsIDB4NTQ5MWM1YzUsIDB4NTA2MDMwMzAsIDB4MDMwMjAxMDEsIDB4YTljZTY3NjcsIDB4N2Q1NjJiMmIsIDB4MTllN2ZlZmUsIDB4NjJiNWQ3ZDcsIDB4ZTY0ZGFiYWIsIDB4OWFlYzc2NzYsIDB4NDU4ZmNhY2EsIDB4OWQxZjgyODIsIDB4NDA4OWM5YzksIDB4ODdmYTdkN2QsIDB4MTVlZmZhZmEsIDB4ZWJiMjU5NTksIDB4Yzk4ZTQ3NDcsIDB4MGJmYmYwZjAsIDB4ZWM0MWFkYWQsIDB4NjdiM2Q0ZDQsIDB4ZmQ1ZmEyYTIsIDB4ZWE0NWFmYWYsIDB4YmYyMzljOWMsIDB4Zjc1M2E0YTQsIDB4OTZlNDcyNzIsIDB4NWI5YmMwYzAsIDB4YzI3NWI3YjcsIDB4MWNlMWZkZmQsIDB4YWUzZDkzOTMsIDB4NmE0YzI2MjYsIDB4NWE2YzM2MzYsIDB4NDE3ZTNmM2YsIDB4MDJmNWY3ZjcsIDB4NGY4M2NjY2MsIDB4NWM2ODM0MzQsIDB4ZjQ1MWE1YTUsIDB4MzRkMWU1ZTUsIDB4MDhmOWYxZjEsIDB4OTNlMjcxNzEsIDB4NzNhYmQ4ZDgsIDB4NTM2MjMxMzEsIDB4M2YyYTE1MTUsIDB4MGMwODA0MDQsIDB4NTI5NWM3YzcsIDB4NjU0NjIzMjMsIDB4NWU5ZGMzYzMsIDB4MjgzMDE4MTgsIDB4YTEzNzk2OTYsIDB4MGYwYTA1MDUsIDB4YjUyZjlhOWEsIDB4MDkwZTA3MDcsIDB4MzYyNDEyMTIsIDB4OWIxYjgwODAsIDB4M2RkZmUyZTIsIDB4MjZjZGViZWIsIDB4Njk0ZTI3MjcsIDB4Y2Q3ZmIyYjIsIDB4OWZlYTc1NzUsIDB4MWIxMjA5MDksIDB4OWUxZDgzODMsIDB4NzQ1ODJjMmMsIDB4MmUzNDFhMWEsIDB4MmQzNjFiMWIsIDB4YjJkYzZlNmUsIDB4ZWViNDVhNWEsIDB4ZmI1YmEwYTAsIDB4ZjZhNDUyNTIsIDB4NGQ3NjNiM2IsIDB4NjFiN2Q2ZDYsIDB4Y2U3ZGIzYjMsIDB4N2I1MjI5MjksIDB4M2VkZGUzZTMsIDB4NzE1ZTJmMmYsIDB4OTcxMzg0ODQsIDB4ZjVhNjUzNTMsIDB4NjhiOWQxZDEsIDB4MDAwMDAwMDAsIDB4MmNjMWVkZWQsIDB4NjA0MDIwMjAsIDB4MWZlM2ZjZmMsIDB4Yzg3OWIxYjEsIDB4ZWRiNjViNWIsIDB4YmVkNDZhNmEsIDB4NDY4ZGNiY2IsIDB4ZDk2N2JlYmUsIDB4NGI3MjM5MzksIDB4ZGU5NDRhNGEsIDB4ZDQ5ODRjNGMsIDB4ZThiMDU4NTgsIDB4NGE4NWNmY2YsIDB4NmJiYmQwZDAsIDB4MmFjNWVmZWYsIDB4ZTU0ZmFhYWEsIDB4MTZlZGZiZmIsIDB4YzU4NjQzNDMsIDB4ZDc5YTRkNGQsIDB4NTU2NjMzMzMsIDB4OTQxMTg1ODUsIDB4Y2Y4YTQ1NDUsIDB4MTBlOWY5ZjksIDB4MDYwNDAyMDIsIDB4ODFmZTdmN2YsIDB4ZjBhMDUwNTAsIDB4NDQ3ODNjM2MsIDB4YmEyNTlmOWYsIDB4ZTM0YmE4YTgsIDB4ZjNhMjUxNTEsIDB4ZmU1ZGEzYTMsIDB4YzA4MDQwNDAsIDB4OGEwNThmOGYsIDB4YWQzZjkyOTIsIDB4YmMyMTlkOWQsIDB4NDg3MDM4MzgsIDB4MDRmMWY1ZjUsIDB4ZGY2M2JjYmMsIDB4YzE3N2I2YjYsIDB4NzVhZmRhZGEsIDB4NjM0MjIxMjEsIDB4MzAyMDEwMTAsIDB4MWFlNWZmZmYsIDB4MGVmZGYzZjMsIDB4NmRiZmQyZDIsIDB4NGM4MWNkY2QsIDB4MTQxODBjMGMsIDB4MzUyNjEzMTMsIDB4MmZjM2VjZWMsIDB4ZTFiZTVmNWYsIDB4YTIzNTk3OTcsIDB4Y2M4ODQ0NDQsIDB4MzkyZTE3MTcsIDB4NTc5M2M0YzQsIDB4ZjI1NWE3YTcsIDB4ODJmYzdlN2UsIDB4NDc3YTNkM2QsIDB4YWNjODY0NjQsIDB4ZTdiYTVkNWQsIDB4MmIzMjE5MTksIDB4OTVlNjczNzMsIDB4YTBjMDYwNjAsIDB4OTgxOTgxODEsIDB4ZDE5ZTRmNGYsIDB4N2ZhM2RjZGMsIDB4NjY0NDIyMjIsIDB4N2U1NDJhMmEsIDB4YWIzYjkwOTAsIDB4ODMwYjg4ODgsIDB4Y2E4YzQ2NDYsIDB4MjljN2VlZWUsIDB4ZDM2YmI4YjgsIDB4M2MyODE0MTQsIDB4NzlhN2RlZGUsIDB4ZTJiYzVlNWUsIDB4MWQxNjBiMGIsIDB4NzZhZGRiZGIsIDB4M2JkYmUwZTAsIDB4NTY2NDMyMzIsIDB4NGU3NDNhM2EsIDB4MWUxNDBhMGEsIDB4ZGI5MjQ5NDksIDB4MGEwYzA2MDYsIDB4NmM0ODI0MjQsIDB4ZTRiODVjNWMsIDB4NWQ5ZmMyYzIsIDB4NmViZGQzZDMsIDB4ZWY0M2FjYWMsIDB4YTZjNDYyNjIsIDB4YTgzOTkxOTEsIDB4YTQzMTk1OTUsIDB4MzdkM2U0ZTQsIDB4OGJmMjc5NzksIDB4MzJkNWU3ZTcsIDB4NDM4YmM4YzgsIDB4NTk2ZTM3MzcsIDB4YjdkYTZkNmQsIDB4OGMwMThkOGQsIDB4NjRiMWQ1ZDUsIDB4ZDI5YzRlNGUsIDB4ZTA0OWE5YTksIDB4YjRkODZjNmMsIDB4ZmFhYzU2NTYsIDB4MDdmM2Y0ZjQsIDB4MjVjZmVhZWEsIDB4YWZjYTY1NjUsIDB4OGVmNDdhN2EsIDB4ZTk0N2FlYWUsIDB4MTgxMDA4MDgsIDB4ZDU2ZmJhYmEsIDB4ODhmMDc4NzgsIDB4NmY0YTI1MjUsIDB4NzI1YzJlMmUsIDB4MjQzODFjMWMsIDB4ZjE1N2E2YTYsIDB4Yzc3M2I0YjQsIDB4NTE5N2M2YzYsIDB4MjNjYmU4ZTgsIDB4N2NhMWRkZGQsIDB4OWNlODc0NzQsIDB4MjEzZTFmMWYsIDB4ZGQ5NjRiNGIsIDB4ZGM2MWJkYmQsIDB4ODYwZDhiOGIsIDB4ODUwZjhhOGEsIDB4OTBlMDcwNzAsIDB4NDI3YzNlM2UsIDB4YzQ3MWI1YjUsIDB4YWFjYzY2NjYsIDB4ZDg5MDQ4NDgsIDB4MDUwNjAzMDMsIDB4MDFmN2Y2ZjYsIDB4MTIxYzBlMGUsIDB4YTNjMjYxNjEsIDB4NWY2YTM1MzUsIDB4ZjlhZTU3NTcsIDB4ZDA2OWI5YjksIDB4OTExNzg2ODYsIDB4NTg5OWMxYzEsIDB4MjczYTFkMWQsIDB4YjkyNzllOWUsIDB4MzhkOWUxZTEsIDB4MTNlYmY4ZjgsIDB4YjMyYjk4OTgsIDB4MzMyMjExMTEsIDB4YmJkMjY5NjksIDB4NzBhOWQ5ZDksIDB4ODkwNzhlOGUsIDB4YTczMzk0OTQsIDB4YjYyZDliOWIsIDB4MjIzYzFlMWUsIDB4OTIxNTg3ODcsIDB4MjBjOWU5ZTksIDB4NDk4N2NlY2UsIDB4ZmZhYTU1NTUsIDB4Nzg1MDI4MjgsIDB4N2FhNWRmZGYsIDB4OGYwMzhjOGMsIDB4Zjg1OWExYTEsIDB4ODAwOTg5ODksIDB4MTcxYTBkMGQsIDB4ZGE2NWJmYmYsIDB4MzFkN2U2ZTYsIDB4YzY4NDQyNDIsIDB4YjhkMDY4NjgsIDB4YzM4MjQxNDEsIDB4YjAyOTk5OTksIDB4Nzc1YTJkMmQsIDB4MTExZTBmMGYsIDB4Y2I3YmIwYjAsIDB4ZmNhODU0NTQsIDB4ZDY2ZGJiYmIsIDB4M2EyYzE2MTZdO1xuICAgIHZhciBUMyA9IFsweDYzYTVjNjYzLCAweDdjODRmODdjLCAweDc3OTllZTc3LCAweDdiOGRmNjdiLCAweGYyMGRmZmYyLCAweDZiYmRkNjZiLCAweDZmYjFkZTZmLCAweGM1NTQ5MWM1LCAweDMwNTA2MDMwLCAweDAxMDMwMjAxLCAweDY3YTljZTY3LCAweDJiN2Q1NjJiLCAweGZlMTllN2ZlLCAweGQ3NjJiNWQ3LCAweGFiZTY0ZGFiLCAweDc2OWFlYzc2LCAweGNhNDU4ZmNhLCAweDgyOWQxZjgyLCAweGM5NDA4OWM5LCAweDdkODdmYTdkLCAweGZhMTVlZmZhLCAweDU5ZWJiMjU5LCAweDQ3Yzk4ZTQ3LCAweGYwMGJmYmYwLCAweGFkZWM0MWFkLCAweGQ0NjdiM2Q0LCAweGEyZmQ1ZmEyLCAweGFmZWE0NWFmLCAweDljYmYyMzljLCAweGE0Zjc1M2E0LCAweDcyOTZlNDcyLCAweGMwNWI5YmMwLCAweGI3YzI3NWI3LCAweGZkMWNlMWZkLCAweDkzYWUzZDkzLCAweDI2NmE0YzI2LCAweDM2NWE2YzM2LCAweDNmNDE3ZTNmLCAweGY3MDJmNWY3LCAweGNjNGY4M2NjLCAweDM0NWM2ODM0LCAweGE1ZjQ1MWE1LCAweGU1MzRkMWU1LCAweGYxMDhmOWYxLCAweDcxOTNlMjcxLCAweGQ4NzNhYmQ4LCAweDMxNTM2MjMxLCAweDE1M2YyYTE1LCAweDA0MGMwODA0LCAweGM3NTI5NWM3LCAweDIzNjU0NjIzLCAweGMzNWU5ZGMzLCAweDE4MjgzMDE4LCAweDk2YTEzNzk2LCAweDA1MGYwYTA1LCAweDlhYjUyZjlhLCAweDA3MDkwZTA3LCAweDEyMzYyNDEyLCAweDgwOWIxYjgwLCAweGUyM2RkZmUyLCAweGViMjZjZGViLCAweDI3Njk0ZTI3LCAweGIyY2Q3ZmIyLCAweDc1OWZlYTc1LCAweDA5MWIxMjA5LCAweDgzOWUxZDgzLCAweDJjNzQ1ODJjLCAweDFhMmUzNDFhLCAweDFiMmQzNjFiLCAweDZlYjJkYzZlLCAweDVhZWViNDVhLCAweGEwZmI1YmEwLCAweDUyZjZhNDUyLCAweDNiNGQ3NjNiLCAweGQ2NjFiN2Q2LCAweGIzY2U3ZGIzLCAweDI5N2I1MjI5LCAweGUzM2VkZGUzLCAweDJmNzE1ZTJmLCAweDg0OTcxMzg0LCAweDUzZjVhNjUzLCAweGQxNjhiOWQxLCAweDAwMDAwMDAwLCAweGVkMmNjMWVkLCAweDIwNjA0MDIwLCAweGZjMWZlM2ZjLCAweGIxYzg3OWIxLCAweDViZWRiNjViLCAweDZhYmVkNDZhLCAweGNiNDY4ZGNiLCAweGJlZDk2N2JlLCAweDM5NGI3MjM5LCAweDRhZGU5NDRhLCAweDRjZDQ5ODRjLCAweDU4ZThiMDU4LCAweGNmNGE4NWNmLCAweGQwNmJiYmQwLCAweGVmMmFjNWVmLCAweGFhZTU0ZmFhLCAweGZiMTZlZGZiLCAweDQzYzU4NjQzLCAweDRkZDc5YTRkLCAweDMzNTU2NjMzLCAweDg1OTQxMTg1LCAweDQ1Y2Y4YTQ1LCAweGY5MTBlOWY5LCAweDAyMDYwNDAyLCAweDdmODFmZTdmLCAweDUwZjBhMDUwLCAweDNjNDQ3ODNjLCAweDlmYmEyNTlmLCAweGE4ZTM0YmE4LCAweDUxZjNhMjUxLCAweGEzZmU1ZGEzLCAweDQwYzA4MDQwLCAweDhmOGEwNThmLCAweDkyYWQzZjkyLCAweDlkYmMyMTlkLCAweDM4NDg3MDM4LCAweGY1MDRmMWY1LCAweGJjZGY2M2JjLCAweGI2YzE3N2I2LCAweGRhNzVhZmRhLCAweDIxNjM0MjIxLCAweDEwMzAyMDEwLCAweGZmMWFlNWZmLCAweGYzMGVmZGYzLCAweGQyNmRiZmQyLCAweGNkNGM4MWNkLCAweDBjMTQxODBjLCAweDEzMzUyNjEzLCAweGVjMmZjM2VjLCAweDVmZTFiZTVmLCAweDk3YTIzNTk3LCAweDQ0Y2M4ODQ0LCAweDE3MzkyZTE3LCAweGM0NTc5M2M0LCAweGE3ZjI1NWE3LCAweDdlODJmYzdlLCAweDNkNDc3YTNkLCAweDY0YWNjODY0LCAweDVkZTdiYTVkLCAweDE5MmIzMjE5LCAweDczOTVlNjczLCAweDYwYTBjMDYwLCAweDgxOTgxOTgxLCAweDRmZDE5ZTRmLCAweGRjN2ZhM2RjLCAweDIyNjY0NDIyLCAweDJhN2U1NDJhLCAweDkwYWIzYjkwLCAweDg4ODMwYjg4LCAweDQ2Y2E4YzQ2LCAweGVlMjljN2VlLCAweGI4ZDM2YmI4LCAweDE0M2MyODE0LCAweGRlNzlhN2RlLCAweDVlZTJiYzVlLCAweDBiMWQxNjBiLCAweGRiNzZhZGRiLCAweGUwM2JkYmUwLCAweDMyNTY2NDMyLCAweDNhNGU3NDNhLCAweDBhMWUxNDBhLCAweDQ5ZGI5MjQ5LCAweDA2MGEwYzA2LCAweDI0NmM0ODI0LCAweDVjZTRiODVjLCAweGMyNWQ5ZmMyLCAweGQzNmViZGQzLCAweGFjZWY0M2FjLCAweDYyYTZjNDYyLCAweDkxYTgzOTkxLCAweDk1YTQzMTk1LCAweGU0MzdkM2U0LCAweDc5OGJmMjc5LCAweGU3MzJkNWU3LCAweGM4NDM4YmM4LCAweDM3NTk2ZTM3LCAweDZkYjdkYTZkLCAweDhkOGMwMThkLCAweGQ1NjRiMWQ1LCAweDRlZDI5YzRlLCAweGE5ZTA0OWE5LCAweDZjYjRkODZjLCAweDU2ZmFhYzU2LCAweGY0MDdmM2Y0LCAweGVhMjVjZmVhLCAweDY1YWZjYTY1LCAweDdhOGVmNDdhLCAweGFlZTk0N2FlLCAweDA4MTgxMDA4LCAweGJhZDU2ZmJhLCAweDc4ODhmMDc4LCAweDI1NmY0YTI1LCAweDJlNzI1YzJlLCAweDFjMjQzODFjLCAweGE2ZjE1N2E2LCAweGI0Yzc3M2I0LCAweGM2NTE5N2M2LCAweGU4MjNjYmU4LCAweGRkN2NhMWRkLCAweDc0OWNlODc0LCAweDFmMjEzZTFmLCAweDRiZGQ5NjRiLCAweGJkZGM2MWJkLCAweDhiODYwZDhiLCAweDhhODUwZjhhLCAweDcwOTBlMDcwLCAweDNlNDI3YzNlLCAweGI1YzQ3MWI1LCAweDY2YWFjYzY2LCAweDQ4ZDg5MDQ4LCAweDAzMDUwNjAzLCAweGY2MDFmN2Y2LCAweDBlMTIxYzBlLCAweDYxYTNjMjYxLCAweDM1NWY2YTM1LCAweDU3ZjlhZTU3LCAweGI5ZDA2OWI5LCAweDg2OTExNzg2LCAweGMxNTg5OWMxLCAweDFkMjczYTFkLCAweDllYjkyNzllLCAweGUxMzhkOWUxLCAweGY4MTNlYmY4LCAweDk4YjMyYjk4LCAweDExMzMyMjExLCAweDY5YmJkMjY5LCAweGQ5NzBhOWQ5LCAweDhlODkwNzhlLCAweDk0YTczMzk0LCAweDliYjYyZDliLCAweDFlMjIzYzFlLCAweDg3OTIxNTg3LCAweGU5MjBjOWU5LCAweGNlNDk4N2NlLCAweDU1ZmZhYTU1LCAweDI4Nzg1MDI4LCAweGRmN2FhNWRmLCAweDhjOGYwMzhjLCAweGExZjg1OWExLCAweDg5ODAwOTg5LCAweDBkMTcxYTBkLCAweGJmZGE2NWJmLCAweGU2MzFkN2U2LCAweDQyYzY4NDQyLCAweDY4YjhkMDY4LCAweDQxYzM4MjQxLCAweDk5YjAyOTk5LCAweDJkNzc1YTJkLCAweDBmMTExZTBmLCAweGIwY2I3YmIwLCAweDU0ZmNhODU0LCAweGJiZDY2ZGJiLCAweDE2M2EyYzE2XTtcbiAgICB2YXIgVDQgPSBbMHg2MzYzYTVjNiwgMHg3YzdjODRmOCwgMHg3Nzc3OTllZSwgMHg3YjdiOGRmNiwgMHhmMmYyMGRmZiwgMHg2YjZiYmRkNiwgMHg2ZjZmYjFkZSwgMHhjNWM1NTQ5MSwgMHgzMDMwNTA2MCwgMHgwMTAxMDMwMiwgMHg2NzY3YTljZSwgMHgyYjJiN2Q1NiwgMHhmZWZlMTllNywgMHhkN2Q3NjJiNSwgMHhhYmFiZTY0ZCwgMHg3Njc2OWFlYywgMHhjYWNhNDU4ZiwgMHg4MjgyOWQxZiwgMHhjOWM5NDA4OSwgMHg3ZDdkODdmYSwgMHhmYWZhMTVlZiwgMHg1OTU5ZWJiMiwgMHg0NzQ3Yzk4ZSwgMHhmMGYwMGJmYiwgMHhhZGFkZWM0MSwgMHhkNGQ0NjdiMywgMHhhMmEyZmQ1ZiwgMHhhZmFmZWE0NSwgMHg5YzljYmYyMywgMHhhNGE0Zjc1MywgMHg3MjcyOTZlNCwgMHhjMGMwNWI5YiwgMHhiN2I3YzI3NSwgMHhmZGZkMWNlMSwgMHg5MzkzYWUzZCwgMHgyNjI2NmE0YywgMHgzNjM2NWE2YywgMHgzZjNmNDE3ZSwgMHhmN2Y3MDJmNSwgMHhjY2NjNGY4MywgMHgzNDM0NWM2OCwgMHhhNWE1ZjQ1MSwgMHhlNWU1MzRkMSwgMHhmMWYxMDhmOSwgMHg3MTcxOTNlMiwgMHhkOGQ4NzNhYiwgMHgzMTMxNTM2MiwgMHgxNTE1M2YyYSwgMHgwNDA0MGMwOCwgMHhjN2M3NTI5NSwgMHgyMzIzNjU0NiwgMHhjM2MzNWU5ZCwgMHgxODE4MjgzMCwgMHg5Njk2YTEzNywgMHgwNTA1MGYwYSwgMHg5YTlhYjUyZiwgMHgwNzA3MDkwZSwgMHgxMjEyMzYyNCwgMHg4MDgwOWIxYiwgMHhlMmUyM2RkZiwgMHhlYmViMjZjZCwgMHgyNzI3Njk0ZSwgMHhiMmIyY2Q3ZiwgMHg3NTc1OWZlYSwgMHgwOTA5MWIxMiwgMHg4MzgzOWUxZCwgMHgyYzJjNzQ1OCwgMHgxYTFhMmUzNCwgMHgxYjFiMmQzNiwgMHg2ZTZlYjJkYywgMHg1YTVhZWViNCwgMHhhMGEwZmI1YiwgMHg1MjUyZjZhNCwgMHgzYjNiNGQ3NiwgMHhkNmQ2NjFiNywgMHhiM2IzY2U3ZCwgMHgyOTI5N2I1MiwgMHhlM2UzM2VkZCwgMHgyZjJmNzE1ZSwgMHg4NDg0OTcxMywgMHg1MzUzZjVhNiwgMHhkMWQxNjhiOSwgMHgwMDAwMDAwMCwgMHhlZGVkMmNjMSwgMHgyMDIwNjA0MCwgMHhmY2ZjMWZlMywgMHhiMWIxYzg3OSwgMHg1YjViZWRiNiwgMHg2YTZhYmVkNCwgMHhjYmNiNDY4ZCwgMHhiZWJlZDk2NywgMHgzOTM5NGI3MiwgMHg0YTRhZGU5NCwgMHg0YzRjZDQ5OCwgMHg1ODU4ZThiMCwgMHhjZmNmNGE4NSwgMHhkMGQwNmJiYiwgMHhlZmVmMmFjNSwgMHhhYWFhZTU0ZiwgMHhmYmZiMTZlZCwgMHg0MzQzYzU4NiwgMHg0ZDRkZDc5YSwgMHgzMzMzNTU2NiwgMHg4NTg1OTQxMSwgMHg0NTQ1Y2Y4YSwgMHhmOWY5MTBlOSwgMHgwMjAyMDYwNCwgMHg3ZjdmODFmZSwgMHg1MDUwZjBhMCwgMHgzYzNjNDQ3OCwgMHg5ZjlmYmEyNSwgMHhhOGE4ZTM0YiwgMHg1MTUxZjNhMiwgMHhhM2EzZmU1ZCwgMHg0MDQwYzA4MCwgMHg4ZjhmOGEwNSwgMHg5MjkyYWQzZiwgMHg5ZDlkYmMyMSwgMHgzODM4NDg3MCwgMHhmNWY1MDRmMSwgMHhiY2JjZGY2MywgMHhiNmI2YzE3NywgMHhkYWRhNzVhZiwgMHgyMTIxNjM0MiwgMHgxMDEwMzAyMCwgMHhmZmZmMWFlNSwgMHhmM2YzMGVmZCwgMHhkMmQyNmRiZiwgMHhjZGNkNGM4MSwgMHgwYzBjMTQxOCwgMHgxMzEzMzUyNiwgMHhlY2VjMmZjMywgMHg1ZjVmZTFiZSwgMHg5Nzk3YTIzNSwgMHg0NDQ0Y2M4OCwgMHgxNzE3MzkyZSwgMHhjNGM0NTc5MywgMHhhN2E3ZjI1NSwgMHg3ZTdlODJmYywgMHgzZDNkNDc3YSwgMHg2NDY0YWNjOCwgMHg1ZDVkZTdiYSwgMHgxOTE5MmIzMiwgMHg3MzczOTVlNiwgMHg2MDYwYTBjMCwgMHg4MTgxOTgxOSwgMHg0ZjRmZDE5ZSwgMHhkY2RjN2ZhMywgMHgyMjIyNjY0NCwgMHgyYTJhN2U1NCwgMHg5MDkwYWIzYiwgMHg4ODg4ODMwYiwgMHg0NjQ2Y2E4YywgMHhlZWVlMjljNywgMHhiOGI4ZDM2YiwgMHgxNDE0M2MyOCwgMHhkZWRlNzlhNywgMHg1ZTVlZTJiYywgMHgwYjBiMWQxNiwgMHhkYmRiNzZhZCwgMHhlMGUwM2JkYiwgMHgzMjMyNTY2NCwgMHgzYTNhNGU3NCwgMHgwYTBhMWUxNCwgMHg0OTQ5ZGI5MiwgMHgwNjA2MGEwYywgMHgyNDI0NmM0OCwgMHg1YzVjZTRiOCwgMHhjMmMyNWQ5ZiwgMHhkM2QzNmViZCwgMHhhY2FjZWY0MywgMHg2MjYyYTZjNCwgMHg5MTkxYTgzOSwgMHg5NTk1YTQzMSwgMHhlNGU0MzdkMywgMHg3OTc5OGJmMiwgMHhlN2U3MzJkNSwgMHhjOGM4NDM4YiwgMHgzNzM3NTk2ZSwgMHg2ZDZkYjdkYSwgMHg4ZDhkOGMwMSwgMHhkNWQ1NjRiMSwgMHg0ZTRlZDI5YywgMHhhOWE5ZTA0OSwgMHg2YzZjYjRkOCwgMHg1NjU2ZmFhYywgMHhmNGY0MDdmMywgMHhlYWVhMjVjZiwgMHg2NTY1YWZjYSwgMHg3YTdhOGVmNCwgMHhhZWFlZTk0NywgMHgwODA4MTgxMCwgMHhiYWJhZDU2ZiwgMHg3ODc4ODhmMCwgMHgyNTI1NmY0YSwgMHgyZTJlNzI1YywgMHgxYzFjMjQzOCwgMHhhNmE2ZjE1NywgMHhiNGI0Yzc3MywgMHhjNmM2NTE5NywgMHhlOGU4MjNjYiwgMHhkZGRkN2NhMSwgMHg3NDc0OWNlOCwgMHgxZjFmMjEzZSwgMHg0YjRiZGQ5NiwgMHhiZGJkZGM2MSwgMHg4YjhiODYwZCwgMHg4YThhODUwZiwgMHg3MDcwOTBlMCwgMHgzZTNlNDI3YywgMHhiNWI1YzQ3MSwgMHg2NjY2YWFjYywgMHg0ODQ4ZDg5MCwgMHgwMzAzMDUwNiwgMHhmNmY2MDFmNywgMHgwZTBlMTIxYywgMHg2MTYxYTNjMiwgMHgzNTM1NWY2YSwgMHg1NzU3ZjlhZSwgMHhiOWI5ZDA2OSwgMHg4Njg2OTExNywgMHhjMWMxNTg5OSwgMHgxZDFkMjczYSwgMHg5ZTllYjkyNywgMHhlMWUxMzhkOSwgMHhmOGY4MTNlYiwgMHg5ODk4YjMyYiwgMHgxMTExMzMyMiwgMHg2OTY5YmJkMiwgMHhkOWQ5NzBhOSwgMHg4ZThlODkwNywgMHg5NDk0YTczMywgMHg5YjliYjYyZCwgMHgxZTFlMjIzYywgMHg4Nzg3OTIxNSwgMHhlOWU5MjBjOSwgMHhjZWNlNDk4NywgMHg1NTU1ZmZhYSwgMHgyODI4Nzg1MCwgMHhkZmRmN2FhNSwgMHg4YzhjOGYwMywgMHhhMWExZjg1OSwgMHg4OTg5ODAwOSwgMHgwZDBkMTcxYSwgMHhiZmJmZGE2NSwgMHhlNmU2MzFkNywgMHg0MjQyYzY4NCwgMHg2ODY4YjhkMCwgMHg0MTQxYzM4MiwgMHg5OTk5YjAyOSwgMHgyZDJkNzc1YSwgMHgwZjBmMTExZSwgMHhiMGIwY2I3YiwgMHg1NDU0ZmNhOCwgMHhiYmJiZDY2ZCwgMHgxNjE2M2EyY107XG5cbiAgICAvLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb25cbiAgICB2YXIgVDUgPSBbMHg1MWY0YTc1MCwgMHg3ZTQxNjU1MywgMHgxYTE3YTRjMywgMHgzYTI3NWU5NiwgMHgzYmFiNmJjYiwgMHgxZjlkNDVmMSwgMHhhY2ZhNThhYiwgMHg0YmUzMDM5MywgMHgyMDMwZmE1NSwgMHhhZDc2NmRmNiwgMHg4OGNjNzY5MSwgMHhmNTAyNGMyNSwgMHg0ZmU1ZDdmYywgMHhjNTJhY2JkNywgMHgyNjM1NDQ4MCwgMHhiNTYyYTM4ZiwgMHhkZWIxNWE0OSwgMHgyNWJhMWI2NywgMHg0NWVhMGU5OCwgMHg1ZGZlYzBlMSwgMHhjMzJmNzUwMiwgMHg4MTRjZjAxMiwgMHg4ZDQ2OTdhMywgMHg2YmQzZjljNiwgMHgwMzhmNWZlNywgMHgxNTkyOWM5NSwgMHhiZjZkN2FlYiwgMHg5NTUyNTlkYSwgMHhkNGJlODMyZCwgMHg1ODc0MjFkMywgMHg0OWUwNjkyOSwgMHg4ZWM5Yzg0NCwgMHg3NWMyODk2YSwgMHhmNDhlNzk3OCwgMHg5OTU4M2U2YiwgMHgyN2I5NzFkZCwgMHhiZWUxNGZiNiwgMHhmMDg4YWQxNywgMHhjOTIwYWM2NiwgMHg3ZGNlM2FiNCwgMHg2M2RmNGExOCwgMHhlNTFhMzE4MiwgMHg5NzUxMzM2MCwgMHg2MjUzN2Y0NSwgMHhiMTY0NzdlMCwgMHhiYjZiYWU4NCwgMHhmZTgxYTAxYywgMHhmOTA4MmI5NCwgMHg3MDQ4Njg1OCwgMHg4ZjQ1ZmQxOSwgMHg5NGRlNmM4NywgMHg1MjdiZjhiNywgMHhhYjczZDMyMywgMHg3MjRiMDJlMiwgMHhlMzFmOGY1NywgMHg2NjU1YWIyYSwgMHhiMmViMjgwNywgMHgyZmI1YzIwMywgMHg4NmM1N2I5YSwgMHhkMzM3MDhhNSwgMHgzMDI4ODdmMiwgMHgyM2JmYTViMiwgMHgwMjAzNmFiYSwgMHhlZDE2ODI1YywgMHg4YWNmMWMyYiwgMHhhNzc5YjQ5MiwgMHhmMzA3ZjJmMCwgMHg0ZTY5ZTJhMSwgMHg2NWRhZjRjZCwgMHgwNjA1YmVkNSwgMHhkMTM0NjIxZiwgMHhjNGE2ZmU4YSwgMHgzNDJlNTM5ZCwgMHhhMmYzNTVhMCwgMHgwNThhZTEzMiwgMHhhNGY2ZWI3NSwgMHgwYjgzZWMzOSwgMHg0MDYwZWZhYSwgMHg1ZTcxOWYwNiwgMHhiZDZlMTA1MSwgMHgzZTIxOGFmOSwgMHg5NmRkMDYzZCwgMHhkZDNlMDVhZSwgMHg0ZGU2YmQ0NiwgMHg5MTU0OGRiNSwgMHg3MWM0NWQwNSwgMHgwNDA2ZDQ2ZiwgMHg2MDUwMTVmZiwgMHgxOTk4ZmIyNCwgMHhkNmJkZTk5NywgMHg4OTQwNDNjYywgMHg2N2Q5OWU3NywgMHhiMGU4NDJiZCwgMHgwNzg5OGI4OCwgMHhlNzE5NWIzOCwgMHg3OWM4ZWVkYiwgMHhhMTdjMGE0NywgMHg3YzQyMGZlOSwgMHhmODg0MWVjOSwgMHgwMDAwMDAwMCwgMHgwOTgwODY4MywgMHgzMjJiZWQ0OCwgMHgxZTExNzBhYywgMHg2YzVhNzI0ZSwgMHhmZDBlZmZmYiwgMHgwZjg1Mzg1NiwgMHgzZGFlZDUxZSwgMHgzNjJkMzkyNywgMHgwYTBmZDk2NCwgMHg2ODVjYTYyMSwgMHg5YjViNTRkMSwgMHgyNDM2MmUzYSwgMHgwYzBhNjdiMSwgMHg5MzU3ZTcwZiwgMHhiNGVlOTZkMiwgMHgxYjliOTE5ZSwgMHg4MGMwYzU0ZiwgMHg2MWRjMjBhMiwgMHg1YTc3NGI2OSwgMHgxYzEyMWExNiwgMHhlMjkzYmEwYSwgMHhjMGEwMmFlNSwgMHgzYzIyZTA0MywgMHgxMjFiMTcxZCwgMHgwZTA5MGQwYiwgMHhmMjhiYzdhZCwgMHgyZGI2YThiOSwgMHgxNDFlYTljOCwgMHg1N2YxMTk4NSwgMHhhZjc1MDc0YywgMHhlZTk5ZGRiYiwgMHhhMzdmNjBmZCwgMHhmNzAxMjY5ZiwgMHg1YzcyZjViYywgMHg0NDY2M2JjNSwgMHg1YmZiN2UzNCwgMHg4YjQzMjk3NiwgMHhjYjIzYzZkYywgMHhiNmVkZmM2OCwgMHhiOGU0ZjE2MywgMHhkNzMxZGNjYSwgMHg0MjYzODUxMCwgMHgxMzk3MjI0MCwgMHg4NGM2MTEyMCwgMHg4NTRhMjQ3ZCwgMHhkMmJiM2RmOCwgMHhhZWY5MzIxMSwgMHhjNzI5YTE2ZCwgMHgxZDllMmY0YiwgMHhkY2IyMzBmMywgMHgwZDg2NTJlYywgMHg3N2MxZTNkMCwgMHgyYmIzMTY2YywgMHhhOTcwYjk5OSwgMHgxMTk0NDhmYSwgMHg0N2U5NjQyMiwgMHhhOGZjOGNjNCwgMHhhMGYwM2YxYSwgMHg1NjdkMmNkOCwgMHgyMjMzOTBlZiwgMHg4NzQ5NGVjNywgMHhkOTM4ZDFjMSwgMHg4Y2NhYTJmZSwgMHg5OGQ0MGIzNiwgMHhhNmY1ODFjZiwgMHhhNTdhZGUyOCwgMHhkYWI3OGUyNiwgMHgzZmFkYmZhNCwgMHgyYzNhOWRlNCwgMHg1MDc4OTIwZCwgMHg2YTVmY2M5YiwgMHg1NDdlNDY2MiwgMHhmNjhkMTNjMiwgMHg5MGQ4YjhlOCwgMHgyZTM5Zjc1ZSwgMHg4MmMzYWZmNSwgMHg5ZjVkODBiZSwgMHg2OWQwOTM3YywgMHg2ZmQ1MmRhOSwgMHhjZjI1MTJiMywgMHhjOGFjOTkzYiwgMHgxMDE4N2RhNywgMHhlODljNjM2ZSwgMHhkYjNiYmI3YiwgMHhjZDI2NzgwOSwgMHg2ZTU5MThmNCwgMHhlYzlhYjcwMSwgMHg4MzRmOWFhOCwgMHhlNjk1NmU2NSwgMHhhYWZmZTY3ZSwgMHgyMWJjY2YwOCwgMHhlZjE1ZThlNiwgMHhiYWU3OWJkOSwgMHg0YTZmMzZjZSwgMHhlYTlmMDlkNCwgMHgyOWIwN2NkNiwgMHgzMWE0YjJhZiwgMHgyYTNmMjMzMSwgMHhjNmE1OTQzMCwgMHgzNWEyNjZjMCwgMHg3NDRlYmMzNywgMHhmYzgyY2FhNiwgMHhlMDkwZDBiMCwgMHgzM2E3ZDgxNSwgMHhmMTA0OTg0YSwgMHg0MWVjZGFmNywgMHg3ZmNkNTAwZSwgMHgxNzkxZjYyZiwgMHg3NjRkZDY4ZCwgMHg0M2VmYjA0ZCwgMHhjY2FhNGQ1NCwgMHhlNDk2MDRkZiwgMHg5ZWQxYjVlMywgMHg0YzZhODgxYiwgMHhjMTJjMWZiOCwgMHg0NjY1NTE3ZiwgMHg5ZDVlZWEwNCwgMHgwMThjMzU1ZCwgMHhmYTg3NzQ3MywgMHhmYjBiNDEyZSwgMHhiMzY3MWQ1YSwgMHg5MmRiZDI1MiwgMHhlOTEwNTYzMywgMHg2ZGQ2NDcxMywgMHg5YWQ3NjE4YywgMHgzN2ExMGM3YSwgMHg1OWY4MTQ4ZSwgMHhlYjEzM2M4OSwgMHhjZWE5MjdlZSwgMHhiNzYxYzkzNSwgMHhlMTFjZTVlZCwgMHg3YTQ3YjEzYywgMHg5Y2QyZGY1OSwgMHg1NWYyNzMzZiwgMHgxODE0Y2U3OSwgMHg3M2M3MzdiZiwgMHg1M2Y3Y2RlYSwgMHg1ZmZkYWE1YiwgMHhkZjNkNmYxNCwgMHg3ODQ0ZGI4NiwgMHhjYWFmZjM4MSwgMHhiOTY4YzQzZSwgMHgzODI0MzQyYywgMHhjMmEzNDA1ZiwgMHgxNjFkYzM3MiwgMHhiY2UyMjUwYywgMHgyODNjNDk4YiwgMHhmZjBkOTU0MSwgMHgzOWE4MDE3MSwgMHgwODBjYjNkZSwgMHhkOGI0ZTQ5YywgMHg2NDU2YzE5MCwgMHg3YmNiODQ2MSwgMHhkNTMyYjY3MCwgMHg0ODZjNWM3NCwgMHhkMGI4NTc0Ml07XG4gICAgdmFyIFQ2ID0gWzB4NTA1MWY0YTcsIDB4NTM3ZTQxNjUsIDB4YzMxYTE3YTQsIDB4OTYzYTI3NWUsIDB4Y2IzYmFiNmIsIDB4ZjExZjlkNDUsIDB4YWJhY2ZhNTgsIDB4OTM0YmUzMDMsIDB4NTUyMDMwZmEsIDB4ZjZhZDc2NmQsIDB4OTE4OGNjNzYsIDB4MjVmNTAyNGMsIDB4ZmM0ZmU1ZDcsIDB4ZDdjNTJhY2IsIDB4ODAyNjM1NDQsIDB4OGZiNTYyYTMsIDB4NDlkZWIxNWEsIDB4NjcyNWJhMWIsIDB4OTg0NWVhMGUsIDB4ZTE1ZGZlYzAsIDB4MDJjMzJmNzUsIDB4MTI4MTRjZjAsIDB4YTM4ZDQ2OTcsIDB4YzY2YmQzZjksIDB4ZTcwMzhmNWYsIDB4OTUxNTkyOWMsIDB4ZWJiZjZkN2EsIDB4ZGE5NTUyNTksIDB4MmRkNGJlODMsIDB4ZDM1ODc0MjEsIDB4Mjk0OWUwNjksIDB4NDQ4ZWM5YzgsIDB4NmE3NWMyODksIDB4NzhmNDhlNzksIDB4NmI5OTU4M2UsIDB4ZGQyN2I5NzEsIDB4YjZiZWUxNGYsIDB4MTdmMDg4YWQsIDB4NjZjOTIwYWMsIDB4YjQ3ZGNlM2EsIDB4MTg2M2RmNGEsIDB4ODJlNTFhMzEsIDB4NjA5NzUxMzMsIDB4NDU2MjUzN2YsIDB4ZTBiMTY0NzcsIDB4ODRiYjZiYWUsIDB4MWNmZTgxYTAsIDB4OTRmOTA4MmIsIDB4NTg3MDQ4NjgsIDB4MTk4ZjQ1ZmQsIDB4ODc5NGRlNmMsIDB4Yjc1MjdiZjgsIDB4MjNhYjczZDMsIDB4ZTI3MjRiMDIsIDB4NTdlMzFmOGYsIDB4MmE2NjU1YWIsIDB4MDdiMmViMjgsIDB4MDMyZmI1YzIsIDB4OWE4NmM1N2IsIDB4YTVkMzM3MDgsIDB4ZjIzMDI4ODcsIDB4YjIyM2JmYTUsIDB4YmEwMjAzNmEsIDB4NWNlZDE2ODIsIDB4MmI4YWNmMWMsIDB4OTJhNzc5YjQsIDB4ZjBmMzA3ZjIsIDB4YTE0ZTY5ZTIsIDB4Y2Q2NWRhZjQsIDB4ZDUwNjA1YmUsIDB4MWZkMTM0NjIsIDB4OGFjNGE2ZmUsIDB4OWQzNDJlNTMsIDB4YTBhMmYzNTUsIDB4MzIwNThhZTEsIDB4NzVhNGY2ZWIsIDB4MzkwYjgzZWMsIDB4YWE0MDYwZWYsIDB4MDY1ZTcxOWYsIDB4NTFiZDZlMTAsIDB4ZjkzZTIxOGEsIDB4M2Q5NmRkMDYsIDB4YWVkZDNlMDUsIDB4NDY0ZGU2YmQsIDB4YjU5MTU0OGQsIDB4MDU3MWM0NWQsIDB4NmYwNDA2ZDQsIDB4ZmY2MDUwMTUsIDB4MjQxOTk4ZmIsIDB4OTdkNmJkZTksIDB4Y2M4OTQwNDMsIDB4Nzc2N2Q5OWUsIDB4YmRiMGU4NDIsIDB4ODgwNzg5OGIsIDB4MzhlNzE5NWIsIDB4ZGI3OWM4ZWUsIDB4NDdhMTdjMGEsIDB4ZTk3YzQyMGYsIDB4YzlmODg0MWUsIDB4MDAwMDAwMDAsIDB4ODMwOTgwODYsIDB4NDgzMjJiZWQsIDB4YWMxZTExNzAsIDB4NGU2YzVhNzIsIDB4ZmJmZDBlZmYsIDB4NTYwZjg1MzgsIDB4MWUzZGFlZDUsIDB4MjczNjJkMzksIDB4NjQwYTBmZDksIDB4MjE2ODVjYTYsIDB4ZDE5YjViNTQsIDB4M2EyNDM2MmUsIDB4YjEwYzBhNjcsIDB4MGY5MzU3ZTcsIDB4ZDJiNGVlOTYsIDB4OWUxYjliOTEsIDB4NGY4MGMwYzUsIDB4YTI2MWRjMjAsIDB4Njk1YTc3NGIsIDB4MTYxYzEyMWEsIDB4MGFlMjkzYmEsIDB4ZTVjMGEwMmEsIDB4NDMzYzIyZTAsIDB4MWQxMjFiMTcsIDB4MGIwZTA5MGQsIDB4YWRmMjhiYzcsIDB4YjkyZGI2YTgsIDB4YzgxNDFlYTksIDB4ODU1N2YxMTksIDB4NGNhZjc1MDcsIDB4YmJlZTk5ZGQsIDB4ZmRhMzdmNjAsIDB4OWZmNzAxMjYsIDB4YmM1YzcyZjUsIDB4YzU0NDY2M2IsIDB4MzQ1YmZiN2UsIDB4NzY4YjQzMjksIDB4ZGNjYjIzYzYsIDB4NjhiNmVkZmMsIDB4NjNiOGU0ZjEsIDB4Y2FkNzMxZGMsIDB4MTA0MjYzODUsIDB4NDAxMzk3MjIsIDB4MjA4NGM2MTEsIDB4N2Q4NTRhMjQsIDB4ZjhkMmJiM2QsIDB4MTFhZWY5MzIsIDB4NmRjNzI5YTEsIDB4NGIxZDllMmYsIDB4ZjNkY2IyMzAsIDB4ZWMwZDg2NTIsIDB4ZDA3N2MxZTMsIDB4NmMyYmIzMTYsIDB4OTlhOTcwYjksIDB4ZmExMTk0NDgsIDB4MjI0N2U5NjQsIDB4YzRhOGZjOGMsIDB4MWFhMGYwM2YsIDB4ZDg1NjdkMmMsIDB4ZWYyMjMzOTAsIDB4Yzc4NzQ5NGUsIDB4YzFkOTM4ZDEsIDB4ZmU4Y2NhYTIsIDB4MzY5OGQ0MGIsIDB4Y2ZhNmY1ODEsIDB4MjhhNTdhZGUsIDB4MjZkYWI3OGUsIDB4YTQzZmFkYmYsIDB4ZTQyYzNhOWQsIDB4MGQ1MDc4OTIsIDB4OWI2YTVmY2MsIDB4NjI1NDdlNDYsIDB4YzJmNjhkMTMsIDB4ZTg5MGQ4YjgsIDB4NWUyZTM5ZjcsIDB4ZjU4MmMzYWYsIDB4YmU5ZjVkODAsIDB4N2M2OWQwOTMsIDB4YTk2ZmQ1MmQsIDB4YjNjZjI1MTIsIDB4M2JjOGFjOTksIDB4YTcxMDE4N2QsIDB4NmVlODljNjMsIDB4N2JkYjNiYmIsIDB4MDljZDI2NzgsIDB4ZjQ2ZTU5MTgsIDB4MDFlYzlhYjcsIDB4YTg4MzRmOWEsIDB4NjVlNjk1NmUsIDB4N2VhYWZmZTYsIDB4MDgyMWJjY2YsIDB4ZTZlZjE1ZTgsIDB4ZDliYWU3OWIsIDB4Y2U0YTZmMzYsIDB4ZDRlYTlmMDksIDB4ZDYyOWIwN2MsIDB4YWYzMWE0YjIsIDB4MzEyYTNmMjMsIDB4MzBjNmE1OTQsIDB4YzAzNWEyNjYsIDB4Mzc3NDRlYmMsIDB4YTZmYzgyY2EsIDB4YjBlMDkwZDAsIDB4MTUzM2E3ZDgsIDB4NGFmMTA0OTgsIDB4Zjc0MWVjZGEsIDB4MGU3ZmNkNTAsIDB4MmYxNzkxZjYsIDB4OGQ3NjRkZDYsIDB4NGQ0M2VmYjAsIDB4NTRjY2FhNGQsIDB4ZGZlNDk2MDQsIDB4ZTM5ZWQxYjUsIDB4MWI0YzZhODgsIDB4YjhjMTJjMWYsIDB4N2Y0NjY1NTEsIDB4MDQ5ZDVlZWEsIDB4NWQwMThjMzUsIDB4NzNmYTg3NzQsIDB4MmVmYjBiNDEsIDB4NWFiMzY3MWQsIDB4NTI5MmRiZDIsIDB4MzNlOTEwNTYsIDB4MTM2ZGQ2NDcsIDB4OGM5YWQ3NjEsIDB4N2EzN2ExMGMsIDB4OGU1OWY4MTQsIDB4ODllYjEzM2MsIDB4ZWVjZWE5MjcsIDB4MzViNzYxYzksIDB4ZWRlMTFjZTUsIDB4M2M3YTQ3YjEsIDB4NTk5Y2QyZGYsIDB4M2Y1NWYyNzMsIDB4NzkxODE0Y2UsIDB4YmY3M2M3MzcsIDB4ZWE1M2Y3Y2QsIDB4NWI1ZmZkYWEsIDB4MTRkZjNkNmYsIDB4ODY3ODQ0ZGIsIDB4ODFjYWFmZjMsIDB4M2ViOTY4YzQsIDB4MmMzODI0MzQsIDB4NWZjMmEzNDAsIDB4NzIxNjFkYzMsIDB4MGNiY2UyMjUsIDB4OGIyODNjNDksIDB4NDFmZjBkOTUsIDB4NzEzOWE4MDEsIDB4ZGUwODBjYjMsIDB4OWNkOGI0ZTQsIDB4OTA2NDU2YzEsIDB4NjE3YmNiODQsIDB4NzBkNTMyYjYsIDB4NzQ0ODZjNWMsIDB4NDJkMGI4NTddO1xuICAgIHZhciBUNyA9IFsweGE3NTA1MWY0LCAweDY1NTM3ZTQxLCAweGE0YzMxYTE3LCAweDVlOTYzYTI3LCAweDZiY2IzYmFiLCAweDQ1ZjExZjlkLCAweDU4YWJhY2ZhLCAweDAzOTM0YmUzLCAweGZhNTUyMDMwLCAweDZkZjZhZDc2LCAweDc2OTE4OGNjLCAweDRjMjVmNTAyLCAweGQ3ZmM0ZmU1LCAweGNiZDdjNTJhLCAweDQ0ODAyNjM1LCAweGEzOGZiNTYyLCAweDVhNDlkZWIxLCAweDFiNjcyNWJhLCAweDBlOTg0NWVhLCAweGMwZTE1ZGZlLCAweDc1MDJjMzJmLCAweGYwMTI4MTRjLCAweDk3YTM4ZDQ2LCAweGY5YzY2YmQzLCAweDVmZTcwMzhmLCAweDljOTUxNTkyLCAweDdhZWJiZjZkLCAweDU5ZGE5NTUyLCAweDgzMmRkNGJlLCAweDIxZDM1ODc0LCAweDY5Mjk0OWUwLCAweGM4NDQ4ZWM5LCAweDg5NmE3NWMyLCAweDc5NzhmNDhlLCAweDNlNmI5OTU4LCAweDcxZGQyN2I5LCAweDRmYjZiZWUxLCAweGFkMTdmMDg4LCAweGFjNjZjOTIwLCAweDNhYjQ3ZGNlLCAweDRhMTg2M2RmLCAweDMxODJlNTFhLCAweDMzNjA5NzUxLCAweDdmNDU2MjUzLCAweDc3ZTBiMTY0LCAweGFlODRiYjZiLCAweGEwMWNmZTgxLCAweDJiOTRmOTA4LCAweDY4NTg3MDQ4LCAweGZkMTk4ZjQ1LCAweDZjODc5NGRlLCAweGY4Yjc1MjdiLCAweGQzMjNhYjczLCAweDAyZTI3MjRiLCAweDhmNTdlMzFmLCAweGFiMmE2NjU1LCAweDI4MDdiMmViLCAweGMyMDMyZmI1LCAweDdiOWE4NmM1LCAweDA4YTVkMzM3LCAweDg3ZjIzMDI4LCAweGE1YjIyM2JmLCAweDZhYmEwMjAzLCAweDgyNWNlZDE2LCAweDFjMmI4YWNmLCAweGI0OTJhNzc5LCAweGYyZjBmMzA3LCAweGUyYTE0ZTY5LCAweGY0Y2Q2NWRhLCAweGJlZDUwNjA1LCAweDYyMWZkMTM0LCAweGZlOGFjNGE2LCAweDUzOWQzNDJlLCAweDU1YTBhMmYzLCAweGUxMzIwNThhLCAweGViNzVhNGY2LCAweGVjMzkwYjgzLCAweGVmYWE0MDYwLCAweDlmMDY1ZTcxLCAweDEwNTFiZDZlLCAweDhhZjkzZTIxLCAweDA2M2Q5NmRkLCAweDA1YWVkZDNlLCAweGJkNDY0ZGU2LCAweDhkYjU5MTU0LCAweDVkMDU3MWM0LCAweGQ0NmYwNDA2LCAweDE1ZmY2MDUwLCAweGZiMjQxOTk4LCAweGU5OTdkNmJkLCAweDQzY2M4OTQwLCAweDllNzc2N2Q5LCAweDQyYmRiMGU4LCAweDhiODgwNzg5LCAweDViMzhlNzE5LCAweGVlZGI3OWM4LCAweDBhNDdhMTdjLCAweDBmZTk3YzQyLCAweDFlYzlmODg0LCAweDAwMDAwMDAwLCAweDg2ODMwOTgwLCAweGVkNDgzMjJiLCAweDcwYWMxZTExLCAweDcyNGU2YzVhLCAweGZmZmJmZDBlLCAweDM4NTYwZjg1LCAweGQ1MWUzZGFlLCAweDM5MjczNjJkLCAweGQ5NjQwYTBmLCAweGE2MjE2ODVjLCAweDU0ZDE5YjViLCAweDJlM2EyNDM2LCAweDY3YjEwYzBhLCAweGU3MGY5MzU3LCAweDk2ZDJiNGVlLCAweDkxOWUxYjliLCAweGM1NGY4MGMwLCAweDIwYTI2MWRjLCAweDRiNjk1YTc3LCAweDFhMTYxYzEyLCAweGJhMGFlMjkzLCAweDJhZTVjMGEwLCAweGUwNDMzYzIyLCAweDE3MWQxMjFiLCAweDBkMGIwZTA5LCAweGM3YWRmMjhiLCAweGE4YjkyZGI2LCAweGE5YzgxNDFlLCAweDE5ODU1N2YxLCAweDA3NGNhZjc1LCAweGRkYmJlZTk5LCAweDYwZmRhMzdmLCAweDI2OWZmNzAxLCAweGY1YmM1YzcyLCAweDNiYzU0NDY2LCAweDdlMzQ1YmZiLCAweDI5NzY4YjQzLCAweGM2ZGNjYjIzLCAweGZjNjhiNmVkLCAweGYxNjNiOGU0LCAweGRjY2FkNzMxLCAweDg1MTA0MjYzLCAweDIyNDAxMzk3LCAweDExMjA4NGM2LCAweDI0N2Q4NTRhLCAweDNkZjhkMmJiLCAweDMyMTFhZWY5LCAweGExNmRjNzI5LCAweDJmNGIxZDllLCAweDMwZjNkY2IyLCAweDUyZWMwZDg2LCAweGUzZDA3N2MxLCAweDE2NmMyYmIzLCAweGI5OTlhOTcwLCAweDQ4ZmExMTk0LCAweDY0MjI0N2U5LCAweDhjYzRhOGZjLCAweDNmMWFhMGYwLCAweDJjZDg1NjdkLCAweDkwZWYyMjMzLCAweDRlYzc4NzQ5LCAweGQxYzFkOTM4LCAweGEyZmU4Y2NhLCAweDBiMzY5OGQ0LCAweDgxY2ZhNmY1LCAweGRlMjhhNTdhLCAweDhlMjZkYWI3LCAweGJmYTQzZmFkLCAweDlkZTQyYzNhLCAweDkyMGQ1MDc4LCAweGNjOWI2YTVmLCAweDQ2NjI1NDdlLCAweDEzYzJmNjhkLCAweGI4ZTg5MGQ4LCAweGY3NWUyZTM5LCAweGFmZjU4MmMzLCAweDgwYmU5ZjVkLCAweDkzN2M2OWQwLCAweDJkYTk2ZmQ1LCAweDEyYjNjZjI1LCAweDk5M2JjOGFjLCAweDdkYTcxMDE4LCAweDYzNmVlODljLCAweGJiN2JkYjNiLCAweDc4MDljZDI2LCAweDE4ZjQ2ZTU5LCAweGI3MDFlYzlhLCAweDlhYTg4MzRmLCAweDZlNjVlNjk1LCAweGU2N2VhYWZmLCAweGNmMDgyMWJjLCAweGU4ZTZlZjE1LCAweDliZDliYWU3LCAweDM2Y2U0YTZmLCAweDA5ZDRlYTlmLCAweDdjZDYyOWIwLCAweGIyYWYzMWE0LCAweDIzMzEyYTNmLCAweDk0MzBjNmE1LCAweDY2YzAzNWEyLCAweGJjMzc3NDRlLCAweGNhYTZmYzgyLCAweGQwYjBlMDkwLCAweGQ4MTUzM2E3LCAweDk4NGFmMTA0LCAweGRhZjc0MWVjLCAweDUwMGU3ZmNkLCAweGY2MmYxNzkxLCAweGQ2OGQ3NjRkLCAweGIwNGQ0M2VmLCAweDRkNTRjY2FhLCAweDA0ZGZlNDk2LCAweGI1ZTM5ZWQxLCAweDg4MWI0YzZhLCAweDFmYjhjMTJjLCAweDUxN2Y0NjY1LCAweGVhMDQ5ZDVlLCAweDM1NWQwMThjLCAweDc0NzNmYTg3LCAweDQxMmVmYjBiLCAweDFkNWFiMzY3LCAweGQyNTI5MmRiLCAweDU2MzNlOTEwLCAweDQ3MTM2ZGQ2LCAweDYxOGM5YWQ3LCAweDBjN2EzN2ExLCAweDE0OGU1OWY4LCAweDNjODllYjEzLCAweDI3ZWVjZWE5LCAweGM5MzViNzYxLCAweGU1ZWRlMTFjLCAweGIxM2M3YTQ3LCAweGRmNTk5Y2QyLCAweDczM2Y1NWYyLCAweGNlNzkxODE0LCAweDM3YmY3M2M3LCAweGNkZWE1M2Y3LCAweGFhNWI1ZmZkLCAweDZmMTRkZjNkLCAweGRiODY3ODQ0LCAweGYzODFjYWFmLCAweGM0M2ViOTY4LCAweDM0MmMzODI0LCAweDQwNWZjMmEzLCAweGMzNzIxNjFkLCAweDI1MGNiY2UyLCAweDQ5OGIyODNjLCAweDk1NDFmZjBkLCAweDAxNzEzOWE4LCAweGIzZGUwODBjLCAweGU0OWNkOGI0LCAweGMxOTA2NDU2LCAweDg0NjE3YmNiLCAweGI2NzBkNTMyLCAweDVjNzQ0ODZjLCAweDU3NDJkMGI4XTtcbiAgICB2YXIgVDggPSBbMHhmNGE3NTA1MSwgMHg0MTY1NTM3ZSwgMHgxN2E0YzMxYSwgMHgyNzVlOTYzYSwgMHhhYjZiY2IzYiwgMHg5ZDQ1ZjExZiwgMHhmYTU4YWJhYywgMHhlMzAzOTM0YiwgMHgzMGZhNTUyMCwgMHg3NjZkZjZhZCwgMHhjYzc2OTE4OCwgMHgwMjRjMjVmNSwgMHhlNWQ3ZmM0ZiwgMHgyYWNiZDdjNSwgMHgzNTQ0ODAyNiwgMHg2MmEzOGZiNSwgMHhiMTVhNDlkZSwgMHhiYTFiNjcyNSwgMHhlYTBlOTg0NSwgMHhmZWMwZTE1ZCwgMHgyZjc1MDJjMywgMHg0Y2YwMTI4MSwgMHg0Njk3YTM4ZCwgMHhkM2Y5YzY2YiwgMHg4ZjVmZTcwMywgMHg5MjljOTUxNSwgMHg2ZDdhZWJiZiwgMHg1MjU5ZGE5NSwgMHhiZTgzMmRkNCwgMHg3NDIxZDM1OCwgMHhlMDY5Mjk0OSwgMHhjOWM4NDQ4ZSwgMHhjMjg5NmE3NSwgMHg4ZTc5NzhmNCwgMHg1ODNlNmI5OSwgMHhiOTcxZGQyNywgMHhlMTRmYjZiZSwgMHg4OGFkMTdmMCwgMHgyMGFjNjZjOSwgMHhjZTNhYjQ3ZCwgMHhkZjRhMTg2MywgMHgxYTMxODJlNSwgMHg1MTMzNjA5NywgMHg1MzdmNDU2MiwgMHg2NDc3ZTBiMSwgMHg2YmFlODRiYiwgMHg4MWEwMWNmZSwgMHgwODJiOTRmOSwgMHg0ODY4NTg3MCwgMHg0NWZkMTk4ZiwgMHhkZTZjODc5NCwgMHg3YmY4Yjc1MiwgMHg3M2QzMjNhYiwgMHg0YjAyZTI3MiwgMHgxZjhmNTdlMywgMHg1NWFiMmE2NiwgMHhlYjI4MDdiMiwgMHhiNWMyMDMyZiwgMHhjNTdiOWE4NiwgMHgzNzA4YTVkMywgMHgyODg3ZjIzMCwgMHhiZmE1YjIyMywgMHgwMzZhYmEwMiwgMHgxNjgyNWNlZCwgMHhjZjFjMmI4YSwgMHg3OWI0OTJhNywgMHgwN2YyZjBmMywgMHg2OWUyYTE0ZSwgMHhkYWY0Y2Q2NSwgMHgwNWJlZDUwNiwgMHgzNDYyMWZkMSwgMHhhNmZlOGFjNCwgMHgyZTUzOWQzNCwgMHhmMzU1YTBhMiwgMHg4YWUxMzIwNSwgMHhmNmViNzVhNCwgMHg4M2VjMzkwYiwgMHg2MGVmYWE0MCwgMHg3MTlmMDY1ZSwgMHg2ZTEwNTFiZCwgMHgyMThhZjkzZSwgMHhkZDA2M2Q5NiwgMHgzZTA1YWVkZCwgMHhlNmJkNDY0ZCwgMHg1NDhkYjU5MSwgMHhjNDVkMDU3MSwgMHgwNmQ0NmYwNCwgMHg1MDE1ZmY2MCwgMHg5OGZiMjQxOSwgMHhiZGU5OTdkNiwgMHg0MDQzY2M4OSwgMHhkOTllNzc2NywgMHhlODQyYmRiMCwgMHg4OThiODgwNywgMHgxOTViMzhlNywgMHhjOGVlZGI3OSwgMHg3YzBhNDdhMSwgMHg0MjBmZTk3YywgMHg4NDFlYzlmOCwgMHgwMDAwMDAwMCwgMHg4MDg2ODMwOSwgMHgyYmVkNDgzMiwgMHgxMTcwYWMxZSwgMHg1YTcyNGU2YywgMHgwZWZmZmJmZCwgMHg4NTM4NTYwZiwgMHhhZWQ1MWUzZCwgMHgyZDM5MjczNiwgMHgwZmQ5NjQwYSwgMHg1Y2E2MjE2OCwgMHg1YjU0ZDE5YiwgMHgzNjJlM2EyNCwgMHgwYTY3YjEwYywgMHg1N2U3MGY5MywgMHhlZTk2ZDJiNCwgMHg5YjkxOWUxYiwgMHhjMGM1NGY4MCwgMHhkYzIwYTI2MSwgMHg3NzRiNjk1YSwgMHgxMjFhMTYxYywgMHg5M2JhMGFlMiwgMHhhMDJhZTVjMCwgMHgyMmUwNDMzYywgMHgxYjE3MWQxMiwgMHgwOTBkMGIwZSwgMHg4YmM3YWRmMiwgMHhiNmE4YjkyZCwgMHgxZWE5YzgxNCwgMHhmMTE5ODU1NywgMHg3NTA3NGNhZiwgMHg5OWRkYmJlZSwgMHg3ZjYwZmRhMywgMHgwMTI2OWZmNywgMHg3MmY1YmM1YywgMHg2NjNiYzU0NCwgMHhmYjdlMzQ1YiwgMHg0MzI5NzY4YiwgMHgyM2M2ZGNjYiwgMHhlZGZjNjhiNiwgMHhlNGYxNjNiOCwgMHgzMWRjY2FkNywgMHg2Mzg1MTA0MiwgMHg5NzIyNDAxMywgMHhjNjExMjA4NCwgMHg0YTI0N2Q4NSwgMHhiYjNkZjhkMiwgMHhmOTMyMTFhZSwgMHgyOWExNmRjNywgMHg5ZTJmNGIxZCwgMHhiMjMwZjNkYywgMHg4NjUyZWMwZCwgMHhjMWUzZDA3NywgMHhiMzE2NmMyYiwgMHg3MGI5OTlhOSwgMHg5NDQ4ZmExMSwgMHhlOTY0MjI0NywgMHhmYzhjYzRhOCwgMHhmMDNmMWFhMCwgMHg3ZDJjZDg1NiwgMHgzMzkwZWYyMiwgMHg0OTRlYzc4NywgMHgzOGQxYzFkOSwgMHhjYWEyZmU4YywgMHhkNDBiMzY5OCwgMHhmNTgxY2ZhNiwgMHg3YWRlMjhhNSwgMHhiNzhlMjZkYSwgMHhhZGJmYTQzZiwgMHgzYTlkZTQyYywgMHg3ODkyMGQ1MCwgMHg1ZmNjOWI2YSwgMHg3ZTQ2NjI1NCwgMHg4ZDEzYzJmNiwgMHhkOGI4ZTg5MCwgMHgzOWY3NWUyZSwgMHhjM2FmZjU4MiwgMHg1ZDgwYmU5ZiwgMHhkMDkzN2M2OSwgMHhkNTJkYTk2ZiwgMHgyNTEyYjNjZiwgMHhhYzk5M2JjOCwgMHgxODdkYTcxMCwgMHg5YzYzNmVlOCwgMHgzYmJiN2JkYiwgMHgyNjc4MDljZCwgMHg1OTE4ZjQ2ZSwgMHg5YWI3MDFlYywgMHg0ZjlhYTg4MywgMHg5NTZlNjVlNiwgMHhmZmU2N2VhYSwgMHhiY2NmMDgyMSwgMHgxNWU4ZTZlZiwgMHhlNzliZDliYSwgMHg2ZjM2Y2U0YSwgMHg5ZjA5ZDRlYSwgMHhiMDdjZDYyOSwgMHhhNGIyYWYzMSwgMHgzZjIzMzEyYSwgMHhhNTk0MzBjNiwgMHhhMjY2YzAzNSwgMHg0ZWJjMzc3NCwgMHg4MmNhYTZmYywgMHg5MGQwYjBlMCwgMHhhN2Q4MTUzMywgMHgwNDk4NGFmMSwgMHhlY2RhZjc0MSwgMHhjZDUwMGU3ZiwgMHg5MWY2MmYxNywgMHg0ZGQ2OGQ3NiwgMHhlZmIwNGQ0MywgMHhhYTRkNTRjYywgMHg5NjA0ZGZlNCwgMHhkMWI1ZTM5ZSwgMHg2YTg4MWI0YywgMHgyYzFmYjhjMSwgMHg2NTUxN2Y0NiwgMHg1ZWVhMDQ5ZCwgMHg4YzM1NWQwMSwgMHg4Nzc0NzNmYSwgMHgwYjQxMmVmYiwgMHg2NzFkNWFiMywgMHhkYmQyNTI5MiwgMHgxMDU2MzNlOSwgMHhkNjQ3MTM2ZCwgMHhkNzYxOGM5YSwgMHhhMTBjN2EzNywgMHhmODE0OGU1OSwgMHgxMzNjODllYiwgMHhhOTI3ZWVjZSwgMHg2MWM5MzViNywgMHgxY2U1ZWRlMSwgMHg0N2IxM2M3YSwgMHhkMmRmNTk5YywgMHhmMjczM2Y1NSwgMHgxNGNlNzkxOCwgMHhjNzM3YmY3MywgMHhmN2NkZWE1MywgMHhmZGFhNWI1ZiwgMHgzZDZmMTRkZiwgMHg0NGRiODY3OCwgMHhhZmYzODFjYSwgMHg2OGM0M2ViOSwgMHgyNDM0MmMzOCwgMHhhMzQwNWZjMiwgMHgxZGMzNzIxNiwgMHhlMjI1MGNiYywgMHgzYzQ5OGIyOCwgMHgwZDk1NDFmZiwgMHhhODAxNzEzOSwgMHgwY2IzZGUwOCwgMHhiNGU0OWNkOCwgMHg1NmMxOTA2NCwgMHhjYjg0NjE3YiwgMHgzMmI2NzBkNSwgMHg2YzVjNzQ0OCwgMHhiODU3NDJkMF07XG5cbiAgICAvLyBUcmFuc2Zvcm1hdGlvbnMgZm9yIGRlY3J5cHRpb24ga2V5IGV4cGFuc2lvblxuICAgIHZhciBVMSA9IFsweDAwMDAwMDAwLCAweDBlMDkwZDBiLCAweDFjMTIxYTE2LCAweDEyMWIxNzFkLCAweDM4MjQzNDJjLCAweDM2MmQzOTI3LCAweDI0MzYyZTNhLCAweDJhM2YyMzMxLCAweDcwNDg2ODU4LCAweDdlNDE2NTUzLCAweDZjNWE3MjRlLCAweDYyNTM3ZjQ1LCAweDQ4NmM1Yzc0LCAweDQ2NjU1MTdmLCAweDU0N2U0NjYyLCAweDVhNzc0YjY5LCAweGUwOTBkMGIwLCAweGVlOTlkZGJiLCAweGZjODJjYWE2LCAweGYyOGJjN2FkLCAweGQ4YjRlNDljLCAweGQ2YmRlOTk3LCAweGM0YTZmZThhLCAweGNhYWZmMzgxLCAweDkwZDhiOGU4LCAweDllZDFiNWUzLCAweDhjY2FhMmZlLCAweDgyYzNhZmY1LCAweGE4ZmM4Y2M0LCAweGE2ZjU4MWNmLCAweGI0ZWU5NmQyLCAweGJhZTc5YmQ5LCAweGRiM2JiYjdiLCAweGQ1MzJiNjcwLCAweGM3MjlhMTZkLCAweGM5MjBhYzY2LCAweGUzMWY4ZjU3LCAweGVkMTY4MjVjLCAweGZmMGQ5NTQxLCAweGYxMDQ5ODRhLCAweGFiNzNkMzIzLCAweGE1N2FkZTI4LCAweGI3NjFjOTM1LCAweGI5NjhjNDNlLCAweDkzNTdlNzBmLCAweDlkNWVlYTA0LCAweDhmNDVmZDE5LCAweDgxNGNmMDEyLCAweDNiYWI2YmNiLCAweDM1YTI2NmMwLCAweDI3Yjk3MWRkLCAweDI5YjA3Y2Q2LCAweDAzOGY1ZmU3LCAweDBkODY1MmVjLCAweDFmOWQ0NWYxLCAweDExOTQ0OGZhLCAweDRiZTMwMzkzLCAweDQ1ZWEwZTk4LCAweDU3ZjExOTg1LCAweDU5ZjgxNDhlLCAweDczYzczN2JmLCAweDdkY2UzYWI0LCAweDZmZDUyZGE5LCAweDYxZGMyMGEyLCAweGFkNzY2ZGY2LCAweGEzN2Y2MGZkLCAweGIxNjQ3N2UwLCAweGJmNmQ3YWViLCAweDk1NTI1OWRhLCAweDliNWI1NGQxLCAweDg5NDA0M2NjLCAweDg3NDk0ZWM3LCAweGRkM2UwNWFlLCAweGQzMzcwOGE1LCAweGMxMmMxZmI4LCAweGNmMjUxMmIzLCAweGU1MWEzMTgyLCAweGViMTMzYzg5LCAweGY5MDgyYjk0LCAweGY3MDEyNjlmLCAweDRkZTZiZDQ2LCAweDQzZWZiMDRkLCAweDUxZjRhNzUwLCAweDVmZmRhYTViLCAweDc1YzI4OTZhLCAweDdiY2I4NDYxLCAweDY5ZDA5MzdjLCAweDY3ZDk5ZTc3LCAweDNkYWVkNTFlLCAweDMzYTdkODE1LCAweDIxYmNjZjA4LCAweDJmYjVjMjAzLCAweDA1OGFlMTMyLCAweDBiODNlYzM5LCAweDE5OThmYjI0LCAweDE3OTFmNjJmLCAweDc2NGRkNjhkLCAweDc4NDRkYjg2LCAweDZhNWZjYzliLCAweDY0NTZjMTkwLCAweDRlNjllMmExLCAweDQwNjBlZmFhLCAweDUyN2JmOGI3LCAweDVjNzJmNWJjLCAweDA2MDViZWQ1LCAweDA4MGNiM2RlLCAweDFhMTdhNGMzLCAweDE0MWVhOWM4LCAweDNlMjE4YWY5LCAweDMwMjg4N2YyLCAweDIyMzM5MGVmLCAweDJjM2E5ZGU0LCAweDk2ZGQwNjNkLCAweDk4ZDQwYjM2LCAweDhhY2YxYzJiLCAweDg0YzYxMTIwLCAweGFlZjkzMjExLCAweGEwZjAzZjFhLCAweGIyZWIyODA3LCAweGJjZTIyNTBjLCAweGU2OTU2ZTY1LCAweGU4OWM2MzZlLCAweGZhODc3NDczLCAweGY0OGU3OTc4LCAweGRlYjE1YTQ5LCAweGQwYjg1NzQyLCAweGMyYTM0MDVmLCAweGNjYWE0ZDU0LCAweDQxZWNkYWY3LCAweDRmZTVkN2ZjLCAweDVkZmVjMGUxLCAweDUzZjdjZGVhLCAweDc5YzhlZWRiLCAweDc3YzFlM2QwLCAweDY1ZGFmNGNkLCAweDZiZDNmOWM2LCAweDMxYTRiMmFmLCAweDNmYWRiZmE0LCAweDJkYjZhOGI5LCAweDIzYmZhNWIyLCAweDA5ODA4NjgzLCAweDA3ODk4Yjg4LCAweDE1OTI5Yzk1LCAweDFiOWI5MTllLCAweGExN2MwYTQ3LCAweGFmNzUwNzRjLCAweGJkNmUxMDUxLCAweGIzNjcxZDVhLCAweDk5NTgzZTZiLCAweDk3NTEzMzYwLCAweDg1NGEyNDdkLCAweDhiNDMyOTc2LCAweGQxMzQ2MjFmLCAweGRmM2Q2ZjE0LCAweGNkMjY3ODA5LCAweGMzMmY3NTAyLCAweGU5MTA1NjMzLCAweGU3MTk1YjM4LCAweGY1MDI0YzI1LCAweGZiMGI0MTJlLCAweDlhZDc2MThjLCAweDk0ZGU2Yzg3LCAweDg2YzU3YjlhLCAweDg4Y2M3NjkxLCAweGEyZjM1NWEwLCAweGFjZmE1OGFiLCAweGJlZTE0ZmI2LCAweGIwZTg0MmJkLCAweGVhOWYwOWQ0LCAweGU0OTYwNGRmLCAweGY2OGQxM2MyLCAweGY4ODQxZWM5LCAweGQyYmIzZGY4LCAweGRjYjIzMGYzLCAweGNlYTkyN2VlLCAweGMwYTAyYWU1LCAweDdhNDdiMTNjLCAweDc0NGViYzM3LCAweDY2NTVhYjJhLCAweDY4NWNhNjIxLCAweDQyNjM4NTEwLCAweDRjNmE4ODFiLCAweDVlNzE5ZjA2LCAweDUwNzg5MjBkLCAweDBhMGZkOTY0LCAweDA0MDZkNDZmLCAweDE2MWRjMzcyLCAweDE4MTRjZTc5LCAweDMyMmJlZDQ4LCAweDNjMjJlMDQzLCAweDJlMzlmNzVlLCAweDIwMzBmYTU1LCAweGVjOWFiNzAxLCAweGUyOTNiYTBhLCAweGYwODhhZDE3LCAweGZlODFhMDFjLCAweGQ0YmU4MzJkLCAweGRhYjc4ZTI2LCAweGM4YWM5OTNiLCAweGM2YTU5NDMwLCAweDljZDJkZjU5LCAweDkyZGJkMjUyLCAweDgwYzBjNTRmLCAweDhlYzljODQ0LCAweGE0ZjZlYjc1LCAweGFhZmZlNjdlLCAweGI4ZTRmMTYzLCAweGI2ZWRmYzY4LCAweDBjMGE2N2IxLCAweDAyMDM2YWJhLCAweDEwMTg3ZGE3LCAweDFlMTE3MGFjLCAweDM0MmU1MzlkLCAweDNhMjc1ZTk2LCAweDI4M2M0OThiLCAweDI2MzU0NDgwLCAweDdjNDIwZmU5LCAweDcyNGIwMmUyLCAweDYwNTAxNWZmLCAweDZlNTkxOGY0LCAweDQ0NjYzYmM1LCAweDRhNmYzNmNlLCAweDU4NzQyMWQzLCAweDU2N2QyY2Q4LCAweDM3YTEwYzdhLCAweDM5YTgwMTcxLCAweDJiYjMxNjZjLCAweDI1YmExYjY3LCAweDBmODUzODU2LCAweDAxOGMzNTVkLCAweDEzOTcyMjQwLCAweDFkOWUyZjRiLCAweDQ3ZTk2NDIyLCAweDQ5ZTA2OTI5LCAweDViZmI3ZTM0LCAweDU1ZjI3MzNmLCAweDdmY2Q1MDBlLCAweDcxYzQ1ZDA1LCAweDYzZGY0YTE4LCAweDZkZDY0NzEzLCAweGQ3MzFkY2NhLCAweGQ5MzhkMWMxLCAweGNiMjNjNmRjLCAweGM1MmFjYmQ3LCAweGVmMTVlOGU2LCAweGUxMWNlNWVkLCAweGYzMDdmMmYwLCAweGZkMGVmZmZiLCAweGE3NzliNDkyLCAweGE5NzBiOTk5LCAweGJiNmJhZTg0LCAweGI1NjJhMzhmLCAweDlmNWQ4MGJlLCAweDkxNTQ4ZGI1LCAweDgzNGY5YWE4LCAweDhkNDY5N2EzXTtcbiAgICB2YXIgVTIgPSBbMHgwMDAwMDAwMCwgMHgwYjBlMDkwZCwgMHgxNjFjMTIxYSwgMHgxZDEyMWIxNywgMHgyYzM4MjQzNCwgMHgyNzM2MmQzOSwgMHgzYTI0MzYyZSwgMHgzMTJhM2YyMywgMHg1ODcwNDg2OCwgMHg1MzdlNDE2NSwgMHg0ZTZjNWE3MiwgMHg0NTYyNTM3ZiwgMHg3NDQ4NmM1YywgMHg3ZjQ2NjU1MSwgMHg2MjU0N2U0NiwgMHg2OTVhNzc0YiwgMHhiMGUwOTBkMCwgMHhiYmVlOTlkZCwgMHhhNmZjODJjYSwgMHhhZGYyOGJjNywgMHg5Y2Q4YjRlNCwgMHg5N2Q2YmRlOSwgMHg4YWM0YTZmZSwgMHg4MWNhYWZmMywgMHhlODkwZDhiOCwgMHhlMzllZDFiNSwgMHhmZThjY2FhMiwgMHhmNTgyYzNhZiwgMHhjNGE4ZmM4YywgMHhjZmE2ZjU4MSwgMHhkMmI0ZWU5NiwgMHhkOWJhZTc5YiwgMHg3YmRiM2JiYiwgMHg3MGQ1MzJiNiwgMHg2ZGM3MjlhMSwgMHg2NmM5MjBhYywgMHg1N2UzMWY4ZiwgMHg1Y2VkMTY4MiwgMHg0MWZmMGQ5NSwgMHg0YWYxMDQ5OCwgMHgyM2FiNzNkMywgMHgyOGE1N2FkZSwgMHgzNWI3NjFjOSwgMHgzZWI5NjhjNCwgMHgwZjkzNTdlNywgMHgwNDlkNWVlYSwgMHgxOThmNDVmZCwgMHgxMjgxNGNmMCwgMHhjYjNiYWI2YiwgMHhjMDM1YTI2NiwgMHhkZDI3Yjk3MSwgMHhkNjI5YjA3YywgMHhlNzAzOGY1ZiwgMHhlYzBkODY1MiwgMHhmMTFmOWQ0NSwgMHhmYTExOTQ0OCwgMHg5MzRiZTMwMywgMHg5ODQ1ZWEwZSwgMHg4NTU3ZjExOSwgMHg4ZTU5ZjgxNCwgMHhiZjczYzczNywgMHhiNDdkY2UzYSwgMHhhOTZmZDUyZCwgMHhhMjYxZGMyMCwgMHhmNmFkNzY2ZCwgMHhmZGEzN2Y2MCwgMHhlMGIxNjQ3NywgMHhlYmJmNmQ3YSwgMHhkYTk1NTI1OSwgMHhkMTliNWI1NCwgMHhjYzg5NDA0MywgMHhjNzg3NDk0ZSwgMHhhZWRkM2UwNSwgMHhhNWQzMzcwOCwgMHhiOGMxMmMxZiwgMHhiM2NmMjUxMiwgMHg4MmU1MWEzMSwgMHg4OWViMTMzYywgMHg5NGY5MDgyYiwgMHg5ZmY3MDEyNiwgMHg0NjRkZTZiZCwgMHg0ZDQzZWZiMCwgMHg1MDUxZjRhNywgMHg1YjVmZmRhYSwgMHg2YTc1YzI4OSwgMHg2MTdiY2I4NCwgMHg3YzY5ZDA5MywgMHg3NzY3ZDk5ZSwgMHgxZTNkYWVkNSwgMHgxNTMzYTdkOCwgMHgwODIxYmNjZiwgMHgwMzJmYjVjMiwgMHgzMjA1OGFlMSwgMHgzOTBiODNlYywgMHgyNDE5OThmYiwgMHgyZjE3OTFmNiwgMHg4ZDc2NGRkNiwgMHg4Njc4NDRkYiwgMHg5YjZhNWZjYywgMHg5MDY0NTZjMSwgMHhhMTRlNjllMiwgMHhhYTQwNjBlZiwgMHhiNzUyN2JmOCwgMHhiYzVjNzJmNSwgMHhkNTA2MDViZSwgMHhkZTA4MGNiMywgMHhjMzFhMTdhNCwgMHhjODE0MWVhOSwgMHhmOTNlMjE4YSwgMHhmMjMwMjg4NywgMHhlZjIyMzM5MCwgMHhlNDJjM2E5ZCwgMHgzZDk2ZGQwNiwgMHgzNjk4ZDQwYiwgMHgyYjhhY2YxYywgMHgyMDg0YzYxMSwgMHgxMWFlZjkzMiwgMHgxYWEwZjAzZiwgMHgwN2IyZWIyOCwgMHgwY2JjZTIyNSwgMHg2NWU2OTU2ZSwgMHg2ZWU4OWM2MywgMHg3M2ZhODc3NCwgMHg3OGY0OGU3OSwgMHg0OWRlYjE1YSwgMHg0MmQwYjg1NywgMHg1ZmMyYTM0MCwgMHg1NGNjYWE0ZCwgMHhmNzQxZWNkYSwgMHhmYzRmZTVkNywgMHhlMTVkZmVjMCwgMHhlYTUzZjdjZCwgMHhkYjc5YzhlZSwgMHhkMDc3YzFlMywgMHhjZDY1ZGFmNCwgMHhjNjZiZDNmOSwgMHhhZjMxYTRiMiwgMHhhNDNmYWRiZiwgMHhiOTJkYjZhOCwgMHhiMjIzYmZhNSwgMHg4MzA5ODA4NiwgMHg4ODA3ODk4YiwgMHg5NTE1OTI5YywgMHg5ZTFiOWI5MSwgMHg0N2ExN2MwYSwgMHg0Y2FmNzUwNywgMHg1MWJkNmUxMCwgMHg1YWIzNjcxZCwgMHg2Yjk5NTgzZSwgMHg2MDk3NTEzMywgMHg3ZDg1NGEyNCwgMHg3NjhiNDMyOSwgMHgxZmQxMzQ2MiwgMHgxNGRmM2Q2ZiwgMHgwOWNkMjY3OCwgMHgwMmMzMmY3NSwgMHgzM2U5MTA1NiwgMHgzOGU3MTk1YiwgMHgyNWY1MDI0YywgMHgyZWZiMGI0MSwgMHg4YzlhZDc2MSwgMHg4Nzk0ZGU2YywgMHg5YTg2YzU3YiwgMHg5MTg4Y2M3NiwgMHhhMGEyZjM1NSwgMHhhYmFjZmE1OCwgMHhiNmJlZTE0ZiwgMHhiZGIwZTg0MiwgMHhkNGVhOWYwOSwgMHhkZmU0OTYwNCwgMHhjMmY2OGQxMywgMHhjOWY4ODQxZSwgMHhmOGQyYmIzZCwgMHhmM2RjYjIzMCwgMHhlZWNlYTkyNywgMHhlNWMwYTAyYSwgMHgzYzdhNDdiMSwgMHgzNzc0NGViYywgMHgyYTY2NTVhYiwgMHgyMTY4NWNhNiwgMHgxMDQyNjM4NSwgMHgxYjRjNmE4OCwgMHgwNjVlNzE5ZiwgMHgwZDUwNzg5MiwgMHg2NDBhMGZkOSwgMHg2ZjA0MDZkNCwgMHg3MjE2MWRjMywgMHg3OTE4MTRjZSwgMHg0ODMyMmJlZCwgMHg0MzNjMjJlMCwgMHg1ZTJlMzlmNywgMHg1NTIwMzBmYSwgMHgwMWVjOWFiNywgMHgwYWUyOTNiYSwgMHgxN2YwODhhZCwgMHgxY2ZlODFhMCwgMHgyZGQ0YmU4MywgMHgyNmRhYjc4ZSwgMHgzYmM4YWM5OSwgMHgzMGM2YTU5NCwgMHg1OTljZDJkZiwgMHg1MjkyZGJkMiwgMHg0ZjgwYzBjNSwgMHg0NDhlYzljOCwgMHg3NWE0ZjZlYiwgMHg3ZWFhZmZlNiwgMHg2M2I4ZTRmMSwgMHg2OGI2ZWRmYywgMHhiMTBjMGE2NywgMHhiYTAyMDM2YSwgMHhhNzEwMTg3ZCwgMHhhYzFlMTE3MCwgMHg5ZDM0MmU1MywgMHg5NjNhMjc1ZSwgMHg4YjI4M2M0OSwgMHg4MDI2MzU0NCwgMHhlOTdjNDIwZiwgMHhlMjcyNGIwMiwgMHhmZjYwNTAxNSwgMHhmNDZlNTkxOCwgMHhjNTQ0NjYzYiwgMHhjZTRhNmYzNiwgMHhkMzU4NzQyMSwgMHhkODU2N2QyYywgMHg3YTM3YTEwYywgMHg3MTM5YTgwMSwgMHg2YzJiYjMxNiwgMHg2NzI1YmExYiwgMHg1NjBmODUzOCwgMHg1ZDAxOGMzNSwgMHg0MDEzOTcyMiwgMHg0YjFkOWUyZiwgMHgyMjQ3ZTk2NCwgMHgyOTQ5ZTA2OSwgMHgzNDViZmI3ZSwgMHgzZjU1ZjI3MywgMHgwZTdmY2Q1MCwgMHgwNTcxYzQ1ZCwgMHgxODYzZGY0YSwgMHgxMzZkZDY0NywgMHhjYWQ3MzFkYywgMHhjMWQ5MzhkMSwgMHhkY2NiMjNjNiwgMHhkN2M1MmFjYiwgMHhlNmVmMTVlOCwgMHhlZGUxMWNlNSwgMHhmMGYzMDdmMiwgMHhmYmZkMGVmZiwgMHg5MmE3NzliNCwgMHg5OWE5NzBiOSwgMHg4NGJiNmJhZSwgMHg4ZmI1NjJhMywgMHhiZTlmNWQ4MCwgMHhiNTkxNTQ4ZCwgMHhhODgzNGY5YSwgMHhhMzhkNDY5N107XG4gICAgdmFyIFUzID0gWzB4MDAwMDAwMDAsIDB4MGQwYjBlMDksIDB4MWExNjFjMTIsIDB4MTcxZDEyMWIsIDB4MzQyYzM4MjQsIDB4MzkyNzM2MmQsIDB4MmUzYTI0MzYsIDB4MjMzMTJhM2YsIDB4Njg1ODcwNDgsIDB4NjU1MzdlNDEsIDB4NzI0ZTZjNWEsIDB4N2Y0NTYyNTMsIDB4NWM3NDQ4NmMsIDB4NTE3ZjQ2NjUsIDB4NDY2MjU0N2UsIDB4NGI2OTVhNzcsIDB4ZDBiMGUwOTAsIDB4ZGRiYmVlOTksIDB4Y2FhNmZjODIsIDB4YzdhZGYyOGIsIDB4ZTQ5Y2Q4YjQsIDB4ZTk5N2Q2YmQsIDB4ZmU4YWM0YTYsIDB4ZjM4MWNhYWYsIDB4YjhlODkwZDgsIDB4YjVlMzllZDEsIDB4YTJmZThjY2EsIDB4YWZmNTgyYzMsIDB4OGNjNGE4ZmMsIDB4ODFjZmE2ZjUsIDB4OTZkMmI0ZWUsIDB4OWJkOWJhZTcsIDB4YmI3YmRiM2IsIDB4YjY3MGQ1MzIsIDB4YTE2ZGM3MjksIDB4YWM2NmM5MjAsIDB4OGY1N2UzMWYsIDB4ODI1Y2VkMTYsIDB4OTU0MWZmMGQsIDB4OTg0YWYxMDQsIDB4ZDMyM2FiNzMsIDB4ZGUyOGE1N2EsIDB4YzkzNWI3NjEsIDB4YzQzZWI5NjgsIDB4ZTcwZjkzNTcsIDB4ZWEwNDlkNWUsIDB4ZmQxOThmNDUsIDB4ZjAxMjgxNGMsIDB4NmJjYjNiYWIsIDB4NjZjMDM1YTIsIDB4NzFkZDI3YjksIDB4N2NkNjI5YjAsIDB4NWZlNzAzOGYsIDB4NTJlYzBkODYsIDB4NDVmMTFmOWQsIDB4NDhmYTExOTQsIDB4MDM5MzRiZTMsIDB4MGU5ODQ1ZWEsIDB4MTk4NTU3ZjEsIDB4MTQ4ZTU5ZjgsIDB4MzdiZjczYzcsIDB4M2FiNDdkY2UsIDB4MmRhOTZmZDUsIDB4MjBhMjYxZGMsIDB4NmRmNmFkNzYsIDB4NjBmZGEzN2YsIDB4NzdlMGIxNjQsIDB4N2FlYmJmNmQsIDB4NTlkYTk1NTIsIDB4NTRkMTliNWIsIDB4NDNjYzg5NDAsIDB4NGVjNzg3NDksIDB4MDVhZWRkM2UsIDB4MDhhNWQzMzcsIDB4MWZiOGMxMmMsIDB4MTJiM2NmMjUsIDB4MzE4MmU1MWEsIDB4M2M4OWViMTMsIDB4MmI5NGY5MDgsIDB4MjY5ZmY3MDEsIDB4YmQ0NjRkZTYsIDB4YjA0ZDQzZWYsIDB4YTc1MDUxZjQsIDB4YWE1YjVmZmQsIDB4ODk2YTc1YzIsIDB4ODQ2MTdiY2IsIDB4OTM3YzY5ZDAsIDB4OWU3NzY3ZDksIDB4ZDUxZTNkYWUsIDB4ZDgxNTMzYTcsIDB4Y2YwODIxYmMsIDB4YzIwMzJmYjUsIDB4ZTEzMjA1OGEsIDB4ZWMzOTBiODMsIDB4ZmIyNDE5OTgsIDB4ZjYyZjE3OTEsIDB4ZDY4ZDc2NGQsIDB4ZGI4Njc4NDQsIDB4Y2M5YjZhNWYsIDB4YzE5MDY0NTYsIDB4ZTJhMTRlNjksIDB4ZWZhYTQwNjAsIDB4ZjhiNzUyN2IsIDB4ZjViYzVjNzIsIDB4YmVkNTA2MDUsIDB4YjNkZTA4MGMsIDB4YTRjMzFhMTcsIDB4YTljODE0MWUsIDB4OGFmOTNlMjEsIDB4ODdmMjMwMjgsIDB4OTBlZjIyMzMsIDB4OWRlNDJjM2EsIDB4MDYzZDk2ZGQsIDB4MGIzNjk4ZDQsIDB4MWMyYjhhY2YsIDB4MTEyMDg0YzYsIDB4MzIxMWFlZjksIDB4M2YxYWEwZjAsIDB4MjgwN2IyZWIsIDB4MjUwY2JjZTIsIDB4NmU2NWU2OTUsIDB4NjM2ZWU4OWMsIDB4NzQ3M2ZhODcsIDB4Nzk3OGY0OGUsIDB4NWE0OWRlYjEsIDB4NTc0MmQwYjgsIDB4NDA1ZmMyYTMsIDB4NGQ1NGNjYWEsIDB4ZGFmNzQxZWMsIDB4ZDdmYzRmZTUsIDB4YzBlMTVkZmUsIDB4Y2RlYTUzZjcsIDB4ZWVkYjc5YzgsIDB4ZTNkMDc3YzEsIDB4ZjRjZDY1ZGEsIDB4ZjljNjZiZDMsIDB4YjJhZjMxYTQsIDB4YmZhNDNmYWQsIDB4YThiOTJkYjYsIDB4YTViMjIzYmYsIDB4ODY4MzA5ODAsIDB4OGI4ODA3ODksIDB4OWM5NTE1OTIsIDB4OTE5ZTFiOWIsIDB4MGE0N2ExN2MsIDB4MDc0Y2FmNzUsIDB4MTA1MWJkNmUsIDB4MWQ1YWIzNjcsIDB4M2U2Yjk5NTgsIDB4MzM2MDk3NTEsIDB4MjQ3ZDg1NGEsIDB4Mjk3NjhiNDMsIDB4NjIxZmQxMzQsIDB4NmYxNGRmM2QsIDB4NzgwOWNkMjYsIDB4NzUwMmMzMmYsIDB4NTYzM2U5MTAsIDB4NWIzOGU3MTksIDB4NGMyNWY1MDIsIDB4NDEyZWZiMGIsIDB4NjE4YzlhZDcsIDB4NmM4Nzk0ZGUsIDB4N2I5YTg2YzUsIDB4NzY5MTg4Y2MsIDB4NTVhMGEyZjMsIDB4NThhYmFjZmEsIDB4NGZiNmJlZTEsIDB4NDJiZGIwZTgsIDB4MDlkNGVhOWYsIDB4MDRkZmU0OTYsIDB4MTNjMmY2OGQsIDB4MWVjOWY4ODQsIDB4M2RmOGQyYmIsIDB4MzBmM2RjYjIsIDB4MjdlZWNlYTksIDB4MmFlNWMwYTAsIDB4YjEzYzdhNDcsIDB4YmMzNzc0NGUsIDB4YWIyYTY2NTUsIDB4YTYyMTY4NWMsIDB4ODUxMDQyNjMsIDB4ODgxYjRjNmEsIDB4OWYwNjVlNzEsIDB4OTIwZDUwNzgsIDB4ZDk2NDBhMGYsIDB4ZDQ2ZjA0MDYsIDB4YzM3MjE2MWQsIDB4Y2U3OTE4MTQsIDB4ZWQ0ODMyMmIsIDB4ZTA0MzNjMjIsIDB4Zjc1ZTJlMzksIDB4ZmE1NTIwMzAsIDB4YjcwMWVjOWEsIDB4YmEwYWUyOTMsIDB4YWQxN2YwODgsIDB4YTAxY2ZlODEsIDB4ODMyZGQ0YmUsIDB4OGUyNmRhYjcsIDB4OTkzYmM4YWMsIDB4OTQzMGM2YTUsIDB4ZGY1OTljZDIsIDB4ZDI1MjkyZGIsIDB4YzU0ZjgwYzAsIDB4Yzg0NDhlYzksIDB4ZWI3NWE0ZjYsIDB4ZTY3ZWFhZmYsIDB4ZjE2M2I4ZTQsIDB4ZmM2OGI2ZWQsIDB4NjdiMTBjMGEsIDB4NmFiYTAyMDMsIDB4N2RhNzEwMTgsIDB4NzBhYzFlMTEsIDB4NTM5ZDM0MmUsIDB4NWU5NjNhMjcsIDB4NDk4YjI4M2MsIDB4NDQ4MDI2MzUsIDB4MGZlOTdjNDIsIDB4MDJlMjcyNGIsIDB4MTVmZjYwNTAsIDB4MThmNDZlNTksIDB4M2JjNTQ0NjYsIDB4MzZjZTRhNmYsIDB4MjFkMzU4NzQsIDB4MmNkODU2N2QsIDB4MGM3YTM3YTEsIDB4MDE3MTM5YTgsIDB4MTY2YzJiYjMsIDB4MWI2NzI1YmEsIDB4Mzg1NjBmODUsIDB4MzU1ZDAxOGMsIDB4MjI0MDEzOTcsIDB4MmY0YjFkOWUsIDB4NjQyMjQ3ZTksIDB4NjkyOTQ5ZTAsIDB4N2UzNDViZmIsIDB4NzMzZjU1ZjIsIDB4NTAwZTdmY2QsIDB4NWQwNTcxYzQsIDB4NGExODYzZGYsIDB4NDcxMzZkZDYsIDB4ZGNjYWQ3MzEsIDB4ZDFjMWQ5MzgsIDB4YzZkY2NiMjMsIDB4Y2JkN2M1MmEsIDB4ZThlNmVmMTUsIDB4ZTVlZGUxMWMsIDB4ZjJmMGYzMDcsIDB4ZmZmYmZkMGUsIDB4YjQ5MmE3NzksIDB4Yjk5OWE5NzAsIDB4YWU4NGJiNmIsIDB4YTM4ZmI1NjIsIDB4ODBiZTlmNWQsIDB4OGRiNTkxNTQsIDB4OWFhODgzNGYsIDB4OTdhMzhkNDZdO1xuICAgIHZhciBVNCA9IFsweDAwMDAwMDAwLCAweDA5MGQwYjBlLCAweDEyMWExNjFjLCAweDFiMTcxZDEyLCAweDI0MzQyYzM4LCAweDJkMzkyNzM2LCAweDM2MmUzYTI0LCAweDNmMjMzMTJhLCAweDQ4Njg1ODcwLCAweDQxNjU1MzdlLCAweDVhNzI0ZTZjLCAweDUzN2Y0NTYyLCAweDZjNWM3NDQ4LCAweDY1NTE3ZjQ2LCAweDdlNDY2MjU0LCAweDc3NGI2OTVhLCAweDkwZDBiMGUwLCAweDk5ZGRiYmVlLCAweDgyY2FhNmZjLCAweDhiYzdhZGYyLCAweGI0ZTQ5Y2Q4LCAweGJkZTk5N2Q2LCAweGE2ZmU4YWM0LCAweGFmZjM4MWNhLCAweGQ4YjhlODkwLCAweGQxYjVlMzllLCAweGNhYTJmZThjLCAweGMzYWZmNTgyLCAweGZjOGNjNGE4LCAweGY1ODFjZmE2LCAweGVlOTZkMmI0LCAweGU3OWJkOWJhLCAweDNiYmI3YmRiLCAweDMyYjY3MGQ1LCAweDI5YTE2ZGM3LCAweDIwYWM2NmM5LCAweDFmOGY1N2UzLCAweDE2ODI1Y2VkLCAweDBkOTU0MWZmLCAweDA0OTg0YWYxLCAweDczZDMyM2FiLCAweDdhZGUyOGE1LCAweDYxYzkzNWI3LCAweDY4YzQzZWI5LCAweDU3ZTcwZjkzLCAweDVlZWEwNDlkLCAweDQ1ZmQxOThmLCAweDRjZjAxMjgxLCAweGFiNmJjYjNiLCAweGEyNjZjMDM1LCAweGI5NzFkZDI3LCAweGIwN2NkNjI5LCAweDhmNWZlNzAzLCAweDg2NTJlYzBkLCAweDlkNDVmMTFmLCAweDk0NDhmYTExLCAweGUzMDM5MzRiLCAweGVhMGU5ODQ1LCAweGYxMTk4NTU3LCAweGY4MTQ4ZTU5LCAweGM3MzdiZjczLCAweGNlM2FiNDdkLCAweGQ1MmRhOTZmLCAweGRjMjBhMjYxLCAweDc2NmRmNmFkLCAweDdmNjBmZGEzLCAweDY0NzdlMGIxLCAweDZkN2FlYmJmLCAweDUyNTlkYTk1LCAweDViNTRkMTliLCAweDQwNDNjYzg5LCAweDQ5NGVjNzg3LCAweDNlMDVhZWRkLCAweDM3MDhhNWQzLCAweDJjMWZiOGMxLCAweDI1MTJiM2NmLCAweDFhMzE4MmU1LCAweDEzM2M4OWViLCAweDA4MmI5NGY5LCAweDAxMjY5ZmY3LCAweGU2YmQ0NjRkLCAweGVmYjA0ZDQzLCAweGY0YTc1MDUxLCAweGZkYWE1YjVmLCAweGMyODk2YTc1LCAweGNiODQ2MTdiLCAweGQwOTM3YzY5LCAweGQ5OWU3NzY3LCAweGFlZDUxZTNkLCAweGE3ZDgxNTMzLCAweGJjY2YwODIxLCAweGI1YzIwMzJmLCAweDhhZTEzMjA1LCAweDgzZWMzOTBiLCAweDk4ZmIyNDE5LCAweDkxZjYyZjE3LCAweDRkZDY4ZDc2LCAweDQ0ZGI4Njc4LCAweDVmY2M5YjZhLCAweDU2YzE5MDY0LCAweDY5ZTJhMTRlLCAweDYwZWZhYTQwLCAweDdiZjhiNzUyLCAweDcyZjViYzVjLCAweDA1YmVkNTA2LCAweDBjYjNkZTA4LCAweDE3YTRjMzFhLCAweDFlYTljODE0LCAweDIxOGFmOTNlLCAweDI4ODdmMjMwLCAweDMzOTBlZjIyLCAweDNhOWRlNDJjLCAweGRkMDYzZDk2LCAweGQ0MGIzNjk4LCAweGNmMWMyYjhhLCAweGM2MTEyMDg0LCAweGY5MzIxMWFlLCAweGYwM2YxYWEwLCAweGViMjgwN2IyLCAweGUyMjUwY2JjLCAweDk1NmU2NWU2LCAweDljNjM2ZWU4LCAweDg3NzQ3M2ZhLCAweDhlNzk3OGY0LCAweGIxNWE0OWRlLCAweGI4NTc0MmQwLCAweGEzNDA1ZmMyLCAweGFhNGQ1NGNjLCAweGVjZGFmNzQxLCAweGU1ZDdmYzRmLCAweGZlYzBlMTVkLCAweGY3Y2RlYTUzLCAweGM4ZWVkYjc5LCAweGMxZTNkMDc3LCAweGRhZjRjZDY1LCAweGQzZjljNjZiLCAweGE0YjJhZjMxLCAweGFkYmZhNDNmLCAweGI2YThiOTJkLCAweGJmYTViMjIzLCAweDgwODY4MzA5LCAweDg5OGI4ODA3LCAweDkyOWM5NTE1LCAweDliOTE5ZTFiLCAweDdjMGE0N2ExLCAweDc1MDc0Y2FmLCAweDZlMTA1MWJkLCAweDY3MWQ1YWIzLCAweDU4M2U2Yjk5LCAweDUxMzM2MDk3LCAweDRhMjQ3ZDg1LCAweDQzMjk3NjhiLCAweDM0NjIxZmQxLCAweDNkNmYxNGRmLCAweDI2NzgwOWNkLCAweDJmNzUwMmMzLCAweDEwNTYzM2U5LCAweDE5NWIzOGU3LCAweDAyNGMyNWY1LCAweDBiNDEyZWZiLCAweGQ3NjE4YzlhLCAweGRlNmM4Nzk0LCAweGM1N2I5YTg2LCAweGNjNzY5MTg4LCAweGYzNTVhMGEyLCAweGZhNThhYmFjLCAweGUxNGZiNmJlLCAweGU4NDJiZGIwLCAweDlmMDlkNGVhLCAweDk2MDRkZmU0LCAweDhkMTNjMmY2LCAweDg0MWVjOWY4LCAweGJiM2RmOGQyLCAweGIyMzBmM2RjLCAweGE5MjdlZWNlLCAweGEwMmFlNWMwLCAweDQ3YjEzYzdhLCAweDRlYmMzNzc0LCAweDU1YWIyYTY2LCAweDVjYTYyMTY4LCAweDYzODUxMDQyLCAweDZhODgxYjRjLCAweDcxOWYwNjVlLCAweDc4OTIwZDUwLCAweDBmZDk2NDBhLCAweDA2ZDQ2ZjA0LCAweDFkYzM3MjE2LCAweDE0Y2U3OTE4LCAweDJiZWQ0ODMyLCAweDIyZTA0MzNjLCAweDM5Zjc1ZTJlLCAweDMwZmE1NTIwLCAweDlhYjcwMWVjLCAweDkzYmEwYWUyLCAweDg4YWQxN2YwLCAweDgxYTAxY2ZlLCAweGJlODMyZGQ0LCAweGI3OGUyNmRhLCAweGFjOTkzYmM4LCAweGE1OTQzMGM2LCAweGQyZGY1OTljLCAweGRiZDI1MjkyLCAweGMwYzU0ZjgwLCAweGM5Yzg0NDhlLCAweGY2ZWI3NWE0LCAweGZmZTY3ZWFhLCAweGU0ZjE2M2I4LCAweGVkZmM2OGI2LCAweDBhNjdiMTBjLCAweDAzNmFiYTAyLCAweDE4N2RhNzEwLCAweDExNzBhYzFlLCAweDJlNTM5ZDM0LCAweDI3NWU5NjNhLCAweDNjNDk4YjI4LCAweDM1NDQ4MDI2LCAweDQyMGZlOTdjLCAweDRiMDJlMjcyLCAweDUwMTVmZjYwLCAweDU5MThmNDZlLCAweDY2M2JjNTQ0LCAweDZmMzZjZTRhLCAweDc0MjFkMzU4LCAweDdkMmNkODU2LCAweGExMGM3YTM3LCAweGE4MDE3MTM5LCAweGIzMTY2YzJiLCAweGJhMWI2NzI1LCAweDg1Mzg1NjBmLCAweDhjMzU1ZDAxLCAweDk3MjI0MDEzLCAweDllMmY0YjFkLCAweGU5NjQyMjQ3LCAweGUwNjkyOTQ5LCAweGZiN2UzNDViLCAweGYyNzMzZjU1LCAweGNkNTAwZTdmLCAweGM0NWQwNTcxLCAweGRmNGExODYzLCAweGQ2NDcxMzZkLCAweDMxZGNjYWQ3LCAweDM4ZDFjMWQ5LCAweDIzYzZkY2NiLCAweDJhY2JkN2M1LCAweDE1ZThlNmVmLCAweDFjZTVlZGUxLCAweDA3ZjJmMGYzLCAweDBlZmZmYmZkLCAweDc5YjQ5MmE3LCAweDcwYjk5OWE5LCAweDZiYWU4NGJiLCAweDYyYTM4ZmI1LCAweDVkODBiZTlmLCAweDU0OGRiNTkxLCAweDRmOWFhODgzLCAweDQ2OTdhMzhkXTtcblxuICAgIGZ1bmN0aW9uIGNvbnZlcnRUb0ludDMyKGJ5dGVzKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBieXRlcy5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goXG4gICAgICAgICAgICAgICAgKGJ5dGVzW2kgICAgXSA8PCAyNCkgfFxuICAgICAgICAgICAgICAgIChieXRlc1tpICsgMV0gPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAoYnl0ZXNbaSArIDJdIDw8ICA4KSB8XG4gICAgICAgICAgICAgICAgIGJ5dGVzW2kgKyAzXVxuICAgICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIHZhciBBRVMgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIEFFUykpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsICdrZXknLCB7XG4gICAgICAgICAgICB2YWx1ZTogY29lcmNlQXJyYXkoa2V5LCB0cnVlKVxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLl9wcmVwYXJlKCk7XG4gICAgfVxuXG5cbiAgICBBRVMucHJvdG90eXBlLl9wcmVwYXJlID0gZnVuY3Rpb24oKSB7XG5cbiAgICAgICAgdmFyIHJvdW5kcyA9IG51bWJlck9mUm91bmRzW3RoaXMua2V5Lmxlbmd0aF07XG4gICAgICAgIGlmIChyb3VuZHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGtleSBzaXplIChtdXN0IGJlIDE2LCAyNCBvciAzMiBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGVuY3J5cHRpb24gcm91bmQga2V5c1xuICAgICAgICB0aGlzLl9LZSA9IFtdO1xuXG4gICAgICAgIC8vIGRlY3J5cHRpb24gcm91bmQga2V5c1xuICAgICAgICB0aGlzLl9LZCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDw9IHJvdW5kczsgaSsrKSB7XG4gICAgICAgICAgICB0aGlzLl9LZS5wdXNoKFswLCAwLCAwLCAwXSk7XG4gICAgICAgICAgICB0aGlzLl9LZC5wdXNoKFswLCAwLCAwLCAwXSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcm91bmRLZXlDb3VudCA9IChyb3VuZHMgKyAxKSAqIDQ7XG4gICAgICAgIHZhciBLQyA9IHRoaXMua2V5Lmxlbmd0aCAvIDQ7XG5cbiAgICAgICAgLy8gY29udmVydCB0aGUga2V5IGludG8gaW50c1xuICAgICAgICB2YXIgdGsgPSBjb252ZXJ0VG9JbnQzMih0aGlzLmtleSk7XG5cbiAgICAgICAgLy8gY29weSB2YWx1ZXMgaW50byByb3VuZCBrZXkgYXJyYXlzXG4gICAgICAgIHZhciBpbmRleDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBLQzsgaSsrKSB7XG4gICAgICAgICAgICBpbmRleCA9IGkgPj4gMjtcbiAgICAgICAgICAgIHRoaXMuX0tlW2luZGV4XVtpICUgNF0gPSB0a1tpXTtcbiAgICAgICAgICAgIHRoaXMuX0tkW3JvdW5kcyAtIGluZGV4XVtpICUgNF0gPSB0a1tpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGtleSBleHBhbnNpb24gKGZpcHMtMTk3IHNlY3Rpb24gNS4yKVxuICAgICAgICB2YXIgcmNvbnBvaW50ZXIgPSAwO1xuICAgICAgICB2YXIgdCA9IEtDLCB0dDtcbiAgICAgICAgd2hpbGUgKHQgPCByb3VuZEtleUNvdW50KSB7XG4gICAgICAgICAgICB0dCA9IHRrW0tDIC0gMV07XG4gICAgICAgICAgICB0a1swXSBePSAoKFNbKHR0ID4+IDE2KSAmIDB4RkZdIDw8IDI0KSBeXG4gICAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+ICA4KSAmIDB4RkZdIDw8IDE2KSBeXG4gICAgICAgICAgICAgICAgICAgICAgKFNbIHR0ICAgICAgICAmIDB4RkZdIDw8ICA4KSBeXG4gICAgICAgICAgICAgICAgICAgICAgIFNbKHR0ID4+IDI0KSAmIDB4RkZdICAgICAgICBeXG4gICAgICAgICAgICAgICAgICAgICAgKHJjb25bcmNvbnBvaW50ZXJdIDw8IDI0KSk7XG4gICAgICAgICAgICByY29ucG9pbnRlciArPSAxO1xuXG4gICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIChmb3Igbm9uLTI1NiBiaXQpXG4gICAgICAgICAgICBpZiAoS0MgIT0gOCkge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgS0M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBrZXkgZXhwYW5zaW9uIGZvciAyNTYtYml0IGtleXMgaXMgXCJzbGlnaHRseSBkaWZmZXJlbnRcIiAoZmlwcy0xOTcpXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgKEtDIC8gMik7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHR0ID0gdGtbKEtDIC8gMikgLSAxXTtcblxuICAgICAgICAgICAgICAgIHRrW0tDIC8gMl0gXj0gKFNbIHR0ICAgICAgICAmIDB4RkZdICAgICAgICBeXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoU1sodHQgPj4gIDgpICYgMHhGRl0gPDwgIDgpIF5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIChTWyh0dCA+PiAxNikgJiAweEZGXSA8PCAxNikgXlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKFNbKHR0ID4+IDI0KSAmIDB4RkZdIDw8IDI0KSk7XG5cbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gKEtDIC8gMikgKyAxOyBpIDwgS0M7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB0a1tpXSBePSB0a1tpIC0gMV07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBjb3B5IHZhbHVlcyBpbnRvIHJvdW5kIGtleSBhcnJheXNcbiAgICAgICAgICAgIHZhciBpID0gMCwgciwgYztcbiAgICAgICAgICAgIHdoaWxlIChpIDwgS0MgJiYgdCA8IHJvdW5kS2V5Q291bnQpIHtcbiAgICAgICAgICAgICAgICByID0gdCA+PiAyO1xuICAgICAgICAgICAgICAgIGMgPSB0ICUgNDtcbiAgICAgICAgICAgICAgICB0aGlzLl9LZVtyXVtjXSA9IHRrW2ldO1xuICAgICAgICAgICAgICAgIHRoaXMuX0tkW3JvdW5kcyAtIHJdW2NdID0gdGtbaSsrXTtcbiAgICAgICAgICAgICAgICB0Kys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBpbnZlcnNlLWNpcGhlci1pZnkgdGhlIGRlY3J5cHRpb24gcm91bmQga2V5IChmaXBzLTE5NyBzZWN0aW9uIDUuMylcbiAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgYyA9IDA7IGMgPCA0OyBjKyspIHtcbiAgICAgICAgICAgICAgICB0dCA9IHRoaXMuX0tkW3JdW2NdO1xuICAgICAgICAgICAgICAgIHRoaXMuX0tkW3JdW2NdID0gKFUxWyh0dCA+PiAyNCkgJiAweEZGXSBeXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVTJbKHR0ID4+IDE2KSAmIDB4RkZdIF5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBVM1sodHQgPj4gIDgpICYgMHhGRl0gXlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFU0WyB0dCAgICAgICAgJiAweEZGXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBBRVMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcbiAgICAgICAgaWYgKHBsYWludGV4dC5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSAxNiBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3VuZHMgPSB0aGlzLl9LZS5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgYSA9IFswLCAwLCAwLCAwXTtcblxuICAgICAgICAvLyBjb252ZXJ0IHBsYWludGV4dCB0byAoaW50cyBeIGtleSlcbiAgICAgICAgdmFyIHQgPSBjb252ZXJ0VG9JbnQzMihwbGFpbnRleHQpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdFtpXSBePSB0aGlzLl9LZVswXVtpXTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFwcGx5IHJvdW5kIHRyYW5zZm9ybXNcbiAgICAgICAgZm9yICh2YXIgciA9IDE7IHIgPCByb3VuZHM7IHIrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgICAgICBhW2ldID0gKFQxWyh0WyBpICAgICAgICAgXSA+PiAyNCkgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgICAgICBUMlsodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICAgICAgVDNbKHRbKGkgKyAyKSAlIDRdID4+ICA4KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgICAgIFQ0WyB0WyhpICsgMykgJSA0XSAgICAgICAgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9LZVtyXVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0ID0gYS5zbGljZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlIGxhc3Qgcm91bmQgaXMgc3BlY2lhbFxuICAgICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlQXJyYXkoMTYpLCB0dDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHR0ID0gdGhpcy5fS2Vbcm91bmRzXVtpXTtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSAgICBdID0gKFNbKHRbIGkgICAgICAgICBdID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU1sodFsoaSArIDEpICUgNF0gPj4gMTYpICYgMHhmZl0gXiAodHQgPj4gMTYpKSAmIDB4ZmY7XG4gICAgICAgICAgICByZXN1bHRbNCAqIGkgKyAyXSA9IChTWyh0WyhpICsgMikgJSA0XSA+PiAgOCkgJiAweGZmXSBeICh0dCA+PiAgOCkpICYgMHhmZjtcbiAgICAgICAgICAgIHJlc3VsdFs0ICogaSArIDNdID0gKFNbIHRbKGkgKyAzKSAlIDRdICAgICAgICAmIDB4ZmZdIF4gIHR0ICAgICAgICkgJiAweGZmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBBRVMucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGlmIChjaXBoZXJ0ZXh0Lmxlbmd0aCAhPSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSAxNiBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciByb3VuZHMgPSB0aGlzLl9LZC5sZW5ndGggLSAxO1xuICAgICAgICB2YXIgYSA9IFswLCAwLCAwLCAwXTtcblxuICAgICAgICAvLyBjb252ZXJ0IHBsYWludGV4dCB0byAoaW50cyBeIGtleSlcbiAgICAgICAgdmFyIHQgPSBjb252ZXJ0VG9JbnQzMihjaXBoZXJ0ZXh0KTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcbiAgICAgICAgICAgIHRbaV0gXj0gdGhpcy5fS2RbMF1baV07XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhcHBseSByb3VuZCB0cmFuc2Zvcm1zXG4gICAgICAgIGZvciAodmFyIHIgPSAxOyByIDwgcm91bmRzOyByKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYVtpXSA9IChUNVsodFsgaSAgICAgICAgICBdID4+IDI0KSAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgICAgIFQ2Wyh0WyhpICsgMykgJSA0XSA+PiAxNikgJiAweGZmXSBeXG4gICAgICAgICAgICAgICAgICAgICAgICBUN1sodFsoaSArIDIpICUgNF0gPj4gIDgpICYgMHhmZl0gXlxuICAgICAgICAgICAgICAgICAgICAgICAgVDhbIHRbKGkgKyAxKSAlIDRdICAgICAgICAmIDB4ZmZdIF5cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX0tkW3JdW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHQgPSBhLnNsaWNlKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyB0aGUgbGFzdCByb3VuZCBpcyBzcGVjaWFsXG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVBcnJheSgxNiksIHR0O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuICAgICAgICAgICAgdHQgPSB0aGlzLl9LZFtyb3VuZHNdW2ldO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICAgIF0gPSAoU2lbKHRbIGkgICAgICAgICBdID4+IDI0KSAmIDB4ZmZdIF4gKHR0ID4+IDI0KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMV0gPSAoU2lbKHRbKGkgKyAzKSAlIDRdID4+IDE2KSAmIDB4ZmZdIF4gKHR0ID4+IDE2KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgMl0gPSAoU2lbKHRbKGkgKyAyKSAlIDRdID4+ICA4KSAmIDB4ZmZdIF4gKHR0ID4+ICA4KSkgJiAweGZmO1xuICAgICAgICAgICAgcmVzdWx0WzQgKiBpICsgM10gPSAoU2lbIHRbKGkgKyAxKSAlIDRdICAgICAgICAmIDB4ZmZdIF4gIHR0ICAgICAgICkgJiAweGZmO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBNb2RlIE9mIE9wZXJhdGlvbiAtIEVsZWN0b25pYyBDb2RlYm9vayAoRUNCKVxuICAgICAqL1xuICAgIHZhciBNb2RlT2ZPcGVyYXRpb25FQ0IgPSBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vZGVPZk9wZXJhdGlvbkVDQikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiRWxlY3Ryb25pYyBDb2RlIEJsb2NrXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiZWNiXCI7XG5cbiAgICAgICAgdGhpcy5fYWVzID0gbmV3IEFFUyhrZXkpO1xuICAgIH1cblxuICAgIE1vZGVPZk9wZXJhdGlvbkVDQi5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uKHBsYWludGV4dCkge1xuICAgICAgICBwbGFpbnRleHQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQpO1xuXG4gICAgICAgIGlmICgocGxhaW50ZXh0Lmxlbmd0aCAlIDE2KSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIHBsYWludGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBjcmVhdGVBcnJheShwbGFpbnRleHQubGVuZ3RoKTtcbiAgICAgICAgdmFyIGJsb2NrID0gY3JlYXRlQXJyYXkoMTYpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSAxNikge1xuICAgICAgICAgICAgY29weUFycmF5KHBsYWludGV4dCwgYmxvY2ssIDAsIGksIGkgKyAxNik7XG4gICAgICAgICAgICBibG9jayA9IHRoaXMuX2Flcy5lbmNyeXB0KGJsb2NrKTtcbiAgICAgICAgICAgIGNvcHlBcnJheShibG9jaywgY2lwaGVydGV4dCwgaSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcbiAgICB9XG5cbiAgICBNb2RlT2ZPcGVyYXRpb25FQ0IucHJvdG90eXBlLmRlY3J5cHQgPSBmdW5jdGlvbihjaXBoZXJ0ZXh0KSB7XG4gICAgICAgIGNpcGhlcnRleHQgPSBjb2VyY2VBcnJheShjaXBoZXJ0ZXh0KTtcblxuICAgICAgICBpZiAoKGNpcGhlcnRleHQubGVuZ3RoICUgMTYpICE9PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY2lwaGVydGV4dCBzaXplIChtdXN0IGJlIG11bHRpcGxlIG9mIDE2IGJ5dGVzKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHBsYWludGV4dCA9IGNyZWF0ZUFycmF5KGNpcGhlcnRleHQubGVuZ3RoKTtcbiAgICAgICAgdmFyIGJsb2NrID0gY3JlYXRlQXJyYXkoMTYpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2lwaGVydGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgIGNvcHlBcnJheShjaXBoZXJ0ZXh0LCBibG9jaywgMCwgaSwgaSArIDE2KTtcbiAgICAgICAgICAgIGJsb2NrID0gdGhpcy5fYWVzLmRlY3J5cHQoYmxvY2spO1xuICAgICAgICAgICAgY29weUFycmF5KGJsb2NrLCBwbGFpbnRleHQsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBNb2RlIE9mIE9wZXJhdGlvbiAtIENpcGhlciBCbG9jayBDaGFpbmluZyAoQ0JDKVxuICAgICAqL1xuICAgIHZhciBNb2RlT2ZPcGVyYXRpb25DQkMgPSBmdW5jdGlvbihrZXksIGl2KSB7XG4gICAgICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBNb2RlT2ZPcGVyYXRpb25DQkMpKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcignQUVTIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuZGVzY3JpcHRpb24gPSBcIkNpcGhlciBCbG9jayBDaGFpbmluZ1wiO1xuICAgICAgICB0aGlzLm5hbWUgPSBcImNiY1wiO1xuXG4gICAgICAgIGlmICghaXYpIHtcbiAgICAgICAgICAgIGl2ID0gY3JlYXRlQXJyYXkoMTYpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoaXYubGVuZ3RoICE9IDE2KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgaW5pdGlhbGF0aW9uIHZlY3RvciBzaXplIChtdXN0IGJlIDE2IGJ5dGVzKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5fbGFzdENpcGhlcmJsb2NrID0gY29lcmNlQXJyYXkoaXYsIHRydWUpO1xuXG4gICAgICAgIHRoaXMuX2FlcyA9IG5ldyBBRVMoa2V5KTtcbiAgICB9XG5cbiAgICBNb2RlT2ZPcGVyYXRpb25DQkMucHJvdG90eXBlLmVuY3J5cHQgPSBmdW5jdGlvbihwbGFpbnRleHQpIHtcbiAgICAgICAgcGxhaW50ZXh0ID0gY29lcmNlQXJyYXkocGxhaW50ZXh0KTtcblxuICAgICAgICBpZiAoKHBsYWludGV4dC5sZW5ndGggJSAxNikgIT09IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gY3JlYXRlQXJyYXkocGxhaW50ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHZhciBibG9jayA9IGNyZWF0ZUFycmF5KDE2KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBsYWludGV4dC5sZW5ndGg7IGkgKz0gMTYpIHtcbiAgICAgICAgICAgIGNvcHlBcnJheShwbGFpbnRleHQsIGJsb2NrLCAwLCBpLCBpICsgMTYpO1xuXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IDE2OyBqKyspIHtcbiAgICAgICAgICAgICAgICBibG9ja1tqXSBePSB0aGlzLl9sYXN0Q2lwaGVyYmxvY2tbal07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHRoaXMuX2xhc3RDaXBoZXJibG9jayA9IHRoaXMuX2Flcy5lbmNyeXB0KGJsb2NrKTtcbiAgICAgICAgICAgIGNvcHlBcnJheSh0aGlzLl9sYXN0Q2lwaGVyYmxvY2ssIGNpcGhlcnRleHQsIGkpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNpcGhlcnRleHQ7XG4gICAgfVxuXG4gICAgTW9kZU9mT3BlcmF0aW9uQ0JDLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24oY2lwaGVydGV4dCkge1xuICAgICAgICBjaXBoZXJ0ZXh0ID0gY29lcmNlQXJyYXkoY2lwaGVydGV4dCk7XG5cbiAgICAgICAgaWYgKChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIDE2KSAhPT0gMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNpcGhlcnRleHQgc2l6ZSAobXVzdCBiZSBtdWx0aXBsZSBvZiAxNiBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBwbGFpbnRleHQgPSBjcmVhdGVBcnJheShjaXBoZXJ0ZXh0Lmxlbmd0aCk7XG4gICAgICAgIHZhciBibG9jayA9IGNyZWF0ZUFycmF5KDE2KTtcblxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNpcGhlcnRleHQubGVuZ3RoOyBpICs9IDE2KSB7XG4gICAgICAgICAgICBjb3B5QXJyYXkoY2lwaGVydGV4dCwgYmxvY2ssIDAsIGksIGkgKyAxNik7XG4gICAgICAgICAgICBibG9jayA9IHRoaXMuX2Flcy5kZWNyeXB0KGJsb2NrKTtcblxuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCAxNjsgaisrKSB7XG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0W2kgKyBqXSA9IGJsb2NrW2pdIF4gdGhpcy5fbGFzdENpcGhlcmJsb2NrW2pdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBjb3B5QXJyYXkoY2lwaGVydGV4dCwgdGhpcy5fbGFzdENpcGhlcmJsb2NrLCAwLCBpLCBpICsgMTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcbiAgICB9XG5cblxuICAgIC8qKlxuICAgICAqICBNb2RlIE9mIE9wZXJhdGlvbiAtIENpcGhlciBGZWVkYmFjayAoQ0ZCKVxuICAgICAqL1xuICAgIHZhciBNb2RlT2ZPcGVyYXRpb25DRkIgPSBmdW5jdGlvbihrZXksIGl2LCBzZWdtZW50U2l6ZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uQ0ZCKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJDaXBoZXIgRmVlZGJhY2tcIjtcbiAgICAgICAgdGhpcy5uYW1lID0gXCJjZmJcIjtcblxuICAgICAgICBpZiAoIWl2KSB7XG4gICAgICAgICAgICBpdiA9IGNyZWF0ZUFycmF5KDE2KTtcblxuICAgICAgICB9IGVsc2UgaWYgKGl2Lmxlbmd0aCAhPSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGluaXRpYWxhdGlvbiB2ZWN0b3Igc2l6ZSAobXVzdCBiZSAxNiBzaXplKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKCFzZWdtZW50U2l6ZSkgeyBzZWdtZW50U2l6ZSA9IDE7IH1cblxuICAgICAgICB0aGlzLnNlZ21lbnRTaXplID0gc2VnbWVudFNpemU7XG5cbiAgICAgICAgdGhpcy5fc2hpZnRSZWdpc3RlciA9IGNvZXJjZUFycmF5KGl2LCB0cnVlKTtcblxuICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG4gICAgfVxuXG4gICAgTW9kZU9mT3BlcmF0aW9uQ0ZCLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0KSB7XG4gICAgICAgIGlmICgocGxhaW50ZXh0Lmxlbmd0aCAlIHRoaXMuc2VnbWVudFNpemUpICE9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBwbGFpbnRleHQgc2l6ZSAobXVzdCBiZSBzZWdtZW50U2l6ZSBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG4gICAgICAgIHZhciB4b3JTZWdtZW50O1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGVuY3J5cHRlZC5sZW5ndGg7IGkgKz0gdGhpcy5zZWdtZW50U2l6ZSkge1xuICAgICAgICAgICAgeG9yU2VnbWVudCA9IHRoaXMuX2Flcy5lbmNyeXB0KHRoaXMuX3NoaWZ0UmVnaXN0ZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aGlzLnNlZ21lbnRTaXplOyBqKyspIHtcbiAgICAgICAgICAgICAgICBlbmNyeXB0ZWRbaSArIGpdIF49IHhvclNlZ21lbnRbal07XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNoaWZ0IHRoZSByZWdpc3RlclxuICAgICAgICAgICAgY29weUFycmF5KHRoaXMuX3NoaWZ0UmVnaXN0ZXIsIHRoaXMuX3NoaWZ0UmVnaXN0ZXIsIDAsIHRoaXMuc2VnbWVudFNpemUpO1xuICAgICAgICAgICAgY29weUFycmF5KGVuY3J5cHRlZCwgdGhpcy5fc2hpZnRSZWdpc3RlciwgMTYgLSB0aGlzLnNlZ21lbnRTaXplLCBpLCBpICsgdGhpcy5zZWdtZW50U2l6ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xuICAgIH1cblxuICAgIE1vZGVPZk9wZXJhdGlvbkNGQi5wcm90b3R5cGUuZGVjcnlwdCA9IGZ1bmN0aW9uKGNpcGhlcnRleHQpIHtcbiAgICAgICAgaWYgKChjaXBoZXJ0ZXh0Lmxlbmd0aCAlIHRoaXMuc2VnbWVudFNpemUpICE9IDApIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBjaXBoZXJ0ZXh0IHNpemUgKG11c3QgYmUgc2VnbWVudFNpemUgYnl0ZXMpJyk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgcGxhaW50ZXh0ID0gY29lcmNlQXJyYXkoY2lwaGVydGV4dCwgdHJ1ZSk7XG5cbiAgICAgICAgdmFyIHhvclNlZ21lbnQ7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGxhaW50ZXh0Lmxlbmd0aDsgaSArPSB0aGlzLnNlZ21lbnRTaXplKSB7XG4gICAgICAgICAgICB4b3JTZWdtZW50ID0gdGhpcy5fYWVzLmVuY3J5cHQodGhpcy5fc2hpZnRSZWdpc3Rlcik7XG5cbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5zZWdtZW50U2l6ZTsgaisrKSB7XG4gICAgICAgICAgICAgICAgcGxhaW50ZXh0W2kgKyBqXSBePSB4b3JTZWdtZW50W2pdO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBTaGlmdCB0aGUgcmVnaXN0ZXJcbiAgICAgICAgICAgIGNvcHlBcnJheSh0aGlzLl9zaGlmdFJlZ2lzdGVyLCB0aGlzLl9zaGlmdFJlZ2lzdGVyLCAwLCB0aGlzLnNlZ21lbnRTaXplKTtcbiAgICAgICAgICAgIGNvcHlBcnJheShjaXBoZXJ0ZXh0LCB0aGlzLl9zaGlmdFJlZ2lzdGVyLCAxNiAtIHRoaXMuc2VnbWVudFNpemUsIGksIGkgKyB0aGlzLnNlZ21lbnRTaXplKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBwbGFpbnRleHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogIE1vZGUgT2YgT3BlcmF0aW9uIC0gT3V0cHV0IEZlZWRiYWNrIChPRkIpXG4gICAgICovXG4gICAgdmFyIE1vZGVPZk9wZXJhdGlvbk9GQiA9IGZ1bmN0aW9uKGtleSwgaXYpIHtcbiAgICAgICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIE1vZGVPZk9wZXJhdGlvbk9GQikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdBRVMgbXVzdCBiZSBpbnN0YW5pdGF0ZWQgd2l0aCBgbmV3YCcpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5kZXNjcmlwdGlvbiA9IFwiT3V0cHV0IEZlZWRiYWNrXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwib2ZiXCI7XG5cbiAgICAgICAgaWYgKCFpdikge1xuICAgICAgICAgICAgaXYgPSBjcmVhdGVBcnJheSgxNik7XG5cbiAgICAgICAgfSBlbHNlIGlmIChpdi5sZW5ndGggIT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBpbml0aWFsYXRpb24gdmVjdG9yIHNpemUgKG11c3QgYmUgMTYgYnl0ZXMpJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLl9sYXN0UHJlY2lwaGVyID0gY29lcmNlQXJyYXkoaXYsIHRydWUpO1xuICAgICAgICB0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXggPSAxNjtcblxuICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG4gICAgfVxuXG4gICAgTW9kZU9mT3BlcmF0aW9uT0ZCLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0KSB7XG4gICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jcnlwdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fbGFzdFByZWNpcGhlckluZGV4ID09PSAxNikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQcmVjaXBoZXIgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9sYXN0UHJlY2lwaGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9sYXN0UHJlY2lwaGVySW5kZXggPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZW5jcnlwdGVkW2ldIF49IHRoaXMuX2xhc3RQcmVjaXBoZXJbdGhpcy5fbGFzdFByZWNpcGhlckluZGV4KytdO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVuY3J5cHRlZDtcbiAgICB9XG5cbiAgICAvLyBEZWNyeXB0aW9uIGlzIHN5bWV0cmljXG4gICAgTW9kZU9mT3BlcmF0aW9uT0ZCLnByb3RvdHlwZS5kZWNyeXB0ID0gTW9kZU9mT3BlcmF0aW9uT0ZCLnByb3RvdHlwZS5lbmNyeXB0O1xuXG5cbiAgICAvKipcbiAgICAgKiAgQ291bnRlciBvYmplY3QgZm9yIENUUiBjb21tb24gbW9kZSBvZiBvcGVyYXRpb25cbiAgICAgKi9cbiAgICB2YXIgQ291bnRlciA9IGZ1bmN0aW9uKGluaXRpYWxWYWx1ZSkge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgQ291bnRlcikpIHtcbiAgICAgICAgICAgIHRocm93IEVycm9yKCdDb3VudGVyIG11c3QgYmUgaW5zdGFuaXRhdGVkIHdpdGggYG5ld2AnKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdlIGFsbG93IDAsIGJ1dCBhbnl0aGluZyBmYWxzZS1pc2ggdXNlcyB0aGUgZGVmYXVsdCAxXG4gICAgICAgIGlmIChpbml0aWFsVmFsdWUgIT09IDAgJiYgIWluaXRpYWxWYWx1ZSkgeyBpbml0aWFsVmFsdWUgPSAxOyB9XG5cbiAgICAgICAgaWYgKHR5cGVvZihpbml0aWFsVmFsdWUpID09PSAnbnVtYmVyJykge1xuICAgICAgICAgICAgdGhpcy5fY291bnRlciA9IGNyZWF0ZUFycmF5KDE2KTtcbiAgICAgICAgICAgIHRoaXMuc2V0VmFsdWUoaW5pdGlhbFZhbHVlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zZXRCeXRlcyhpbml0aWFsVmFsdWUpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgQ291bnRlci5wcm90b3R5cGUuc2V0VmFsdWUgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICBpZiAodHlwZW9mKHZhbHVlKSAhPT0gJ251bWJlcicgfHwgcGFyc2VJbnQodmFsdWUpICE9IHZhbHVlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ludmFsaWQgY291bnRlciB2YWx1ZSAobXVzdCBiZSBhbiBpbnRlZ2VyKScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAxNTsgaW5kZXggPj0gMDsgLS1pbmRleCkge1xuICAgICAgICAgICAgdGhpcy5fY291bnRlcltpbmRleF0gPSB2YWx1ZSAlIDI1NjtcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWUgPj4gODtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIENvdW50ZXIucHJvdG90eXBlLnNldEJ5dGVzID0gZnVuY3Rpb24oYnl0ZXMpIHtcbiAgICAgICAgYnl0ZXMgPSBjb2VyY2VBcnJheShieXRlcywgdHJ1ZSk7XG5cbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPSAxNikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGNvdW50ZXIgYnl0ZXMgc2l6ZSAobXVzdCBiZSAxNiBieXRlcyknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSBieXRlcztcbiAgICB9O1xuXG4gICAgQ291bnRlci5wcm90b3R5cGUuaW5jcmVtZW50ID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxNTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jb3VudGVyW2ldID09PSAyNTUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3VudGVyW2ldID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fY291bnRlcltpXSsrO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG5cbiAgICAvKipcbiAgICAgKiAgTW9kZSBPZiBPcGVyYXRpb24gLSBDb3VudGVyIChDVFIpXG4gICAgICovXG4gICAgdmFyIE1vZGVPZk9wZXJhdGlvbkNUUiA9IGZ1bmN0aW9uKGtleSwgY291bnRlcikge1xuICAgICAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgTW9kZU9mT3BlcmF0aW9uQ1RSKSkge1xuICAgICAgICAgICAgdGhyb3cgRXJyb3IoJ0FFUyBtdXN0IGJlIGluc3Rhbml0YXRlZCB3aXRoIGBuZXdgJyk7XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmRlc2NyaXB0aW9uID0gXCJDb3VudGVyXCI7XG4gICAgICAgIHRoaXMubmFtZSA9IFwiY3RyXCI7XG5cbiAgICAgICAgaWYgKCEoY291bnRlciBpbnN0YW5jZW9mIENvdW50ZXIpKSB7XG4gICAgICAgICAgICBjb3VudGVyID0gbmV3IENvdW50ZXIoY291bnRlcilcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2NvdW50ZXIgPSBjb3VudGVyO1xuXG4gICAgICAgIHRoaXMuX3JlbWFpbmluZ0NvdW50ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXggPSAxNjtcblxuICAgICAgICB0aGlzLl9hZXMgPSBuZXcgQUVTKGtleSk7XG4gICAgfVxuXG4gICAgTW9kZU9mT3BlcmF0aW9uQ1RSLnByb3RvdHlwZS5lbmNyeXB0ID0gZnVuY3Rpb24ocGxhaW50ZXh0KSB7XG4gICAgICAgIHZhciBlbmNyeXB0ZWQgPSBjb2VyY2VBcnJheShwbGFpbnRleHQsIHRydWUpO1xuXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZW5jcnlwdGVkLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcmVtYWluaW5nQ291bnRlckluZGV4ID09PSAxNikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlbWFpbmluZ0NvdW50ZXIgPSB0aGlzLl9hZXMuZW5jcnlwdCh0aGlzLl9jb3VudGVyLl9jb3VudGVyKTtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXggPSAwO1xuICAgICAgICAgICAgICAgIHRoaXMuX2NvdW50ZXIuaW5jcmVtZW50KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbmNyeXB0ZWRbaV0gXj0gdGhpcy5fcmVtYWluaW5nQ291bnRlclt0aGlzLl9yZW1haW5pbmdDb3VudGVySW5kZXgrK107XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZW5jcnlwdGVkO1xuICAgIH1cblxuICAgIC8vIERlY3J5cHRpb24gaXMgc3ltZXRyaWNcbiAgICBNb2RlT2ZPcGVyYXRpb25DVFIucHJvdG90eXBlLmRlY3J5cHQgPSBNb2RlT2ZPcGVyYXRpb25DVFIucHJvdG90eXBlLmVuY3J5cHQ7XG5cblxuICAgIC8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4gICAgLy8gUGFkZGluZ1xuXG4gICAgLy8gU2VlOmh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmMyMzE1XG4gICAgZnVuY3Rpb24gcGtjczdwYWQoZGF0YSkge1xuICAgICAgICBkYXRhID0gY29lcmNlQXJyYXkoZGF0YSwgdHJ1ZSk7XG4gICAgICAgIHZhciBwYWRkZXIgPSAxNiAtIChkYXRhLmxlbmd0aCAlIDE2KTtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGRhdGEubGVuZ3RoICsgcGFkZGVyKTtcbiAgICAgICAgY29weUFycmF5KGRhdGEsIHJlc3VsdCk7XG4gICAgICAgIGZvciAodmFyIGkgPSBkYXRhLmxlbmd0aDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0W2ldID0gcGFkZGVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcGtjczdzdHJpcChkYXRhKSB7XG4gICAgICAgIGRhdGEgPSBjb2VyY2VBcnJheShkYXRhLCB0cnVlKTtcbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgMTYpIHsgdGhyb3cgbmV3IEVycm9yKCdQS0NTIzcgaW52YWxpZCBsZW5ndGgnKTsgfVxuXG4gICAgICAgIHZhciBwYWRkZXIgPSBkYXRhW2RhdGEubGVuZ3RoIC0gMV07XG4gICAgICAgIGlmIChwYWRkZXIgPiAxNikgeyB0aHJvdyBuZXcgRXJyb3IoJ1BLQ1MjNyBwYWRkaW5nIGJ5dGUgb3V0IG9mIHJhbmdlJyk7IH1cblxuICAgICAgICB2YXIgbGVuZ3RoID0gZGF0YS5sZW5ndGggLSBwYWRkZXI7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcGFkZGVyOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChkYXRhW2xlbmd0aCArIGldICE9PSBwYWRkZXIpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BLQ1MjNyBpbnZhbGlkIHBhZGRpbmcgYnl0ZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHJlc3VsdCA9IGNyZWF0ZUFycmF5KGxlbmd0aCk7XG4gICAgICAgIGNvcHlBcnJheShkYXRhLCByZXN1bHQsIDAsIDAsIGxlbmd0aCk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbiAgICAvLyBFeHBvcnRpbmdcblxuXG4gICAgLy8gVGhlIGJsb2NrIGNpcGhlclxuICAgIHZhciBhZXNqcyA9IHtcbiAgICAgICAgQUVTOiBBRVMsXG4gICAgICAgIENvdW50ZXI6IENvdW50ZXIsXG5cbiAgICAgICAgTW9kZU9mT3BlcmF0aW9uOiB7XG4gICAgICAgICAgICBlY2I6IE1vZGVPZk9wZXJhdGlvbkVDQixcbiAgICAgICAgICAgIGNiYzogTW9kZU9mT3BlcmF0aW9uQ0JDLFxuICAgICAgICAgICAgY2ZiOiBNb2RlT2ZPcGVyYXRpb25DRkIsXG4gICAgICAgICAgICBvZmI6IE1vZGVPZk9wZXJhdGlvbk9GQixcbiAgICAgICAgICAgIGN0cjogTW9kZU9mT3BlcmF0aW9uQ1RSXG4gICAgICAgIH0sXG5cbiAgICAgICAgdXRpbHM6IHtcbiAgICAgICAgICAgIGhleDogY29udmVydEhleCxcbiAgICAgICAgICAgIHV0Zjg6IGNvbnZlcnRVdGY4XG4gICAgICAgIH0sXG5cbiAgICAgICAgcGFkZGluZzoge1xuICAgICAgICAgICAgcGtjczc6IHtcbiAgICAgICAgICAgICAgICBwYWQ6IHBrY3M3cGFkLFxuICAgICAgICAgICAgICAgIHN0cmlwOiBwa2NzN3N0cmlwXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG5cbiAgICAgICAgX2FycmF5VGVzdDoge1xuICAgICAgICAgICAgY29lcmNlQXJyYXk6IGNvZXJjZUFycmF5LFxuICAgICAgICAgICAgY3JlYXRlQXJyYXk6IGNyZWF0ZUFycmF5LFxuICAgICAgICAgICAgY29weUFycmF5OiBjb3B5QXJyYXksXG4gICAgICAgIH1cbiAgICB9O1xuXG5cbiAgICAvLyBub2RlLmpzXG4gICAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGFlc2pzXG5cbiAgICAvLyBSZXF1aXJlSlMvQU1EXG4gICAgLy8gaHR0cDovL3d3dy5yZXF1aXJlanMub3JnL2RvY3MvYXBpLmh0bWxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vYW1kanMvYW1kanMtYXBpL3dpa2kvQU1EXG4gICAgfSBlbHNlIGlmICh0eXBlb2YoZGVmaW5lKSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgICAgIGRlZmluZShhZXNqcyk7XG5cbiAgICAvLyBXZWIgQnJvd3NlcnNcbiAgICB9IGVsc2Uge1xuXG4gICAgICAgIC8vIElmIHRoZXJlIHdhcyBhbiBleGlzdGluZyBsaWJyYXJ5IGF0IFwiYWVzanNcIiBtYWtlIHN1cmUgaXQncyBzdGlsbCBhdmFpbGFibGVcbiAgICAgICAgaWYgKHJvb3QuYWVzanMpIHtcbiAgICAgICAgICAgIGFlc2pzLl9hZXNqcyA9IHJvb3QuYWVzanM7XG4gICAgICAgIH1cblxuICAgICAgICByb290LmFlc2pzID0gYWVzanM7XG4gICAgfVxuXG5cbn0pKHRoaXMpO1xuIiwiJ3VzZSBzdHJpY3QnXG52YXIgQUxQSEFCRVQgPSAncXB6cnk5eDhnZjJ0dmR3MHMzam41NGtoY2U2bXVhN2wnXG5cbi8vIHByZS1jb21wdXRlIGxvb2t1cCB0YWJsZVxudmFyIEFMUEhBQkVUX01BUCA9IHt9XG5mb3IgKHZhciB6ID0gMDsgeiA8IEFMUEhBQkVULmxlbmd0aDsgeisrKSB7XG4gIHZhciB4ID0gQUxQSEFCRVQuY2hhckF0KHopXG5cbiAgaWYgKEFMUEhBQkVUX01BUFt4XSAhPT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgVHlwZUVycm9yKHggKyAnIGlzIGFtYmlndW91cycpXG4gIEFMUEhBQkVUX01BUFt4XSA9IHpcbn1cblxuZnVuY3Rpb24gcG9seW1vZFN0ZXAgKHByZSkge1xuICB2YXIgYiA9IHByZSA+PiAyNVxuICByZXR1cm4gKChwcmUgJiAweDFGRkZGRkYpIDw8IDUpIF5cbiAgICAoLSgoYiA+PiAwKSAmIDEpICYgMHgzYjZhNTdiMikgXlxuICAgICgtKChiID4+IDEpICYgMSkgJiAweDI2NTA4ZTZkKSBeXG4gICAgKC0oKGIgPj4gMikgJiAxKSAmIDB4MWVhMTE5ZmEpIF5cbiAgICAoLSgoYiA+PiAzKSAmIDEpICYgMHgzZDQyMzNkZCkgXlxuICAgICgtKChiID4+IDQpICYgMSkgJiAweDJhMTQ2MmIzKVxufVxuXG5mdW5jdGlvbiBwcmVmaXhDaGsgKHByZWZpeCkge1xuICB2YXIgY2hrID0gMVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeC5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjID0gcHJlZml4LmNoYXJDb2RlQXQoaSlcbiAgICBpZiAoYyA8IDMzIHx8IGMgPiAxMjYpIHJldHVybiAnSW52YWxpZCBwcmVmaXggKCcgKyBwcmVmaXggKyAnKSdcblxuICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiAoYyA+PiA1KVxuICB9XG4gIGNoayA9IHBvbHltb2RTdGVwKGNoaylcblxuICBmb3IgKGkgPSAwOyBpIDwgcHJlZml4Lmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIHYgPSBwcmVmaXguY2hhckNvZGVBdChpKVxuICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiAodiAmIDB4MWYpXG4gIH1cbiAgcmV0dXJuIGNoa1xufVxuXG5mdW5jdGlvbiBlbmNvZGUgKHByZWZpeCwgd29yZHMsIExJTUlUKSB7XG4gIExJTUlUID0gTElNSVQgfHwgOTBcbiAgaWYgKChwcmVmaXgubGVuZ3RoICsgNyArIHdvcmRzLmxlbmd0aCkgPiBMSU1JVCkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhjZWVkcyBsZW5ndGggbGltaXQnKVxuXG4gIHByZWZpeCA9IHByZWZpeC50b0xvd2VyQ2FzZSgpXG5cbiAgLy8gZGV0ZXJtaW5lIGNoayBtb2RcbiAgdmFyIGNoayA9IHByZWZpeENoayhwcmVmaXgpXG4gIGlmICh0eXBlb2YgY2hrID09PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKGNoaylcblxuICB2YXIgcmVzdWx0ID0gcHJlZml4ICsgJzEnXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgeCA9IHdvcmRzW2ldXG4gICAgaWYgKCh4ID4+IDUpICE9PSAwKSB0aHJvdyBuZXcgRXJyb3IoJ05vbiA1LWJpdCB3b3JkJylcblxuICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiB4XG4gICAgcmVzdWx0ICs9IEFMUEhBQkVULmNoYXJBdCh4KVxuICB9XG5cbiAgZm9yIChpID0gMDsgaSA8IDY7ICsraSkge1xuICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaylcbiAgfVxuICBjaGsgXj0gMVxuXG4gIGZvciAoaSA9IDA7IGkgPCA2OyArK2kpIHtcbiAgICB2YXIgdiA9IChjaGsgPj4gKCg1IC0gaSkgKiA1KSkgJiAweDFmXG4gICAgcmVzdWx0ICs9IEFMUEhBQkVULmNoYXJBdCh2KVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBfX2RlY29kZSAoc3RyLCBMSU1JVCkge1xuICBMSU1JVCA9IExJTUlUIHx8IDkwXG4gIGlmIChzdHIubGVuZ3RoIDwgOCkgcmV0dXJuIHN0ciArICcgdG9vIHNob3J0J1xuICBpZiAoc3RyLmxlbmd0aCA+IExJTUlUKSByZXR1cm4gJ0V4Y2VlZHMgbGVuZ3RoIGxpbWl0J1xuXG4gIC8vIGRvbid0IGFsbG93IG1peGVkIGNhc2VcbiAgdmFyIGxvd2VyZWQgPSBzdHIudG9Mb3dlckNhc2UoKVxuICB2YXIgdXBwZXJlZCA9IHN0ci50b1VwcGVyQ2FzZSgpXG4gIGlmIChzdHIgIT09IGxvd2VyZWQgJiYgc3RyICE9PSB1cHBlcmVkKSByZXR1cm4gJ01peGVkLWNhc2Ugc3RyaW5nICcgKyBzdHJcbiAgc3RyID0gbG93ZXJlZFxuXG4gIHZhciBzcGxpdCA9IHN0ci5sYXN0SW5kZXhPZignMScpXG4gIGlmIChzcGxpdCA9PT0gLTEpIHJldHVybiAnTm8gc2VwYXJhdG9yIGNoYXJhY3RlciBmb3IgJyArIHN0clxuICBpZiAoc3BsaXQgPT09IDApIHJldHVybiAnTWlzc2luZyBwcmVmaXggZm9yICcgKyBzdHJcblxuICB2YXIgcHJlZml4ID0gc3RyLnNsaWNlKDAsIHNwbGl0KVxuICB2YXIgd29yZENoYXJzID0gc3RyLnNsaWNlKHNwbGl0ICsgMSlcbiAgaWYgKHdvcmRDaGFycy5sZW5ndGggPCA2KSByZXR1cm4gJ0RhdGEgdG9vIHNob3J0J1xuXG4gIHZhciBjaGsgPSBwcmVmaXhDaGsocHJlZml4KVxuICBpZiAodHlwZW9mIGNoayA9PT0gJ3N0cmluZycpIHJldHVybiBjaGtcblxuICB2YXIgd29yZHMgPSBbXVxuICBmb3IgKHZhciBpID0gMDsgaSA8IHdvcmRDaGFycy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjID0gd29yZENoYXJzLmNoYXJBdChpKVxuICAgIHZhciB2ID0gQUxQSEFCRVRfTUFQW2NdXG4gICAgaWYgKHYgPT09IHVuZGVmaW5lZCkgcmV0dXJuICdVbmtub3duIGNoYXJhY3RlciAnICsgY1xuICAgIGNoayA9IHBvbHltb2RTdGVwKGNoaykgXiB2XG5cbiAgICAvLyBub3QgaW4gdGhlIGNoZWNrc3VtP1xuICAgIGlmIChpICsgNiA+PSB3b3JkQ2hhcnMubGVuZ3RoKSBjb250aW51ZVxuICAgIHdvcmRzLnB1c2godilcbiAgfVxuXG4gIGlmIChjaGsgIT09IDEpIHJldHVybiAnSW52YWxpZCBjaGVja3N1bSBmb3IgJyArIHN0clxuICByZXR1cm4geyBwcmVmaXg6IHByZWZpeCwgd29yZHM6IHdvcmRzIH1cbn1cblxuZnVuY3Rpb24gZGVjb2RlVW5zYWZlICgpIHtcbiAgdmFyIHJlcyA9IF9fZGVjb2RlLmFwcGx5KG51bGwsIGFyZ3VtZW50cylcbiAgaWYgKHR5cGVvZiByZXMgPT09ICdvYmplY3QnKSByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGRlY29kZSAoc3RyKSB7XG4gIHZhciByZXMgPSBfX2RlY29kZS5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gIGlmICh0eXBlb2YgcmVzID09PSAnb2JqZWN0JykgcmV0dXJuIHJlc1xuXG4gIHRocm93IG5ldyBFcnJvcihyZXMpXG59XG5cbmZ1bmN0aW9uIGNvbnZlcnQgKGRhdGEsIGluQml0cywgb3V0Qml0cywgcGFkKSB7XG4gIHZhciB2YWx1ZSA9IDBcbiAgdmFyIGJpdHMgPSAwXG4gIHZhciBtYXhWID0gKDEgPDwgb3V0Qml0cykgLSAxXG5cbiAgdmFyIHJlc3VsdCA9IFtdXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7ICsraSkge1xuICAgIHZhbHVlID0gKHZhbHVlIDw8IGluQml0cykgfCBkYXRhW2ldXG4gICAgYml0cyArPSBpbkJpdHNcblxuICAgIHdoaWxlIChiaXRzID49IG91dEJpdHMpIHtcbiAgICAgIGJpdHMgLT0gb3V0Qml0c1xuICAgICAgcmVzdWx0LnB1c2goKHZhbHVlID4+IGJpdHMpICYgbWF4VilcbiAgICB9XG4gIH1cblxuICBpZiAocGFkKSB7XG4gICAgaWYgKGJpdHMgPiAwKSB7XG4gICAgICByZXN1bHQucHVzaCgodmFsdWUgPDwgKG91dEJpdHMgLSBiaXRzKSkgJiBtYXhWKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBpZiAoYml0cyA+PSBpbkJpdHMpIHJldHVybiAnRXhjZXNzIHBhZGRpbmcnXG4gICAgaWYgKCh2YWx1ZSA8PCAob3V0Qml0cyAtIGJpdHMpKSAmIG1heFYpIHJldHVybiAnTm9uLXplcm8gcGFkZGluZydcbiAgfVxuXG4gIHJldHVybiByZXN1bHRcbn1cblxuZnVuY3Rpb24gdG9Xb3Jkc1Vuc2FmZSAoYnl0ZXMpIHtcbiAgdmFyIHJlcyA9IGNvbnZlcnQoYnl0ZXMsIDgsIDUsIHRydWUpXG4gIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gdG9Xb3JkcyAoYnl0ZXMpIHtcbiAgdmFyIHJlcyA9IGNvbnZlcnQoYnl0ZXMsIDgsIDUsIHRydWUpXG4gIGlmIChBcnJheS5pc0FycmF5KHJlcykpIHJldHVybiByZXNcblxuICB0aHJvdyBuZXcgRXJyb3IocmVzKVxufVxuXG5mdW5jdGlvbiBmcm9tV29yZHNVbnNhZmUgKHdvcmRzKSB7XG4gIHZhciByZXMgPSBjb252ZXJ0KHdvcmRzLCA1LCA4LCBmYWxzZSlcbiAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSkgcmV0dXJuIHJlc1xufVxuXG5mdW5jdGlvbiBmcm9tV29yZHMgKHdvcmRzKSB7XG4gIHZhciByZXMgPSBjb252ZXJ0KHdvcmRzLCA1LCA4LCBmYWxzZSlcbiAgaWYgKEFycmF5LmlzQXJyYXkocmVzKSkgcmV0dXJuIHJlc1xuXG4gIHRocm93IG5ldyBFcnJvcihyZXMpXG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBkZWNvZGVVbnNhZmU6IGRlY29kZVVuc2FmZSxcbiAgZGVjb2RlOiBkZWNvZGUsXG4gIGVuY29kZTogZW5jb2RlLFxuICB0b1dvcmRzVW5zYWZlOiB0b1dvcmRzVW5zYWZlLFxuICB0b1dvcmRzOiB0b1dvcmRzLFxuICBmcm9tV29yZHNVbnNhZmU6IGZyb21Xb3Jkc1Vuc2FmZSxcbiAgZnJvbVdvcmRzOiBmcm9tV29yZHNcbn1cbiIsIihmdW5jdGlvbiAobW9kdWxlLCBleHBvcnRzKSB7XG4gICd1c2Ugc3RyaWN0JztcblxuICAvLyBVdGlsc1xuICBmdW5jdGlvbiBhc3NlcnQgKHZhbCwgbXNnKSB7XG4gICAgaWYgKCF2YWwpIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbiAgfVxuXG4gIC8vIENvdWxkIHVzZSBgaW5oZXJpdHNgIG1vZHVsZSwgYnV0IGRvbid0IHdhbnQgdG8gbW92ZSBmcm9tIHNpbmdsZSBmaWxlXG4gIC8vIGFyY2hpdGVjdHVyZSB5ZXQuXG4gIGZ1bmN0aW9uIGluaGVyaXRzIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvcjtcbiAgICB2YXIgVGVtcEN0b3IgPSBmdW5jdGlvbiAoKSB7fTtcbiAgICBUZW1wQ3Rvci5wcm90b3R5cGUgPSBzdXBlckN0b3IucHJvdG90eXBlO1xuICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKCk7XG4gICAgY3Rvci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBjdG9yO1xuICB9XG5cbiAgLy8gQk5cblxuICBmdW5jdGlvbiBCTiAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAoQk4uaXNCTihudW1iZXIpKSB7XG4gICAgICByZXR1cm4gbnVtYmVyO1xuICAgIH1cblxuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIHRoaXMud29yZHMgPSBudWxsO1xuICAgIHRoaXMubGVuZ3RoID0gMDtcblxuICAgIC8vIFJlZHVjdGlvbiBjb250ZXh0XG4gICAgdGhpcy5yZWQgPSBudWxsO1xuXG4gICAgaWYgKG51bWJlciAhPT0gbnVsbCkge1xuICAgICAgaWYgKGJhc2UgPT09ICdsZScgfHwgYmFzZSA9PT0gJ2JlJykge1xuICAgICAgICBlbmRpYW4gPSBiYXNlO1xuICAgICAgICBiYXNlID0gMTA7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuX2luaXQobnVtYmVyIHx8IDAsIGJhc2UgfHwgMTAsIGVuZGlhbiB8fCAnYmUnKTtcbiAgICB9XG4gIH1cbiAgaWYgKHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBCTjtcbiAgfSBlbHNlIHtcbiAgICBleHBvcnRzLkJOID0gQk47XG4gIH1cblxuICBCTi5CTiA9IEJOO1xuICBCTi53b3JkU2l6ZSA9IDI2O1xuXG4gIHZhciBCdWZmZXI7XG4gIHRyeSB7XG4gICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cuQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgQnVmZmVyID0gd2luZG93LkJ1ZmZlcjtcbiAgICB9IGVsc2Uge1xuICAgICAgQnVmZmVyID0gcmVxdWlyZSgnYnVmZmVyJykuQnVmZmVyO1xuICAgIH1cbiAgfSBjYXRjaCAoZSkge1xuICB9XG5cbiAgQk4uaXNCTiA9IGZ1bmN0aW9uIGlzQk4gKG51bSkge1xuICAgIGlmIChudW0gaW5zdGFuY2VvZiBCTikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bSAhPT0gbnVsbCAmJiB0eXBlb2YgbnVtID09PSAnb2JqZWN0JyAmJlxuICAgICAgbnVtLmNvbnN0cnVjdG9yLndvcmRTaXplID09PSBCTi53b3JkU2l6ZSAmJiBBcnJheS5pc0FycmF5KG51bS53b3Jkcyk7XG4gIH07XG5cbiAgQk4ubWF4ID0gZnVuY3Rpb24gbWF4IChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPiAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ubWluID0gZnVuY3Rpb24gbWluIChsZWZ0LCByaWdodCkge1xuICAgIGlmIChsZWZ0LmNtcChyaWdodCkgPCAwKSByZXR1cm4gbGVmdDtcbiAgICByZXR1cm4gcmlnaHQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gaW5pdCAobnVtYmVyLCBiYXNlLCBlbmRpYW4pIHtcbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ251bWJlcicpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0TnVtYmVyKG51bWJlciwgYmFzZSwgZW5kaWFuKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIG51bWJlciA9PT0gJ29iamVjdCcpIHtcbiAgICAgIHJldHVybiB0aGlzLl9pbml0QXJyYXkobnVtYmVyLCBiYXNlLCBlbmRpYW4pO1xuICAgIH1cblxuICAgIGlmIChiYXNlID09PSAnaGV4Jykge1xuICAgICAgYmFzZSA9IDE2O1xuICAgIH1cbiAgICBhc3NlcnQoYmFzZSA9PT0gKGJhc2UgfCAwKSAmJiBiYXNlID49IDIgJiYgYmFzZSA8PSAzNik7XG5cbiAgICBudW1iZXIgPSBudW1iZXIudG9TdHJpbmcoKS5yZXBsYWNlKC9cXHMrL2csICcnKTtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGlmIChudW1iZXJbMF0gPT09ICctJykge1xuICAgICAgc3RhcnQrKztcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA8IG51bWJlci5sZW5ndGgpIHtcbiAgICAgIGlmIChiYXNlID09PSAxNikge1xuICAgICAgICB0aGlzLl9wYXJzZUhleChudW1iZXIsIHN0YXJ0LCBlbmRpYW4pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5fcGFyc2VCYXNlKG51bWJlciwgYmFzZSwgc3RhcnQpO1xuICAgICAgICBpZiAoZW5kaWFuID09PSAnbGUnKSB7XG4gICAgICAgICAgdGhpcy5faW5pdEFycmF5KHRoaXMudG9BcnJheSgpLCBiYXNlLCBlbmRpYW4pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faW5pdE51bWJlciA9IGZ1bmN0aW9uIF9pbml0TnVtYmVyIChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIGlmIChudW1iZXIgPCAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIG51bWJlciA9IC1udW1iZXI7XG4gICAgfVxuICAgIGlmIChudW1iZXIgPCAweDQwMDAwMDApIHtcbiAgICAgIHRoaXMud29yZHMgPSBbIG51bWJlciAmIDB4M2ZmZmZmZiBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH0gZWxzZSBpZiAobnVtYmVyIDwgMHgxMDAwMDAwMDAwMDAwMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFtcbiAgICAgICAgbnVtYmVyICYgMHgzZmZmZmZmLFxuICAgICAgICAobnVtYmVyIC8gMHg0MDAwMDAwKSAmIDB4M2ZmZmZmZlxuICAgICAgXTtcbiAgICAgIHRoaXMubGVuZ3RoID0gMjtcbiAgICB9IGVsc2Uge1xuICAgICAgYXNzZXJ0KG51bWJlciA8IDB4MjAwMDAwMDAwMDAwMDApOyAvLyAyIF4gNTMgKHVuc2FmZSlcbiAgICAgIHRoaXMud29yZHMgPSBbXG4gICAgICAgIG51bWJlciAmIDB4M2ZmZmZmZixcbiAgICAgICAgKG51bWJlciAvIDB4NDAwMDAwMCkgJiAweDNmZmZmZmYsXG4gICAgICAgIDFcbiAgICAgIF07XG4gICAgICB0aGlzLmxlbmd0aCA9IDM7XG4gICAgfVxuXG4gICAgaWYgKGVuZGlhbiAhPT0gJ2xlJykgcmV0dXJuO1xuXG4gICAgLy8gUmV2ZXJzZSB0aGUgYnl0ZXNcbiAgICB0aGlzLl9pbml0QXJyYXkodGhpcy50b0FycmF5KCksIGJhc2UsIGVuZGlhbik7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pbml0QXJyYXkgPSBmdW5jdGlvbiBfaW5pdEFycmF5IChudW1iZXIsIGJhc2UsIGVuZGlhbikge1xuICAgIC8vIFBlcmhhcHMgYSBVaW50OEFycmF5XG4gICAgYXNzZXJ0KHR5cGVvZiBudW1iZXIubGVuZ3RoID09PSAnbnVtYmVyJyk7XG4gICAgaWYgKG51bWJlci5sZW5ndGggPD0gMCkge1xuICAgICAgdGhpcy53b3JkcyA9IFsgMCBdO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwobnVtYmVyLmxlbmd0aCAvIDMpO1xuICAgIHRoaXMud29yZHMgPSBuZXcgQXJyYXkodGhpcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IDA7XG4gICAgfVxuXG4gICAgdmFyIGosIHc7XG4gICAgdmFyIG9mZiA9IDA7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDEsIGogPSAwOyBpID49IDA7IGkgLT0gMykge1xuICAgICAgICB3ID0gbnVtYmVyW2ldIHwgKG51bWJlcltpIC0gMV0gPDwgOCkgfCAobnVtYmVyW2kgLSAyXSA8PCAxNik7XG4gICAgICAgIHRoaXMud29yZHNbal0gfD0gKHcgPDwgb2ZmKSAmIDB4M2ZmZmZmZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqICsgMV0gPSAodyA+Pj4gKDI2IC0gb2ZmKSkgJiAweDNmZmZmZmY7XG4gICAgICAgIG9mZiArPSAyNDtcbiAgICAgICAgaWYgKG9mZiA+PSAyNikge1xuICAgICAgICAgIG9mZiAtPSAyNjtcbiAgICAgICAgICBqKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVuZGlhbiA9PT0gJ2xlJykge1xuICAgICAgZm9yIChpID0gMCwgaiA9IDA7IGkgPCBudW1iZXIubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdyA9IG51bWJlcltpXSB8IChudW1iZXJbaSArIDFdIDw8IDgpIHwgKG51bWJlcltpICsgMl0gPDwgMTYpO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9ICh3IDw8IG9mZikgJiAweDNmZmZmZmY7XG4gICAgICAgIHRoaXMud29yZHNbaiArIDFdID0gKHcgPj4+ICgyNiAtIG9mZikpICYgMHgzZmZmZmZmO1xuICAgICAgICBvZmYgKz0gMjQ7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaisrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXg0Qml0cyAoc3RyaW5nLCBpbmRleCkge1xuICAgIHZhciBjID0gc3RyaW5nLmNoYXJDb2RlQXQoaW5kZXgpO1xuICAgIC8vICdBJyAtICdGJ1xuICAgIGlmIChjID49IDY1ICYmIGMgPD0gNzApIHtcbiAgICAgIHJldHVybiBjIC0gNTU7XG4gICAgLy8gJ2EnIC0gJ2YnXG4gICAgfSBlbHNlIGlmIChjID49IDk3ICYmIGMgPD0gMTAyKSB7XG4gICAgICByZXR1cm4gYyAtIDg3O1xuICAgIC8vICcwJyAtICc5J1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gKGMgLSA0OCkgJiAweGY7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGFyc2VIZXhCeXRlIChzdHJpbmcsIGxvd2VyQm91bmQsIGluZGV4KSB7XG4gICAgdmFyIHIgPSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXgpO1xuICAgIGlmIChpbmRleCAtIDEgPj0gbG93ZXJCb3VuZCkge1xuICAgICAgciB8PSBwYXJzZUhleDRCaXRzKHN0cmluZywgaW5kZXggLSAxKSA8PCA0O1xuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VIZXggPSBmdW5jdGlvbiBfcGFyc2VIZXggKG51bWJlciwgc3RhcnQsIGVuZGlhbikge1xuICAgIC8vIENyZWF0ZSBwb3NzaWJseSBiaWdnZXIgYXJyYXkgdG8gZW5zdXJlIHRoYXQgaXQgZml0cyB0aGUgbnVtYmVyXG4gICAgdGhpcy5sZW5ndGggPSBNYXRoLmNlaWwoKG51bWJlci5sZW5ndGggLSBzdGFydCkgLyA2KTtcbiAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgIH1cblxuICAgIC8vIDI0LWJpdHMgY2h1bmtzXG4gICAgdmFyIG9mZiA9IDA7XG4gICAgdmFyIGogPSAwO1xuXG4gICAgdmFyIHc7XG4gICAgaWYgKGVuZGlhbiA9PT0gJ2JlJykge1xuICAgICAgZm9yIChpID0gbnVtYmVyLmxlbmd0aCAtIDE7IGkgPj0gc3RhcnQ7IGkgLT0gMikge1xuICAgICAgICB3ID0gcGFyc2VIZXhCeXRlKG51bWJlciwgc3RhcnQsIGkpIDw8IG9mZjtcbiAgICAgICAgdGhpcy53b3Jkc1tqXSB8PSB3ICYgMHgzZmZmZmZmO1xuICAgICAgICBpZiAob2ZmID49IDE4KSB7XG4gICAgICAgICAgb2ZmIC09IDE4O1xuICAgICAgICAgIGogKz0gMTtcbiAgICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgPj4+IDI2O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG9mZiArPSA4O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJzZUxlbmd0aCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICAgIGZvciAoaSA9IHBhcnNlTGVuZ3RoICUgMiA9PT0gMCA/IHN0YXJ0ICsgMSA6IHN0YXJ0OyBpIDwgbnVtYmVyLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgICAgIHcgPSBwYXJzZUhleEJ5dGUobnVtYmVyLCBzdGFydCwgaSkgPDwgb2ZmO1xuICAgICAgICB0aGlzLndvcmRzW2pdIHw9IHcgJiAweDNmZmZmZmY7XG4gICAgICAgIGlmIChvZmYgPj0gMTgpIHtcbiAgICAgICAgICBvZmYgLT0gMTg7XG4gICAgICAgICAgaiArPSAxO1xuICAgICAgICAgIHRoaXMud29yZHNbal0gfD0gdyA+Pj4gMjY7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb2ZmICs9IDg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgZnVuY3Rpb24gcGFyc2VCYXNlIChzdHIsIHN0YXJ0LCBlbmQsIG11bCkge1xuICAgIHZhciByID0gMDtcbiAgICB2YXIgbGVuID0gTWF0aC5taW4oc3RyLmxlbmd0aCwgZW5kKTtcbiAgICBmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCBsZW47IGkrKykge1xuICAgICAgdmFyIGMgPSBzdHIuY2hhckNvZGVBdChpKSAtIDQ4O1xuXG4gICAgICByICo9IG11bDtcblxuICAgICAgLy8gJ2EnXG4gICAgICBpZiAoYyA+PSA0OSkge1xuICAgICAgICByICs9IGMgLSA0OSArIDB4YTtcblxuICAgICAgLy8gJ0EnXG4gICAgICB9IGVsc2UgaWYgKGMgPj0gMTcpIHtcbiAgICAgICAgciArPSBjIC0gMTcgKyAweGE7XG5cbiAgICAgIC8vICcwJyAtICc5J1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgciArPSBjO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcjtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5fcGFyc2VCYXNlID0gZnVuY3Rpb24gX3BhcnNlQmFzZSAobnVtYmVyLCBiYXNlLCBzdGFydCkge1xuICAgIC8vIEluaXRpYWxpemUgYXMgemVyb1xuICAgIHRoaXMud29yZHMgPSBbIDAgXTtcbiAgICB0aGlzLmxlbmd0aCA9IDE7XG5cbiAgICAvLyBGaW5kIGxlbmd0aCBvZiBsaW1iIGluIGJhc2VcbiAgICBmb3IgKHZhciBsaW1iTGVuID0gMCwgbGltYlBvdyA9IDE7IGxpbWJQb3cgPD0gMHgzZmZmZmZmOyBsaW1iUG93ICo9IGJhc2UpIHtcbiAgICAgIGxpbWJMZW4rKztcbiAgICB9XG4gICAgbGltYkxlbi0tO1xuICAgIGxpbWJQb3cgPSAobGltYlBvdyAvIGJhc2UpIHwgMDtcblxuICAgIHZhciB0b3RhbCA9IG51bWJlci5sZW5ndGggLSBzdGFydDtcbiAgICB2YXIgbW9kID0gdG90YWwgJSBsaW1iTGVuO1xuICAgIHZhciBlbmQgPSBNYXRoLm1pbih0b3RhbCwgdG90YWwgLSBtb2QpICsgc3RhcnQ7XG5cbiAgICB2YXIgd29yZCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgZW5kOyBpICs9IGxpbWJMZW4pIHtcbiAgICAgIHdvcmQgPSBwYXJzZUJhc2UobnVtYmVyLCBpLCBpICsgbGltYkxlbiwgYmFzZSk7XG5cbiAgICAgIHRoaXMuaW11bG4obGltYlBvdyk7XG4gICAgICBpZiAodGhpcy53b3Jkc1swXSArIHdvcmQgPCAweDQwMDAwMDApIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSArPSB3b3JkO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5faWFkZG4od29yZCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1vZCAhPT0gMCkge1xuICAgICAgdmFyIHBvdyA9IDE7XG4gICAgICB3b3JkID0gcGFyc2VCYXNlKG51bWJlciwgaSwgbnVtYmVyLmxlbmd0aCwgYmFzZSk7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBtb2Q7IGkrKykge1xuICAgICAgICBwb3cgKj0gYmFzZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5pbXVsbihwb3cpO1xuICAgICAgaWYgKHRoaXMud29yZHNbMF0gKyB3b3JkIDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIHRoaXMud29yZHNbMF0gKz0gd29yZDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuX2lhZGRuKHdvcmQpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuY29weSA9IGZ1bmN0aW9uIGNvcHkgKGRlc3QpIHtcbiAgICBkZXN0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGRlc3Qud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldO1xuICAgIH1cbiAgICBkZXN0Lmxlbmd0aCA9IHRoaXMubGVuZ3RoO1xuICAgIGRlc3QubmVnYXRpdmUgPSB0aGlzLm5lZ2F0aXZlO1xuICAgIGRlc3QucmVkID0gdGhpcy5yZWQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNsb25lID0gZnVuY3Rpb24gY2xvbmUgKCkge1xuICAgIHZhciByID0gbmV3IEJOKG51bGwpO1xuICAgIHRoaXMuY29weShyKTtcbiAgICByZXR1cm4gcjtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX2V4cGFuZCA9IGZ1bmN0aW9uIF9leHBhbmQgKHNpemUpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBzaXplKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gUmVtb3ZlIGxlYWRpbmcgYDBgIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdHJpcCA9IGZ1bmN0aW9uIHN0cmlwICgpIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPiAxICYmIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSA9PT0gMCkge1xuICAgICAgdGhpcy5sZW5ndGgtLTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9ub3JtU2lnbiA9IGZ1bmN0aW9uIF9ub3JtU2lnbiAoKSB7XG4gICAgLy8gLTAgPSAwXG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW5zcGVjdCA9IGZ1bmN0aW9uIGluc3BlY3QgKCkge1xuICAgIHJldHVybiAodGhpcy5yZWQgPyAnPEJOLVI6ICcgOiAnPEJOOiAnKSArIHRoaXMudG9TdHJpbmcoMTYpICsgJz4nO1xuICB9O1xuXG4gIC8qXG5cbiAgdmFyIHplcm9zID0gW107XG4gIHZhciBncm91cFNpemVzID0gW107XG4gIHZhciBncm91cEJhc2VzID0gW107XG5cbiAgdmFyIHMgPSAnJztcbiAgdmFyIGkgPSAtMTtcbiAgd2hpbGUgKCsraSA8IEJOLndvcmRTaXplKSB7XG4gICAgemVyb3NbaV0gPSBzO1xuICAgIHMgKz0gJzAnO1xuICB9XG4gIGdyb3VwU2l6ZXNbMF0gPSAwO1xuICBncm91cFNpemVzWzFdID0gMDtcbiAgZ3JvdXBCYXNlc1swXSA9IDA7XG4gIGdyb3VwQmFzZXNbMV0gPSAwO1xuICB2YXIgYmFzZSA9IDIgLSAxO1xuICB3aGlsZSAoKytiYXNlIDwgMzYgKyAxKSB7XG4gICAgdmFyIGdyb3VwU2l6ZSA9IDA7XG4gICAgdmFyIGdyb3VwQmFzZSA9IDE7XG4gICAgd2hpbGUgKGdyb3VwQmFzZSA8ICgxIDw8IEJOLndvcmRTaXplKSAvIGJhc2UpIHtcbiAgICAgIGdyb3VwQmFzZSAqPSBiYXNlO1xuICAgICAgZ3JvdXBTaXplICs9IDE7XG4gICAgfVxuICAgIGdyb3VwU2l6ZXNbYmFzZV0gPSBncm91cFNpemU7XG4gICAgZ3JvdXBCYXNlc1tiYXNlXSA9IGdyb3VwQmFzZTtcbiAgfVxuXG4gICovXG5cbiAgdmFyIHplcm9zID0gW1xuICAgICcnLFxuICAgICcwJyxcbiAgICAnMDAnLFxuICAgICcwMDAnLFxuICAgICcwMDAwJyxcbiAgICAnMDAwMDAnLFxuICAgICcwMDAwMDAnLFxuICAgICcwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJyxcbiAgICAnMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAnLFxuICAgICcwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwJ1xuICBdO1xuXG4gIHZhciBncm91cFNpemVzID0gW1xuICAgIDAsIDAsXG4gICAgMjUsIDE2LCAxMiwgMTEsIDEwLCA5LCA4LFxuICAgIDgsIDcsIDcsIDcsIDcsIDYsIDYsXG4gICAgNiwgNiwgNiwgNiwgNiwgNSwgNSxcbiAgICA1LCA1LCA1LCA1LCA1LCA1LCA1LFxuICAgIDUsIDUsIDUsIDUsIDUsIDUsIDVcbiAgXTtcblxuICB2YXIgZ3JvdXBCYXNlcyA9IFtcbiAgICAwLCAwLFxuICAgIDMzNTU0NDMyLCA0MzA0NjcyMSwgMTY3NzcyMTYsIDQ4ODI4MTI1LCA2MDQ2NjE3NiwgNDAzNTM2MDcsIDE2Nzc3MjE2LFxuICAgIDQzMDQ2NzIxLCAxMDAwMDAwMCwgMTk0ODcxNzEsIDM1ODMxODA4LCA2Mjc0ODUxNywgNzUyOTUzNiwgMTEzOTA2MjUsXG4gICAgMTY3NzcyMTYsIDI0MTM3NTY5LCAzNDAxMjIyNCwgNDcwNDU4ODEsIDY0MDAwMDAwLCA0MDg0MTAxLCA1MTUzNjMyLFxuICAgIDY0MzYzNDMsIDc5NjI2MjQsIDk3NjU2MjUsIDExODgxMzc2LCAxNDM0ODkwNywgMTcyMTAzNjgsIDIwNTExMTQ5LFxuICAgIDI0MzAwMDAwLCAyODYyOTE1MSwgMzM1NTQ0MzIsIDM5MTM1MzkzLCA0NTQzNTQyNCwgNTI1MjE4NzUsIDYwNDY2MTc2XG4gIF07XG5cbiAgQk4ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcgKGJhc2UsIHBhZGRpbmcpIHtcbiAgICBiYXNlID0gYmFzZSB8fCAxMDtcbiAgICBwYWRkaW5nID0gcGFkZGluZyB8IDAgfHwgMTtcblxuICAgIHZhciBvdXQ7XG4gICAgaWYgKGJhc2UgPT09IDE2IHx8IGJhc2UgPT09ICdoZXgnKSB7XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBvZmYgPSAwO1xuICAgICAgdmFyIGNhcnJ5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdyA9IHRoaXMud29yZHNbaV07XG4gICAgICAgIHZhciB3b3JkID0gKCgodyA8PCBvZmYpIHwgY2FycnkpICYgMHhmZmZmZmYpLnRvU3RyaW5nKDE2KTtcbiAgICAgICAgY2FycnkgPSAodyA+Pj4gKDI0IC0gb2ZmKSkgJiAweGZmZmZmZjtcbiAgICAgICAgaWYgKGNhcnJ5ICE9PSAwIHx8IGkgIT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgIG91dCA9IHplcm9zWzYgLSB3b3JkLmxlbmd0aF0gKyB3b3JkICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHdvcmQgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgICAgb2ZmICs9IDI7XG4gICAgICAgIGlmIChvZmYgPj0gMjYpIHtcbiAgICAgICAgICBvZmYgLT0gMjY7XG4gICAgICAgICAgaS0tO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgICAgb3V0ID0gY2FycnkudG9TdHJpbmcoMTYpICsgb3V0O1xuICAgICAgfVxuICAgICAgd2hpbGUgKG91dC5sZW5ndGggJSBwYWRkaW5nICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIG91dCA9ICctJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvdXQ7XG4gICAgfVxuXG4gICAgaWYgKGJhc2UgPT09IChiYXNlIHwgMCkgJiYgYmFzZSA+PSAyICYmIGJhc2UgPD0gMzYpIHtcbiAgICAgIC8vIHZhciBncm91cFNpemUgPSBNYXRoLmZsb29yKEJOLndvcmRTaXplICogTWF0aC5MTjIgLyBNYXRoLmxvZyhiYXNlKSk7XG4gICAgICB2YXIgZ3JvdXBTaXplID0gZ3JvdXBTaXplc1tiYXNlXTtcbiAgICAgIC8vIHZhciBncm91cEJhc2UgPSBNYXRoLnBvdyhiYXNlLCBncm91cFNpemUpO1xuICAgICAgdmFyIGdyb3VwQmFzZSA9IGdyb3VwQmFzZXNbYmFzZV07XG4gICAgICBvdXQgPSAnJztcbiAgICAgIHZhciBjID0gdGhpcy5jbG9uZSgpO1xuICAgICAgYy5uZWdhdGl2ZSA9IDA7XG4gICAgICB3aGlsZSAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgdmFyIHIgPSBjLm1vZG4oZ3JvdXBCYXNlKS50b1N0cmluZyhiYXNlKTtcbiAgICAgICAgYyA9IGMuaWRpdm4oZ3JvdXBCYXNlKTtcblxuICAgICAgICBpZiAoIWMuaXNaZXJvKCkpIHtcbiAgICAgICAgICBvdXQgPSB6ZXJvc1tncm91cFNpemUgLSByLmxlbmd0aF0gKyByICsgb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dCA9IHIgKyBvdXQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmlzWmVybygpKSB7XG4gICAgICAgIG91dCA9ICcwJyArIG91dDtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChvdXQubGVuZ3RoICUgcGFkZGluZyAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnMCcgKyBvdXQ7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICBvdXQgPSAnLScgKyBvdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gb3V0O1xuICAgIH1cblxuICAgIGFzc2VydChmYWxzZSwgJ0Jhc2Ugc2hvdWxkIGJlIGJldHdlZW4gMiBhbmQgMzYnKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9OdW1iZXIgPSBmdW5jdGlvbiB0b051bWJlciAoKSB7XG4gICAgdmFyIHJldCA9IHRoaXMud29yZHNbMF07XG4gICAgaWYgKHRoaXMubGVuZ3RoID09PSAyKSB7XG4gICAgICByZXQgKz0gdGhpcy53b3Jkc1sxXSAqIDB4NDAwMDAwMDtcbiAgICB9IGVsc2UgaWYgKHRoaXMubGVuZ3RoID09PSAzICYmIHRoaXMud29yZHNbMl0gPT09IDB4MDEpIHtcbiAgICAgIC8vIE5PVEU6IGF0IHRoaXMgc3RhZ2UgaXQgaXMga25vd24gdGhhdCB0aGUgdG9wIGJpdCBpcyBzZXRcbiAgICAgIHJldCArPSAweDEwMDAwMDAwMDAwMDAwICsgKHRoaXMud29yZHNbMV0gKiAweDQwMDAwMDApO1xuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiAyKSB7XG4gICAgICBhc3NlcnQoZmFsc2UsICdOdW1iZXIgY2FuIG9ubHkgc2FmZWx5IHN0b3JlIHVwIHRvIDUzIGJpdHMnKTtcbiAgICB9XG4gICAgcmV0dXJuICh0aGlzLm5lZ2F0aXZlICE9PSAwKSA/IC1yZXQgOiByZXQ7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uIHRvSlNPTiAoKSB7XG4gICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoMTYpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIHRvQnVmZmVyIChlbmRpYW4sIGxlbmd0aCkge1xuICAgIGFzc2VydCh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyk7XG4gICAgcmV0dXJuIHRoaXMudG9BcnJheUxpa2UoQnVmZmVyLCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXkgPSBmdW5jdGlvbiB0b0FycmF5IChlbmRpYW4sIGxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRvQXJyYXlMaWtlKEFycmF5LCBlbmRpYW4sIGxlbmd0aCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnRvQXJyYXlMaWtlID0gZnVuY3Rpb24gdG9BcnJheUxpa2UgKEFycmF5VHlwZSwgZW5kaWFuLCBsZW5ndGgpIHtcbiAgICB2YXIgYnl0ZUxlbmd0aCA9IHRoaXMuYnl0ZUxlbmd0aCgpO1xuICAgIHZhciByZXFMZW5ndGggPSBsZW5ndGggfHwgTWF0aC5tYXgoMSwgYnl0ZUxlbmd0aCk7XG4gICAgYXNzZXJ0KGJ5dGVMZW5ndGggPD0gcmVxTGVuZ3RoLCAnYnl0ZSBhcnJheSBsb25nZXIgdGhhbiBkZXNpcmVkIGxlbmd0aCcpO1xuICAgIGFzc2VydChyZXFMZW5ndGggPiAwLCAnUmVxdWVzdGVkIGFycmF5IGxlbmd0aCA8PSAwJyk7XG5cbiAgICB0aGlzLnN0cmlwKCk7XG4gICAgdmFyIGxpdHRsZUVuZGlhbiA9IGVuZGlhbiA9PT0gJ2xlJztcbiAgICB2YXIgcmVzID0gbmV3IEFycmF5VHlwZShyZXFMZW5ndGgpO1xuXG4gICAgdmFyIGIsIGk7XG4gICAgdmFyIHEgPSB0aGlzLmNsb25lKCk7XG4gICAgaWYgKCFsaXR0bGVFbmRpYW4pIHtcbiAgICAgIC8vIEFzc3VtZSBiaWctZW5kaWFuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgcmVxTGVuZ3RoIC0gYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAoaSA9IDA7ICFxLmlzWmVybygpOyBpKyspIHtcbiAgICAgICAgYiA9IHEuYW5kbG4oMHhmZik7XG4gICAgICAgIHEuaXVzaHJuKDgpO1xuXG4gICAgICAgIHJlc1tyZXFMZW5ndGggLSBpIC0gMV0gPSBiO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgPSAwOyAhcS5pc1plcm8oKTsgaSsrKSB7XG4gICAgICAgIGIgPSBxLmFuZGxuKDB4ZmYpO1xuICAgICAgICBxLml1c2hybig4KTtcblxuICAgICAgICByZXNbaV0gPSBiO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgaSA8IHJlcUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHJlc1tpXSA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBpZiAoTWF0aC5jbHozMikge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgcmV0dXJuIDMyIC0gTWF0aC5jbHozMih3KTtcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIEJOLnByb3RvdHlwZS5fY291bnRCaXRzID0gZnVuY3Rpb24gX2NvdW50Qml0cyAodykge1xuICAgICAgdmFyIHQgPSB3O1xuICAgICAgdmFyIHIgPSAwO1xuICAgICAgaWYgKHQgPj0gMHgxMDAwKSB7XG4gICAgICAgIHIgKz0gMTM7XG4gICAgICAgIHQgPj4+PSAxMztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4NDApIHtcbiAgICAgICAgciArPSA3O1xuICAgICAgICB0ID4+Pj0gNztcbiAgICAgIH1cbiAgICAgIGlmICh0ID49IDB4OCkge1xuICAgICAgICByICs9IDQ7XG4gICAgICAgIHQgPj4+PSA0O1xuICAgICAgfVxuICAgICAgaWYgKHQgPj0gMHgwMikge1xuICAgICAgICByICs9IDI7XG4gICAgICAgIHQgPj4+PSAyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHIgKyB0O1xuICAgIH07XG4gIH1cblxuICBCTi5wcm90b3R5cGUuX3plcm9CaXRzID0gZnVuY3Rpb24gX3plcm9CaXRzICh3KSB7XG4gICAgLy8gU2hvcnQtY3V0XG4gICAgaWYgKHcgPT09IDApIHJldHVybiAyNjtcblxuICAgIHZhciB0ID0gdztcbiAgICB2YXIgciA9IDA7XG4gICAgaWYgKCh0ICYgMHgxZmZmKSA9PT0gMCkge1xuICAgICAgciArPSAxMztcbiAgICAgIHQgPj4+PSAxMztcbiAgICB9XG4gICAgaWYgKCh0ICYgMHg3ZikgPT09IDApIHtcbiAgICAgIHIgKz0gNztcbiAgICAgIHQgPj4+PSA3O1xuICAgIH1cbiAgICBpZiAoKHQgJiAweGYpID09PSAwKSB7XG4gICAgICByICs9IDQ7XG4gICAgICB0ID4+Pj0gNDtcbiAgICB9XG4gICAgaWYgKCh0ICYgMHgzKSA9PT0gMCkge1xuICAgICAgciArPSAyO1xuICAgICAgdCA+Pj49IDI7XG4gICAgfVxuICAgIGlmICgodCAmIDB4MSkgPT09IDApIHtcbiAgICAgIHIrKztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG51bWJlciBvZiB1c2VkIGJpdHMgaW4gYSBCTlxuICBCTi5wcm90b3R5cGUuYml0TGVuZ3RoID0gZnVuY3Rpb24gYml0TGVuZ3RoICgpIHtcbiAgICB2YXIgdyA9IHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgaGkgPSB0aGlzLl9jb3VudEJpdHModyk7XG4gICAgcmV0dXJuICh0aGlzLmxlbmd0aCAtIDEpICogMjYgKyBoaTtcbiAgfTtcblxuICBmdW5jdGlvbiB0b0JpdEFycmF5IChudW0pIHtcbiAgICB2YXIgdyA9IG5ldyBBcnJheShudW0uYml0TGVuZ3RoKCkpO1xuXG4gICAgZm9yICh2YXIgYml0ID0gMDsgYml0IDwgdy5sZW5ndGg7IGJpdCsrKSB7XG4gICAgICB2YXIgb2ZmID0gKGJpdCAvIDI2KSB8IDA7XG4gICAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgICB3W2JpdF0gPSAobnVtLndvcmRzW29mZl0gJiAoMSA8PCB3Yml0KSkgPj4+IHdiaXQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHc7XG4gIH1cblxuICAvLyBOdW1iZXIgb2YgdHJhaWxpbmcgemVybyBiaXRzXG4gIEJOLnByb3RvdHlwZS56ZXJvQml0cyA9IGZ1bmN0aW9uIHplcm9CaXRzICgpIHtcbiAgICBpZiAodGhpcy5pc1plcm8oKSkgcmV0dXJuIDA7XG5cbiAgICB2YXIgciA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYiA9IHRoaXMuX3plcm9CaXRzKHRoaXMud29yZHNbaV0pO1xuICAgICAgciArPSBiO1xuICAgICAgaWYgKGIgIT09IDI2KSBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmJ5dGVMZW5ndGggPSBmdW5jdGlvbiBieXRlTGVuZ3RoICgpIHtcbiAgICByZXR1cm4gTWF0aC5jZWlsKHRoaXMuYml0TGVuZ3RoKCkgLyA4KTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9Ud29zID0gZnVuY3Rpb24gdG9Ud29zICh3aWR0aCkge1xuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5hYnMoKS5pbm90bih3aWR0aCkuaWFkZG4oMSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNsb25lKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21Ud29zID0gZnVuY3Rpb24gZnJvbVR3b3MgKHdpZHRoKSB7XG4gICAgaWYgKHRoaXMudGVzdG4od2lkdGggLSAxKSkge1xuICAgICAgcmV0dXJuIHRoaXMubm90bih3aWR0aCkuaWFkZG4oMSkuaW5lZygpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pc05lZyA9IGZ1bmN0aW9uIGlzTmVnICgpIHtcbiAgICByZXR1cm4gdGhpcy5uZWdhdGl2ZSAhPT0gMDtcbiAgfTtcblxuICAvLyBSZXR1cm4gbmVnYXRpdmUgY2xvbmUgb2YgYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW5lZygpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pbmVnID0gZnVuY3Rpb24gaW5lZyAoKSB7XG4gICAgaWYgKCF0aGlzLmlzWmVybygpKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlIF49IDE7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1b3IgPSBmdW5jdGlvbiBpdW9yIChudW0pIHtcbiAgICB3aGlsZSAodGhpcy5sZW5ndGggPCBudW0ubGVuZ3RoKSB7XG4gICAgICB0aGlzLndvcmRzW3RoaXMubGVuZ3RoKytdID0gMDtcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG51bS5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV0gfCBudW0ud29yZHNbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW9yID0gZnVuY3Rpb24gaW9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdW9yKG51bSk7XG4gIH07XG5cbiAgLy8gT3IgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLm9yID0gZnVuY3Rpb24gb3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaW9yKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudW9yID0gZnVuY3Rpb24gdW9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXVvcih0aGlzKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1YW5kID0gZnVuY3Rpb24gaXVhbmQgKG51bSkge1xuICAgIC8vIGIgPSBtaW4tbGVuZ3RoKG51bSwgdGhpcylcbiAgICB2YXIgYjtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSB7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBiID0gdGhpcztcbiAgICB9XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB0aGlzLndvcmRzW2ldICYgbnVtLndvcmRzW2ldO1xuICAgIH1cblxuICAgIHRoaXMubGVuZ3RoID0gYi5sZW5ndGg7XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5pYW5kID0gZnVuY3Rpb24gaWFuZCAobnVtKSB7XG4gICAgYXNzZXJ0KCh0aGlzLm5lZ2F0aXZlIHwgbnVtLm5lZ2F0aXZlKSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVhbmQobnVtKTtcbiAgfTtcblxuICAvLyBBbmQgYG51bWAgd2l0aCBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmFuZCA9IGZ1bmN0aW9uIGFuZCAobnVtKSB7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhbmQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnVhbmQgPSBmdW5jdGlvbiB1YW5kIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml1YW5kKG51bSk7XG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLml1YW5kKHRoaXMpO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXV4b3IgPSBmdW5jdGlvbiBpdXhvciAobnVtKSB7XG4gICAgLy8gYS5sZW5ndGggPiBiLmxlbmd0aFxuICAgIHZhciBhO1xuICAgIHZhciBiO1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHtcbiAgICAgIGEgPSB0aGlzO1xuICAgICAgYiA9IG51bTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IG51bTtcbiAgICAgIGIgPSB0aGlzO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYi5sZW5ndGg7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV0gXiBiLndvcmRzW2ldO1xuICAgIH1cblxuICAgIGlmICh0aGlzICE9PSBhKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLml4b3IgPSBmdW5jdGlvbiBpeG9yIChudW0pIHtcbiAgICBhc3NlcnQoKHRoaXMubmVnYXRpdmUgfCBudW0ubmVnYXRpdmUpID09PSAwKTtcbiAgICByZXR1cm4gdGhpcy5pdXhvcihudW0pO1xuICB9O1xuXG4gIC8vIFhvciBgbnVtYCB3aXRoIGB0aGlzYFxuICBCTi5wcm90b3R5cGUueG9yID0gZnVuY3Rpb24geG9yIChudW0pIHtcbiAgICBpZiAodGhpcy5sZW5ndGggPiBudW0ubGVuZ3RoKSByZXR1cm4gdGhpcy5jbG9uZSgpLml4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXhvcih0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXhvciA9IGZ1bmN0aW9uIHV4b3IgKG51bSkge1xuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaXV4b3IobnVtKTtcbiAgICByZXR1cm4gbnVtLmNsb25lKCkuaXV4b3IodGhpcyk7XG4gIH07XG5cbiAgLy8gTm90IGBgdGhpc2BgIHdpdGggYGB3aWR0aGBgIGJpdHdpZHRoXG4gIEJOLnByb3RvdHlwZS5pbm90biA9IGZ1bmN0aW9uIGlub3RuICh3aWR0aCkge1xuICAgIGFzc2VydCh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInICYmIHdpZHRoID49IDApO1xuXG4gICAgdmFyIGJ5dGVzTmVlZGVkID0gTWF0aC5jZWlsKHdpZHRoIC8gMjYpIHwgMDtcbiAgICB2YXIgYml0c0xlZnQgPSB3aWR0aCAlIDI2O1xuXG4gICAgLy8gRXh0ZW5kIHRoZSBidWZmZXIgd2l0aCBsZWFkaW5nIHplcm9lc1xuICAgIHRoaXMuX2V4cGFuZChieXRlc05lZWRlZCk7XG5cbiAgICBpZiAoYml0c0xlZnQgPiAwKSB7XG4gICAgICBieXRlc05lZWRlZC0tO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBjb21wbGV0ZSB3b3Jkc1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYnl0ZXNOZWVkZWQ7IGkrKykge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IH50aGlzLndvcmRzW2ldICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSB0aGUgcmVzaWR1ZVxuICAgIGlmIChiaXRzTGVmdCA+IDApIHtcbiAgICAgIHRoaXMud29yZHNbaV0gPSB+dGhpcy53b3Jkc1tpXSAmICgweDNmZmZmZmYgPj4gKDI2IC0gYml0c0xlZnQpKTtcbiAgICB9XG5cbiAgICAvLyBBbmQgcmVtb3ZlIGxlYWRpbmcgemVyb2VzXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubm90biA9IGZ1bmN0aW9uIG5vdG4gKHdpZHRoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbm90bih3aWR0aCk7XG4gIH07XG5cbiAgLy8gU2V0IGBiaXRgIG9mIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuc2V0biA9IGZ1bmN0aW9uIHNldG4gKGJpdCwgdmFsKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXQgPT09ICdudW1iZXInICYmIGJpdCA+PSAwKTtcblxuICAgIHZhciBvZmYgPSAoYml0IC8gMjYpIHwgMDtcbiAgICB2YXIgd2JpdCA9IGJpdCAlIDI2O1xuXG4gICAgdGhpcy5fZXhwYW5kKG9mZiArIDEpO1xuXG4gICAgaWYgKHZhbCkge1xuICAgICAgdGhpcy53b3Jkc1tvZmZdID0gdGhpcy53b3Jkc1tvZmZdIHwgKDEgPDwgd2JpdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud29yZHNbb2ZmXSA9IHRoaXMud29yZHNbb2ZmXSAmIH4oMSA8PCB3Yml0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIEFkZCBgbnVtYCB0byBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlhZGQgPSBmdW5jdGlvbiBpYWRkIChudW0pIHtcbiAgICB2YXIgcjtcblxuICAgIC8vIG5lZ2F0aXZlICsgcG9zaXRpdmVcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgciA9IHRoaXMuaXN1YihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSBePSAxO1xuICAgICAgcmV0dXJuIHRoaXMuX25vcm1TaWduKCk7XG5cbiAgICAvLyBwb3NpdGl2ZSArIG5lZ2F0aXZlXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHIgPSB0aGlzLmlzdWIobnVtKTtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gci5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBhLmxlbmd0aCA+IGIubGVuZ3RoXG4gICAgdmFyIGEsIGI7XG4gICAgaWYgKHRoaXMubGVuZ3RoID4gbnVtLmxlbmd0aCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgICBjYXJyeSA9IHIgPj4+IDI2O1xuICAgIH1cbiAgICBmb3IgKDsgY2FycnkgIT09IDAgJiYgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApICsgY2Fycnk7XG4gICAgICB0aGlzLndvcmRzW2ldID0gciAmIDB4M2ZmZmZmZjtcbiAgICAgIGNhcnJ5ID0gciA+Pj4gMjY7XG4gICAgfVxuXG4gICAgdGhpcy5sZW5ndGggPSBhLmxlbmd0aDtcbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGhdID0gY2Fycnk7XG4gICAgICB0aGlzLmxlbmd0aCsrO1xuICAgIC8vIENvcHkgdGhlIHJlc3Qgb2YgdGhlIHdvcmRzXG4gICAgfSBlbHNlIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICBmb3IgKDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGEud29yZHNbaV07XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgLy8gQWRkIGBudW1gIHRvIGB0aGlzYFxuICBCTi5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChudW0pIHtcbiAgICB2YXIgcmVzO1xuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDAgJiYgdGhpcy5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMDtcbiAgICAgIHJlcyA9IHRoaXMuc3ViKG51bSk7XG4gICAgICBudW0ubmVnYXRpdmUgXj0gMTtcbiAgICAgIHJldHVybiByZXM7XG4gICAgfSBlbHNlIGlmIChudW0ubmVnYXRpdmUgPT09IDAgJiYgdGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICByZXMgPSBudW0uc3ViKHRoaXMpO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gcmVzO1xuICAgIH1cblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZChudW0pO1xuXG4gICAgcmV0dXJuIG51bS5jbG9uZSgpLmlhZGQodGhpcyk7XG4gIH07XG5cbiAgLy8gU3VidHJhY3QgYG51bWAgZnJvbSBgdGhpc2AgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLmlzdWIgPSBmdW5jdGlvbiBpc3ViIChudW0pIHtcbiAgICAvLyB0aGlzIC0gKC1udW0pID0gdGhpcyArIG51bVxuICAgIGlmIChudW0ubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIG51bS5uZWdhdGl2ZSA9IDA7XG4gICAgICB2YXIgciA9IHRoaXMuaWFkZChudW0pO1xuICAgICAgbnVtLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiByLl9ub3JtU2lnbigpO1xuXG4gICAgLy8gLXRoaXMgLSBudW0gPSAtKHRoaXMgKyBudW0pXG4gICAgfSBlbHNlIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMuaWFkZChudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcy5fbm9ybVNpZ24oKTtcbiAgICB9XG5cbiAgICAvLyBBdCB0aGlzIHBvaW50IGJvdGggbnVtYmVycyBhcmUgcG9zaXRpdmVcbiAgICB2YXIgY21wID0gdGhpcy5jbXAobnVtKTtcblxuICAgIC8vIE9wdGltaXphdGlvbiAtIHplcm9pZnlcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gYSA+IGJcbiAgICB2YXIgYSwgYjtcbiAgICBpZiAoY21wID4gMCkge1xuICAgICAgYSA9IHRoaXM7XG4gICAgICBiID0gbnVtO1xuICAgIH0gZWxzZSB7XG4gICAgICBhID0gbnVtO1xuICAgICAgYiA9IHRoaXM7XG4gICAgfVxuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiAgICAgIHIgPSAoYS53b3Jkc1tpXSB8IDApIC0gKGIud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSByID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHIgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIGZvciAoOyBjYXJyeSAhPT0gMCAmJiBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgciA9IChhLndvcmRzW2ldIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gciA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaV0gPSByICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIC8vIENvcHkgcmVzdCBvZiB0aGUgd29yZHNcbiAgICBpZiAoY2FycnkgPT09IDAgJiYgaSA8IGEubGVuZ3RoICYmIGEgIT09IHRoaXMpIHtcbiAgICAgIGZvciAoOyBpIDwgYS5sZW5ndGg7IGkrKykge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gYS53b3Jkc1tpXTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpKTtcblxuICAgIGlmIChhICE9PSB0aGlzKSB7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5zdHJpcCgpO1xuICB9O1xuXG4gIC8vIFN1YnRyYWN0IGBudW1gIGZyb20gYHRoaXNgXG4gIEJOLnByb3RvdHlwZS5zdWIgPSBmdW5jdGlvbiBzdWIgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1YihudW0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIHNtYWxsTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICB2YXIgbGVuID0gKHNlbGYubGVuZ3RoICsgbnVtLmxlbmd0aCkgfCAwO1xuICAgIG91dC5sZW5ndGggPSBsZW47XG4gICAgbGVuID0gKGxlbiAtIDEpIHwgMDtcblxuICAgIC8vIFBlZWwgb25lIGl0ZXJhdGlvbiAoY29tcGlsZXIgY2FuJ3QgZG8gaXQsIGJlY2F1c2Ugb2YgY29kZSBjb21wbGV4aXR5KVxuICAgIHZhciBhID0gc2VsZi53b3Jkc1swXSB8IDA7XG4gICAgdmFyIGIgPSBudW0ud29yZHNbMF0gfCAwO1xuICAgIHZhciByID0gYSAqIGI7XG5cbiAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgIHZhciBjYXJyeSA9IChyIC8gMHg0MDAwMDAwKSB8IDA7XG4gICAgb3V0LndvcmRzWzBdID0gbG87XG5cbiAgICBmb3IgKHZhciBrID0gMTsgayA8IGxlbjsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGNhcnJ5ID4+PiAyNjtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gKGsgLSBqKSB8IDA7XG4gICAgICAgIGEgPSBzZWxmLndvcmRzW2ldIHwgMDtcbiAgICAgICAgYiA9IG51bS53b3Jkc1tqXSB8IDA7XG4gICAgICAgIHIgPSBhICogYiArIHJ3b3JkO1xuICAgICAgICBuY2FycnkgKz0gKHIgLyAweDQwMDAwMDApIHwgMDtcbiAgICAgICAgcndvcmQgPSByICYgMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQgfCAwO1xuICAgICAgY2FycnkgPSBuY2FycnkgfCAwO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG91dC53b3Jkc1trXSA9IGNhcnJ5IHwgMDtcbiAgICB9IGVsc2Uge1xuICAgICAgb3V0Lmxlbmd0aC0tO1xuICAgIH1cblxuICAgIHJldHVybiBvdXQuc3RyaXAoKTtcbiAgfVxuXG4gIC8vIFRPRE8oaW5kdXRueSk6IGl0IG1heSBiZSByZWFzb25hYmxlIHRvIG9taXQgaXQgZm9yIHVzZXJzIHdobyBkb24ndCBuZWVkXG4gIC8vIHRvIHdvcmsgd2l0aCAyNTYtYml0IG51bWJlcnMsIG90aGVyd2lzZSBpdCBnaXZlcyAyMCUgaW1wcm92ZW1lbnQgZm9yIDI1Ni1iaXRcbiAgLy8gbXVsdGlwbGljYXRpb24gKGxpa2UgZWxsaXB0aWMgc2VjcDI1NmsxKS5cbiAgdmFyIGNvbWIxME11bFRvID0gZnVuY3Rpb24gY29tYjEwTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgdmFyIGEgPSBzZWxmLndvcmRzO1xuICAgIHZhciBiID0gbnVtLndvcmRzO1xuICAgIHZhciBvID0gb3V0LndvcmRzO1xuICAgIHZhciBjID0gMDtcbiAgICB2YXIgbG87XG4gICAgdmFyIG1pZDtcbiAgICB2YXIgaGk7XG4gICAgdmFyIGEwID0gYVswXSB8IDA7XG4gICAgdmFyIGFsMCA9IGEwICYgMHgxZmZmO1xuICAgIHZhciBhaDAgPSBhMCA+Pj4gMTM7XG4gICAgdmFyIGExID0gYVsxXSB8IDA7XG4gICAgdmFyIGFsMSA9IGExICYgMHgxZmZmO1xuICAgIHZhciBhaDEgPSBhMSA+Pj4gMTM7XG4gICAgdmFyIGEyID0gYVsyXSB8IDA7XG4gICAgdmFyIGFsMiA9IGEyICYgMHgxZmZmO1xuICAgIHZhciBhaDIgPSBhMiA+Pj4gMTM7XG4gICAgdmFyIGEzID0gYVszXSB8IDA7XG4gICAgdmFyIGFsMyA9IGEzICYgMHgxZmZmO1xuICAgIHZhciBhaDMgPSBhMyA+Pj4gMTM7XG4gICAgdmFyIGE0ID0gYVs0XSB8IDA7XG4gICAgdmFyIGFsNCA9IGE0ICYgMHgxZmZmO1xuICAgIHZhciBhaDQgPSBhNCA+Pj4gMTM7XG4gICAgdmFyIGE1ID0gYVs1XSB8IDA7XG4gICAgdmFyIGFsNSA9IGE1ICYgMHgxZmZmO1xuICAgIHZhciBhaDUgPSBhNSA+Pj4gMTM7XG4gICAgdmFyIGE2ID0gYVs2XSB8IDA7XG4gICAgdmFyIGFsNiA9IGE2ICYgMHgxZmZmO1xuICAgIHZhciBhaDYgPSBhNiA+Pj4gMTM7XG4gICAgdmFyIGE3ID0gYVs3XSB8IDA7XG4gICAgdmFyIGFsNyA9IGE3ICYgMHgxZmZmO1xuICAgIHZhciBhaDcgPSBhNyA+Pj4gMTM7XG4gICAgdmFyIGE4ID0gYVs4XSB8IDA7XG4gICAgdmFyIGFsOCA9IGE4ICYgMHgxZmZmO1xuICAgIHZhciBhaDggPSBhOCA+Pj4gMTM7XG4gICAgdmFyIGE5ID0gYVs5XSB8IDA7XG4gICAgdmFyIGFsOSA9IGE5ICYgMHgxZmZmO1xuICAgIHZhciBhaDkgPSBhOSA+Pj4gMTM7XG4gICAgdmFyIGIwID0gYlswXSB8IDA7XG4gICAgdmFyIGJsMCA9IGIwICYgMHgxZmZmO1xuICAgIHZhciBiaDAgPSBiMCA+Pj4gMTM7XG4gICAgdmFyIGIxID0gYlsxXSB8IDA7XG4gICAgdmFyIGJsMSA9IGIxICYgMHgxZmZmO1xuICAgIHZhciBiaDEgPSBiMSA+Pj4gMTM7XG4gICAgdmFyIGIyID0gYlsyXSB8IDA7XG4gICAgdmFyIGJsMiA9IGIyICYgMHgxZmZmO1xuICAgIHZhciBiaDIgPSBiMiA+Pj4gMTM7XG4gICAgdmFyIGIzID0gYlszXSB8IDA7XG4gICAgdmFyIGJsMyA9IGIzICYgMHgxZmZmO1xuICAgIHZhciBiaDMgPSBiMyA+Pj4gMTM7XG4gICAgdmFyIGI0ID0gYls0XSB8IDA7XG4gICAgdmFyIGJsNCA9IGI0ICYgMHgxZmZmO1xuICAgIHZhciBiaDQgPSBiNCA+Pj4gMTM7XG4gICAgdmFyIGI1ID0gYls1XSB8IDA7XG4gICAgdmFyIGJsNSA9IGI1ICYgMHgxZmZmO1xuICAgIHZhciBiaDUgPSBiNSA+Pj4gMTM7XG4gICAgdmFyIGI2ID0gYls2XSB8IDA7XG4gICAgdmFyIGJsNiA9IGI2ICYgMHgxZmZmO1xuICAgIHZhciBiaDYgPSBiNiA+Pj4gMTM7XG4gICAgdmFyIGI3ID0gYls3XSB8IDA7XG4gICAgdmFyIGJsNyA9IGI3ICYgMHgxZmZmO1xuICAgIHZhciBiaDcgPSBiNyA+Pj4gMTM7XG4gICAgdmFyIGI4ID0gYls4XSB8IDA7XG4gICAgdmFyIGJsOCA9IGI4ICYgMHgxZmZmO1xuICAgIHZhciBiaDggPSBiOCA+Pj4gMTM7XG4gICAgdmFyIGI5ID0gYls5XSB8IDA7XG4gICAgdmFyIGJsOSA9IGI5ICYgMHgxZmZmO1xuICAgIHZhciBiaDkgPSBiOSA+Pj4gMTM7XG5cbiAgICBvdXQubmVnYXRpdmUgPSBzZWxmLm5lZ2F0aXZlIF4gbnVtLm5lZ2F0aXZlO1xuICAgIG91dC5sZW5ndGggPSAxOTtcbiAgICAvKiBrID0gMCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwwLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgwLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgwLCBiaDApO1xuICAgIHZhciB3MCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzAgPj4+IDI2KSkgfCAwO1xuICAgIHcwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwxLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgxLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoMSkpIHwgMDtcbiAgICB2YXIgdzEgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxID4+PiAyNikpIHwgMDtcbiAgICB3MSAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDIgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDIsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsMiwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMiwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoMiwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgyKSkgfCAwO1xuICAgIHZhciB3MiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzIgPj4+IDI2KSkgfCAwO1xuICAgIHcyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsMywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWwzLCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgzLCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWgzLCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmgzKSkgfCAwO1xuICAgIHZhciB3MyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzMgPj4+IDI2KSkgfCAwO1xuICAgIHczICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNCwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw0LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg0LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNCkpIHwgMDtcbiAgICB2YXIgdzQgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc0ID4+PiAyNikpIHwgMDtcbiAgICB3NCAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDUgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDUsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsNSwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNSwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoNSwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg1KSkgfCAwO1xuICAgIHZhciB3NSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzUgPj4+IDI2KSkgfCAwO1xuICAgIHc1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNiwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw2LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg2LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg2LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg2KSkgfCAwO1xuICAgIHZhciB3NiA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzYgPj4+IDI2KSkgfCAwO1xuICAgIHc2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gNyAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsNywgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw3LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg3LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwwLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDAsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDAsIGJoNykpIHwgMDtcbiAgICB2YXIgdzcgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHc3ID4+PiAyNikpIHwgMDtcbiAgICB3NyAmPSAweDNmZmZmZmY7XG4gICAgLyogayA9IDggKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDgsIGJsMCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOCwgYmgwKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOCwgYmwwKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOCwgYmgwKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDEpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDEpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDIpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwyKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgyKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmwzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsMykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoMykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDQpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDQpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw1KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg1KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNikpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNikpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDcpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDcpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw4KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg4KSkgfCAwO1xuICAgIHZhciB3OCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzggPj4+IDI2KSkgfCAwO1xuICAgIHc4ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gOSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwwKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDApO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDApKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDApO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmwxKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDEpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsMSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoMSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwyLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDIsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDIsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDEsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgxLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgxLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwwLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDAsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMCwgYmg5KSkgfCAwO1xuICAgIHZhciB3OSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzkgPj4+IDI2KSkgfCAwO1xuICAgIHc5ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTAgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgxKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwxKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgxKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgyKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDIpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDIpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDMpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmwzKSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmgzKSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwxLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDEsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMSwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMSwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTAgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMCA+Pj4gMjYpKSB8IDA7XG4gICAgdzEwICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTEgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsMik7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmgyKTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmwyKSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmgyKTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsMykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmgzKSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDMpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDMpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw0KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg0KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDUpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNSkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNSkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsMywgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWwzLCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDMsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDMsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDIsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsMiwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWgyLCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWgyLCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxMSA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzExID4+PiAyNikpIHwgMDtcbiAgICB3MTEgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxMiAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmwzKTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDMpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDMpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDMpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw0KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDQpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNSwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw1LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDUsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDUsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDQsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg0LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg0LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWwzLCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDMsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoMywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoMywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTIgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMiA+Pj4gMjYpKSB8IDA7XG4gICAgdzEyICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTMgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg0KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw0KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg0KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg1KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDUpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDUpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDYpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw2KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg2KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw0LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDQsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNCwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNCwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTMgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxMyA+Pj4gMjYpKSB8IDA7XG4gICAgdzEzICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTQgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNSk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg1KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw1KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg1KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsNikpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg2KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDYpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDYpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoNykpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw3KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg3KSkgfCAwO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsNiwgYmw4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw2LCBiaDgpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDYsIGJsOCkpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDYsIGJoOCkpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDUsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNSwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg1LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg1LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNCA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE0ID4+PiAyNikpIHwgMDtcbiAgICB3MTQgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxNSAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw2KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDYpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDYpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDYpO1xuICAgIGxvID0gKGxvICsgTWF0aC5pbXVsKGFsOCwgYmw3KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWw4LCBiaDcpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhaDgsIGJsNykpIHwgMDtcbiAgICBoaSA9IChoaSArIE1hdGguaW11bChhaDgsIGJoNykpIHwgMDtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDcsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsNywgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg3LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg3LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw2LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDYsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNiwgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNiwgYmg5KSkgfCAwO1xuICAgIHZhciB3MTUgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNSA+Pj4gMjYpKSB8IDA7XG4gICAgdzE1ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTYgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsNyk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg3KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw3KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg3KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOCkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg4KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDgpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDgpKSB8IDA7XG4gICAgbG8gPSAobG8gKyBNYXRoLmltdWwoYWw3LCBibDkpKSB8IDA7XG4gICAgbWlkID0gKG1pZCArIE1hdGguaW11bChhbDcsIGJoOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoNywgYmw5KSkgfCAwO1xuICAgIGhpID0gKGhpICsgTWF0aC5pbXVsKGFoNywgYmg5KSkgfCAwO1xuICAgIHZhciB3MTYgPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxNiA+Pj4gMjYpKSB8IDA7XG4gICAgdzE2ICY9IDB4M2ZmZmZmZjtcbiAgICAvKiBrID0gMTcgKi9cbiAgICBsbyA9IE1hdGguaW11bChhbDksIGJsOCk7XG4gICAgbWlkID0gTWF0aC5pbXVsKGFsOSwgYmg4KTtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFoOSwgYmw4KSkgfCAwO1xuICAgIGhpID0gTWF0aC5pbXVsKGFoOSwgYmg4KTtcbiAgICBsbyA9IChsbyArIE1hdGguaW11bChhbDgsIGJsOSkpIHwgMDtcbiAgICBtaWQgPSAobWlkICsgTWF0aC5pbXVsKGFsOCwgYmg5KSkgfCAwO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg4LCBibDkpKSB8IDA7XG4gICAgaGkgPSAoaGkgKyBNYXRoLmltdWwoYWg4LCBiaDkpKSB8IDA7XG4gICAgdmFyIHcxNyA9ICgoKGMgKyBsbykgfCAwKSArICgobWlkICYgMHgxZmZmKSA8PCAxMykpIHwgMDtcbiAgICBjID0gKCgoaGkgKyAobWlkID4+PiAxMykpIHwgMCkgKyAodzE3ID4+PiAyNikpIHwgMDtcbiAgICB3MTcgJj0gMHgzZmZmZmZmO1xuICAgIC8qIGsgPSAxOCAqL1xuICAgIGxvID0gTWF0aC5pbXVsKGFsOSwgYmw5KTtcbiAgICBtaWQgPSBNYXRoLmltdWwoYWw5LCBiaDkpO1xuICAgIG1pZCA9IChtaWQgKyBNYXRoLmltdWwoYWg5LCBibDkpKSB8IDA7XG4gICAgaGkgPSBNYXRoLmltdWwoYWg5LCBiaDkpO1xuICAgIHZhciB3MTggPSAoKChjICsgbG8pIHwgMCkgKyAoKG1pZCAmIDB4MWZmZikgPDwgMTMpKSB8IDA7XG4gICAgYyA9ICgoKGhpICsgKG1pZCA+Pj4gMTMpKSB8IDApICsgKHcxOCA+Pj4gMjYpKSB8IDA7XG4gICAgdzE4ICY9IDB4M2ZmZmZmZjtcbiAgICBvWzBdID0gdzA7XG4gICAgb1sxXSA9IHcxO1xuICAgIG9bMl0gPSB3MjtcbiAgICBvWzNdID0gdzM7XG4gICAgb1s0XSA9IHc0O1xuICAgIG9bNV0gPSB3NTtcbiAgICBvWzZdID0gdzY7XG4gICAgb1s3XSA9IHc3O1xuICAgIG9bOF0gPSB3ODtcbiAgICBvWzldID0gdzk7XG4gICAgb1sxMF0gPSB3MTA7XG4gICAgb1sxMV0gPSB3MTE7XG4gICAgb1sxMl0gPSB3MTI7XG4gICAgb1sxM10gPSB3MTM7XG4gICAgb1sxNF0gPSB3MTQ7XG4gICAgb1sxNV0gPSB3MTU7XG4gICAgb1sxNl0gPSB3MTY7XG4gICAgb1sxN10gPSB3MTc7XG4gICAgb1sxOF0gPSB3MTg7XG4gICAgaWYgKGMgIT09IDApIHtcbiAgICAgIG9bMTldID0gYztcbiAgICAgIG91dC5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIG91dDtcbiAgfTtcblxuICAvLyBQb2x5ZmlsbCBjb21iXG4gIGlmICghTWF0aC5pbXVsKSB7XG4gICAgY29tYjEwTXVsVG8gPSBzbWFsbE11bFRvO1xuICB9XG5cbiAgZnVuY3Rpb24gYmlnTXVsVG8gKHNlbGYsIG51bSwgb3V0KSB7XG4gICAgb3V0Lm5lZ2F0aXZlID0gbnVtLm5lZ2F0aXZlIF4gc2VsZi5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0gc2VsZi5sZW5ndGggKyBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICB2YXIgaG5jYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgayA9IDA7IGsgPCBvdXQubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAvLyBTdW0gYWxsIHdvcmRzIHdpdGggdGhlIHNhbWUgYGkgKyBqID0ga2AgYW5kIGFjY3VtdWxhdGUgYG5jYXJyeWAsXG4gICAgICAvLyBub3RlIHRoYXQgbmNhcnJ5IGNvdWxkIGJlID49IDB4M2ZmZmZmZlxuICAgICAgdmFyIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgICBobmNhcnJ5ID0gMDtcbiAgICAgIHZhciByd29yZCA9IGNhcnJ5ICYgMHgzZmZmZmZmO1xuICAgICAgdmFyIG1heEogPSBNYXRoLm1pbihrLCBudW0ubGVuZ3RoIC0gMSk7XG4gICAgICBmb3IgKHZhciBqID0gTWF0aC5tYXgoMCwgayAtIHNlbGYubGVuZ3RoICsgMSk7IGogPD0gbWF4SjsgaisrKSB7XG4gICAgICAgIHZhciBpID0gayAtIGo7XG4gICAgICAgIHZhciBhID0gc2VsZi53b3Jkc1tpXSB8IDA7XG4gICAgICAgIHZhciBiID0gbnVtLndvcmRzW2pdIHwgMDtcbiAgICAgICAgdmFyIHIgPSBhICogYjtcblxuICAgICAgICB2YXIgbG8gPSByICYgMHgzZmZmZmZmO1xuICAgICAgICBuY2FycnkgPSAobmNhcnJ5ICsgKChyIC8gMHg0MDAwMDAwKSB8IDApKSB8IDA7XG4gICAgICAgIGxvID0gKGxvICsgcndvcmQpIHwgMDtcbiAgICAgICAgcndvcmQgPSBsbyAmIDB4M2ZmZmZmZjtcbiAgICAgICAgbmNhcnJ5ID0gKG5jYXJyeSArIChsbyA+Pj4gMjYpKSB8IDA7XG5cbiAgICAgICAgaG5jYXJyeSArPSBuY2FycnkgPj4+IDI2O1xuICAgICAgICBuY2FycnkgJj0gMHgzZmZmZmZmO1xuICAgICAgfVxuICAgICAgb3V0LndvcmRzW2tdID0gcndvcmQ7XG4gICAgICBjYXJyeSA9IG5jYXJyeTtcbiAgICAgIG5jYXJyeSA9IGhuY2Fycnk7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgb3V0LndvcmRzW2tdID0gY2Fycnk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG91dC5sZW5ndGgtLTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH1cblxuICBmdW5jdGlvbiBqdW1ib011bFRvIChzZWxmLCBudW0sIG91dCkge1xuICAgIHZhciBmZnRtID0gbmV3IEZGVE0oKTtcbiAgICByZXR1cm4gZmZ0bS5tdWxwKHNlbGYsIG51bSwgb3V0KTtcbiAgfVxuXG4gIEJOLnByb3RvdHlwZS5tdWxUbyA9IGZ1bmN0aW9uIG11bFRvIChudW0sIG91dCkge1xuICAgIHZhciByZXM7XG4gICAgdmFyIGxlbiA9IHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aDtcbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDEwICYmIG51bS5sZW5ndGggPT09IDEwKSB7XG4gICAgICByZXMgPSBjb21iMTBNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCA2Mykge1xuICAgICAgcmVzID0gc21hbGxNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIGlmIChsZW4gPCAxMDI0KSB7XG4gICAgICByZXMgPSBiaWdNdWxUbyh0aGlzLCBudW0sIG91dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlcyA9IGp1bWJvTXVsVG8odGhpcywgbnVtLCBvdXQpO1xuICAgIH1cblxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gQ29vbGV5LVR1a2V5IGFsZ29yaXRobSBmb3IgRkZUXG4gIC8vIHNsaWdodGx5IHJldmlzaXRlZCB0byByZWx5IG9uIGxvb3BpbmcgaW5zdGVhZCBvZiByZWN1cnNpb25cblxuICBmdW5jdGlvbiBGRlRNICh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG5cbiAgRkZUTS5wcm90b3R5cGUubWFrZVJCVCA9IGZ1bmN0aW9uIG1ha2VSQlQgKE4pIHtcbiAgICB2YXIgdCA9IG5ldyBBcnJheShOKTtcbiAgICB2YXIgbCA9IEJOLnByb3RvdHlwZS5fY291bnRCaXRzKE4pIC0gMTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykge1xuICAgICAgdFtpXSA9IHRoaXMucmV2QmluKGksIGwsIE4pO1xuICAgIH1cblxuICAgIHJldHVybiB0O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYmluYXJ5LXJldmVyc2VkIHJlcHJlc2VudGF0aW9uIG9mIGB4YFxuICBGRlRNLnByb3RvdHlwZS5yZXZCaW4gPSBmdW5jdGlvbiByZXZCaW4gKHgsIGwsIE4pIHtcbiAgICBpZiAoeCA9PT0gMCB8fCB4ID09PSBOIC0gMSkgcmV0dXJuIHg7XG5cbiAgICB2YXIgcmIgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICByYiB8PSAoeCAmIDEpIDw8IChsIC0gaSAtIDEpO1xuICAgICAgeCA+Pj0gMTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmI7XG4gIH07XG5cbiAgLy8gUGVyZm9ybXMgXCJ0d2VlZGxpbmdcIiBwaGFzZSwgdGhlcmVmb3JlICdlbXVsYXRpbmcnXG4gIC8vIGJlaGF2aW91ciBvZiB0aGUgcmVjdXJzaXZlIGFsZ29yaXRobVxuICBGRlRNLnByb3RvdHlwZS5wZXJtdXRlID0gZnVuY3Rpb24gcGVybXV0ZSAocmJ0LCByd3MsIGl3cywgcnR3cywgaXR3cywgTikge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBydHdzW2ldID0gcndzW3JidFtpXV07XG4gICAgICBpdHdzW2ldID0gaXdzW3JidFtpXV07XG4gICAgfVxuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnRyYW5zZm9ybSA9IGZ1bmN0aW9uIHRyYW5zZm9ybSAocndzLCBpd3MsIHJ0d3MsIGl0d3MsIE4sIHJidCkge1xuICAgIHRoaXMucGVybXV0ZShyYnQsIHJ3cywgaXdzLCBydHdzLCBpdHdzLCBOKTtcblxuICAgIGZvciAodmFyIHMgPSAxOyBzIDwgTjsgcyA8PD0gMSkge1xuICAgICAgdmFyIGwgPSBzIDw8IDE7XG5cbiAgICAgIHZhciBydHdkZiA9IE1hdGguY29zKDIgKiBNYXRoLlBJIC8gbCk7XG4gICAgICB2YXIgaXR3ZGYgPSBNYXRoLnNpbigyICogTWF0aC5QSSAvIGwpO1xuXG4gICAgICBmb3IgKHZhciBwID0gMDsgcCA8IE47IHAgKz0gbCkge1xuICAgICAgICB2YXIgcnR3ZGZfID0gcnR3ZGY7XG4gICAgICAgIHZhciBpdHdkZl8gPSBpdHdkZjtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHM7IGorKykge1xuICAgICAgICAgIHZhciByZSA9IHJ0d3NbcCArIGpdO1xuICAgICAgICAgIHZhciBpZSA9IGl0d3NbcCArIGpdO1xuXG4gICAgICAgICAgdmFyIHJvID0gcnR3c1twICsgaiArIHNdO1xuICAgICAgICAgIHZhciBpbyA9IGl0d3NbcCArIGogKyBzXTtcblxuICAgICAgICAgIHZhciByeCA9IHJ0d2RmXyAqIHJvIC0gaXR3ZGZfICogaW87XG5cbiAgICAgICAgICBpbyA9IHJ0d2RmXyAqIGlvICsgaXR3ZGZfICogcm87XG4gICAgICAgICAgcm8gPSByeDtcblxuICAgICAgICAgIHJ0d3NbcCArIGpdID0gcmUgKyBybztcbiAgICAgICAgICBpdHdzW3AgKyBqXSA9IGllICsgaW87XG5cbiAgICAgICAgICBydHdzW3AgKyBqICsgc10gPSByZSAtIHJvO1xuICAgICAgICAgIGl0d3NbcCArIGogKyBzXSA9IGllIC0gaW87XG5cbiAgICAgICAgICAvKiBqc2hpbnQgbWF4ZGVwdGggOiBmYWxzZSAqL1xuICAgICAgICAgIGlmIChqICE9PSBsKSB7XG4gICAgICAgICAgICByeCA9IHJ0d2RmICogcnR3ZGZfIC0gaXR3ZGYgKiBpdHdkZl87XG5cbiAgICAgICAgICAgIGl0d2RmXyA9IHJ0d2RmICogaXR3ZGZfICsgaXR3ZGYgKiBydHdkZl87XG4gICAgICAgICAgICBydHdkZl8gPSByeDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUuZ3Vlc3NMZW4xM2IgPSBmdW5jdGlvbiBndWVzc0xlbjEzYiAobiwgbSkge1xuICAgIHZhciBOID0gTWF0aC5tYXgobSwgbikgfCAxO1xuICAgIHZhciBvZGQgPSBOICYgMTtcbiAgICB2YXIgaSA9IDA7XG4gICAgZm9yIChOID0gTiAvIDIgfCAwOyBOOyBOID0gTiA+Pj4gMSkge1xuICAgICAgaSsrO1xuICAgIH1cblxuICAgIHJldHVybiAxIDw8IGkgKyAxICsgb2RkO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbmp1Z2F0ZSA9IGZ1bmN0aW9uIGNvbmp1Z2F0ZSAocndzLCBpd3MsIE4pIHtcbiAgICBpZiAoTiA8PSAxKSByZXR1cm47XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE4gLyAyOyBpKyspIHtcbiAgICAgIHZhciB0ID0gcndzW2ldO1xuXG4gICAgICByd3NbaV0gPSByd3NbTiAtIGkgLSAxXTtcbiAgICAgIHJ3c1tOIC0gaSAtIDFdID0gdDtcblxuICAgICAgdCA9IGl3c1tpXTtcblxuICAgICAgaXdzW2ldID0gLWl3c1tOIC0gaSAtIDFdO1xuICAgICAgaXdzW04gLSBpIC0gMV0gPSAtdDtcbiAgICB9XG4gIH07XG5cbiAgRkZUTS5wcm90b3R5cGUubm9ybWFsaXplMTNiID0gZnVuY3Rpb24gbm9ybWFsaXplMTNiICh3cywgTikge1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBOIC8gMjsgaSsrKSB7XG4gICAgICB2YXIgdyA9IE1hdGgucm91bmQod3NbMiAqIGkgKyAxXSAvIE4pICogMHgyMDAwICtcbiAgICAgICAgTWF0aC5yb3VuZCh3c1syICogaV0gLyBOKSArXG4gICAgICAgIGNhcnJ5O1xuXG4gICAgICB3c1tpXSA9IHcgJiAweDNmZmZmZmY7XG5cbiAgICAgIGlmICh3IDwgMHg0MDAwMDAwKSB7XG4gICAgICAgIGNhcnJ5ID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNhcnJ5ID0gdyAvIDB4NDAwMDAwMCB8IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHdzO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLmNvbnZlcnQxM2IgPSBmdW5jdGlvbiBjb252ZXJ0MTNiICh3cywgbGVuLCByd3MsIE4pIHtcbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgIGNhcnJ5ID0gY2FycnkgKyAod3NbaV0gfCAwKTtcblxuICAgICAgcndzWzIgKiBpXSA9IGNhcnJ5ICYgMHgxZmZmOyBjYXJyeSA9IGNhcnJ5ID4+PiAxMztcbiAgICAgIHJ3c1syICogaSArIDFdID0gY2FycnkgJiAweDFmZmY7IGNhcnJ5ID0gY2FycnkgPj4+IDEzO1xuICAgIH1cblxuICAgIC8vIFBhZCB3aXRoIHplcm9lc1xuICAgIGZvciAoaSA9IDIgKiBsZW47IGkgPCBOOyArK2kpIHtcbiAgICAgIHJ3c1tpXSA9IDA7XG4gICAgfVxuXG4gICAgYXNzZXJ0KGNhcnJ5ID09PSAwKTtcbiAgICBhc3NlcnQoKGNhcnJ5ICYgfjB4MWZmZikgPT09IDApO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLnN0dWIgPSBmdW5jdGlvbiBzdHViIChOKSB7XG4gICAgdmFyIHBoID0gbmV3IEFycmF5KE4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICBwaFtpXSA9IDA7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBoO1xuICB9O1xuXG4gIEZGVE0ucHJvdG90eXBlLm11bHAgPSBmdW5jdGlvbiBtdWxwICh4LCB5LCBvdXQpIHtcbiAgICB2YXIgTiA9IDIgKiB0aGlzLmd1ZXNzTGVuMTNiKHgubGVuZ3RoLCB5Lmxlbmd0aCk7XG5cbiAgICB2YXIgcmJ0ID0gdGhpcy5tYWtlUkJUKE4pO1xuXG4gICAgdmFyIF8gPSB0aGlzLnN0dWIoTik7XG5cbiAgICB2YXIgcndzID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciByd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBpd3N0ID0gbmV3IEFycmF5KE4pO1xuXG4gICAgdmFyIG5yd3MgPSBuZXcgQXJyYXkoTik7XG4gICAgdmFyIG5yd3N0ID0gbmV3IEFycmF5KE4pO1xuICAgIHZhciBuaXdzdCA9IG5ldyBBcnJheShOKTtcblxuICAgIHZhciBybXdzID0gb3V0LndvcmRzO1xuICAgIHJtd3MubGVuZ3RoID0gTjtcblxuICAgIHRoaXMuY29udmVydDEzYih4LndvcmRzLCB4Lmxlbmd0aCwgcndzLCBOKTtcbiAgICB0aGlzLmNvbnZlcnQxM2IoeS53b3JkcywgeS5sZW5ndGgsIG5yd3MsIE4pO1xuXG4gICAgdGhpcy50cmFuc2Zvcm0ocndzLCBfLCByd3N0LCBpd3N0LCBOLCByYnQpO1xuICAgIHRoaXMudHJhbnNmb3JtKG5yd3MsIF8sIG5yd3N0LCBuaXdzdCwgTiwgcmJ0KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKSB7XG4gICAgICB2YXIgcnggPSByd3N0W2ldICogbnJ3c3RbaV0gLSBpd3N0W2ldICogbml3c3RbaV07XG4gICAgICBpd3N0W2ldID0gcndzdFtpXSAqIG5pd3N0W2ldICsgaXdzdFtpXSAqIG5yd3N0W2ldO1xuICAgICAgcndzdFtpXSA9IHJ4O1xuICAgIH1cblxuICAgIHRoaXMuY29uanVnYXRlKHJ3c3QsIGl3c3QsIE4pO1xuICAgIHRoaXMudHJhbnNmb3JtKHJ3c3QsIGl3c3QsIHJtd3MsIF8sIE4sIHJidCk7XG4gICAgdGhpcy5jb25qdWdhdGUocm13cywgXywgTik7XG4gICAgdGhpcy5ub3JtYWxpemUxM2Iocm13cywgTik7XG5cbiAgICBvdXQubmVnYXRpdmUgPSB4Lm5lZ2F0aXZlIF4geS5uZWdhdGl2ZTtcbiAgICBvdXQubGVuZ3RoID0geC5sZW5ndGggKyB5Lmxlbmd0aDtcbiAgICByZXR1cm4gb3V0LnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gTXVsdGlwbHkgYHRoaXNgIGJ5IGBudW1gXG4gIEJOLnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKG51bSkge1xuICAgIHZhciBvdXQgPSBuZXcgQk4obnVsbCk7XG4gICAgb3V0LndvcmRzID0gbmV3IEFycmF5KHRoaXMubGVuZ3RoICsgbnVtLmxlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXMubXVsVG8obnVtLCBvdXQpO1xuICB9O1xuXG4gIC8vIE11bHRpcGx5IGVtcGxveWluZyBGRlRcbiAgQk4ucHJvdG90eXBlLm11bGYgPSBmdW5jdGlvbiBtdWxmIChudW0pIHtcbiAgICB2YXIgb3V0ID0gbmV3IEJOKG51bGwpO1xuICAgIG91dC53b3JkcyA9IG5ldyBBcnJheSh0aGlzLmxlbmd0aCArIG51bS5sZW5ndGgpO1xuICAgIHJldHVybiBqdW1ib011bFRvKHRoaXMsIG51bSwgb3V0KTtcbiAgfTtcblxuICAvLyBJbi1wbGFjZSBNdWx0aXBsaWNhdGlvblxuICBCTi5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkubXVsVG8obnVtLCB0aGlzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaW11bG4gPSBmdW5jdGlvbiBpbXVsbiAobnVtKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBudW0gPT09ICdudW1iZXInKTtcbiAgICBhc3NlcnQobnVtIDwgMHg0MDAwMDAwKTtcblxuICAgIC8vIENhcnJ5XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gKHRoaXMud29yZHNbaV0gfCAwKSAqIG51bTtcbiAgICAgIHZhciBsbyA9ICh3ICYgMHgzZmZmZmZmKSArIChjYXJyeSAmIDB4M2ZmZmZmZik7XG4gICAgICBjYXJyeSA+Pj0gMjY7XG4gICAgICBjYXJyeSArPSAodyAvIDB4NDAwMDAwMCkgfCAwO1xuICAgICAgLy8gTk9URTogbG8gaXMgMjdiaXQgbWF4aW11bVxuICAgICAgY2FycnkgKz0gbG8gPj4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgIH1cblxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubXVsbiA9IGZ1bmN0aW9uIG11bG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaW11bG4obnVtKTtcbiAgfTtcblxuICAvLyBgdGhpc2AgKiBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoKSB7XG4gICAgcmV0dXJuIHRoaXMubXVsKHRoaXMpO1xuICB9O1xuXG4gIC8vIGB0aGlzYCAqIGB0aGlzYCBpbi1wbGFjZVxuICBCTi5wcm90b3R5cGUuaXNxciA9IGZ1bmN0aW9uIGlzcXIgKCkge1xuICAgIHJldHVybiB0aGlzLmltdWwodGhpcy5jbG9uZSgpKTtcbiAgfTtcblxuICAvLyBNYXRoLnBvdyhgdGhpc2AsIGBudW1gKVxuICBCTi5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChudW0pIHtcbiAgICB2YXIgdyA9IHRvQml0QXJyYXkobnVtKTtcbiAgICBpZiAody5sZW5ndGggPT09IDApIHJldHVybiBuZXcgQk4oMSk7XG5cbiAgICAvLyBTa2lwIGxlYWRpbmcgemVyb2VzXG4gICAgdmFyIHJlcyA9IHRoaXM7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB3Lmxlbmd0aDsgaSsrLCByZXMgPSByZXMuc3FyKCkpIHtcbiAgICAgIGlmICh3W2ldICE9PSAwKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoKytpIDwgdy5sZW5ndGgpIHtcbiAgICAgIGZvciAodmFyIHEgPSByZXMuc3FyKCk7IGkgPCB3Lmxlbmd0aDsgaSsrLCBxID0gcS5zcXIoKSkge1xuICAgICAgICBpZiAod1tpXSA9PT0gMCkgY29udGludWU7XG5cbiAgICAgICAgcmVzID0gcmVzLm11bChxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIC8vIFNoaWZ0LWxlZnQgaW4tcGxhY2VcbiAgQk4ucHJvdG90eXBlLml1c2hsbiA9IGZ1bmN0aW9uIGl1c2hsbiAoYml0cykge1xuICAgIGFzc2VydCh0eXBlb2YgYml0cyA9PT0gJ251bWJlcicgJiYgYml0cyA+PSAwKTtcbiAgICB2YXIgciA9IGJpdHMgJSAyNjtcbiAgICB2YXIgcyA9IChiaXRzIC0gcikgLyAyNjtcbiAgICB2YXIgY2FycnlNYXNrID0gKDB4M2ZmZmZmZiA+Pj4gKDI2IC0gcikpIDw8ICgyNiAtIHIpO1xuICAgIHZhciBpO1xuXG4gICAgaWYgKHIgIT09IDApIHtcbiAgICAgIHZhciBjYXJyeSA9IDA7XG5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBuZXdDYXJyeSA9IHRoaXMud29yZHNbaV0gJiBjYXJyeU1hc2s7XG4gICAgICAgIHZhciBjID0gKCh0aGlzLndvcmRzW2ldIHwgMCkgLSBuZXdDYXJyeSkgPDwgcjtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IGMgfCBjYXJyeTtcbiAgICAgICAgY2FycnkgPSBuZXdDYXJyeSA+Pj4gKDI2IC0gcik7XG4gICAgICB9XG5cbiAgICAgIGlmIChjYXJyeSkge1xuICAgICAgICB0aGlzLndvcmRzW2ldID0gY2Fycnk7XG4gICAgICAgIHRoaXMubGVuZ3RoKys7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHMgIT09IDApIHtcbiAgICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpICsgc10gPSB0aGlzLndvcmRzW2ldO1xuICAgICAgfVxuXG4gICAgICBmb3IgKGkgPSAwOyBpIDwgczsgaSsrKSB7XG4gICAgICAgIHRoaXMud29yZHNbaV0gPSAwO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmxlbmd0aCArPSBzO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaGxuID0gZnVuY3Rpb24gaXNobG4gKGJpdHMpIHtcbiAgICAvLyBUT0RPKGluZHV0bnkpOiBpbXBsZW1lbnQgbWVcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCk7XG4gICAgcmV0dXJuIHRoaXMuaXVzaGxuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFNoaWZ0LXJpZ2h0IGluLXBsYWNlXG4gIC8vIE5PVEU6IGBoaW50YCBpcyBhIGxvd2VzdCBiaXQgYmVmb3JlIHRyYWlsaW5nIHplcm9lc1xuICAvLyBOT1RFOiBpZiBgZXh0ZW5kZWRgIGlzIHByZXNlbnQgLSBpdCB3aWxsIGJlIGZpbGxlZCB3aXRoIGRlc3Ryb3llZCBiaXRzXG4gIEJOLnByb3RvdHlwZS5pdXNocm4gPSBmdW5jdGlvbiBpdXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciBoO1xuICAgIGlmIChoaW50KSB7XG4gICAgICBoID0gKGhpbnQgLSAoaGludCAlIDI2KSkgLyAyNjtcbiAgICB9IGVsc2Uge1xuICAgICAgaCA9IDA7XG4gICAgfVxuXG4gICAgdmFyIHIgPSBiaXRzICUgMjY7XG4gICAgdmFyIHMgPSBNYXRoLm1pbigoYml0cyAtIHIpIC8gMjYsIHRoaXMubGVuZ3RoKTtcbiAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICB2YXIgbWFza2VkV29yZHMgPSBleHRlbmRlZDtcblxuICAgIGggLT0gcztcbiAgICBoID0gTWF0aC5tYXgoMCwgaCk7XG5cbiAgICAvLyBFeHRlbmRlZCBtb2RlLCBjb3B5IG1hc2tlZCBwYXJ0XG4gICAgaWYgKG1hc2tlZFdvcmRzKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHM7IGkrKykge1xuICAgICAgICBtYXNrZWRXb3Jkcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaV07XG4gICAgICB9XG4gICAgICBtYXNrZWRXb3Jkcy5sZW5ndGggPSBzO1xuICAgIH1cblxuICAgIGlmIChzID09PSAwKSB7XG4gICAgICAvLyBOby1vcCwgd2Ugc2hvdWxkIG5vdCBtb3ZlIGFueXRoaW5nIGF0IGFsbFxuICAgIH0gZWxzZSBpZiAodGhpcy5sZW5ndGggPiBzKSB7XG4gICAgICB0aGlzLmxlbmd0aCAtPSBzO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSA9IHRoaXMud29yZHNbaSArIHNdO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLndvcmRzWzBdID0gMDtcbiAgICAgIHRoaXMubGVuZ3RoID0gMTtcbiAgICB9XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAoaSA9IHRoaXMubGVuZ3RoIC0gMTsgaSA+PSAwICYmIChjYXJyeSAhPT0gMCB8fCBpID49IGgpOyBpLS0pIHtcbiAgICAgIHZhciB3b3JkID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB0aGlzLndvcmRzW2ldID0gKGNhcnJ5IDw8ICgyNiAtIHIpKSB8ICh3b3JkID4+PiByKTtcbiAgICAgIGNhcnJ5ID0gd29yZCAmIG1hc2s7XG4gICAgfVxuXG4gICAgLy8gUHVzaCBjYXJyaWVkIGJpdHMgYXMgYSBtYXNrXG4gICAgaWYgKG1hc2tlZFdvcmRzICYmIGNhcnJ5ICE9PSAwKSB7XG4gICAgICBtYXNrZWRXb3Jkcy53b3Jkc1ttYXNrZWRXb3Jkcy5sZW5ndGgrK10gPSBjYXJyeTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgIHRoaXMud29yZHNbMF0gPSAwO1xuICAgICAgdGhpcy5sZW5ndGggPSAxO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzaHJuID0gZnVuY3Rpb24gaXNocm4gKGJpdHMsIGhpbnQsIGV4dGVuZGVkKSB7XG4gICAgLy8gVE9ETyhpbmR1dG55KTogaW1wbGVtZW50IG1lXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDApO1xuICAgIHJldHVybiB0aGlzLml1c2hybihiaXRzLCBoaW50LCBleHRlbmRlZCk7XG4gIH07XG5cbiAgLy8gU2hpZnQtbGVmdFxuICBCTi5wcm90b3R5cGUuc2hsbiA9IGZ1bmN0aW9uIHNobG4gKGJpdHMpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlzaGxuKGJpdHMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51c2hsbiA9IGZ1bmN0aW9uIHVzaGxuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pdXNobG4oYml0cyk7XG4gIH07XG5cbiAgLy8gU2hpZnQtcmlnaHRcbiAgQk4ucHJvdG90eXBlLnNocm4gPSBmdW5jdGlvbiBzaHJuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pc2hybihiaXRzKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudXNocm4gPSBmdW5jdGlvbiB1c2hybiAoYml0cykge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXVzaHJuKGJpdHMpO1xuICB9O1xuXG4gIC8vIFRlc3QgaWYgbiBiaXQgaXMgc2V0XG4gIEJOLnByb3RvdHlwZS50ZXN0biA9IGZ1bmN0aW9uIHRlc3RuIChiaXQpIHtcbiAgICBhc3NlcnQodHlwZW9mIGJpdCA9PT0gJ251bWJlcicgJiYgYml0ID49IDApO1xuICAgIHZhciByID0gYml0ICUgMjY7XG4gICAgdmFyIHMgPSAoYml0IC0gcikgLyAyNjtcbiAgICB2YXIgcSA9IDEgPDwgcjtcblxuICAgIC8vIEZhc3QgY2FzZTogYml0IGlzIG11Y2ggaGlnaGVyIHRoYW4gYWxsIGV4aXN0aW5nIHdvcmRzXG4gICAgaWYgKHRoaXMubGVuZ3RoIDw9IHMpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIENoZWNrIGJpdCBhbmQgcmV0dXJuXG4gICAgdmFyIHcgPSB0aGlzLndvcmRzW3NdO1xuXG4gICAgcmV0dXJuICEhKHcgJiBxKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gb25seSBsb3dlcnMgYml0cyBvZiBudW1iZXIgKGluLXBsYWNlKVxuICBCTi5wcm90b3R5cGUuaW1hc2tuID0gZnVuY3Rpb24gaW1hc2tuIChiaXRzKSB7XG4gICAgYXNzZXJ0KHR5cGVvZiBiaXRzID09PSAnbnVtYmVyJyAmJiBiaXRzID49IDApO1xuICAgIHZhciByID0gYml0cyAlIDI2O1xuICAgIHZhciBzID0gKGJpdHMgLSByKSAvIDI2O1xuXG4gICAgYXNzZXJ0KHRoaXMubmVnYXRpdmUgPT09IDAsICdpbWFza24gd29ya3Mgb25seSB3aXRoIHBvc2l0aXZlIG51bWJlcnMnKTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA8PSBzKSB7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICBpZiAociAhPT0gMCkge1xuICAgICAgcysrO1xuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWluKHMsIHRoaXMubGVuZ3RoKTtcblxuICAgIGlmIChyICE9PSAwKSB7XG4gICAgICB2YXIgbWFzayA9IDB4M2ZmZmZmZiBeICgoMHgzZmZmZmZmID4+PiByKSA8PCByKTtcbiAgICAgIHRoaXMud29yZHNbdGhpcy5sZW5ndGggLSAxXSAmPSBtYXNrO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgLy8gUmV0dXJuIG9ubHkgbG93ZXJzIGJpdHMgb2YgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5tYXNrbiA9IGZ1bmN0aW9uIG1hc2tuIChiaXRzKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pbWFza24oYml0cyk7XG4gIH07XG5cbiAgLy8gQWRkIHBsYWluIG51bWJlciBgbnVtYCB0byBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlhZGRuID0gZnVuY3Rpb24gaWFkZG4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlzdWJuKC1udW0pO1xuXG4gICAgLy8gUG9zc2libGUgc2lnbiBjaGFuZ2VcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgaWYgKHRoaXMubGVuZ3RoID09PSAxICYmICh0aGlzLndvcmRzWzBdIHwgMCkgPCBudW0pIHtcbiAgICAgICAgdGhpcy53b3Jkc1swXSA9IG51bSAtICh0aGlzLndvcmRzWzBdIHwgMCk7XG4gICAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDA7XG4gICAgICB0aGlzLmlzdWJuKG51bSk7XG4gICAgICB0aGlzLm5lZ2F0aXZlID0gMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCB3aXRob3V0IGNoZWNrc1xuICAgIHJldHVybiB0aGlzLl9pYWRkbihudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5faWFkZG4gPSBmdW5jdGlvbiBfaWFkZG4gKG51bSkge1xuICAgIHRoaXMud29yZHNbMF0gKz0gbnVtO1xuXG4gICAgLy8gQ2FycnlcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPj0gMHg0MDAwMDAwOyBpKyspIHtcbiAgICAgIHRoaXMud29yZHNbaV0gLT0gMHg0MDAwMDAwO1xuICAgICAgaWYgKGkgPT09IHRoaXMubGVuZ3RoIC0gMSkge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSA9IDE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLndvcmRzW2kgKyAxXSsrO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLmxlbmd0aCA9IE1hdGgubWF4KHRoaXMubGVuZ3RoLCBpICsgMSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBTdWJ0cmFjdCBwbGFpbiBudW1iZXIgYG51bWAgZnJvbSBgdGhpc2BcbiAgQk4ucHJvdG90eXBlLmlzdWJuID0gZnVuY3Rpb24gaXN1Ym4gKG51bSkge1xuICAgIGFzc2VydCh0eXBlb2YgbnVtID09PSAnbnVtYmVyJyk7XG4gICAgYXNzZXJ0KG51bSA8IDB4NDAwMDAwMCk7XG4gICAgaWYgKG51bSA8IDApIHJldHVybiB0aGlzLmlhZGRuKC1udW0pO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDApIHtcbiAgICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuICAgICAgdGhpcy5pYWRkbihudW0pO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICB0aGlzLndvcmRzWzBdIC09IG51bTtcblxuICAgIGlmICh0aGlzLmxlbmd0aCA9PT0gMSAmJiB0aGlzLndvcmRzWzBdIDwgMCkge1xuICAgICAgdGhpcy53b3Jkc1swXSA9IC10aGlzLndvcmRzWzBdO1xuICAgICAgdGhpcy5uZWdhdGl2ZSA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIENhcnJ5XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoICYmIHRoaXMud29yZHNbaV0gPCAwOyBpKyspIHtcbiAgICAgICAgdGhpcy53b3Jkc1tpXSArPSAweDQwMDAwMDA7XG4gICAgICAgIHRoaXMud29yZHNbaSArIDFdIC09IDE7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuYWRkbiA9IGZ1bmN0aW9uIGFkZG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaWFkZG4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuc3VibiA9IGZ1bmN0aW9uIHN1Ym4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkuaXN1Ym4obnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuaWFicyA9IGZ1bmN0aW9uIGlhYnMgKCkge1xuICAgIHRoaXMubmVnYXRpdmUgPSAwO1xuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmFicyA9IGZ1bmN0aW9uIGFicyAoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoKS5pYWJzKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLl9pc2hsbnN1Ym11bCA9IGZ1bmN0aW9uIF9pc2hsbnN1Ym11bCAobnVtLCBtdWwsIHNoaWZ0KSB7XG4gICAgdmFyIGxlbiA9IG51bS5sZW5ndGggKyBzaGlmdDtcbiAgICB2YXIgaTtcblxuICAgIHRoaXMuX2V4cGFuZChsZW4pO1xuXG4gICAgdmFyIHc7XG4gICAgdmFyIGNhcnJ5ID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtLmxlbmd0aDsgaSsrKSB7XG4gICAgICB3ID0gKHRoaXMud29yZHNbaSArIHNoaWZ0XSB8IDApICsgY2Fycnk7XG4gICAgICB2YXIgcmlnaHQgPSAobnVtLndvcmRzW2ldIHwgMCkgKiBtdWw7XG4gICAgICB3IC09IHJpZ2h0ICYgMHgzZmZmZmZmO1xuICAgICAgY2FycnkgPSAodyA+PiAyNikgLSAoKHJpZ2h0IC8gMHg0MDAwMDAwKSB8IDApO1xuICAgICAgdGhpcy53b3Jkc1tpICsgc2hpZnRdID0gdyAmIDB4M2ZmZmZmZjtcbiAgICB9XG4gICAgZm9yICg7IGkgPCB0aGlzLmxlbmd0aCAtIHNoaWZ0OyBpKyspIHtcbiAgICAgIHcgPSAodGhpcy53b3Jkc1tpICsgc2hpZnRdIHwgMCkgKyBjYXJyeTtcbiAgICAgIGNhcnJ5ID0gdyA+PiAyNjtcbiAgICAgIHRoaXMud29yZHNbaSArIHNoaWZ0XSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuXG4gICAgaWYgKGNhcnJ5ID09PSAwKSByZXR1cm4gdGhpcy5zdHJpcCgpO1xuXG4gICAgLy8gU3VidHJhY3Rpb24gb3ZlcmZsb3dcbiAgICBhc3NlcnQoY2FycnkgPT09IC0xKTtcbiAgICBjYXJyeSA9IDA7XG4gICAgZm9yIChpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHcgPSAtKHRoaXMud29yZHNbaV0gfCAwKSArIGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+IDI2O1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHcgJiAweDNmZmZmZmY7XG4gICAgfVxuICAgIHRoaXMubmVnYXRpdmUgPSAxO1xuXG4gICAgcmV0dXJuIHRoaXMuc3RyaXAoKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuX3dvcmREaXYgPSBmdW5jdGlvbiBfd29yZERpdiAobnVtLCBtb2RlKSB7XG4gICAgdmFyIHNoaWZ0ID0gdGhpcy5sZW5ndGggLSBudW0ubGVuZ3RoO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW07XG5cbiAgICAvLyBOb3JtYWxpemVcbiAgICB2YXIgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB2YXIgYmhpQml0cyA9IHRoaXMuX2NvdW50Qml0cyhiaGkpO1xuICAgIHNoaWZ0ID0gMjYgLSBiaGlCaXRzO1xuICAgIGlmIChzaGlmdCAhPT0gMCkge1xuICAgICAgYiA9IGIudXNobG4oc2hpZnQpO1xuICAgICAgYS5pdXNobG4oc2hpZnQpO1xuICAgICAgYmhpID0gYi53b3Jkc1tiLmxlbmd0aCAtIDFdIHwgMDtcbiAgICB9XG5cbiAgICAvLyBJbml0aWFsaXplIHF1b3RpZW50XG4gICAgdmFyIG0gPSBhLmxlbmd0aCAtIGIubGVuZ3RoO1xuICAgIHZhciBxO1xuXG4gICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICBxID0gbmV3IEJOKG51bGwpO1xuICAgICAgcS5sZW5ndGggPSBtICsgMTtcbiAgICAgIHEud29yZHMgPSBuZXcgQXJyYXkocS5sZW5ndGgpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHEud29yZHNbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBkaWZmID0gYS5jbG9uZSgpLl9pc2hsbnN1Ym11bChiLCAxLCBtKTtcbiAgICBpZiAoZGlmZi5uZWdhdGl2ZSA9PT0gMCkge1xuICAgICAgYSA9IGRpZmY7XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW21dID0gMTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmb3IgKHZhciBqID0gbSAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICB2YXIgcWogPSAoYS53b3Jkc1tiLmxlbmd0aCArIGpdIHwgMCkgKiAweDQwMDAwMDAgK1xuICAgICAgICAoYS53b3Jkc1tiLmxlbmd0aCArIGogLSAxXSB8IDApO1xuXG4gICAgICAvLyBOT1RFOiAocWogLyBiaGkpIGlzICgweDNmZmZmZmYgKiAweDQwMDAwMDAgKyAweDNmZmZmZmYpIC8gMHgyMDAwMDAwIG1heFxuICAgICAgLy8gKDB4N2ZmZmZmZilcbiAgICAgIHFqID0gTWF0aC5taW4oKHFqIC8gYmhpKSB8IDAsIDB4M2ZmZmZmZik7XG5cbiAgICAgIGEuX2lzaGxuc3VibXVsKGIsIHFqLCBqKTtcbiAgICAgIHdoaWxlIChhLm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICAgIHFqLS07XG4gICAgICAgIGEubmVnYXRpdmUgPSAwO1xuICAgICAgICBhLl9pc2hsbnN1Ym11bChiLCAxLCBqKTtcbiAgICAgICAgaWYgKCFhLmlzWmVybygpKSB7XG4gICAgICAgICAgYS5uZWdhdGl2ZSBePSAxO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocSkge1xuICAgICAgICBxLndvcmRzW2pdID0gcWo7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChxKSB7XG4gICAgICBxLnN0cmlwKCk7XG4gICAgfVxuICAgIGEuc3RyaXAoKTtcblxuICAgIC8vIERlbm9ybWFsaXplXG4gICAgaWYgKG1vZGUgIT09ICdkaXYnICYmIHNoaWZ0ICE9PSAwKSB7XG4gICAgICBhLml1c2hybihzaGlmdCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGRpdjogcSB8fCBudWxsLFxuICAgICAgbW9kOiBhXG4gICAgfTtcbiAgfTtcblxuICAvLyBOT1RFOiAxKSBgbW9kZWAgY2FuIGJlIHNldCB0byBgbW9kYCB0byByZXF1ZXN0IG1vZCBvbmx5LFxuICAvLyAgICAgICB0byBgZGl2YCB0byByZXF1ZXN0IGRpdiBvbmx5LCBvciBiZSBhYnNlbnQgdG9cbiAgLy8gICAgICAgcmVxdWVzdCBib3RoIGRpdiAmIG1vZFxuICAvLyAgICAgICAyKSBgcG9zaXRpdmVgIGlzIHRydWUgaWYgdW5zaWduZWQgbW9kIGlzIHJlcXVlc3RlZFxuICBCTi5wcm90b3R5cGUuZGl2bW9kID0gZnVuY3Rpb24gZGl2bW9kIChudW0sIG1vZGUsIHBvc2l0aXZlKSB7XG4gICAgYXNzZXJ0KCFudW0uaXNaZXJvKCkpO1xuXG4gICAgaWYgKHRoaXMuaXNaZXJvKCkpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogbmV3IEJOKDApLFxuICAgICAgICBtb2Q6IG5ldyBCTigwKVxuICAgICAgfTtcbiAgICB9XG5cbiAgICB2YXIgZGl2LCBtb2QsIHJlcztcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCAmJiBudW0ubmVnYXRpdmUgPT09IDApIHtcbiAgICAgIHJlcyA9IHRoaXMubmVnKCkuZGl2bW9kKG51bSwgbW9kZSk7XG5cbiAgICAgIGlmIChtb2RlICE9PSAnbW9kJykge1xuICAgICAgICBkaXYgPSByZXMuZGl2Lm5lZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAobW9kZSAhPT0gJ2RpdicpIHtcbiAgICAgICAgbW9kID0gcmVzLm1vZC5uZWcoKTtcbiAgICAgICAgaWYgKHBvc2l0aXZlICYmIG1vZC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgICAgIG1vZC5pYWRkKG51bSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiBkaXYsXG4gICAgICAgIG1vZDogbW9kXG4gICAgICB9O1xuICAgIH1cblxuICAgIGlmICh0aGlzLm5lZ2F0aXZlID09PSAwICYmIG51bS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdtb2QnKSB7XG4gICAgICAgIGRpdiA9IHJlcy5kaXYubmVnKCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogZGl2LFxuICAgICAgICBtb2Q6IHJlcy5tb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCh0aGlzLm5lZ2F0aXZlICYgbnVtLm5lZ2F0aXZlKSAhPT0gMCkge1xuICAgICAgcmVzID0gdGhpcy5uZWcoKS5kaXZtb2QobnVtLm5lZygpLCBtb2RlKTtcblxuICAgICAgaWYgKG1vZGUgIT09ICdkaXYnKSB7XG4gICAgICAgIG1vZCA9IHJlcy5tb2QubmVnKCk7XG4gICAgICAgIGlmIChwb3NpdGl2ZSAmJiBtb2QubmVnYXRpdmUgIT09IDApIHtcbiAgICAgICAgICBtb2QuaXN1YihudW0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGRpdjogcmVzLmRpdixcbiAgICAgICAgbW9kOiBtb2RcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQm90aCBudW1iZXJzIGFyZSBwb3NpdGl2ZSBhdCB0aGlzIHBvaW50XG5cbiAgICAvLyBTdHJpcCBib3RoIG51bWJlcnMgdG8gYXBwcm94aW1hdGUgc2hpZnQgdmFsdWVcbiAgICBpZiAobnVtLmxlbmd0aCA+IHRoaXMubGVuZ3RoIHx8IHRoaXMuY21wKG51bSkgPCAwKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBkaXY6IG5ldyBCTigwKSxcbiAgICAgICAgbW9kOiB0aGlzXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8vIFZlcnkgc2hvcnQgcmVkdWN0aW9uXG4gICAgaWYgKG51bS5sZW5ndGggPT09IDEpIHtcbiAgICAgIGlmIChtb2RlID09PSAnZGl2Jykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogdGhpcy5kaXZuKG51bS53b3Jkc1swXSksXG4gICAgICAgICAgbW9kOiBudWxsXG4gICAgICAgIH07XG4gICAgICB9XG5cbiAgICAgIGlmIChtb2RlID09PSAnbW9kJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGRpdjogbnVsbCxcbiAgICAgICAgICBtb2Q6IG5ldyBCTih0aGlzLm1vZG4obnVtLndvcmRzWzBdKSlcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZGl2OiB0aGlzLmRpdm4obnVtLndvcmRzWzBdKSxcbiAgICAgICAgbW9kOiBuZXcgQk4odGhpcy5tb2RuKG51bS53b3Jkc1swXSkpXG4gICAgICB9O1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLl93b3JkRGl2KG51bSwgbW9kZSk7XG4gIH07XG5cbiAgLy8gRmluZCBgdGhpc2AgLyBgbnVtYFxuICBCTi5wcm90b3R5cGUuZGl2ID0gZnVuY3Rpb24gZGl2IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5kaXZtb2QobnVtLCAnZGl2JywgZmFsc2UpLmRpdjtcbiAgfTtcblxuICAvLyBGaW5kIGB0aGlzYCAlIGBudW1gXG4gIEJOLnByb3RvdHlwZS5tb2QgPSBmdW5jdGlvbiBtb2QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmRpdm1vZChudW0sICdtb2QnLCBmYWxzZSkubW9kO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS51bW9kID0gZnVuY3Rpb24gdW1vZCAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2bW9kKG51bSwgJ21vZCcsIHRydWUpLm1vZDtcbiAgfTtcblxuICAvLyBGaW5kIFJvdW5kKGB0aGlzYCAvIGBudW1gKVxuICBCTi5wcm90b3R5cGUuZGl2Um91bmQgPSBmdW5jdGlvbiBkaXZSb3VuZCAobnVtKSB7XG4gICAgdmFyIGRtID0gdGhpcy5kaXZtb2QobnVtKTtcblxuICAgIC8vIEZhc3QgY2FzZSAtIGV4YWN0IGRpdmlzaW9uXG4gICAgaWYgKGRtLm1vZC5pc1plcm8oKSkgcmV0dXJuIGRtLmRpdjtcblxuICAgIHZhciBtb2QgPSBkbS5kaXYubmVnYXRpdmUgIT09IDAgPyBkbS5tb2QuaXN1YihudW0pIDogZG0ubW9kO1xuXG4gICAgdmFyIGhhbGYgPSBudW0udXNocm4oMSk7XG4gICAgdmFyIHIyID0gbnVtLmFuZGxuKDEpO1xuICAgIHZhciBjbXAgPSBtb2QuY21wKGhhbGYpO1xuXG4gICAgLy8gUm91bmQgZG93blxuICAgIGlmIChjbXAgPCAwIHx8IHIyID09PSAxICYmIGNtcCA9PT0gMCkgcmV0dXJuIGRtLmRpdjtcblxuICAgIC8vIFJvdW5kIHVwXG4gICAgcmV0dXJuIGRtLmRpdi5uZWdhdGl2ZSAhPT0gMCA/IGRtLmRpdi5pc3VibigxKSA6IGRtLmRpdi5pYWRkbigxKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubW9kbiA9IGZ1bmN0aW9uIG1vZG4gKG51bSkge1xuICAgIGFzc2VydChudW0gPD0gMHgzZmZmZmZmKTtcbiAgICB2YXIgcCA9ICgxIDw8IDI2KSAlIG51bTtcblxuICAgIHZhciBhY2MgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICBhY2MgPSAocCAqIGFjYyArICh0aGlzLndvcmRzW2ldIHwgMCkpICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiBhY2M7XG4gIH07XG5cbiAgLy8gSW4tcGxhY2UgZGl2aXNpb24gYnkgbnVtYmVyXG4gIEJOLnByb3RvdHlwZS5pZGl2biA9IGZ1bmN0aW9uIGlkaXZuIChudW0pIHtcbiAgICBhc3NlcnQobnVtIDw9IDB4M2ZmZmZmZik7XG5cbiAgICB2YXIgY2FycnkgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgdyA9ICh0aGlzLndvcmRzW2ldIHwgMCkgKyBjYXJyeSAqIDB4NDAwMDAwMDtcbiAgICAgIHRoaXMud29yZHNbaV0gPSAodyAvIG51bSkgfCAwO1xuICAgICAgY2FycnkgPSB3ICUgbnVtO1xuICAgIH1cblxuICAgIHJldHVybiB0aGlzLnN0cmlwKCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmRpdm4gPSBmdW5jdGlvbiBkaXZuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLmlkaXZuKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmVnY2QgPSBmdW5jdGlvbiBlZ2NkIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgeCA9IHRoaXM7XG4gICAgdmFyIHkgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoeC5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgeCA9IHgudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgeCA9IHguY2xvbmUoKTtcbiAgICB9XG5cbiAgICAvLyBBICogeCArIEIgKiB5ID0geFxuICAgIHZhciBBID0gbmV3IEJOKDEpO1xuICAgIHZhciBCID0gbmV3IEJOKDApO1xuXG4gICAgLy8gQyAqIHggKyBEICogeSA9IHlcbiAgICB2YXIgQyA9IG5ldyBCTigwKTtcbiAgICB2YXIgRCA9IG5ldyBCTigxKTtcblxuICAgIHZhciBnID0gMDtcblxuICAgIHdoaWxlICh4LmlzRXZlbigpICYmIHkuaXNFdmVuKCkpIHtcbiAgICAgIHguaXVzaHJuKDEpO1xuICAgICAgeS5pdXNocm4oMSk7XG4gICAgICArK2c7XG4gICAgfVxuXG4gICAgdmFyIHlwID0geS5jbG9uZSgpO1xuICAgIHZhciB4cCA9IHguY2xvbmUoKTtcblxuICAgIHdoaWxlICgheC5pc1plcm8oKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKHgud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICB4Lml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoQS5pc09kZCgpIHx8IEIuaXNPZGQoKSkge1xuICAgICAgICAgICAgQS5pYWRkKHlwKTtcbiAgICAgICAgICAgIEIuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQS5pdXNocm4oMSk7XG4gICAgICAgICAgQi5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgaiA9IDAsIGptID0gMTsgKHkud29yZHNbMF0gJiBqbSkgPT09IDAgJiYgaiA8IDI2OyArK2osIGptIDw8PSAxKTtcbiAgICAgIGlmIChqID4gMCkge1xuICAgICAgICB5Lml1c2hybihqKTtcbiAgICAgICAgd2hpbGUgKGotLSA+IDApIHtcbiAgICAgICAgICBpZiAoQy5pc09kZCgpIHx8IEQuaXNPZGQoKSkge1xuICAgICAgICAgICAgQy5pYWRkKHlwKTtcbiAgICAgICAgICAgIEQuaXN1Yih4cCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgQy5pdXNocm4oMSk7XG4gICAgICAgICAgRC5pdXNocm4oMSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHguY21wKHkpID49IDApIHtcbiAgICAgICAgeC5pc3ViKHkpO1xuICAgICAgICBBLmlzdWIoQyk7XG4gICAgICAgIEIuaXN1YihEKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHkuaXN1Yih4KTtcbiAgICAgICAgQy5pc3ViKEEpO1xuICAgICAgICBELmlzdWIoQik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGE6IEMsXG4gICAgICBiOiBELFxuICAgICAgZ2NkOiB5Lml1c2hsbihnKVxuICAgIH07XG4gIH07XG5cbiAgLy8gVGhpcyBpcyByZWR1Y2VkIGluY2FybmF0aW9uIG9mIHRoZSBiaW5hcnkgRUVBXG4gIC8vIGFib3ZlLCBkZXNpZ25hdGVkIHRvIGludmVydCBtZW1iZXJzIG9mIHRoZVxuICAvLyBfcHJpbWVfIGZpZWxkcyBGKHApIGF0IGEgbWF4aW1hbCBzcGVlZFxuICBCTi5wcm90b3R5cGUuX2ludm1wID0gZnVuY3Rpb24gX2ludm1wIChwKSB7XG4gICAgYXNzZXJ0KHAubmVnYXRpdmUgPT09IDApO1xuICAgIGFzc2VydCghcC5pc1plcm8oKSk7XG5cbiAgICB2YXIgYSA9IHRoaXM7XG4gICAgdmFyIGIgPSBwLmNsb25lKCk7XG5cbiAgICBpZiAoYS5uZWdhdGl2ZSAhPT0gMCkge1xuICAgICAgYSA9IGEudW1vZChwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICB2YXIgeDEgPSBuZXcgQk4oMSk7XG4gICAgdmFyIHgyID0gbmV3IEJOKDApO1xuXG4gICAgdmFyIGRlbHRhID0gYi5jbG9uZSgpO1xuXG4gICAgd2hpbGUgKGEuY21wbigxKSA+IDAgJiYgYi5jbXBuKDEpID4gMCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGltID0gMTsgKGEud29yZHNbMF0gJiBpbSkgPT09IDAgJiYgaSA8IDI2OyArK2ksIGltIDw8PSAxKTtcbiAgICAgIGlmIChpID4gMCkge1xuICAgICAgICBhLml1c2hybihpKTtcbiAgICAgICAgd2hpbGUgKGktLSA+IDApIHtcbiAgICAgICAgICBpZiAoeDEuaXNPZGQoKSkge1xuICAgICAgICAgICAgeDEuaWFkZChkZWx0YSk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgeDEuaXVzaHJuKDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGogPSAwLCBqbSA9IDE7IChiLndvcmRzWzBdICYgam0pID09PSAwICYmIGogPCAyNjsgKytqLCBqbSA8PD0gMSk7XG4gICAgICBpZiAoaiA+IDApIHtcbiAgICAgICAgYi5pdXNocm4oaik7XG4gICAgICAgIHdoaWxlIChqLS0gPiAwKSB7XG4gICAgICAgICAgaWYgKHgyLmlzT2RkKCkpIHtcbiAgICAgICAgICAgIHgyLmlhZGQoZGVsdGEpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHgyLml1c2hybigxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAoYS5jbXAoYikgPj0gMCkge1xuICAgICAgICBhLmlzdWIoYik7XG4gICAgICAgIHgxLmlzdWIoeDIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYi5pc3ViKGEpO1xuICAgICAgICB4Mi5pc3ViKHgxKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgcmVzO1xuICAgIGlmIChhLmNtcG4oMSkgPT09IDApIHtcbiAgICAgIHJlcyA9IHgxO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXMgPSB4MjtcbiAgICB9XG5cbiAgICBpZiAocmVzLmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMuaWFkZChwKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5nY2QgPSBmdW5jdGlvbiBnY2QgKG51bSkge1xuICAgIGlmICh0aGlzLmlzWmVybygpKSByZXR1cm4gbnVtLmFicygpO1xuICAgIGlmIChudW0uaXNaZXJvKCkpIHJldHVybiB0aGlzLmFicygpO1xuXG4gICAgdmFyIGEgPSB0aGlzLmNsb25lKCk7XG4gICAgdmFyIGIgPSBudW0uY2xvbmUoKTtcbiAgICBhLm5lZ2F0aXZlID0gMDtcbiAgICBiLm5lZ2F0aXZlID0gMDtcblxuICAgIC8vIFJlbW92ZSBjb21tb24gZmFjdG9yIG9mIHR3b1xuICAgIGZvciAodmFyIHNoaWZ0ID0gMDsgYS5pc0V2ZW4oKSAmJiBiLmlzRXZlbigpOyBzaGlmdCsrKSB7XG4gICAgICBhLml1c2hybigxKTtcbiAgICAgIGIuaXVzaHJuKDEpO1xuICAgIH1cblxuICAgIGRvIHtcbiAgICAgIHdoaWxlIChhLmlzRXZlbigpKSB7XG4gICAgICAgIGEuaXVzaHJuKDEpO1xuICAgICAgfVxuICAgICAgd2hpbGUgKGIuaXNFdmVuKCkpIHtcbiAgICAgICAgYi5pdXNocm4oMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciByID0gYS5jbXAoYik7XG4gICAgICBpZiAociA8IDApIHtcbiAgICAgICAgLy8gU3dhcCBgYWAgYW5kIGBiYCB0byBtYWtlIGBhYCBhbHdheXMgYmlnZ2VyIHRoYW4gYGJgXG4gICAgICAgIHZhciB0ID0gYTtcbiAgICAgICAgYSA9IGI7XG4gICAgICAgIGIgPSB0O1xuICAgICAgfSBlbHNlIGlmIChyID09PSAwIHx8IGIuY21wbigxKSA9PT0gMCkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgYS5pc3ViKGIpO1xuICAgIH0gd2hpbGUgKHRydWUpO1xuXG4gICAgcmV0dXJuIGIuaXVzaGxuKHNoaWZ0KTtcbiAgfTtcblxuICAvLyBJbnZlcnQgbnVtYmVyIGluIHRoZSBmaWVsZCBGKG51bSlcbiAgQk4ucHJvdG90eXBlLmludm0gPSBmdW5jdGlvbiBpbnZtIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5lZ2NkKG51bSkuYS51bW9kKG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzRXZlbiA9IGZ1bmN0aW9uIGlzRXZlbiAoKSB7XG4gICAgcmV0dXJuICh0aGlzLndvcmRzWzBdICYgMSkgPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzT2RkID0gZnVuY3Rpb24gaXNPZGQgKCkge1xuICAgIHJldHVybiAodGhpcy53b3Jkc1swXSAmIDEpID09PSAxO1xuICB9O1xuXG4gIC8vIEFuZCBmaXJzdCB3b3JkIGFuZCBudW1cbiAgQk4ucHJvdG90eXBlLmFuZGxuID0gZnVuY3Rpb24gYW5kbG4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLndvcmRzWzBdICYgbnVtO1xuICB9O1xuXG4gIC8vIEluY3JlbWVudCBhdCB0aGUgYml0IHBvc2l0aW9uIGluLWxpbmVcbiAgQk4ucHJvdG90eXBlLmJpbmNuID0gZnVuY3Rpb24gYmluY24gKGJpdCkge1xuICAgIGFzc2VydCh0eXBlb2YgYml0ID09PSAnbnVtYmVyJyk7XG4gICAgdmFyIHIgPSBiaXQgJSAyNjtcbiAgICB2YXIgcyA9IChiaXQgLSByKSAvIDI2O1xuICAgIHZhciBxID0gMSA8PCByO1xuXG4gICAgLy8gRmFzdCBjYXNlOiBiaXQgaXMgbXVjaCBoaWdoZXIgdGhhbiBhbGwgZXhpc3Rpbmcgd29yZHNcbiAgICBpZiAodGhpcy5sZW5ndGggPD0gcykge1xuICAgICAgdGhpcy5fZXhwYW5kKHMgKyAxKTtcbiAgICAgIHRoaXMud29yZHNbc10gfD0gcTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBiaXQgYW5kIHByb3BhZ2F0ZSwgaWYgbmVlZGVkXG4gICAgdmFyIGNhcnJ5ID0gcTtcbiAgICBmb3IgKHZhciBpID0gczsgY2FycnkgIT09IDAgJiYgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gdGhpcy53b3Jkc1tpXSB8IDA7XG4gICAgICB3ICs9IGNhcnJ5O1xuICAgICAgY2FycnkgPSB3ID4+PiAyNjtcbiAgICAgIHcgJj0gMHgzZmZmZmZmO1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IHc7XG4gICAgfVxuICAgIGlmIChjYXJyeSAhPT0gMCkge1xuICAgICAgdGhpcy53b3Jkc1tpXSA9IGNhcnJ5O1xuICAgICAgdGhpcy5sZW5ndGgrKztcbiAgICB9XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmlzWmVybyA9IGZ1bmN0aW9uIGlzWmVybyAoKSB7XG4gICAgcmV0dXJuIHRoaXMubGVuZ3RoID09PSAxICYmIHRoaXMud29yZHNbMF0gPT09IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmNtcG4gPSBmdW5jdGlvbiBjbXBuIChudW0pIHtcbiAgICB2YXIgbmVnYXRpdmUgPSBudW0gPCAwO1xuXG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgIW5lZ2F0aXZlKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbmVnYXRpdmUpIHJldHVybiAxO1xuXG4gICAgdGhpcy5zdHJpcCgpO1xuXG4gICAgdmFyIHJlcztcbiAgICBpZiAodGhpcy5sZW5ndGggPiAxKSB7XG4gICAgICByZXMgPSAxO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAobmVnYXRpdmUpIHtcbiAgICAgICAgbnVtID0gLW51bTtcbiAgICAgIH1cblxuICAgICAgYXNzZXJ0KG51bSA8PSAweDNmZmZmZmYsICdOdW1iZXIgaXMgdG9vIGJpZycpO1xuXG4gICAgICB2YXIgdyA9IHRoaXMud29yZHNbMF0gfCAwO1xuICAgICAgcmVzID0gdyA9PT0gbnVtID8gMCA6IHcgPCBudW0gPyAtMSA6IDE7XG4gICAgfVxuICAgIGlmICh0aGlzLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gLXJlcyB8IDA7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvLyBDb21wYXJlIHR3byBudW1iZXJzIGFuZCByZXR1cm46XG4gIC8vIDEgLSBpZiBgdGhpc2AgPiBgbnVtYFxuICAvLyAwIC0gaWYgYHRoaXNgID09IGBudW1gXG4gIC8vIC0xIC0gaWYgYHRoaXNgIDwgYG51bWBcbiAgQk4ucHJvdG90eXBlLmNtcCA9IGZ1bmN0aW9uIGNtcCAobnVtKSB7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgIT09IDAgJiYgbnVtLm5lZ2F0aXZlID09PSAwKSByZXR1cm4gLTE7XG4gICAgaWYgKHRoaXMubmVnYXRpdmUgPT09IDAgJiYgbnVtLm5lZ2F0aXZlICE9PSAwKSByZXR1cm4gMTtcblxuICAgIHZhciByZXMgPSB0aGlzLnVjbXAobnVtKTtcbiAgICBpZiAodGhpcy5uZWdhdGl2ZSAhPT0gMCkgcmV0dXJuIC1yZXMgfCAwO1xuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgLy8gVW5zaWduZWQgY29tcGFyaXNvblxuICBCTi5wcm90b3R5cGUudWNtcCA9IGZ1bmN0aW9uIHVjbXAgKG51bSkge1xuICAgIC8vIEF0IHRoaXMgcG9pbnQgYm90aCBudW1iZXJzIGhhdmUgdGhlIHNhbWUgc2lnblxuICAgIGlmICh0aGlzLmxlbmd0aCA+IG51bS5sZW5ndGgpIHJldHVybiAxO1xuICAgIGlmICh0aGlzLmxlbmd0aCA8IG51bS5sZW5ndGgpIHJldHVybiAtMTtcblxuICAgIHZhciByZXMgPSAwO1xuICAgIGZvciAodmFyIGkgPSB0aGlzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgYSA9IHRoaXMud29yZHNbaV0gfCAwO1xuICAgICAgdmFyIGIgPSBudW0ud29yZHNbaV0gfCAwO1xuXG4gICAgICBpZiAoYSA9PT0gYikgY29udGludWU7XG4gICAgICBpZiAoYSA8IGIpIHtcbiAgICAgICAgcmVzID0gLTE7XG4gICAgICB9IGVsc2UgaWYgKGEgPiBiKSB7XG4gICAgICAgIHJlcyA9IDE7XG4gICAgICB9XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZ3RuID0gZnVuY3Rpb24gZ3RuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IDE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ID0gZnVuY3Rpb24gZ3QgKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcChudW0pID09PSAxO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5ndGVuID0gZnVuY3Rpb24gZ3RlbiAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wbihudW0pID49IDA7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmd0ZSA9IGZ1bmN0aW9uIGd0ZSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPj0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRuID0gZnVuY3Rpb24gbHRuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPT09IC0xO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5sdCA9IGZ1bmN0aW9uIGx0IChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA9PT0gLTE7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmx0ZW4gPSBmdW5jdGlvbiBsdGVuIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXBuKG51bSkgPD0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUubHRlID0gZnVuY3Rpb24gbHRlIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5jbXAobnVtKSA8PSAwO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5lcW4gPSBmdW5jdGlvbiBlcW4gKG51bSkge1xuICAgIHJldHVybiB0aGlzLmNtcG4obnVtKSA9PT0gMDtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUuZXEgPSBmdW5jdGlvbiBlcSAobnVtKSB7XG4gICAgcmV0dXJuIHRoaXMuY21wKG51bSkgPT09IDA7XG4gIH07XG5cbiAgLy9cbiAgLy8gQSByZWR1Y2UgY29udGV4dCwgY291bGQgYmUgdXNpbmcgbW9udGdvbWVyeSBvciBzb21ldGhpbmcgYmV0dGVyLCBkZXBlbmRpbmdcbiAgLy8gb24gdGhlIGBtYCBpdHNlbGYuXG4gIC8vXG4gIEJOLnJlZCA9IGZ1bmN0aW9uIHJlZCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBSZWQobnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUudG9SZWQgPSBmdW5jdGlvbiB0b1JlZCAoY3R4KSB7XG4gICAgYXNzZXJ0KCF0aGlzLnJlZCwgJ0FscmVhZHkgYSBudW1iZXIgaW4gcmVkdWN0aW9uIGNvbnRleHQnKTtcbiAgICBhc3NlcnQodGhpcy5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgcmV0dXJuIGN0eC5jb252ZXJ0VG8odGhpcykuX2ZvcmNlUmVkKGN0eCk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLmZyb21SZWQgPSBmdW5jdGlvbiBmcm9tUmVkICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdmcm9tUmVkIHdvcmtzIG9ubHkgd2l0aCBudW1iZXJzIGluIHJlZHVjdGlvbiBjb250ZXh0Jyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmNvbnZlcnRGcm9tKHRoaXMpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5fZm9yY2VSZWQgPSBmdW5jdGlvbiBfZm9yY2VSZWQgKGN0eCkge1xuICAgIHRoaXMucmVkID0gY3R4O1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5mb3JjZVJlZCA9IGZ1bmN0aW9uIGZvcmNlUmVkIChjdHgpIHtcbiAgICBhc3NlcnQoIXRoaXMucmVkLCAnQWxyZWFkeSBhIG51bWJlciBpbiByZWR1Y3Rpb24gY29udGV4dCcpO1xuICAgIHJldHVybiB0aGlzLl9mb3JjZVJlZChjdHgpO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRBZGQgPSBmdW5jdGlvbiByZWRBZGQgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZEFkZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICByZXR1cm4gdGhpcy5yZWQuYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElBZGQgPSBmdW5jdGlvbiByZWRJQWRkIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJQWRkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pYWRkKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFN1YiA9IGZ1bmN0aW9uIHJlZFN1YiAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3ViIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSVN1YiA9IGZ1bmN0aW9uIHJlZElTdWIgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZElTdWIgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLmlzdWIodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkU2hsID0gZnVuY3Rpb24gcmVkU2hsIChudW0pIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRTaGwgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNobCh0aGlzLCBudW0pO1xuICB9O1xuXG4gIEJOLnByb3RvdHlwZS5yZWRNdWwgPSBmdW5jdGlvbiByZWRNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5tdWwodGhpcywgbnVtKTtcbiAgfTtcblxuICBCTi5wcm90b3R5cGUucmVkSU11bCA9IGZ1bmN0aW9uIHJlZElNdWwgKG51bSkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZE11bCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5Mih0aGlzLCBudW0pO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbXVsKHRoaXMsIG51bSk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFNxciA9IGZ1bmN0aW9uIHJlZFNxciAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5zcXIodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZElTcXIgPSBmdW5jdGlvbiByZWRJU3FyICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJU3FyIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pc3FyKHRoaXMpO1xuICB9O1xuXG4gIC8vIFNxdWFyZSByb290IG92ZXIgcFxuICBCTi5wcm90b3R5cGUucmVkU3FydCA9IGZ1bmN0aW9uIHJlZFNxcnQgKCkge1xuICAgIGFzc2VydCh0aGlzLnJlZCwgJ3JlZFNxcnQgd29ya3Mgb25seSB3aXRoIHJlZCBudW1iZXJzJyk7XG4gICAgdGhpcy5yZWQuX3ZlcmlmeTEodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMucmVkLnNxcnQodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZEludm0gPSBmdW5jdGlvbiByZWRJbnZtICgpIHtcbiAgICBhc3NlcnQodGhpcy5yZWQsICdyZWRJbnZtIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5pbnZtKHRoaXMpO1xuICB9O1xuXG4gIC8vIFJldHVybiBuZWdhdGl2ZSBjbG9uZSBvZiBgdGhpc2AgJSBgcmVkIG1vZHVsb2BcbiAgQk4ucHJvdG90eXBlLnJlZE5lZyA9IGZ1bmN0aW9uIHJlZE5lZyAoKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkLCAncmVkTmVnIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICAgIHRoaXMucmVkLl92ZXJpZnkxKHRoaXMpO1xuICAgIHJldHVybiB0aGlzLnJlZC5uZWcodGhpcyk7XG4gIH07XG5cbiAgQk4ucHJvdG90eXBlLnJlZFBvdyA9IGZ1bmN0aW9uIHJlZFBvdyAobnVtKSB7XG4gICAgYXNzZXJ0KHRoaXMucmVkICYmICFudW0ucmVkLCAncmVkUG93KG5vcm1hbE51bSknKTtcbiAgICB0aGlzLnJlZC5fdmVyaWZ5MSh0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5yZWQucG93KHRoaXMsIG51bSk7XG4gIH07XG5cbiAgLy8gUHJpbWUgbnVtYmVycyB3aXRoIGVmZmljaWVudCByZWR1Y3Rpb25cbiAgdmFyIHByaW1lcyA9IHtcbiAgICBrMjU2OiBudWxsLFxuICAgIHAyMjQ6IG51bGwsXG4gICAgcDE5MjogbnVsbCxcbiAgICBwMjU1MTk6IG51bGxcbiAgfTtcblxuICAvLyBQc2V1ZG8tTWVyc2VubmUgcHJpbWVcbiAgZnVuY3Rpb24gTVByaW1lIChuYW1lLCBwKSB7XG4gICAgLy8gUCA9IDIgXiBOIC0gS1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5wID0gbmV3IEJOKHAsIDE2KTtcbiAgICB0aGlzLm4gPSB0aGlzLnAuYml0TGVuZ3RoKCk7XG4gICAgdGhpcy5rID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLm4pLmlzdWIodGhpcy5wKTtcblxuICAgIHRoaXMudG1wID0gdGhpcy5fdG1wKCk7XG4gIH1cblxuICBNUHJpbWUucHJvdG90eXBlLl90bXAgPSBmdW5jdGlvbiBfdG1wICgpIHtcbiAgICB2YXIgdG1wID0gbmV3IEJOKG51bGwpO1xuICAgIHRtcC53b3JkcyA9IG5ldyBBcnJheShNYXRoLmNlaWwodGhpcy5uIC8gMTMpKTtcbiAgICByZXR1cm4gdG1wO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuaXJlZHVjZSA9IGZ1bmN0aW9uIGlyZWR1Y2UgKG51bSkge1xuICAgIC8vIEFzc3VtZXMgdGhhdCBgbnVtYCBpcyBsZXNzIHRoYW4gYFBeMmBcbiAgICAvLyBudW0gPSBISSAqICgyIF4gTiAtIEspICsgSEkgKiBLICsgTE8gPSBISSAqIEsgKyBMTyAobW9kIFApXG4gICAgdmFyIHIgPSBudW07XG4gICAgdmFyIHJsZW47XG5cbiAgICBkbyB7XG4gICAgICB0aGlzLnNwbGl0KHIsIHRoaXMudG1wKTtcbiAgICAgIHIgPSB0aGlzLmltdWxLKHIpO1xuICAgICAgciA9IHIuaWFkZCh0aGlzLnRtcCk7XG4gICAgICBybGVuID0gci5iaXRMZW5ndGgoKTtcbiAgICB9IHdoaWxlIChybGVuID4gdGhpcy5uKTtcblxuICAgIHZhciBjbXAgPSBybGVuIDwgdGhpcy5uID8gLTEgOiByLnVjbXAodGhpcy5wKTtcbiAgICBpZiAoY21wID09PSAwKSB7XG4gICAgICByLndvcmRzWzBdID0gMDtcbiAgICAgIHIubGVuZ3RoID0gMTtcbiAgICB9IGVsc2UgaWYgKGNtcCA+IDApIHtcbiAgICAgIHIuaXN1Yih0aGlzLnApO1xuICAgIH0gZWxzZSB7XG4gICAgICBpZiAoci5zdHJpcCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIC8vIHIgaXMgQk4gdjQgaW5zdGFuY2VcbiAgICAgICAgci5zdHJpcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gciBpcyBCTiB2NSBpbnN0YW5jZVxuICAgICAgICByLl9zdHJpcCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIE1QcmltZS5wcm90b3R5cGUuc3BsaXQgPSBmdW5jdGlvbiBzcGxpdCAoaW5wdXQsIG91dCkge1xuICAgIGlucHV0Lml1c2hybih0aGlzLm4sIDAsIG91dCk7XG4gIH07XG5cbiAgTVByaW1lLnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICByZXR1cm4gbnVtLmltdWwodGhpcy5rKTtcbiAgfTtcblxuICBmdW5jdGlvbiBLMjU2ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnazI1NicsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmUgZmZmZmZjMmYnKTtcbiAgfVxuICBpbmhlcml0cyhLMjU2LCBNUHJpbWUpO1xuXG4gIEsyNTYucHJvdG90eXBlLnNwbGl0ID0gZnVuY3Rpb24gc3BsaXQgKGlucHV0LCBvdXRwdXQpIHtcbiAgICAvLyAyNTYgPSA5ICogMjYgKyAyMlxuICAgIHZhciBtYXNrID0gMHgzZmZmZmY7XG5cbiAgICB2YXIgb3V0TGVuID0gTWF0aC5taW4oaW5wdXQubGVuZ3RoLCA5KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dExlbjsgaSsrKSB7XG4gICAgICBvdXRwdXQud29yZHNbaV0gPSBpbnB1dC53b3Jkc1tpXTtcbiAgICB9XG4gICAgb3V0cHV0Lmxlbmd0aCA9IG91dExlbjtcblxuICAgIGlmIChpbnB1dC5sZW5ndGggPD0gOSkge1xuICAgICAgaW5wdXQud29yZHNbMF0gPSAwO1xuICAgICAgaW5wdXQubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvLyBTaGlmdCBieSA5IGxpbWJzXG4gICAgdmFyIHByZXYgPSBpbnB1dC53b3Jkc1s5XTtcbiAgICBvdXRwdXQud29yZHNbb3V0cHV0Lmxlbmd0aCsrXSA9IHByZXYgJiBtYXNrO1xuXG4gICAgZm9yIChpID0gMTA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5leHQgPSBpbnB1dC53b3Jkc1tpXSB8IDA7XG4gICAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gKChuZXh0ICYgbWFzaykgPDwgNCkgfCAocHJldiA+Pj4gMjIpO1xuICAgICAgcHJldiA9IG5leHQ7XG4gICAgfVxuICAgIHByZXYgPj4+PSAyMjtcbiAgICBpbnB1dC53b3Jkc1tpIC0gMTBdID0gcHJldjtcbiAgICBpZiAocHJldiA9PT0gMCAmJiBpbnB1dC5sZW5ndGggPiAxMCkge1xuICAgICAgaW5wdXQubGVuZ3RoIC09IDEwO1xuICAgIH0gZWxzZSB7XG4gICAgICBpbnB1dC5sZW5ndGggLT0gOTtcbiAgICB9XG4gIH07XG5cbiAgSzI1Ni5wcm90b3R5cGUuaW11bEsgPSBmdW5jdGlvbiBpbXVsSyAobnVtKSB7XG4gICAgLy8gSyA9IDB4MTAwMDAwM2QxID0gWyAweDQwLCAweDNkMSBdXG4gICAgbnVtLndvcmRzW251bS5sZW5ndGhdID0gMDtcbiAgICBudW0ud29yZHNbbnVtLmxlbmd0aCArIDFdID0gMDtcbiAgICBudW0ubGVuZ3RoICs9IDI7XG5cbiAgICAvLyBib3VuZGVkIGF0OiAweDQwICogMHgzZmZmZmZmICsgMHgzZDAgPSAweDEwMDAwMDM5MFxuICAgIHZhciBsbyA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB3ID0gbnVtLndvcmRzW2ldIHwgMDtcbiAgICAgIGxvICs9IHcgKiAweDNkMTtcbiAgICAgIG51bS53b3Jkc1tpXSA9IGxvICYgMHgzZmZmZmZmO1xuICAgICAgbG8gPSB3ICogMHg0MCArICgobG8gLyAweDQwMDAwMDApIHwgMCk7XG4gICAgfVxuXG4gICAgLy8gRmFzdCBsZW5ndGggcmVkdWN0aW9uXG4gICAgaWYgKG51bS53b3Jkc1tudW0ubGVuZ3RoIC0gMV0gPT09IDApIHtcbiAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIGlmIChudW0ud29yZHNbbnVtLmxlbmd0aCAtIDFdID09PSAwKSB7XG4gICAgICAgIG51bS5sZW5ndGgtLTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG51bTtcbiAgfTtcblxuICBmdW5jdGlvbiBQMjI0ICgpIHtcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAncDIyNCcsXG4gICAgICAnZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgZmZmZmZmZmYgMDAwMDAwMDAgMDAwMDAwMDAgMDAwMDAwMDEnKTtcbiAgfVxuICBpbmhlcml0cyhQMjI0LCBNUHJpbWUpO1xuXG4gIGZ1bmN0aW9uIFAxOTIgKCkge1xuICAgIE1QcmltZS5jYWxsKFxuICAgICAgdGhpcyxcbiAgICAgICdwMTkyJyxcbiAgICAgICdmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZiBmZmZmZmZmZSBmZmZmZmZmZiBmZmZmZmZmZicpO1xuICB9XG4gIGluaGVyaXRzKFAxOTIsIE1QcmltZSk7XG5cbiAgZnVuY3Rpb24gUDI1NTE5ICgpIHtcbiAgICAvLyAyIF4gMjU1IC0gMTlcbiAgICBNUHJpbWUuY2FsbChcbiAgICAgIHRoaXMsXG4gICAgICAnMjU1MTknLFxuICAgICAgJzdmZmZmZmZmZmZmZmZmZmYgZmZmZmZmZmZmZmZmZmZmZiBmZmZmZmZmZmZmZmZmZmZmIGZmZmZmZmZmZmZmZmZmZWQnKTtcbiAgfVxuICBpbmhlcml0cyhQMjU1MTksIE1QcmltZSk7XG5cbiAgUDI1NTE5LnByb3RvdHlwZS5pbXVsSyA9IGZ1bmN0aW9uIGltdWxLIChudW0pIHtcbiAgICAvLyBLID0gMHgxM1xuICAgIHZhciBjYXJyeSA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBudW0ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBoaSA9IChudW0ud29yZHNbaV0gfCAwKSAqIDB4MTMgKyBjYXJyeTtcbiAgICAgIHZhciBsbyA9IGhpICYgMHgzZmZmZmZmO1xuICAgICAgaGkgPj4+PSAyNjtcblxuICAgICAgbnVtLndvcmRzW2ldID0gbG87XG4gICAgICBjYXJyeSA9IGhpO1xuICAgIH1cbiAgICBpZiAoY2FycnkgIT09IDApIHtcbiAgICAgIG51bS53b3Jkc1tudW0ubGVuZ3RoKytdID0gY2Fycnk7XG4gICAgfVxuICAgIHJldHVybiBudW07XG4gIH07XG5cbiAgLy8gRXhwb3J0ZWQgbW9zdGx5IGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB1c2UgcGxhaW4gbmFtZSBpbnN0ZWFkXG4gIEJOLl9wcmltZSA9IGZ1bmN0aW9uIHByaW1lIChuYW1lKSB7XG4gICAgLy8gQ2FjaGVkIHZlcnNpb24gb2YgcHJpbWVcbiAgICBpZiAocHJpbWVzW25hbWVdKSByZXR1cm4gcHJpbWVzW25hbWVdO1xuXG4gICAgdmFyIHByaW1lO1xuICAgIGlmIChuYW1lID09PSAnazI1NicpIHtcbiAgICAgIHByaW1lID0gbmV3IEsyNTYoKTtcbiAgICB9IGVsc2UgaWYgKG5hbWUgPT09ICdwMjI0Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDIyNCgpO1xuICAgIH0gZWxzZSBpZiAobmFtZSA9PT0gJ3AxOTInKSB7XG4gICAgICBwcmltZSA9IG5ldyBQMTkyKCk7XG4gICAgfSBlbHNlIGlmIChuYW1lID09PSAncDI1NTE5Jykge1xuICAgICAgcHJpbWUgPSBuZXcgUDI1NTE5KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBwcmltZSAnICsgbmFtZSk7XG4gICAgfVxuICAgIHByaW1lc1tuYW1lXSA9IHByaW1lO1xuXG4gICAgcmV0dXJuIHByaW1lO1xuICB9O1xuXG4gIC8vXG4gIC8vIEJhc2UgcmVkdWN0aW9uIGVuZ2luZVxuICAvL1xuICBmdW5jdGlvbiBSZWQgKG0pIHtcbiAgICBpZiAodHlwZW9mIG0gPT09ICdzdHJpbmcnKSB7XG4gICAgICB2YXIgcHJpbWUgPSBCTi5fcHJpbWUobSk7XG4gICAgICB0aGlzLm0gPSBwcmltZS5wO1xuICAgICAgdGhpcy5wcmltZSA9IHByaW1lO1xuICAgIH0gZWxzZSB7XG4gICAgICBhc3NlcnQobS5ndG4oMSksICdtb2R1bHVzIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICAgIHRoaXMubSA9IG07XG4gICAgICB0aGlzLnByaW1lID0gbnVsbDtcbiAgICB9XG4gIH1cblxuICBSZWQucHJvdG90eXBlLl92ZXJpZnkxID0gZnVuY3Rpb24gX3ZlcmlmeTEgKGEpIHtcbiAgICBhc3NlcnQoYS5uZWdhdGl2ZSA9PT0gMCwgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcG9zaXRpdmVzJyk7XG4gICAgYXNzZXJ0KGEucmVkLCAncmVkIHdvcmtzIG9ubHkgd2l0aCByZWQgbnVtYmVycycpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuX3ZlcmlmeTIgPSBmdW5jdGlvbiBfdmVyaWZ5MiAoYSwgYikge1xuICAgIGFzc2VydCgoYS5uZWdhdGl2ZSB8IGIubmVnYXRpdmUpID09PSAwLCAncmVkIHdvcmtzIG9ubHkgd2l0aCBwb3NpdGl2ZXMnKTtcbiAgICBhc3NlcnQoYS5yZWQgJiYgYS5yZWQgPT09IGIucmVkLFxuICAgICAgJ3JlZCB3b3JrcyBvbmx5IHdpdGggcmVkIG51bWJlcnMnKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmltb2QgPSBmdW5jdGlvbiBpbW9kIChhKSB7XG4gICAgaWYgKHRoaXMucHJpbWUpIHJldHVybiB0aGlzLnByaW1lLmlyZWR1Y2UoYSkuX2ZvcmNlUmVkKHRoaXMpO1xuICAgIHJldHVybiBhLnVtb2QodGhpcy5tKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5uZWcgPSBmdW5jdGlvbiBuZWcgKGEpIHtcbiAgICBpZiAoYS5pc1plcm8oKSkge1xuICAgICAgcmV0dXJuIGEuY2xvbmUoKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5tLnN1YihhKS5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5hZGQgPSBmdW5jdGlvbiBhZGQgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuXG4gICAgdmFyIHJlcyA9IGEuYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pYWRkID0gZnVuY3Rpb24gaWFkZCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pYWRkKGIpO1xuICAgIGlmIChyZXMuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzLmlzdWIodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnN1YiA9IGZ1bmN0aW9uIHN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5zdWIoYik7XG4gICAgaWYgKHJlcy5jbXBuKDApIDwgMCkge1xuICAgICAgcmVzLmlhZGQodGhpcy5tKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcy5fZm9yY2VSZWQodGhpcyk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3ViID0gZnVuY3Rpb24gaXN1YiAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG5cbiAgICB2YXIgcmVzID0gYS5pc3ViKGIpO1xuICAgIGlmIChyZXMuY21wbigwKSA8IDApIHtcbiAgICAgIHJlcy5pYWRkKHRoaXMubSk7XG4gICAgfVxuICAgIHJldHVybiByZXM7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5zaGwgPSBmdW5jdGlvbiBzaGwgKGEsIG51bSkge1xuICAgIHRoaXMuX3ZlcmlmeTEoYSk7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLnVzaGxuKG51bSkpO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICB0aGlzLl92ZXJpZnkyKGEsIGIpO1xuICAgIHJldHVybiB0aGlzLmltb2QoYS5pbXVsKGIpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLm11bCA9IGZ1bmN0aW9uIG11bCAoYSwgYikge1xuICAgIHRoaXMuX3ZlcmlmeTIoYSwgYik7XG4gICAgcmV0dXJuIHRoaXMuaW1vZChhLm11bChiKSk7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5pc3FyID0gZnVuY3Rpb24gaXNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLmltdWwoYSwgYS5jbG9uZSgpKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxciA9IGZ1bmN0aW9uIHNxciAoYSkge1xuICAgIHJldHVybiB0aGlzLm11bChhLCBhKTtcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLnNxcnQgPSBmdW5jdGlvbiBzcXJ0IChhKSB7XG4gICAgaWYgKGEuaXNaZXJvKCkpIHJldHVybiBhLmNsb25lKCk7XG5cbiAgICB2YXIgbW9kMyA9IHRoaXMubS5hbmRsbigzKTtcbiAgICBhc3NlcnQobW9kMyAlIDIgPT09IDEpO1xuXG4gICAgLy8gRmFzdCBjYXNlXG4gICAgaWYgKG1vZDMgPT09IDMpIHtcbiAgICAgIHZhciBwb3cgPSB0aGlzLm0uYWRkKG5ldyBCTigxKSkuaXVzaHJuKDIpO1xuICAgICAgcmV0dXJuIHRoaXMucG93KGEsIHBvdyk7XG4gICAgfVxuXG4gICAgLy8gVG9uZWxsaS1TaGFua3MgYWxnb3JpdGhtIChUb3RhbGx5IHVub3B0aW1pemVkIGFuZCBzbG93KVxuICAgIC8vXG4gICAgLy8gRmluZCBRIGFuZCBTLCB0aGF0IFEgKiAyIF4gUyA9IChQIC0gMSlcbiAgICB2YXIgcSA9IHRoaXMubS5zdWJuKDEpO1xuICAgIHZhciBzID0gMDtcbiAgICB3aGlsZSAoIXEuaXNaZXJvKCkgJiYgcS5hbmRsbigxKSA9PT0gMCkge1xuICAgICAgcysrO1xuICAgICAgcS5pdXNocm4oMSk7XG4gICAgfVxuICAgIGFzc2VydCghcS5pc1plcm8oKSk7XG5cbiAgICB2YXIgb25lID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHZhciBuT25lID0gb25lLnJlZE5lZygpO1xuXG4gICAgLy8gRmluZCBxdWFkcmF0aWMgbm9uLXJlc2lkdWVcbiAgICAvLyBOT1RFOiBNYXggaXMgc3VjaCBiZWNhdXNlIG9mIGdlbmVyYWxpemVkIFJpZW1hbm4gaHlwb3RoZXNpcy5cbiAgICB2YXIgbHBvdyA9IHRoaXMubS5zdWJuKDEpLml1c2hybigxKTtcbiAgICB2YXIgeiA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICB6ID0gbmV3IEJOKDIgKiB6ICogeikudG9SZWQodGhpcyk7XG5cbiAgICB3aGlsZSAodGhpcy5wb3coeiwgbHBvdykuY21wKG5PbmUpICE9PSAwKSB7XG4gICAgICB6LnJlZElBZGQobk9uZSk7XG4gICAgfVxuXG4gICAgdmFyIGMgPSB0aGlzLnBvdyh6LCBxKTtcbiAgICB2YXIgciA9IHRoaXMucG93KGEsIHEuYWRkbigxKS5pdXNocm4oMSkpO1xuICAgIHZhciB0ID0gdGhpcy5wb3coYSwgcSk7XG4gICAgdmFyIG0gPSBzO1xuICAgIHdoaWxlICh0LmNtcChvbmUpICE9PSAwKSB7XG4gICAgICB2YXIgdG1wID0gdDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyB0bXAuY21wKG9uZSkgIT09IDA7IGkrKykge1xuICAgICAgICB0bXAgPSB0bXAucmVkU3FyKCk7XG4gICAgICB9XG4gICAgICBhc3NlcnQoaSA8IG0pO1xuICAgICAgdmFyIGIgPSB0aGlzLnBvdyhjLCBuZXcgQk4oMSkuaXVzaGxuKG0gLSBpIC0gMSkpO1xuXG4gICAgICByID0gci5yZWRNdWwoYik7XG4gICAgICBjID0gYi5yZWRTcXIoKTtcbiAgICAgIHQgPSB0LnJlZE11bChjKTtcbiAgICAgIG0gPSBpO1xuICAgIH1cblxuICAgIHJldHVybiByO1xuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUuaW52bSA9IGZ1bmN0aW9uIGludm0gKGEpIHtcbiAgICB2YXIgaW52ID0gYS5faW52bXAodGhpcy5tKTtcbiAgICBpZiAoaW52Lm5lZ2F0aXZlICE9PSAwKSB7XG4gICAgICBpbnYubmVnYXRpdmUgPSAwO1xuICAgICAgcmV0dXJuIHRoaXMuaW1vZChpbnYpLnJlZE5lZygpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gdGhpcy5pbW9kKGludik7XG4gICAgfVxuICB9O1xuXG4gIFJlZC5wcm90b3R5cGUucG93ID0gZnVuY3Rpb24gcG93IChhLCBudW0pIHtcbiAgICBpZiAobnVtLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIGlmIChudW0uY21wbigxKSA9PT0gMCkgcmV0dXJuIGEuY2xvbmUoKTtcblxuICAgIHZhciB3aW5kb3dTaXplID0gNDtcbiAgICB2YXIgd25kID0gbmV3IEFycmF5KDEgPDwgd2luZG93U2l6ZSk7XG4gICAgd25kWzBdID0gbmV3IEJOKDEpLnRvUmVkKHRoaXMpO1xuICAgIHduZFsxXSA9IGE7XG4gICAgZm9yICh2YXIgaSA9IDI7IGkgPCB3bmQubGVuZ3RoOyBpKyspIHtcbiAgICAgIHduZFtpXSA9IHRoaXMubXVsKHduZFtpIC0gMV0sIGEpO1xuICAgIH1cblxuICAgIHZhciByZXMgPSB3bmRbMF07XG4gICAgdmFyIGN1cnJlbnQgPSAwO1xuICAgIHZhciBjdXJyZW50TGVuID0gMDtcbiAgICB2YXIgc3RhcnQgPSBudW0uYml0TGVuZ3RoKCkgJSAyNjtcbiAgICBpZiAoc3RhcnQgPT09IDApIHtcbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgZm9yIChpID0gbnVtLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgICB2YXIgd29yZCA9IG51bS53b3Jkc1tpXTtcbiAgICAgIGZvciAodmFyIGogPSBzdGFydCAtIDE7IGogPj0gMDsgai0tKSB7XG4gICAgICAgIHZhciBiaXQgPSAod29yZCA+PiBqKSAmIDE7XG4gICAgICAgIGlmIChyZXMgIT09IHduZFswXSkge1xuICAgICAgICAgIHJlcyA9IHRoaXMuc3FyKHJlcyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoYml0ID09PSAwICYmIGN1cnJlbnQgPT09IDApIHtcbiAgICAgICAgICBjdXJyZW50TGVuID0gMDtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnQgPDw9IDE7XG4gICAgICAgIGN1cnJlbnQgfD0gYml0O1xuICAgICAgICBjdXJyZW50TGVuKys7XG4gICAgICAgIGlmIChjdXJyZW50TGVuICE9PSB3aW5kb3dTaXplICYmIChpICE9PSAwIHx8IGogIT09IDApKSBjb250aW51ZTtcblxuICAgICAgICByZXMgPSB0aGlzLm11bChyZXMsIHduZFtjdXJyZW50XSk7XG4gICAgICAgIGN1cnJlbnRMZW4gPSAwO1xuICAgICAgICBjdXJyZW50ID0gMDtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gMjY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICBSZWQucHJvdG90eXBlLmNvbnZlcnRUbyA9IGZ1bmN0aW9uIGNvbnZlcnRUbyAobnVtKSB7XG4gICAgdmFyIHIgPSBudW0udW1vZCh0aGlzLm0pO1xuXG4gICAgcmV0dXJuIHIgPT09IG51bSA/IHIuY2xvbmUoKSA6IHI7XG4gIH07XG5cbiAgUmVkLnByb3RvdHlwZS5jb252ZXJ0RnJvbSA9IGZ1bmN0aW9uIGNvbnZlcnRGcm9tIChudW0pIHtcbiAgICB2YXIgcmVzID0gbnVtLmNsb25lKCk7XG4gICAgcmVzLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHJlcztcbiAgfTtcblxuICAvL1xuICAvLyBNb250Z29tZXJ5IG1ldGhvZCBlbmdpbmVcbiAgLy9cblxuICBCTi5tb250ID0gZnVuY3Rpb24gbW9udCAobnVtKSB7XG4gICAgcmV0dXJuIG5ldyBNb250KG51bSk7XG4gIH07XG5cbiAgZnVuY3Rpb24gTW9udCAobSkge1xuICAgIFJlZC5jYWxsKHRoaXMsIG0pO1xuXG4gICAgdGhpcy5zaGlmdCA9IHRoaXMubS5iaXRMZW5ndGgoKTtcbiAgICBpZiAodGhpcy5zaGlmdCAlIDI2ICE9PSAwKSB7XG4gICAgICB0aGlzLnNoaWZ0ICs9IDI2IC0gKHRoaXMuc2hpZnQgJSAyNik7XG4gICAgfVxuXG4gICAgdGhpcy5yID0gbmV3IEJOKDEpLml1c2hsbih0aGlzLnNoaWZ0KTtcbiAgICB0aGlzLnIyID0gdGhpcy5pbW9kKHRoaXMuci5zcXIoKSk7XG4gICAgdGhpcy5yaW52ID0gdGhpcy5yLl9pbnZtcCh0aGlzLm0pO1xuXG4gICAgdGhpcy5taW52ID0gdGhpcy5yaW52Lm11bCh0aGlzLnIpLmlzdWJuKDEpLmRpdih0aGlzLm0pO1xuICAgIHRoaXMubWludiA9IHRoaXMubWludi51bW9kKHRoaXMucik7XG4gICAgdGhpcy5taW52ID0gdGhpcy5yLnN1Yih0aGlzLm1pbnYpO1xuICB9XG4gIGluaGVyaXRzKE1vbnQsIFJlZCk7XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydFRvID0gZnVuY3Rpb24gY29udmVydFRvIChudW0pIHtcbiAgICByZXR1cm4gdGhpcy5pbW9kKG51bS51c2hsbih0aGlzLnNoaWZ0KSk7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuY29udmVydEZyb20gPSBmdW5jdGlvbiBjb252ZXJ0RnJvbSAobnVtKSB7XG4gICAgdmFyIHIgPSB0aGlzLmltb2QobnVtLm11bCh0aGlzLnJpbnYpKTtcbiAgICByLnJlZCA9IG51bGw7XG4gICAgcmV0dXJuIHI7XG4gIH07XG5cbiAgTW9udC5wcm90b3R5cGUuaW11bCA9IGZ1bmN0aW9uIGltdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSB7XG4gICAgICBhLndvcmRzWzBdID0gMDtcbiAgICAgIGEubGVuZ3RoID0gMTtcbiAgICAgIHJldHVybiBhO1xuICAgIH1cblxuICAgIHZhciB0ID0gYS5pbXVsKGIpO1xuICAgIHZhciBjID0gdC5tYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5taW52KS5pbWFza24odGhpcy5zaGlmdCkubXVsKHRoaXMubSk7XG4gICAgdmFyIHUgPSB0LmlzdWIoYykuaXVzaHJuKHRoaXMuc2hpZnQpO1xuICAgIHZhciByZXMgPSB1O1xuXG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5tdWwgPSBmdW5jdGlvbiBtdWwgKGEsIGIpIHtcbiAgICBpZiAoYS5pc1plcm8oKSB8fCBiLmlzWmVybygpKSByZXR1cm4gbmV3IEJOKDApLl9mb3JjZVJlZCh0aGlzKTtcblxuICAgIHZhciB0ID0gYS5tdWwoYik7XG4gICAgdmFyIGMgPSB0Lm1hc2tuKHRoaXMuc2hpZnQpLm11bCh0aGlzLm1pbnYpLmltYXNrbih0aGlzLnNoaWZ0KS5tdWwodGhpcy5tKTtcbiAgICB2YXIgdSA9IHQuaXN1YihjKS5pdXNocm4odGhpcy5zaGlmdCk7XG4gICAgdmFyIHJlcyA9IHU7XG4gICAgaWYgKHUuY21wKHRoaXMubSkgPj0gMCkge1xuICAgICAgcmVzID0gdS5pc3ViKHRoaXMubSk7XG4gICAgfSBlbHNlIGlmICh1LmNtcG4oMCkgPCAwKSB7XG4gICAgICByZXMgPSB1LmlhZGQodGhpcy5tKTtcbiAgICB9XG5cbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcblxuICBNb250LnByb3RvdHlwZS5pbnZtID0gZnVuY3Rpb24gaW52bSAoYSkge1xuICAgIC8vIChBUileLTEgKiBSXjIgPSAoQV4tMSAqIFJeLTEpICogUl4yID0gQV4tMSAqIFJcbiAgICB2YXIgcmVzID0gdGhpcy5pbW9kKGEuX2ludm1wKHRoaXMubSkubXVsKHRoaXMucjIpKTtcbiAgICByZXR1cm4gcmVzLl9mb3JjZVJlZCh0aGlzKTtcbiAgfTtcbn0pKHR5cGVvZiBtb2R1bGUgPT09ICd1bmRlZmluZWQnIHx8IG1vZHVsZSwgdGhpcyk7XG4iLCJleHBvcnQgY29uc3QgdmVyc2lvbiA9IFwiZXRoZXJzLzUuNS4yXCI7XG4vLyMgc291cmNlTWFwcGluZ1VSTD1fdmVyc2lvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbmltcG9ydCB7IEJhc2VDb250cmFjdCwgQ29udHJhY3QsIENvbnRyYWN0RmFjdG9yeSB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9jb250cmFjdHNcIjtcbmltcG9ydCB7IEJpZ051bWJlciwgRml4ZWROdW1iZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYmlnbnVtYmVyXCI7XG5pbXBvcnQgeyBTaWduZXIsIFZvaWRTaWduZXIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvYWJzdHJhY3Qtc2lnbmVyXCI7XG5pbXBvcnQgeyBXYWxsZXQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvd2FsbGV0XCI7XG5pbXBvcnQgKiBhcyBjb25zdGFudHMgZnJvbSBcIkBldGhlcnNwcm9qZWN0L2NvbnN0YW50c1wiO1xuaW1wb3J0ICogYXMgcHJvdmlkZXJzIGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm92aWRlcnNcIjtcbmltcG9ydCB7IGdldERlZmF1bHRQcm92aWRlciB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9wcm92aWRlcnNcIjtcbmltcG9ydCB7IFdvcmRsaXN0LCB3b3JkbGlzdHMgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvd29yZGxpc3RzXCI7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tIFwiLi91dGlsc1wiO1xuaW1wb3J0IHsgRXJyb3JDb2RlIGFzIGVycm9ycywgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBDb21waWxlLVRpbWUgQ29uc3RhbnRzXG4vLyBUaGlzIGlzIGdlbmVyYXRlZCBieSBcIm5wbSBydW4gZGlzdFwiXG5pbXBvcnQgeyB2ZXJzaW9uIH0gZnJvbSBcIi4vX3ZlcnNpb25cIjtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIodmVyc2lvbik7XG4vLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIEV4cG9ydHNcbmV4cG9ydCB7IFNpZ25lciwgV2FsbGV0LCBWb2lkU2lnbmVyLCBnZXREZWZhdWx0UHJvdmlkZXIsIHByb3ZpZGVycywgQmFzZUNvbnRyYWN0LCBDb250cmFjdCwgQ29udHJhY3RGYWN0b3J5LCBCaWdOdW1iZXIsIEZpeGVkTnVtYmVyLCBjb25zdGFudHMsIGVycm9ycywgbG9nZ2VyLCB1dGlscywgd29yZGxpc3RzLCBcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ29tcGlsZS1UaW1lIENvbnN0YW50c1xudmVyc2lvbiwgV29yZGxpc3QgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV0aGVycy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcbi8vIFRvIG1vZGlmeSB0aGlzIGZpbGUsIHlvdSBtdXN0IHVwZGF0ZSAuL21pc2MvYWRtaW4vbGliL2NtZHMvdXBkYXRlLWV4cG9ydHMuanNcbmltcG9ydCAqIGFzIGV0aGVycyBmcm9tIFwiLi9ldGhlcnNcIjtcbnRyeSB7XG4gICAgY29uc3QgYW55R2xvYmFsID0gd2luZG93O1xuICAgIGlmIChhbnlHbG9iYWwuX2V0aGVycyA9PSBudWxsKSB7XG4gICAgICAgIGFueUdsb2JhbC5fZXRoZXJzID0gZXRoZXJzO1xuICAgIH1cbn1cbmNhdGNoIChlcnJvcikgeyB9XG5leHBvcnQgeyBldGhlcnMgfTtcbmV4cG9ydCB7IFNpZ25lciwgV2FsbGV0LCBWb2lkU2lnbmVyLCBnZXREZWZhdWx0UHJvdmlkZXIsIHByb3ZpZGVycywgQmFzZUNvbnRyYWN0LCBDb250cmFjdCwgQ29udHJhY3RGYWN0b3J5LCBCaWdOdW1iZXIsIEZpeGVkTnVtYmVyLCBjb25zdGFudHMsIGVycm9ycywgbG9nZ2VyLCB1dGlscywgd29yZGxpc3RzLCBcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gQ29tcGlsZS1UaW1lIENvbnN0YW50c1xudmVyc2lvbiwgV29yZGxpc3QgfSBmcm9tIFwiLi9ldGhlcnNcIjtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xuaW1wb3J0IHsgQWJpQ29kZXIsIGNoZWNrUmVzdWx0RXJyb3JzLCBDb25zdHJ1Y3RvckZyYWdtZW50LCBkZWZhdWx0QWJpQ29kZXIsIEVycm9yRnJhZ21lbnQsIEV2ZW50RnJhZ21lbnQsIEZvcm1hdFR5cGVzLCBGcmFnbWVudCwgRnVuY3Rpb25GcmFnbWVudCwgSW5kZXhlZCwgSW50ZXJmYWNlLCBMb2dEZXNjcmlwdGlvbiwgUGFyYW1UeXBlLCBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2FiaVwiO1xuaW1wb3J0IHsgZ2V0QWRkcmVzcywgZ2V0Q3JlYXRlMkFkZHJlc3MsIGdldENvbnRyYWN0QWRkcmVzcywgZ2V0SWNhcEFkZHJlc3MsIGlzQWRkcmVzcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9hZGRyZXNzXCI7XG5pbXBvcnQgKiBhcyBiYXNlNjQgZnJvbSBcIkBldGhlcnNwcm9qZWN0L2Jhc2U2NFwiO1xuaW1wb3J0IHsgQmFzZTU4IGFzIGJhc2U1OCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9iYXNleFwiO1xuaW1wb3J0IHsgYXJyYXlpZnksIGNvbmNhdCwgaGV4Q29uY2F0LCBoZXhEYXRhU2xpY2UsIGhleERhdGFMZW5ndGgsIGhleGxpZnksIGhleFN0cmlwWmVyb3MsIGhleFZhbHVlLCBoZXhaZXJvUGFkLCBpc0J5dGVzLCBpc0J5dGVzTGlrZSwgaXNIZXhTdHJpbmcsIGpvaW5TaWduYXR1cmUsIHplcm9QYWQsIHNwbGl0U2lnbmF0dXJlLCBzdHJpcFplcm9zIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2J5dGVzXCI7XG5pbXBvcnQgeyBfVHlwZWREYXRhRW5jb2RlciwgaGFzaE1lc3NhZ2UsIGlkLCBpc1ZhbGlkTmFtZSwgbmFtZWhhc2ggfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvaGFzaFwiO1xuaW1wb3J0IHsgZGVmYXVsdFBhdGgsIGVudHJvcHlUb01uZW1vbmljLCBnZXRBY2NvdW50UGF0aCwgSEROb2RlLCBpc1ZhbGlkTW5lbW9uaWMsIG1uZW1vbmljVG9FbnRyb3B5LCBtbmVtb25pY1RvU2VlZCB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9oZG5vZGVcIjtcbmltcG9ydCB7IGdldEpzb25XYWxsZXRBZGRyZXNzIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2pzb24td2FsbGV0c1wiO1xuaW1wb3J0IHsga2VjY2FrMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2tlY2NhazI1NlwiO1xuaW1wb3J0IHsgTG9nZ2VyIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L2xvZ2dlclwiO1xuaW1wb3J0IHsgY29tcHV0ZUhtYWMsIHJpcGVtZDE2MCwgc2hhMjU2LCBzaGE1MTIgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc2hhMlwiO1xuaW1wb3J0IHsga2VjY2FrMjU2IGFzIHNvbGlkaXR5S2VjY2FrMjU2LCBwYWNrIGFzIHNvbGlkaXR5UGFjaywgc2hhMjU2IGFzIHNvbGlkaXR5U2hhMjU2IH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3NvbGlkaXR5XCI7XG5pbXBvcnQgeyByYW5kb21CeXRlcywgc2h1ZmZsZWQgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcmFuZG9tXCI7XG5pbXBvcnQgeyBjaGVja1Byb3BlcnRpZXMsIGRlZXBDb3B5LCBkZWZpbmVSZWFkT25seSwgZ2V0U3RhdGljLCByZXNvbHZlUHJvcGVydGllcywgc2hhbGxvd0NvcHkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3QvcHJvcGVydGllc1wiO1xuaW1wb3J0ICogYXMgUkxQIGZyb20gXCJAZXRoZXJzcHJvamVjdC9ybHBcIjtcbmltcG9ydCB7IGNvbXB1dGVQdWJsaWNLZXksIHJlY292ZXJQdWJsaWNLZXksIFNpZ25pbmdLZXkgfSBmcm9tIFwiQGV0aGVyc3Byb2plY3Qvc2lnbmluZy1rZXlcIjtcbmltcG9ydCB7IGZvcm1hdEJ5dGVzMzJTdHJpbmcsIG5hbWVwcmVwLCBwYXJzZUJ5dGVzMzJTdHJpbmcsIF90b0VzY2FwZWRVdGY4U3RyaW5nLCB0b1V0ZjhCeXRlcywgdG9VdGY4Q29kZVBvaW50cywgdG9VdGY4U3RyaW5nLCBVdGY4RXJyb3JGdW5jcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC9zdHJpbmdzXCI7XG5pbXBvcnQgeyBhY2Nlc3NMaXN0aWZ5LCBjb21wdXRlQWRkcmVzcywgcGFyc2UgYXMgcGFyc2VUcmFuc2FjdGlvbiwgcmVjb3ZlckFkZHJlc3MsIHNlcmlhbGl6ZSBhcyBzZXJpYWxpemVUcmFuc2FjdGlvbiwgVHJhbnNhY3Rpb25UeXBlcyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC90cmFuc2FjdGlvbnNcIjtcbmltcG9ydCB7IGNvbW1pZnksIGZvcm1hdEV0aGVyLCBwYXJzZUV0aGVyLCBmb3JtYXRVbml0cywgcGFyc2VVbml0cyB9IGZyb20gXCJAZXRoZXJzcHJvamVjdC91bml0c1wiO1xuaW1wb3J0IHsgdmVyaWZ5TWVzc2FnZSwgdmVyaWZ5VHlwZWREYXRhIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dhbGxldFwiO1xuaW1wb3J0IHsgX2ZldGNoRGF0YSwgZmV0Y2hKc29uLCBwb2xsIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3dlYlwiO1xuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFbnVtc1xuaW1wb3J0IHsgU3VwcG9ydGVkQWxnb3JpdGhtIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3NoYTJcIjtcbmltcG9ydCB7IFVuaWNvZGVOb3JtYWxpemF0aW9uRm9ybSwgVXRmOEVycm9yUmVhc29uIH0gZnJvbSBcIkBldGhlcnNwcm9qZWN0L3N0cmluZ3NcIjtcbi8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gRXhwb3J0c1xuZXhwb3J0IHsgQWJpQ29kZXIsIGRlZmF1bHRBYmlDb2RlciwgRnJhZ21lbnQsIENvbnN0cnVjdG9yRnJhZ21lbnQsIEVycm9yRnJhZ21lbnQsIEV2ZW50RnJhZ21lbnQsIEZ1bmN0aW9uRnJhZ21lbnQsIFBhcmFtVHlwZSwgRm9ybWF0VHlwZXMsIGNoZWNrUmVzdWx0RXJyb3JzLCBMb2dnZXIsIFJMUCwgX2ZldGNoRGF0YSwgZmV0Y2hKc29uLCBwb2xsLCBjaGVja1Byb3BlcnRpZXMsIGRlZXBDb3B5LCBkZWZpbmVSZWFkT25seSwgZ2V0U3RhdGljLCByZXNvbHZlUHJvcGVydGllcywgc2hhbGxvd0NvcHksIGFycmF5aWZ5LCBjb25jYXQsIHN0cmlwWmVyb3MsIHplcm9QYWQsIGlzQnl0ZXMsIGlzQnl0ZXNMaWtlLCBkZWZhdWx0UGF0aCwgSEROb2RlLCBTaWduaW5nS2V5LCBJbnRlcmZhY2UsIExvZ0Rlc2NyaXB0aW9uLCBUcmFuc2FjdGlvbkRlc2NyaXB0aW9uLCBiYXNlNTgsIGJhc2U2NCwgaGV4bGlmeSwgaXNIZXhTdHJpbmcsIGhleENvbmNhdCwgaGV4U3RyaXBaZXJvcywgaGV4VmFsdWUsIGhleFplcm9QYWQsIGhleERhdGFMZW5ndGgsIGhleERhdGFTbGljZSwgbmFtZXByZXAsIF90b0VzY2FwZWRVdGY4U3RyaW5nLCB0b1V0ZjhCeXRlcywgdG9VdGY4Q29kZVBvaW50cywgdG9VdGY4U3RyaW5nLCBVdGY4RXJyb3JGdW5jcywgZm9ybWF0Qnl0ZXMzMlN0cmluZywgcGFyc2VCeXRlczMyU3RyaW5nLCBoYXNoTWVzc2FnZSwgbmFtZWhhc2gsIGlzVmFsaWROYW1lLCBpZCwgX1R5cGVkRGF0YUVuY29kZXIsIGdldEFkZHJlc3MsIGdldEljYXBBZGRyZXNzLCBnZXRDb250cmFjdEFkZHJlc3MsIGdldENyZWF0ZTJBZGRyZXNzLCBpc0FkZHJlc3MsIGZvcm1hdEV0aGVyLCBwYXJzZUV0aGVyLCBmb3JtYXRVbml0cywgcGFyc2VVbml0cywgY29tbWlmeSwgY29tcHV0ZUhtYWMsIGtlY2NhazI1NiwgcmlwZW1kMTYwLCBzaGEyNTYsIHNoYTUxMiwgcmFuZG9tQnl0ZXMsIHNodWZmbGVkLCBzb2xpZGl0eVBhY2ssIHNvbGlkaXR5S2VjY2FrMjU2LCBzb2xpZGl0eVNoYTI1Niwgc3BsaXRTaWduYXR1cmUsIGpvaW5TaWduYXR1cmUsIGFjY2Vzc0xpc3RpZnksIHBhcnNlVHJhbnNhY3Rpb24sIHNlcmlhbGl6ZVRyYW5zYWN0aW9uLCBUcmFuc2FjdGlvblR5cGVzLCBnZXRKc29uV2FsbGV0QWRkcmVzcywgY29tcHV0ZUFkZHJlc3MsIHJlY292ZXJBZGRyZXNzLCBjb21wdXRlUHVibGljS2V5LCByZWNvdmVyUHVibGljS2V5LCB2ZXJpZnlNZXNzYWdlLCB2ZXJpZnlUeXBlZERhdGEsIGdldEFjY291bnRQYXRoLCBtbmVtb25pY1RvRW50cm9weSwgZW50cm9weVRvTW5lbW9uaWMsIGlzVmFsaWRNbmVtb25pYywgbW5lbW9uaWNUb1NlZWQsIFxuLy8vLy8vLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBFbnVtc1xuU3VwcG9ydGVkQWxnb3JpdGhtLCBVbmljb2RlTm9ybWFsaXphdGlvbkZvcm0sIFV0ZjhFcnJvclJlYXNvbiwgSW5kZXhlZCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXRpbHMuanMubWFwIiwidmFyIGhhc2ggPSBleHBvcnRzO1xuXG5oYXNoLnV0aWxzID0gcmVxdWlyZSgnLi9oYXNoL3V0aWxzJyk7XG5oYXNoLmNvbW1vbiA9IHJlcXVpcmUoJy4vaGFzaC9jb21tb24nKTtcbmhhc2guc2hhID0gcmVxdWlyZSgnLi9oYXNoL3NoYScpO1xuaGFzaC5yaXBlbWQgPSByZXF1aXJlKCcuL2hhc2gvcmlwZW1kJyk7XG5oYXNoLmhtYWMgPSByZXF1aXJlKCcuL2hhc2gvaG1hYycpO1xuXG4vLyBQcm94eSBoYXNoIGZ1bmN0aW9ucyB0byB0aGUgbWFpbiBvYmplY3Rcbmhhc2guc2hhMSA9IGhhc2guc2hhLnNoYTE7XG5oYXNoLnNoYTI1NiA9IGhhc2guc2hhLnNoYTI1Njtcbmhhc2guc2hhMjI0ID0gaGFzaC5zaGEuc2hhMjI0O1xuaGFzaC5zaGEzODQgPSBoYXNoLnNoYS5zaGEzODQ7XG5oYXNoLnNoYTUxMiA9IGhhc2guc2hhLnNoYTUxMjtcbmhhc2gucmlwZW1kMTYwID0gaGFzaC5yaXBlbWQucmlwZW1kMTYwO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuL3V0aWxzJyk7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnbWluaW1hbGlzdGljLWFzc2VydCcpO1xuXG5mdW5jdGlvbiBCbG9ja0hhc2goKSB7XG4gIHRoaXMucGVuZGluZyA9IG51bGw7XG4gIHRoaXMucGVuZGluZ1RvdGFsID0gMDtcbiAgdGhpcy5ibG9ja1NpemUgPSB0aGlzLmNvbnN0cnVjdG9yLmJsb2NrU2l6ZTtcbiAgdGhpcy5vdXRTaXplID0gdGhpcy5jb25zdHJ1Y3Rvci5vdXRTaXplO1xuICB0aGlzLmhtYWNTdHJlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IuaG1hY1N0cmVuZ3RoO1xuICB0aGlzLnBhZExlbmd0aCA9IHRoaXMuY29uc3RydWN0b3IucGFkTGVuZ3RoIC8gODtcbiAgdGhpcy5lbmRpYW4gPSAnYmlnJztcblxuICB0aGlzLl9kZWx0YTggPSB0aGlzLmJsb2NrU2l6ZSAvIDg7XG4gIHRoaXMuX2RlbHRhMzIgPSB0aGlzLmJsb2NrU2l6ZSAvIDMyO1xufVxuZXhwb3J0cy5CbG9ja0hhc2ggPSBCbG9ja0hhc2g7XG5cbkJsb2NrSGFzaC5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG4gIC8vIENvbnZlcnQgbWVzc2FnZSB0byBhcnJheSwgcGFkIGl0LCBhbmQgam9pbiBpbnRvIDMyYml0IGJsb2Nrc1xuICBtc2cgPSB1dGlscy50b0FycmF5KG1zZywgZW5jKTtcbiAgaWYgKCF0aGlzLnBlbmRpbmcpXG4gICAgdGhpcy5wZW5kaW5nID0gbXNnO1xuICBlbHNlXG4gICAgdGhpcy5wZW5kaW5nID0gdGhpcy5wZW5kaW5nLmNvbmNhdChtc2cpO1xuICB0aGlzLnBlbmRpbmdUb3RhbCArPSBtc2cubGVuZ3RoO1xuXG4gIC8vIEVub3VnaCBkYXRhLCB0cnkgdXBkYXRpbmdcbiAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPj0gdGhpcy5fZGVsdGE4KSB7XG4gICAgbXNnID0gdGhpcy5wZW5kaW5nO1xuXG4gICAgLy8gUHJvY2VzcyBwZW5kaW5nIGRhdGEgaW4gYmxvY2tzXG4gICAgdmFyIHIgPSBtc2cubGVuZ3RoICUgdGhpcy5fZGVsdGE4O1xuICAgIHRoaXMucGVuZGluZyA9IG1zZy5zbGljZShtc2cubGVuZ3RoIC0gciwgbXNnLmxlbmd0aCk7XG4gICAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPT09IDApXG4gICAgICB0aGlzLnBlbmRpbmcgPSBudWxsO1xuXG4gICAgbXNnID0gdXRpbHMuam9pbjMyKG1zZywgMCwgbXNnLmxlbmd0aCAtIHIsIHRoaXMuZW5kaWFuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gdGhpcy5fZGVsdGEzMilcbiAgICAgIHRoaXMuX3VwZGF0ZShtc2csIGksIGkgKyB0aGlzLl9kZWx0YTMyKTtcbiAgfVxuXG4gIHJldHVybiB0aGlzO1xufTtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIHRoaXMudXBkYXRlKHRoaXMuX3BhZCgpKTtcbiAgYXNzZXJ0KHRoaXMucGVuZGluZyA9PT0gbnVsbCk7XG5cbiAgcmV0dXJuIHRoaXMuX2RpZ2VzdChlbmMpO1xufTtcblxuQmxvY2tIYXNoLnByb3RvdHlwZS5fcGFkID0gZnVuY3Rpb24gcGFkKCkge1xuICB2YXIgbGVuID0gdGhpcy5wZW5kaW5nVG90YWw7XG4gIHZhciBieXRlcyA9IHRoaXMuX2RlbHRhODtcbiAgdmFyIGsgPSBieXRlcyAtICgobGVuICsgdGhpcy5wYWRMZW5ndGgpICUgYnl0ZXMpO1xuICB2YXIgcmVzID0gbmV3IEFycmF5KGsgKyB0aGlzLnBhZExlbmd0aCk7XG4gIHJlc1swXSA9IDB4ODA7XG4gIGZvciAodmFyIGkgPSAxOyBpIDwgazsgaSsrKVxuICAgIHJlc1tpXSA9IDA7XG5cbiAgLy8gQXBwZW5kIGxlbmd0aFxuICBsZW4gPDw9IDM7XG4gIGlmICh0aGlzLmVuZGlhbiA9PT0gJ2JpZycpIHtcbiAgICBmb3IgKHZhciB0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG4gICAgICByZXNbaSsrXSA9IDA7XG5cbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAobGVuID4+PiAyNCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDgpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IGxlbiAmIDB4ZmY7XG4gIH0gZWxzZSB7XG4gICAgcmVzW2krK10gPSBsZW4gJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gOCkgJiAweGZmO1xuICAgIHJlc1tpKytdID0gKGxlbiA+Pj4gMTYpICYgMHhmZjtcbiAgICByZXNbaSsrXSA9IChsZW4gPj4+IDI0KSAmIDB4ZmY7XG4gICAgcmVzW2krK10gPSAwO1xuICAgIHJlc1tpKytdID0gMDtcbiAgICByZXNbaSsrXSA9IDA7XG4gICAgcmVzW2krK10gPSAwO1xuXG4gICAgZm9yICh0ID0gODsgdCA8IHRoaXMucGFkTGVuZ3RoOyB0KyspXG4gICAgICByZXNbaSsrXSA9IDA7XG4gIH1cblxuICByZXR1cm4gcmVzO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxuZnVuY3Rpb24gSG1hYyhoYXNoLCBrZXksIGVuYykge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgSG1hYykpXG4gICAgcmV0dXJuIG5ldyBIbWFjKGhhc2gsIGtleSwgZW5jKTtcbiAgdGhpcy5IYXNoID0gaGFzaDtcbiAgdGhpcy5ibG9ja1NpemUgPSBoYXNoLmJsb2NrU2l6ZSAvIDg7XG4gIHRoaXMub3V0U2l6ZSA9IGhhc2gub3V0U2l6ZSAvIDg7XG4gIHRoaXMuaW5uZXIgPSBudWxsO1xuICB0aGlzLm91dGVyID0gbnVsbDtcblxuICB0aGlzLl9pbml0KHV0aWxzLnRvQXJyYXkoa2V5LCBlbmMpKTtcbn1cbm1vZHVsZS5leHBvcnRzID0gSG1hYztcblxuSG1hYy5wcm90b3R5cGUuX2luaXQgPSBmdW5jdGlvbiBpbml0KGtleSkge1xuICAvLyBTaG9ydGVuIGtleSwgaWYgbmVlZGVkXG4gIGlmIChrZXkubGVuZ3RoID4gdGhpcy5ibG9ja1NpemUpXG4gICAga2V5ID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpLmRpZ2VzdCgpO1xuICBhc3NlcnQoa2V5Lmxlbmd0aCA8PSB0aGlzLmJsb2NrU2l6ZSk7XG5cbiAgLy8gQWRkIHBhZGRpbmcgdG8ga2V5XG4gIGZvciAodmFyIGkgPSBrZXkubGVuZ3RoOyBpIDwgdGhpcy5ibG9ja1NpemU7IGkrKylcbiAgICBrZXkucHVzaCgwKTtcblxuICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgIGtleVtpXSBePSAweDM2O1xuICB0aGlzLmlubmVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xuXG4gIC8vIDB4MzYgXiAweDVjID0gMHg2YVxuICBmb3IgKGkgPSAwOyBpIDwga2V5Lmxlbmd0aDsgaSsrKVxuICAgIGtleVtpXSBePSAweDZhO1xuICB0aGlzLm91dGVyID0gbmV3IHRoaXMuSGFzaCgpLnVwZGF0ZShrZXkpO1xufTtcblxuSG1hYy5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlKG1zZywgZW5jKSB7XG4gIHRoaXMuaW5uZXIudXBkYXRlKG1zZywgZW5jKTtcbiAgcmV0dXJuIHRoaXM7XG59O1xuXG5IbWFjLnByb3RvdHlwZS5kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIHRoaXMub3V0ZXIudXBkYXRlKHRoaXMuaW5uZXIuZGlnZXN0KCkpO1xuICByZXR1cm4gdGhpcy5vdXRlci5kaWdlc3QoZW5jKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xuXG52YXIgcm90bDMyID0gdXRpbHMucm90bDMyO1xudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfMyA9IHV0aWxzLnN1bTMyXzM7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxuZnVuY3Rpb24gUklQRU1EMTYwKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgUklQRU1EMTYwKSlcbiAgICByZXR1cm4gbmV3IFJJUEVNRDE2MCgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuXG4gIHRoaXMuaCA9IFsgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NiwgMHhjM2QyZTFmMCBdO1xuICB0aGlzLmVuZGlhbiA9ICdsaXR0bGUnO1xufVxudXRpbHMuaW5oZXJpdHMoUklQRU1EMTYwLCBCbG9ja0hhc2gpO1xuZXhwb3J0cy5yaXBlbWQxNjAgPSBSSVBFTUQxNjA7XG5cblJJUEVNRDE2MC5ibG9ja1NpemUgPSA1MTI7XG5SSVBFTUQxNjAub3V0U2l6ZSA9IDE2MDtcblJJUEVNRDE2MC5obWFjU3RyZW5ndGggPSAxOTI7XG5SSVBFTUQxNjAucGFkTGVuZ3RoID0gNjQ7XG5cblJJUEVNRDE2MC5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uIHVwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHZhciBBID0gdGhpcy5oWzBdO1xuICB2YXIgQiA9IHRoaXMuaFsxXTtcbiAgdmFyIEMgPSB0aGlzLmhbMl07XG4gIHZhciBEID0gdGhpcy5oWzNdO1xuICB2YXIgRSA9IHRoaXMuaFs0XTtcbiAgdmFyIEFoID0gQTtcbiAgdmFyIEJoID0gQjtcbiAgdmFyIENoID0gQztcbiAgdmFyIERoID0gRDtcbiAgdmFyIEVoID0gRTtcbiAgZm9yICh2YXIgaiA9IDA7IGogPCA4MDsgaisrKSB7XG4gICAgdmFyIFQgPSBzdW0zMihcbiAgICAgIHJvdGwzMihcbiAgICAgICAgc3VtMzJfNChBLCBmKGosIEIsIEMsIEQpLCBtc2dbcltqXSArIHN0YXJ0XSwgSyhqKSksXG4gICAgICAgIHNbal0pLFxuICAgICAgRSk7XG4gICAgQSA9IEU7XG4gICAgRSA9IEQ7XG4gICAgRCA9IHJvdGwzMihDLCAxMCk7XG4gICAgQyA9IEI7XG4gICAgQiA9IFQ7XG4gICAgVCA9IHN1bTMyKFxuICAgICAgcm90bDMyKFxuICAgICAgICBzdW0zMl80KEFoLCBmKDc5IC0gaiwgQmgsIENoLCBEaCksIG1zZ1tyaFtqXSArIHN0YXJ0XSwgS2goaikpLFxuICAgICAgICBzaFtqXSksXG4gICAgICBFaCk7XG4gICAgQWggPSBFaDtcbiAgICBFaCA9IERoO1xuICAgIERoID0gcm90bDMyKENoLCAxMCk7XG4gICAgQ2ggPSBCaDtcbiAgICBCaCA9IFQ7XG4gIH1cbiAgVCA9IHN1bTMyXzModGhpcy5oWzFdLCBDLCBEaCk7XG4gIHRoaXMuaFsxXSA9IHN1bTMyXzModGhpcy5oWzJdLCBELCBFaCk7XG4gIHRoaXMuaFsyXSA9IHN1bTMyXzModGhpcy5oWzNdLCBFLCBBaCk7XG4gIHRoaXMuaFszXSA9IHN1bTMyXzModGhpcy5oWzRdLCBBLCBCaCk7XG4gIHRoaXMuaFs0XSA9IHN1bTMyXzModGhpcy5oWzBdLCBCLCBDaCk7XG4gIHRoaXMuaFswXSA9IFQ7XG59O1xuXG5SSVBFTUQxNjAucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2xpdHRsZScpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnbGl0dGxlJyk7XG59O1xuXG5mdW5jdGlvbiBmKGosIHgsIHksIHopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIHggXiB5IF4gejtcbiAgZWxzZSBpZiAoaiA8PSAzMSlcbiAgICByZXR1cm4gKHggJiB5KSB8ICgofngpICYgeik7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuICh4IHwgKH55KSkgXiB6O1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAoeCAmIHopIHwgKHkgJiAofnopKTtcbiAgZWxzZVxuICAgIHJldHVybiB4IF4gKHkgfCAofnopKTtcbn1cblxuZnVuY3Rpb24gSyhqKSB7XG4gIGlmIChqIDw9IDE1KVxuICAgIHJldHVybiAweDAwMDAwMDAwO1xuICBlbHNlIGlmIChqIDw9IDMxKVxuICAgIHJldHVybiAweDVhODI3OTk5O1xuICBlbHNlIGlmIChqIDw9IDQ3KVxuICAgIHJldHVybiAweDZlZDllYmExO1xuICBlbHNlIGlmIChqIDw9IDYzKVxuICAgIHJldHVybiAweDhmMWJiY2RjO1xuICBlbHNlXG4gICAgcmV0dXJuIDB4YTk1M2ZkNGU7XG59XG5cbmZ1bmN0aW9uIEtoKGopIHtcbiAgaWYgKGogPD0gMTUpXG4gICAgcmV0dXJuIDB4NTBhMjhiZTY7XG4gIGVsc2UgaWYgKGogPD0gMzEpXG4gICAgcmV0dXJuIDB4NWM0ZGQxMjQ7XG4gIGVsc2UgaWYgKGogPD0gNDcpXG4gICAgcmV0dXJuIDB4NmQ3MDNlZjM7XG4gIGVsc2UgaWYgKGogPD0gNjMpXG4gICAgcmV0dXJuIDB4N2E2ZDc2ZTk7XG4gIGVsc2VcbiAgICByZXR1cm4gMHgwMDAwMDAwMDtcbn1cblxudmFyIHIgPSBbXG4gIDAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwLCAxMSwgMTIsIDEzLCAxNCwgMTUsXG4gIDcsIDQsIDEzLCAxLCAxMCwgNiwgMTUsIDMsIDEyLCAwLCA5LCA1LCAyLCAxNCwgMTEsIDgsXG4gIDMsIDEwLCAxNCwgNCwgOSwgMTUsIDgsIDEsIDIsIDcsIDAsIDYsIDEzLCAxMSwgNSwgMTIsXG4gIDEsIDksIDExLCAxMCwgMCwgOCwgMTIsIDQsIDEzLCAzLCA3LCAxNSwgMTQsIDUsIDYsIDIsXG4gIDQsIDAsIDUsIDksIDcsIDEyLCAyLCAxMCwgMTQsIDEsIDMsIDgsIDExLCA2LCAxNSwgMTNcbl07XG5cbnZhciByaCA9IFtcbiAgNSwgMTQsIDcsIDAsIDksIDIsIDExLCA0LCAxMywgNiwgMTUsIDgsIDEsIDEwLCAzLCAxMixcbiAgNiwgMTEsIDMsIDcsIDAsIDEzLCA1LCAxMCwgMTQsIDE1LCA4LCAxMiwgNCwgOSwgMSwgMixcbiAgMTUsIDUsIDEsIDMsIDcsIDE0LCA2LCA5LCAxMSwgOCwgMTIsIDIsIDEwLCAwLCA0LCAxMyxcbiAgOCwgNiwgNCwgMSwgMywgMTEsIDE1LCAwLCA1LCAxMiwgMiwgMTMsIDksIDcsIDEwLCAxNCxcbiAgMTIsIDE1LCAxMCwgNCwgMSwgNSwgOCwgNywgNiwgMiwgMTMsIDE0LCAwLCAzLCA5LCAxMVxuXTtcblxudmFyIHMgPSBbXG4gIDExLCAxNCwgMTUsIDEyLCA1LCA4LCA3LCA5LCAxMSwgMTMsIDE0LCAxNSwgNiwgNywgOSwgOCxcbiAgNywgNiwgOCwgMTMsIDExLCA5LCA3LCAxNSwgNywgMTIsIDE1LCA5LCAxMSwgNywgMTMsIDEyLFxuICAxMSwgMTMsIDYsIDcsIDE0LCA5LCAxMywgMTUsIDE0LCA4LCAxMywgNiwgNSwgMTIsIDcsIDUsXG4gIDExLCAxMiwgMTQsIDE1LCAxNCwgMTUsIDksIDgsIDksIDE0LCA1LCA2LCA4LCA2LCA1LCAxMixcbiAgOSwgMTUsIDUsIDExLCA2LCA4LCAxMywgMTIsIDUsIDEyLCAxMywgMTQsIDExLCA4LCA1LCA2XG5dO1xuXG52YXIgc2ggPSBbXG4gIDgsIDksIDksIDExLCAxMywgMTUsIDE1LCA1LCA3LCA3LCA4LCAxMSwgMTQsIDE0LCAxMiwgNixcbiAgOSwgMTMsIDE1LCA3LCAxMiwgOCwgOSwgMTEsIDcsIDcsIDEyLCA3LCA2LCAxNSwgMTMsIDExLFxuICA5LCA3LCAxNSwgMTEsIDgsIDYsIDYsIDE0LCAxMiwgMTMsIDUsIDE0LCAxMywgMTMsIDcsIDUsXG4gIDE1LCA1LCA4LCAxMSwgMTQsIDE0LCA2LCAxNCwgNiwgOSwgMTIsIDksIDEyLCA1LCAxNSwgOCxcbiAgOCwgNSwgMTIsIDksIDEyLCA1LCAxNCwgNiwgOCwgMTMsIDYsIDUsIDE1LCAxMywgMTEsIDExXG5dO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5leHBvcnRzLnNoYTEgPSByZXF1aXJlKCcuL3NoYS8xJyk7XG5leHBvcnRzLnNoYTIyNCA9IHJlcXVpcmUoJy4vc2hhLzIyNCcpO1xuZXhwb3J0cy5zaGEyNTYgPSByZXF1aXJlKCcuL3NoYS8yNTYnKTtcbmV4cG9ydHMuc2hhMzg0ID0gcmVxdWlyZSgnLi9zaGEvMzg0Jyk7XG5leHBvcnRzLnNoYTUxMiA9IHJlcXVpcmUoJy4vc2hhLzUxMicpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIGNvbW1vbiA9IHJlcXVpcmUoJy4uL2NvbW1vbicpO1xudmFyIHNoYUNvbW1vbiA9IHJlcXVpcmUoJy4vY29tbW9uJyk7XG5cbnZhciByb3RsMzIgPSB1dGlscy5yb3RsMzI7XG52YXIgc3VtMzIgPSB1dGlscy5zdW0zMjtcbnZhciBzdW0zMl81ID0gdXRpbHMuc3VtMzJfNTtcbnZhciBmdF8xID0gc2hhQ29tbW9uLmZ0XzE7XG52YXIgQmxvY2tIYXNoID0gY29tbW9uLkJsb2NrSGFzaDtcblxudmFyIHNoYTFfSyA9IFtcbiAgMHg1QTgyNzk5OSwgMHg2RUQ5RUJBMSxcbiAgMHg4RjFCQkNEQywgMHhDQTYyQzFENlxuXTtcblxuZnVuY3Rpb24gU0hBMSgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTEpKVxuICAgIHJldHVybiBuZXcgU0hBMSgpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSwgMHg5OGJhZGNmZSxcbiAgICAweDEwMzI1NDc2LCAweGMzZDJlMWYwIF07XG4gIHRoaXMuVyA9IG5ldyBBcnJheSg4MCk7XG59XG5cbnV0aWxzLmluaGVyaXRzKFNIQTEsIEJsb2NrSGFzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IFNIQTE7XG5cblNIQTEuYmxvY2tTaXplID0gNTEyO1xuU0hBMS5vdXRTaXplID0gMTYwO1xuU0hBMS5obWFjU3RyZW5ndGggPSA4MDtcblNIQTEucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTEucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcblxuICBmb3IoOyBpIDwgVy5sZW5ndGg7IGkrKylcbiAgICBXW2ldID0gcm90bDMyKFdbaSAtIDNdIF4gV1tpIC0gOF0gXiBXW2kgLSAxNF0gXiBXW2kgLSAxNl0sIDEpO1xuXG4gIHZhciBhID0gdGhpcy5oWzBdO1xuICB2YXIgYiA9IHRoaXMuaFsxXTtcbiAgdmFyIGMgPSB0aGlzLmhbMl07XG4gIHZhciBkID0gdGhpcy5oWzNdO1xuICB2YXIgZSA9IHRoaXMuaFs0XTtcblxuICBmb3IgKGkgPSAwOyBpIDwgVy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBzID0gfn4oaSAvIDIwKTtcbiAgICB2YXIgdCA9IHN1bTMyXzUocm90bDMyKGEsIDUpLCBmdF8xKHMsIGIsIGMsIGQpLCBlLCBXW2ldLCBzaGExX0tbc10pO1xuICAgIGUgPSBkO1xuICAgIGQgPSBjO1xuICAgIGMgPSByb3RsMzIoYiwgMzApO1xuICAgIGIgPSBhO1xuICAgIGEgPSB0O1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbn07XG5cblNIQTEucHJvdG90eXBlLl9kaWdlc3QgPSBmdW5jdGlvbiBkaWdlc3QoZW5jKSB7XG4gIGlmIChlbmMgPT09ICdoZXgnKVxuICAgIHJldHVybiB1dGlscy50b0hleDMyKHRoaXMuaCwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLCAnYmlnJyk7XG59O1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIFNIQTI1NiA9IHJlcXVpcmUoJy4vMjU2Jyk7XG5cbmZ1bmN0aW9uIFNIQTIyNCgpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTIyNCkpXG4gICAgcmV0dXJuIG5ldyBTSEEyMjQoKTtcblxuICBTSEEyNTYuY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4YzEwNTllZDgsIDB4MzY3Y2Q1MDcsIDB4MzA3MGRkMTcsIDB4ZjcwZTU5MzksXG4gICAgMHhmZmMwMGIzMSwgMHg2ODU4MTUxMSwgMHg2NGY5OGZhNywgMHhiZWZhNGZhNCBdO1xufVxudXRpbHMuaW5oZXJpdHMoU0hBMjI0LCBTSEEyNTYpO1xubW9kdWxlLmV4cG9ydHMgPSBTSEEyMjQ7XG5cblNIQTIyNC5ibG9ja1NpemUgPSA1MTI7XG5TSEEyMjQub3V0U2l6ZSA9IDIyNDtcblNIQTIyNC5obWFjU3RyZW5ndGggPSAxOTI7XG5TSEEyMjQucGFkTGVuZ3RoID0gNjQ7XG5cblNIQTIyNC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgLy8gSnVzdCB0cnVuY2F0ZSBvdXRwdXRcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDcpLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmguc2xpY2UoMCwgNyksICdiaWcnKTtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBzaGFDb21tb24gPSByZXF1aXJlKCcuL2NvbW1vbicpO1xudmFyIGFzc2VydCA9IHJlcXVpcmUoJ21pbmltYWxpc3RpYy1hc3NlcnQnKTtcblxudmFyIHN1bTMyID0gdXRpbHMuc3VtMzI7XG52YXIgc3VtMzJfNCA9IHV0aWxzLnN1bTMyXzQ7XG52YXIgc3VtMzJfNSA9IHV0aWxzLnN1bTMyXzU7XG52YXIgY2gzMiA9IHNoYUNvbW1vbi5jaDMyO1xudmFyIG1hajMyID0gc2hhQ29tbW9uLm1hajMyO1xudmFyIHMwXzI1NiA9IHNoYUNvbW1vbi5zMF8yNTY7XG52YXIgczFfMjU2ID0gc2hhQ29tbW9uLnMxXzI1NjtcbnZhciBnMF8yNTYgPSBzaGFDb21tb24uZzBfMjU2O1xudmFyIGcxXzI1NiA9IHNoYUNvbW1vbi5nMV8yNTY7XG5cbnZhciBCbG9ja0hhc2ggPSBjb21tb24uQmxvY2tIYXNoO1xuXG52YXIgc2hhMjU2X0sgPSBbXG4gIDB4NDI4YTJmOTgsIDB4NzEzNzQ0OTEsIDB4YjVjMGZiY2YsIDB4ZTliNWRiYTUsXG4gIDB4Mzk1NmMyNWIsIDB4NTlmMTExZjEsIDB4OTIzZjgyYTQsIDB4YWIxYzVlZDUsXG4gIDB4ZDgwN2FhOTgsIDB4MTI4MzViMDEsIDB4MjQzMTg1YmUsIDB4NTUwYzdkYzMsXG4gIDB4NzJiZTVkNzQsIDB4ODBkZWIxZmUsIDB4OWJkYzA2YTcsIDB4YzE5YmYxNzQsXG4gIDB4ZTQ5YjY5YzEsIDB4ZWZiZTQ3ODYsIDB4MGZjMTlkYzYsIDB4MjQwY2ExY2MsXG4gIDB4MmRlOTJjNmYsIDB4NGE3NDg0YWEsIDB4NWNiMGE5ZGMsIDB4NzZmOTg4ZGEsXG4gIDB4OTgzZTUxNTIsIDB4YTgzMWM2NmQsIDB4YjAwMzI3YzgsIDB4YmY1OTdmYzcsXG4gIDB4YzZlMDBiZjMsIDB4ZDVhNzkxNDcsIDB4MDZjYTYzNTEsIDB4MTQyOTI5NjcsXG4gIDB4MjdiNzBhODUsIDB4MmUxYjIxMzgsIDB4NGQyYzZkZmMsIDB4NTMzODBkMTMsXG4gIDB4NjUwYTczNTQsIDB4NzY2YTBhYmIsIDB4ODFjMmM5MmUsIDB4OTI3MjJjODUsXG4gIDB4YTJiZmU4YTEsIDB4YTgxYTY2NGIsIDB4YzI0YjhiNzAsIDB4Yzc2YzUxYTMsXG4gIDB4ZDE5MmU4MTksIDB4ZDY5OTA2MjQsIDB4ZjQwZTM1ODUsIDB4MTA2YWEwNzAsXG4gIDB4MTlhNGMxMTYsIDB4MWUzNzZjMDgsIDB4Mjc0ODc3NGMsIDB4MzRiMGJjYjUsXG4gIDB4MzkxYzBjYjMsIDB4NGVkOGFhNGEsIDB4NWI5Y2NhNGYsIDB4NjgyZTZmZjMsXG4gIDB4NzQ4ZjgyZWUsIDB4NzhhNTYzNmYsIDB4ODRjODc4MTQsIDB4OGNjNzAyMDgsXG4gIDB4OTBiZWZmZmEsIDB4YTQ1MDZjZWIsIDB4YmVmOWEzZjcsIDB4YzY3MTc4ZjJcbl07XG5cbmZ1bmN0aW9uIFNIQTI1NigpIHtcbiAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIFNIQTI1NikpXG4gICAgcmV0dXJuIG5ldyBTSEEyNTYoKTtcblxuICBCbG9ja0hhc2guY2FsbCh0aGlzKTtcbiAgdGhpcy5oID0gW1xuICAgIDB4NmEwOWU2NjcsIDB4YmI2N2FlODUsIDB4M2M2ZWYzNzIsIDB4YTU0ZmY1M2EsXG4gICAgMHg1MTBlNTI3ZiwgMHg5YjA1Njg4YywgMHgxZjgzZDlhYiwgMHg1YmUwY2QxOVxuICBdO1xuICB0aGlzLmsgPSBzaGEyNTZfSztcbiAgdGhpcy5XID0gbmV3IEFycmF5KDY0KTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTI1NiwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMjU2O1xuXG5TSEEyNTYuYmxvY2tTaXplID0gNTEyO1xuU0hBMjU2Lm91dFNpemUgPSAyNTY7XG5TSEEyNTYuaG1hY1N0cmVuZ3RoID0gMTkyO1xuU0hBMjU2LnBhZExlbmd0aCA9IDY0O1xuXG5TSEEyNTYucHJvdG90eXBlLl91cGRhdGUgPSBmdW5jdGlvbiBfdXBkYXRlKG1zZywgc3RhcnQpIHtcbiAgdmFyIFcgPSB0aGlzLlc7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCAxNjsgaSsrKVxuICAgIFdbaV0gPSBtc2dbc3RhcnQgKyBpXTtcbiAgZm9yICg7IGkgPCBXLmxlbmd0aDsgaSsrKVxuICAgIFdbaV0gPSBzdW0zMl80KGcxXzI1NihXW2kgLSAyXSksIFdbaSAtIDddLCBnMF8yNTYoV1tpIC0gMTVdKSwgV1tpIC0gMTZdKTtcblxuICB2YXIgYSA9IHRoaXMuaFswXTtcbiAgdmFyIGIgPSB0aGlzLmhbMV07XG4gIHZhciBjID0gdGhpcy5oWzJdO1xuICB2YXIgZCA9IHRoaXMuaFszXTtcbiAgdmFyIGUgPSB0aGlzLmhbNF07XG4gIHZhciBmID0gdGhpcy5oWzVdO1xuICB2YXIgZyA9IHRoaXMuaFs2XTtcbiAgdmFyIGggPSB0aGlzLmhbN107XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yIChpID0gMDsgaSA8IFcubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgVDEgPSBzdW0zMl81KGgsIHMxXzI1NihlKSwgY2gzMihlLCBmLCBnKSwgdGhpcy5rW2ldLCBXW2ldKTtcbiAgICB2YXIgVDIgPSBzdW0zMihzMF8yNTYoYSksIG1hajMyKGEsIGIsIGMpKTtcbiAgICBoID0gZztcbiAgICBnID0gZjtcbiAgICBmID0gZTtcbiAgICBlID0gc3VtMzIoZCwgVDEpO1xuICAgIGQgPSBjO1xuICAgIGMgPSBiO1xuICAgIGIgPSBhO1xuICAgIGEgPSBzdW0zMihUMSwgVDIpO1xuICB9XG5cbiAgdGhpcy5oWzBdID0gc3VtMzIodGhpcy5oWzBdLCBhKTtcbiAgdGhpcy5oWzFdID0gc3VtMzIodGhpcy5oWzFdLCBiKTtcbiAgdGhpcy5oWzJdID0gc3VtMzIodGhpcy5oWzJdLCBjKTtcbiAgdGhpcy5oWzNdID0gc3VtMzIodGhpcy5oWzNdLCBkKTtcbiAgdGhpcy5oWzRdID0gc3VtMzIodGhpcy5oWzRdLCBlKTtcbiAgdGhpcy5oWzVdID0gc3VtMzIodGhpcy5oWzVdLCBmKTtcbiAgdGhpcy5oWzZdID0gc3VtMzIodGhpcy5oWzZdLCBnKTtcbiAgdGhpcy5oWzddID0gc3VtMzIodGhpcy5oWzddLCBoKTtcbn07XG5cblNIQTI1Ni5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLCAnYmlnJyk7XG4gIGVsc2VcbiAgICByZXR1cm4gdXRpbHMuc3BsaXQzMih0aGlzLmgsICdiaWcnKTtcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4uL3V0aWxzJyk7XG5cbnZhciBTSEE1MTIgPSByZXF1aXJlKCcuLzUxMicpO1xuXG5mdW5jdGlvbiBTSEEzODQoKSB7XG4gIGlmICghKHRoaXMgaW5zdGFuY2VvZiBTSEEzODQpKVxuICAgIHJldHVybiBuZXcgU0hBMzg0KCk7XG5cbiAgU0hBNTEyLmNhbGwodGhpcyk7XG4gIHRoaXMuaCA9IFtcbiAgICAweGNiYmI5ZDVkLCAweGMxMDU5ZWQ4LFxuICAgIDB4NjI5YTI5MmEsIDB4MzY3Y2Q1MDcsXG4gICAgMHg5MTU5MDE1YSwgMHgzMDcwZGQxNyxcbiAgICAweDE1MmZlY2Q4LCAweGY3MGU1OTM5LFxuICAgIDB4NjczMzI2NjcsIDB4ZmZjMDBiMzEsXG4gICAgMHg4ZWI0NGE4NywgMHg2ODU4MTUxMSxcbiAgICAweGRiMGMyZTBkLCAweDY0Zjk4ZmE3LFxuICAgIDB4NDdiNTQ4MWQsIDB4YmVmYTRmYTQgXTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTM4NCwgU0hBNTEyKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBMzg0O1xuXG5TSEEzODQuYmxvY2tTaXplID0gMTAyNDtcblNIQTM4NC5vdXRTaXplID0gMzg0O1xuU0hBMzg0LmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTM4NC5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTM4NC5wcm90b3R5cGUuX2RpZ2VzdCA9IGZ1bmN0aW9uIGRpZ2VzdChlbmMpIHtcbiAgaWYgKGVuYyA9PT0gJ2hleCcpXG4gICAgcmV0dXJuIHV0aWxzLnRvSGV4MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xuICBlbHNlXG4gICAgcmV0dXJuIHV0aWxzLnNwbGl0MzIodGhpcy5oLnNsaWNlKDAsIDEyKSwgJ2JpZycpO1xufTtcbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi4vdXRpbHMnKTtcbnZhciBjb21tb24gPSByZXF1aXJlKCcuLi9jb21tb24nKTtcbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG5cbnZhciByb3RyNjRfaGkgPSB1dGlscy5yb3RyNjRfaGk7XG52YXIgcm90cjY0X2xvID0gdXRpbHMucm90cjY0X2xvO1xudmFyIHNocjY0X2hpID0gdXRpbHMuc2hyNjRfaGk7XG52YXIgc2hyNjRfbG8gPSB1dGlscy5zaHI2NF9sbztcbnZhciBzdW02NCA9IHV0aWxzLnN1bTY0O1xudmFyIHN1bTY0X2hpID0gdXRpbHMuc3VtNjRfaGk7XG52YXIgc3VtNjRfbG8gPSB1dGlscy5zdW02NF9sbztcbnZhciBzdW02NF80X2hpID0gdXRpbHMuc3VtNjRfNF9oaTtcbnZhciBzdW02NF80X2xvID0gdXRpbHMuc3VtNjRfNF9sbztcbnZhciBzdW02NF81X2hpID0gdXRpbHMuc3VtNjRfNV9oaTtcbnZhciBzdW02NF81X2xvID0gdXRpbHMuc3VtNjRfNV9sbztcblxudmFyIEJsb2NrSGFzaCA9IGNvbW1vbi5CbG9ja0hhc2g7XG5cbnZhciBzaGE1MTJfSyA9IFtcbiAgMHg0MjhhMmY5OCwgMHhkNzI4YWUyMiwgMHg3MTM3NDQ5MSwgMHgyM2VmNjVjZCxcbiAgMHhiNWMwZmJjZiwgMHhlYzRkM2IyZiwgMHhlOWI1ZGJhNSwgMHg4MTg5ZGJiYyxcbiAgMHgzOTU2YzI1YiwgMHhmMzQ4YjUzOCwgMHg1OWYxMTFmMSwgMHhiNjA1ZDAxOSxcbiAgMHg5MjNmODJhNCwgMHhhZjE5NGY5YiwgMHhhYjFjNWVkNSwgMHhkYTZkODExOCxcbiAgMHhkODA3YWE5OCwgMHhhMzAzMDI0MiwgMHgxMjgzNWIwMSwgMHg0NTcwNmZiZSxcbiAgMHgyNDMxODViZSwgMHg0ZWU0YjI4YywgMHg1NTBjN2RjMywgMHhkNWZmYjRlMixcbiAgMHg3MmJlNWQ3NCwgMHhmMjdiODk2ZiwgMHg4MGRlYjFmZSwgMHgzYjE2OTZiMSxcbiAgMHg5YmRjMDZhNywgMHgyNWM3MTIzNSwgMHhjMTliZjE3NCwgMHhjZjY5MjY5NCxcbiAgMHhlNDliNjljMSwgMHg5ZWYxNGFkMiwgMHhlZmJlNDc4NiwgMHgzODRmMjVlMyxcbiAgMHgwZmMxOWRjNiwgMHg4YjhjZDViNSwgMHgyNDBjYTFjYywgMHg3N2FjOWM2NSxcbiAgMHgyZGU5MmM2ZiwgMHg1OTJiMDI3NSwgMHg0YTc0ODRhYSwgMHg2ZWE2ZTQ4MyxcbiAgMHg1Y2IwYTlkYywgMHhiZDQxZmJkNCwgMHg3NmY5ODhkYSwgMHg4MzExNTNiNSxcbiAgMHg5ODNlNTE1MiwgMHhlZTY2ZGZhYiwgMHhhODMxYzY2ZCwgMHgyZGI0MzIxMCxcbiAgMHhiMDAzMjdjOCwgMHg5OGZiMjEzZiwgMHhiZjU5N2ZjNywgMHhiZWVmMGVlNCxcbiAgMHhjNmUwMGJmMywgMHgzZGE4OGZjMiwgMHhkNWE3OTE0NywgMHg5MzBhYTcyNSxcbiAgMHgwNmNhNjM1MSwgMHhlMDAzODI2ZiwgMHgxNDI5Mjk2NywgMHgwYTBlNmU3MCxcbiAgMHgyN2I3MGE4NSwgMHg0NmQyMmZmYywgMHgyZTFiMjEzOCwgMHg1YzI2YzkyNixcbiAgMHg0ZDJjNmRmYywgMHg1YWM0MmFlZCwgMHg1MzM4MGQxMywgMHg5ZDk1YjNkZixcbiAgMHg2NTBhNzM1NCwgMHg4YmFmNjNkZSwgMHg3NjZhMGFiYiwgMHgzYzc3YjJhOCxcbiAgMHg4MWMyYzkyZSwgMHg0N2VkYWVlNiwgMHg5MjcyMmM4NSwgMHgxNDgyMzUzYixcbiAgMHhhMmJmZThhMSwgMHg0Y2YxMDM2NCwgMHhhODFhNjY0YiwgMHhiYzQyMzAwMSxcbiAgMHhjMjRiOGI3MCwgMHhkMGY4OTc5MSwgMHhjNzZjNTFhMywgMHgwNjU0YmUzMCxcbiAgMHhkMTkyZTgxOSwgMHhkNmVmNTIxOCwgMHhkNjk5MDYyNCwgMHg1NTY1YTkxMCxcbiAgMHhmNDBlMzU4NSwgMHg1NzcxMjAyYSwgMHgxMDZhYTA3MCwgMHgzMmJiZDFiOCxcbiAgMHgxOWE0YzExNiwgMHhiOGQyZDBjOCwgMHgxZTM3NmMwOCwgMHg1MTQxYWI1MyxcbiAgMHgyNzQ4Nzc0YywgMHhkZjhlZWI5OSwgMHgzNGIwYmNiNSwgMHhlMTliNDhhOCxcbiAgMHgzOTFjMGNiMywgMHhjNWM5NWE2MywgMHg0ZWQ4YWE0YSwgMHhlMzQxOGFjYixcbiAgMHg1YjljY2E0ZiwgMHg3NzYzZTM3MywgMHg2ODJlNmZmMywgMHhkNmIyYjhhMyxcbiAgMHg3NDhmODJlZSwgMHg1ZGVmYjJmYywgMHg3OGE1NjM2ZiwgMHg0MzE3MmY2MCxcbiAgMHg4NGM4NzgxNCwgMHhhMWYwYWI3MiwgMHg4Y2M3MDIwOCwgMHgxYTY0MzllYyxcbiAgMHg5MGJlZmZmYSwgMHgyMzYzMWUyOCwgMHhhNDUwNmNlYiwgMHhkZTgyYmRlOSxcbiAgMHhiZWY5YTNmNywgMHhiMmM2NzkxNSwgMHhjNjcxNzhmMiwgMHhlMzcyNTMyYixcbiAgMHhjYTI3M2VjZSwgMHhlYTI2NjE5YywgMHhkMTg2YjhjNywgMHgyMWMwYzIwNyxcbiAgMHhlYWRhN2RkNiwgMHhjZGUwZWIxZSwgMHhmNTdkNGY3ZiwgMHhlZTZlZDE3OCxcbiAgMHgwNmYwNjdhYSwgMHg3MjE3NmZiYSwgMHgwYTYzN2RjNSwgMHhhMmM4OThhNixcbiAgMHgxMTNmOTgwNCwgMHhiZWY5MGRhZSwgMHgxYjcxMGIzNSwgMHgxMzFjNDcxYixcbiAgMHgyOGRiNzdmNSwgMHgyMzA0N2Q4NCwgMHgzMmNhYWI3YiwgMHg0MGM3MjQ5MyxcbiAgMHgzYzllYmUwYSwgMHgxNWM5YmViYywgMHg0MzFkNjdjNCwgMHg5YzEwMGQ0YyxcbiAgMHg0Y2M1ZDRiZSwgMHhjYjNlNDJiNiwgMHg1OTdmMjk5YywgMHhmYzY1N2UyYSxcbiAgMHg1ZmNiNmZhYiwgMHgzYWQ2ZmFlYywgMHg2YzQ0MTk4YywgMHg0YTQ3NTgxN1xuXTtcblxuZnVuY3Rpb24gU0hBNTEyKCkge1xuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgU0hBNTEyKSlcbiAgICByZXR1cm4gbmV3IFNIQTUxMigpO1xuXG4gIEJsb2NrSGFzaC5jYWxsKHRoaXMpO1xuICB0aGlzLmggPSBbXG4gICAgMHg2YTA5ZTY2NywgMHhmM2JjYzkwOCxcbiAgICAweGJiNjdhZTg1LCAweDg0Y2FhNzNiLFxuICAgIDB4M2M2ZWYzNzIsIDB4ZmU5NGY4MmIsXG4gICAgMHhhNTRmZjUzYSwgMHg1ZjFkMzZmMSxcbiAgICAweDUxMGU1MjdmLCAweGFkZTY4MmQxLFxuICAgIDB4OWIwNTY4OGMsIDB4MmIzZTZjMWYsXG4gICAgMHgxZjgzZDlhYiwgMHhmYjQxYmQ2YixcbiAgICAweDViZTBjZDE5LCAweDEzN2UyMTc5IF07XG4gIHRoaXMuayA9IHNoYTUxMl9LO1xuICB0aGlzLlcgPSBuZXcgQXJyYXkoMTYwKTtcbn1cbnV0aWxzLmluaGVyaXRzKFNIQTUxMiwgQmxvY2tIYXNoKTtcbm1vZHVsZS5leHBvcnRzID0gU0hBNTEyO1xuXG5TSEE1MTIuYmxvY2tTaXplID0gMTAyNDtcblNIQTUxMi5vdXRTaXplID0gNTEyO1xuU0hBNTEyLmhtYWNTdHJlbmd0aCA9IDE5MjtcblNIQTUxMi5wYWRMZW5ndGggPSAxMjg7XG5cblNIQTUxMi5wcm90b3R5cGUuX3ByZXBhcmVCbG9jayA9IGZ1bmN0aW9uIF9wcmVwYXJlQmxvY2sobXNnLCBzdGFydCkge1xuICB2YXIgVyA9IHRoaXMuVztcblxuICAvLyAzMiB4IDMyYml0IHdvcmRzXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgMzI7IGkrKylcbiAgICBXW2ldID0gbXNnW3N0YXJ0ICsgaV07XG4gIGZvciAoOyBpIDwgVy5sZW5ndGg7IGkgKz0gMikge1xuICAgIHZhciBjMF9oaSA9IGcxXzUxMl9oaShXW2kgLSA0XSwgV1tpIC0gM10pOyAgLy8gaSAtIDJcbiAgICB2YXIgYzBfbG8gPSBnMV81MTJfbG8oV1tpIC0gNF0sIFdbaSAtIDNdKTtcbiAgICB2YXIgYzFfaGkgPSBXW2kgLSAxNF07ICAvLyBpIC0gN1xuICAgIHZhciBjMV9sbyA9IFdbaSAtIDEzXTtcbiAgICB2YXIgYzJfaGkgPSBnMF81MTJfaGkoV1tpIC0gMzBdLCBXW2kgLSAyOV0pOyAgLy8gaSAtIDE1XG4gICAgdmFyIGMyX2xvID0gZzBfNTEyX2xvKFdbaSAtIDMwXSwgV1tpIC0gMjldKTtcbiAgICB2YXIgYzNfaGkgPSBXW2kgLSAzMl07ICAvLyBpIC0gMTZcbiAgICB2YXIgYzNfbG8gPSBXW2kgLSAzMV07XG5cbiAgICBXW2ldID0gc3VtNjRfNF9oaShcbiAgICAgIGMwX2hpLCBjMF9sbyxcbiAgICAgIGMxX2hpLCBjMV9sbyxcbiAgICAgIGMyX2hpLCBjMl9sbyxcbiAgICAgIGMzX2hpLCBjM19sbyk7XG4gICAgV1tpICsgMV0gPSBzdW02NF80X2xvKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvKTtcbiAgfVxufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fdXBkYXRlID0gZnVuY3Rpb24gX3VwZGF0ZShtc2csIHN0YXJ0KSB7XG4gIHRoaXMuX3ByZXBhcmVCbG9jayhtc2csIHN0YXJ0KTtcblxuICB2YXIgVyA9IHRoaXMuVztcblxuICB2YXIgYWggPSB0aGlzLmhbMF07XG4gIHZhciBhbCA9IHRoaXMuaFsxXTtcbiAgdmFyIGJoID0gdGhpcy5oWzJdO1xuICB2YXIgYmwgPSB0aGlzLmhbM107XG4gIHZhciBjaCA9IHRoaXMuaFs0XTtcbiAgdmFyIGNsID0gdGhpcy5oWzVdO1xuICB2YXIgZGggPSB0aGlzLmhbNl07XG4gIHZhciBkbCA9IHRoaXMuaFs3XTtcbiAgdmFyIGVoID0gdGhpcy5oWzhdO1xuICB2YXIgZWwgPSB0aGlzLmhbOV07XG4gIHZhciBmaCA9IHRoaXMuaFsxMF07XG4gIHZhciBmbCA9IHRoaXMuaFsxMV07XG4gIHZhciBnaCA9IHRoaXMuaFsxMl07XG4gIHZhciBnbCA9IHRoaXMuaFsxM107XG4gIHZhciBoaCA9IHRoaXMuaFsxNF07XG4gIHZhciBobCA9IHRoaXMuaFsxNV07XG5cbiAgYXNzZXJ0KHRoaXMuay5sZW5ndGggPT09IFcubGVuZ3RoKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBXLmxlbmd0aDsgaSArPSAyKSB7XG4gICAgdmFyIGMwX2hpID0gaGg7XG4gICAgdmFyIGMwX2xvID0gaGw7XG4gICAgdmFyIGMxX2hpID0gczFfNTEyX2hpKGVoLCBlbCk7XG4gICAgdmFyIGMxX2xvID0gczFfNTEyX2xvKGVoLCBlbCk7XG4gICAgdmFyIGMyX2hpID0gY2g2NF9oaShlaCwgZWwsIGZoLCBmbCwgZ2gsIGdsKTtcbiAgICB2YXIgYzJfbG8gPSBjaDY0X2xvKGVoLCBlbCwgZmgsIGZsLCBnaCwgZ2wpO1xuICAgIHZhciBjM19oaSA9IHRoaXMua1tpXTtcbiAgICB2YXIgYzNfbG8gPSB0aGlzLmtbaSArIDFdO1xuICAgIHZhciBjNF9oaSA9IFdbaV07XG4gICAgdmFyIGM0X2xvID0gV1tpICsgMV07XG5cbiAgICB2YXIgVDFfaGkgPSBzdW02NF81X2hpKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgYzRfaGksIGM0X2xvKTtcbiAgICB2YXIgVDFfbG8gPSBzdW02NF81X2xvKFxuICAgICAgYzBfaGksIGMwX2xvLFxuICAgICAgYzFfaGksIGMxX2xvLFxuICAgICAgYzJfaGksIGMyX2xvLFxuICAgICAgYzNfaGksIGMzX2xvLFxuICAgICAgYzRfaGksIGM0X2xvKTtcblxuICAgIGMwX2hpID0gczBfNTEyX2hpKGFoLCBhbCk7XG4gICAgYzBfbG8gPSBzMF81MTJfbG8oYWgsIGFsKTtcbiAgICBjMV9oaSA9IG1hajY0X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wpO1xuICAgIGMxX2xvID0gbWFqNjRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCk7XG5cbiAgICB2YXIgVDJfaGkgPSBzdW02NF9oaShjMF9oaSwgYzBfbG8sIGMxX2hpLCBjMV9sbyk7XG4gICAgdmFyIFQyX2xvID0gc3VtNjRfbG8oYzBfaGksIGMwX2xvLCBjMV9oaSwgYzFfbG8pO1xuXG4gICAgaGggPSBnaDtcbiAgICBobCA9IGdsO1xuXG4gICAgZ2ggPSBmaDtcbiAgICBnbCA9IGZsO1xuXG4gICAgZmggPSBlaDtcbiAgICBmbCA9IGVsO1xuXG4gICAgZWggPSBzdW02NF9oaShkaCwgZGwsIFQxX2hpLCBUMV9sbyk7XG4gICAgZWwgPSBzdW02NF9sbyhkbCwgZGwsIFQxX2hpLCBUMV9sbyk7XG5cbiAgICBkaCA9IGNoO1xuICAgIGRsID0gY2w7XG5cbiAgICBjaCA9IGJoO1xuICAgIGNsID0gYmw7XG5cbiAgICBiaCA9IGFoO1xuICAgIGJsID0gYWw7XG5cbiAgICBhaCA9IHN1bTY0X2hpKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgICBhbCA9IHN1bTY0X2xvKFQxX2hpLCBUMV9sbywgVDJfaGksIFQyX2xvKTtcbiAgfVxuXG4gIHN1bTY0KHRoaXMuaCwgMCwgYWgsIGFsKTtcbiAgc3VtNjQodGhpcy5oLCAyLCBiaCwgYmwpO1xuICBzdW02NCh0aGlzLmgsIDQsIGNoLCBjbCk7XG4gIHN1bTY0KHRoaXMuaCwgNiwgZGgsIGRsKTtcbiAgc3VtNjQodGhpcy5oLCA4LCBlaCwgZWwpO1xuICBzdW02NCh0aGlzLmgsIDEwLCBmaCwgZmwpO1xuICBzdW02NCh0aGlzLmgsIDEyLCBnaCwgZ2wpO1xuICBzdW02NCh0aGlzLmgsIDE0LCBoaCwgaGwpO1xufTtcblxuU0hBNTEyLnByb3RvdHlwZS5fZGlnZXN0ID0gZnVuY3Rpb24gZGlnZXN0KGVuYykge1xuICBpZiAoZW5jID09PSAnaGV4JylcbiAgICByZXR1cm4gdXRpbHMudG9IZXgzMih0aGlzLmgsICdiaWcnKTtcbiAgZWxzZVxuICAgIHJldHVybiB1dGlscy5zcGxpdDMyKHRoaXMuaCwgJ2JpZycpO1xufTtcblxuZnVuY3Rpb24gY2g2NF9oaSh4aCwgeGwsIHloLCB5bCwgemgpIHtcbiAgdmFyIHIgPSAoeGggJiB5aCkgXiAoKH54aCkgJiB6aCk7XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gY2g2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKCh+eGwpICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIG1hajY0X2hpKHhoLCB4bCwgeWgsIHlsLCB6aCkge1xuICB2YXIgciA9ICh4aCAmIHloKSBeICh4aCAmIHpoKSBeICh5aCAmIHpoKTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBtYWo2NF9sbyh4aCwgeGwsIHloLCB5bCwgemgsIHpsKSB7XG4gIHZhciByID0gKHhsICYgeWwpIF4gKHhsICYgemwpIF4gKHlsICYgemwpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMwXzUxMl9oaSh4aCwgeGwpIHtcbiAgdmFyIGMwX2hpID0gcm90cjY0X2hpKHhoLCB4bCwgMjgpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGwsIHhoLCAyKTsgIC8vIDM0XG4gIHZhciBjMl9oaSA9IHJvdHI2NF9oaSh4bCwgeGgsIDcpOyAgLy8gMzlcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBzMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDI4KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMik7ICAvLyAzNFxuICB2YXIgYzJfbG8gPSByb3RyNjRfbG8oeGwsIHhoLCA3KTsgIC8vIDM5XG5cbiAgdmFyIHIgPSBjMF9sbyBeIGMxX2xvIF4gYzJfbG87XG4gIGlmIChyIDwgMClcbiAgICByICs9IDB4MTAwMDAwMDAwO1xuICByZXR1cm4gcjtcbn1cblxuZnVuY3Rpb24gczFfNTEyX2hpKHhoLCB4bCkge1xuICB2YXIgYzBfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCAxNCk7XG4gIHZhciBjMV9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE4KTtcbiAgdmFyIGMyX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgOSk7ICAvLyA0MVxuXG4gIHZhciByID0gYzBfaGkgXiBjMV9oaSBeIGMyX2hpO1xuICBpZiAociA8IDApXG4gICAgciArPSAweDEwMDAwMDAwMDtcbiAgcmV0dXJuIHI7XG59XG5cbmZ1bmN0aW9uIHMxXzUxMl9sbyh4aCwgeGwpIHtcbiAgdmFyIGMwX2xvID0gcm90cjY0X2xvKHhoLCB4bCwgMTQpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCAxOCk7XG4gIHZhciBjMl9sbyA9IHJvdHI2NF9sbyh4bCwgeGgsIDkpOyAgLy8gNDFcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDEpO1xuICB2YXIgYzFfaGkgPSByb3RyNjRfaGkoeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMF81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDEpO1xuICB2YXIgYzFfbG8gPSByb3RyNjRfbG8oeGgsIHhsLCA4KTtcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA3KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfaGkoeGgsIHhsKSB7XG4gIHZhciBjMF9oaSA9IHJvdHI2NF9oaSh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2hpID0gcm90cjY0X2hpKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2hpID0gc2hyNjRfaGkoeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2hpIF4gYzFfaGkgXiBjMl9oaTtcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuXG5mdW5jdGlvbiBnMV81MTJfbG8oeGgsIHhsKSB7XG4gIHZhciBjMF9sbyA9IHJvdHI2NF9sbyh4aCwgeGwsIDE5KTtcbiAgdmFyIGMxX2xvID0gcm90cjY0X2xvKHhsLCB4aCwgMjkpOyAgLy8gNjFcbiAgdmFyIGMyX2xvID0gc2hyNjRfbG8oeGgsIHhsLCA2KTtcblxuICB2YXIgciA9IGMwX2xvIF4gYzFfbG8gXiBjMl9sbztcbiAgaWYgKHIgPCAwKVxuICAgIHIgKz0gMHgxMDAwMDAwMDA7XG4gIHJldHVybiByO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xudmFyIHJvdHIzMiA9IHV0aWxzLnJvdHIzMjtcblxuZnVuY3Rpb24gZnRfMShzLCB4LCB5LCB6KSB7XG4gIGlmIChzID09PSAwKVxuICAgIHJldHVybiBjaDMyKHgsIHksIHopO1xuICBpZiAocyA9PT0gMSB8fCBzID09PSAzKVxuICAgIHJldHVybiBwMzIoeCwgeSwgeik7XG4gIGlmIChzID09PSAyKVxuICAgIHJldHVybiBtYWozMih4LCB5LCB6KTtcbn1cbmV4cG9ydHMuZnRfMSA9IGZ0XzE7XG5cbmZ1bmN0aW9uIGNoMzIoeCwgeSwgeikge1xuICByZXR1cm4gKHggJiB5KSBeICgofngpICYgeik7XG59XG5leHBvcnRzLmNoMzIgPSBjaDMyO1xuXG5mdW5jdGlvbiBtYWozMih4LCB5LCB6KSB7XG4gIHJldHVybiAoeCAmIHkpIF4gKHggJiB6KSBeICh5ICYgeik7XG59XG5leHBvcnRzLm1hajMyID0gbWFqMzI7XG5cbmZ1bmN0aW9uIHAzMih4LCB5LCB6KSB7XG4gIHJldHVybiB4IF4geSBeIHo7XG59XG5leHBvcnRzLnAzMiA9IHAzMjtcblxuZnVuY3Rpb24gczBfMjU2KHgpIHtcbiAgcmV0dXJuIHJvdHIzMih4LCAyKSBeIHJvdHIzMih4LCAxMykgXiByb3RyMzIoeCwgMjIpO1xufVxuZXhwb3J0cy5zMF8yNTYgPSBzMF8yNTY7XG5cbmZ1bmN0aW9uIHMxXzI1Nih4KSB7XG4gIHJldHVybiByb3RyMzIoeCwgNikgXiByb3RyMzIoeCwgMTEpIF4gcm90cjMyKHgsIDI1KTtcbn1cbmV4cG9ydHMuczFfMjU2ID0gczFfMjU2O1xuXG5mdW5jdGlvbiBnMF8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDcpIF4gcm90cjMyKHgsIDE4KSBeICh4ID4+PiAzKTtcbn1cbmV4cG9ydHMuZzBfMjU2ID0gZzBfMjU2O1xuXG5mdW5jdGlvbiBnMV8yNTYoeCkge1xuICByZXR1cm4gcm90cjMyKHgsIDE3KSBeIHJvdHIzMih4LCAxOSkgXiAoeCA+Pj4gMTApO1xufVxuZXhwb3J0cy5nMV8yNTYgPSBnMV8yNTY7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciBhc3NlcnQgPSByZXF1aXJlKCdtaW5pbWFsaXN0aWMtYXNzZXJ0Jyk7XG52YXIgaW5oZXJpdHMgPSByZXF1aXJlKCdpbmhlcml0cycpO1xuXG5leHBvcnRzLmluaGVyaXRzID0gaW5oZXJpdHM7XG5cbmZ1bmN0aW9uIGlzU3Vycm9nYXRlUGFpcihtc2csIGkpIHtcbiAgaWYgKChtc2cuY2hhckNvZGVBdChpKSAmIDB4RkMwMCkgIT09IDB4RDgwMCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoaSA8IDAgfHwgaSArIDEgPj0gbXNnLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKG1zZy5jaGFyQ29kZUF0KGkgKyAxKSAmIDB4RkMwMCkgPT09IDB4REMwMDtcbn1cblxuZnVuY3Rpb24gdG9BcnJheShtc2csIGVuYykge1xuICBpZiAoQXJyYXkuaXNBcnJheShtc2cpKVxuICAgIHJldHVybiBtc2cuc2xpY2UoKTtcbiAgaWYgKCFtc2cpXG4gICAgcmV0dXJuIFtdO1xuICB2YXIgcmVzID0gW107XG4gIGlmICh0eXBlb2YgbXNnID09PSAnc3RyaW5nJykge1xuICAgIGlmICghZW5jKSB7XG4gICAgICAvLyBJbnNwaXJlZCBieSBzdHJpbmdUb1V0ZjhCeXRlQXJyYXkoKSBpbiBjbG9zdXJlLWxpYnJhcnkgYnkgR29vZ2xlXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iLzg1OThkODcyNDJhZjU5YWFjMjMzMjcwNzQyYzg5ODRlMmIyYmRiZTAvY2xvc3VyZS9nb29nL2NyeXB0L2NyeXB0LmpzI0wxMTctTDE0M1xuICAgICAgLy8gQXBhY2hlIExpY2Vuc2UgMi4wXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZ29vZ2xlL2Nsb3N1cmUtbGlicmFyeS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gICAgICB2YXIgcCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgYyA9IG1zZy5jaGFyQ29kZUF0KGkpO1xuICAgICAgICBpZiAoYyA8IDEyOCkge1xuICAgICAgICAgIHJlc1twKytdID0gYztcbiAgICAgICAgfSBlbHNlIGlmIChjIDwgMjA0OCkge1xuICAgICAgICAgIHJlc1twKytdID0gKGMgPj4gNikgfCAxOTI7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfSBlbHNlIGlmIChpc1N1cnJvZ2F0ZVBhaXIobXNnLCBpKSkge1xuICAgICAgICAgIGMgPSAweDEwMDAwICsgKChjICYgMHgwM0ZGKSA8PCAxMCkgKyAobXNnLmNoYXJDb2RlQXQoKytpKSAmIDB4MDNGRik7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiAxOCkgfCAyNDA7XG4gICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gMTIpICYgNjMpIHwgMTI4O1xuICAgICAgICAgIHJlc1twKytdID0gKChjID4+IDYpICYgNjMpIHwgMTI4O1xuICAgICAgICAgIHJlc1twKytdID0gKGMgJiA2MykgfCAxMjg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyA+PiAxMikgfCAyMjQ7XG4gICAgICAgICAgcmVzW3ArK10gPSAoKGMgPj4gNikgJiA2MykgfCAxMjg7XG4gICAgICAgICAgcmVzW3ArK10gPSAoYyAmIDYzKSB8IDEyODtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoZW5jID09PSAnaGV4Jykge1xuICAgICAgbXNnID0gbXNnLnJlcGxhY2UoL1teYS16MC05XSsvaWcsICcnKTtcbiAgICAgIGlmIChtc2cubGVuZ3RoICUgMiAhPT0gMClcbiAgICAgICAgbXNnID0gJzAnICsgbXNnO1xuICAgICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkgKz0gMilcbiAgICAgICAgcmVzLnB1c2gocGFyc2VJbnQobXNnW2ldICsgbXNnW2kgKyAxXSwgMTYpKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgZm9yIChpID0gMDsgaSA8IG1zZy5sZW5ndGg7IGkrKylcbiAgICAgIHJlc1tpXSA9IG1zZ1tpXSB8IDA7XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9BcnJheSA9IHRvQXJyYXk7XG5cbmZ1bmN0aW9uIHRvSGV4KG1zZykge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrKVxuICAgIHJlcyArPSB6ZXJvMihtc2dbaV0udG9TdHJpbmcoMTYpKTtcbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMudG9IZXggPSB0b0hleDtcblxuZnVuY3Rpb24gaHRvbmwodykge1xuICB2YXIgcmVzID0gKHcgPj4+IDI0KSB8XG4gICAgICAgICAgICAoKHcgPj4+IDgpICYgMHhmZjAwKSB8XG4gICAgICAgICAgICAoKHcgPDwgOCkgJiAweGZmMDAwMCkgfFxuICAgICAgICAgICAgKCh3ICYgMHhmZikgPDwgMjQpO1xuICByZXR1cm4gcmVzID4+PiAwO1xufVxuZXhwb3J0cy5odG9ubCA9IGh0b25sO1xuXG5mdW5jdGlvbiB0b0hleDMyKG1zZywgZW5kaWFuKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtc2cubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgdyA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnbGl0dGxlJylcbiAgICAgIHcgPSBodG9ubCh3KTtcbiAgICByZXMgKz0gemVybzgody50b1N0cmluZygxNikpO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLnRvSGV4MzIgPSB0b0hleDMyO1xuXG5mdW5jdGlvbiB6ZXJvMih3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxuZXhwb3J0cy56ZXJvMiA9IHplcm8yO1xuXG5mdW5jdGlvbiB6ZXJvOCh3b3JkKSB7XG4gIGlmICh3b3JkLmxlbmd0aCA9PT0gNylcbiAgICByZXR1cm4gJzAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDYpXG4gICAgcmV0dXJuICcwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNSlcbiAgICByZXR1cm4gJzAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gNClcbiAgICByZXR1cm4gJzAwMDAnICsgd29yZDtcbiAgZWxzZSBpZiAod29yZC5sZW5ndGggPT09IDMpXG4gICAgcmV0dXJuICcwMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMilcbiAgICByZXR1cm4gJzAwMDAwMCcgKyB3b3JkO1xuICBlbHNlIGlmICh3b3JkLmxlbmd0aCA9PT0gMSlcbiAgICByZXR1cm4gJzAwMDAwMDAnICsgd29yZDtcbiAgZWxzZVxuICAgIHJldHVybiB3b3JkO1xufVxuZXhwb3J0cy56ZXJvOCA9IHplcm84O1xuXG5mdW5jdGlvbiBqb2luMzIobXNnLCBzdGFydCwgZW5kLCBlbmRpYW4pIHtcbiAgdmFyIGxlbiA9IGVuZCAtIHN0YXJ0O1xuICBhc3NlcnQobGVuICUgNCA9PT0gMCk7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuIC8gNCk7XG4gIGZvciAodmFyIGkgPSAwLCBrID0gc3RhcnQ7IGkgPCByZXMubGVuZ3RoOyBpKyssIGsgKz0gNCkge1xuICAgIHZhciB3O1xuICAgIGlmIChlbmRpYW4gPT09ICdiaWcnKVxuICAgICAgdyA9IChtc2dba10gPDwgMjQpIHwgKG1zZ1trICsgMV0gPDwgMTYpIHwgKG1zZ1trICsgMl0gPDwgOCkgfCBtc2dbayArIDNdO1xuICAgIGVsc2VcbiAgICAgIHcgPSAobXNnW2sgKyAzXSA8PCAyNCkgfCAobXNnW2sgKyAyXSA8PCAxNikgfCAobXNnW2sgKyAxXSA8PCA4KSB8IG1zZ1trXTtcbiAgICByZXNbaV0gPSB3ID4+PiAwO1xuICB9XG4gIHJldHVybiByZXM7XG59XG5leHBvcnRzLmpvaW4zMiA9IGpvaW4zMjtcblxuZnVuY3Rpb24gc3BsaXQzMihtc2csIGVuZGlhbikge1xuICB2YXIgcmVzID0gbmV3IEFycmF5KG1zZy5sZW5ndGggKiA0KTtcbiAgZm9yICh2YXIgaSA9IDAsIGsgPSAwOyBpIDwgbXNnLmxlbmd0aDsgaSsrLCBrICs9IDQpIHtcbiAgICB2YXIgbSA9IG1zZ1tpXTtcbiAgICBpZiAoZW5kaWFuID09PSAnYmlnJykge1xuICAgICAgcmVzW2tdID0gbSA+Pj4gMjQ7XG4gICAgICByZXNbayArIDFdID0gKG0gPj4+IDE2KSAmIDB4ZmY7XG4gICAgICByZXNbayArIDJdID0gKG0gPj4+IDgpICYgMHhmZjtcbiAgICAgIHJlc1trICsgM10gPSBtICYgMHhmZjtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2sgKyAzXSA9IG0gPj4+IDI0O1xuICAgICAgcmVzW2sgKyAyXSA9IChtID4+PiAxNikgJiAweGZmO1xuICAgICAgcmVzW2sgKyAxXSA9IChtID4+PiA4KSAmIDB4ZmY7XG4gICAgICByZXNba10gPSBtICYgMHhmZjtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlcztcbn1cbmV4cG9ydHMuc3BsaXQzMiA9IHNwbGl0MzI7XG5cbmZ1bmN0aW9uIHJvdHIzMih3LCBiKSB7XG4gIHJldHVybiAodyA+Pj4gYikgfCAodyA8PCAoMzIgLSBiKSk7XG59XG5leHBvcnRzLnJvdHIzMiA9IHJvdHIzMjtcblxuZnVuY3Rpb24gcm90bDMyKHcsIGIpIHtcbiAgcmV0dXJuICh3IDw8IGIpIHwgKHcgPj4+ICgzMiAtIGIpKTtcbn1cbmV4cG9ydHMucm90bDMyID0gcm90bDMyO1xuXG5mdW5jdGlvbiBzdW0zMihhLCBiKSB7XG4gIHJldHVybiAoYSArIGIpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMiA9IHN1bTMyO1xuXG5mdW5jdGlvbiBzdW0zMl8zKGEsIGIsIGMpIHtcbiAgcmV0dXJuIChhICsgYiArIGMpID4+PiAwO1xufVxuZXhwb3J0cy5zdW0zMl8zID0gc3VtMzJfMztcblxuZnVuY3Rpb24gc3VtMzJfNChhLCBiLCBjLCBkKSB7XG4gIHJldHVybiAoYSArIGIgKyBjICsgZCkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzQgPSBzdW0zMl80O1xuXG5mdW5jdGlvbiBzdW0zMl81KGEsIGIsIGMsIGQsIGUpIHtcbiAgcmV0dXJuIChhICsgYiArIGMgKyBkICsgZSkgPj4+IDA7XG59XG5leHBvcnRzLnN1bTMyXzUgPSBzdW0zMl81O1xuXG5mdW5jdGlvbiBzdW02NChidWYsIHBvcywgYWgsIGFsKSB7XG4gIHZhciBiaCA9IGJ1Zltwb3NdO1xuICB2YXIgYmwgPSBidWZbcG9zICsgMV07XG5cbiAgdmFyIGxvID0gKGFsICsgYmwpID4+PiAwO1xuICB2YXIgaGkgPSAobG8gPCBhbCA/IDEgOiAwKSArIGFoICsgYmg7XG4gIGJ1Zltwb3NdID0gaGkgPj4+IDA7XG4gIGJ1Zltwb3MgKyAxXSA9IGxvO1xufVxuZXhwb3J0cy5zdW02NCA9IHN1bTY0O1xuXG5mdW5jdGlvbiBzdW02NF9oaShhaCwgYWwsIGJoLCBibCkge1xuICB2YXIgbG8gPSAoYWwgKyBibCkgPj4+IDA7XG4gIHZhciBoaSA9IChsbyA8IGFsID8gMSA6IDApICsgYWggKyBiaDtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF9oaSA9IHN1bTY0X2hpO1xuXG5mdW5jdGlvbiBzdW02NF9sbyhhaCwgYWwsIGJoLCBibCkge1xuICB2YXIgbG8gPSBhbCArIGJsO1xuICByZXR1cm4gbG8gPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0X2xvID0gc3VtNjRfbG87XG5cbmZ1bmN0aW9uIHN1bTY0XzRfaGkoYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBsbyA9IGFsO1xuICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuXG4gIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgY2Fycnk7XG4gIHJldHVybiBoaSA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNF9oaSA9IHN1bTY0XzRfaGk7XG5cbmZ1bmN0aW9uIHN1bTY0XzRfbG8oYWgsIGFsLCBiaCwgYmwsIGNoLCBjbCwgZGgsIGRsKSB7XG4gIHZhciBsbyA9IGFsICsgYmwgKyBjbCArIGRsO1xuICByZXR1cm4gbG8gPj4+IDA7XG59XG5leHBvcnRzLnN1bTY0XzRfbG8gPSBzdW02NF80X2xvO1xuXG5mdW5jdGlvbiBzdW02NF81X2hpKGFoLCBhbCwgYmgsIGJsLCBjaCwgY2wsIGRoLCBkbCwgZWgsIGVsKSB7XG4gIHZhciBjYXJyeSA9IDA7XG4gIHZhciBsbyA9IGFsO1xuICBsbyA9IChsbyArIGJsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBhbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGNsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBjbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGRsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBkbCA/IDEgOiAwO1xuICBsbyA9IChsbyArIGVsKSA+Pj4gMDtcbiAgY2FycnkgKz0gbG8gPCBlbCA/IDEgOiAwO1xuXG4gIHZhciBoaSA9IGFoICsgYmggKyBjaCArIGRoICsgZWggKyBjYXJyeTtcbiAgcmV0dXJuIGhpID4+PiAwO1xufVxuZXhwb3J0cy5zdW02NF81X2hpID0gc3VtNjRfNV9oaTtcblxuZnVuY3Rpb24gc3VtNjRfNV9sbyhhaCwgYWwsIGJoLCBibCwgY2gsIGNsLCBkaCwgZGwsIGVoLCBlbCkge1xuICB2YXIgbG8gPSBhbCArIGJsICsgY2wgKyBkbCArIGVsO1xuXG4gIHJldHVybiBsbyA+Pj4gMDtcbn1cbmV4cG9ydHMuc3VtNjRfNV9sbyA9IHN1bTY0XzVfbG87XG5cbmZ1bmN0aW9uIHJvdHI2NF9oaShhaCwgYWwsIG51bSkge1xuICB2YXIgciA9IChhbCA8PCAoMzIgLSBudW0pKSB8IChhaCA+Pj4gbnVtKTtcbiAgcmV0dXJuIHIgPj4+IDA7XG59XG5leHBvcnRzLnJvdHI2NF9oaSA9IHJvdHI2NF9oaTtcblxuZnVuY3Rpb24gcm90cjY0X2xvKGFoLCBhbCwgbnVtKSB7XG4gIHZhciByID0gKGFoIDw8ICgzMiAtIG51bSkpIHwgKGFsID4+PiBudW0pO1xuICByZXR1cm4gciA+Pj4gMDtcbn1cbmV4cG9ydHMucm90cjY0X2xvID0gcm90cjY0X2xvO1xuXG5mdW5jdGlvbiBzaHI2NF9oaShhaCwgYWwsIG51bSkge1xuICByZXR1cm4gYWggPj4+IG51bTtcbn1cbmV4cG9ydHMuc2hyNjRfaGkgPSBzaHI2NF9oaTtcblxuZnVuY3Rpb24gc2hyNjRfbG8oYWgsIGFsLCBudW0pIHtcbiAgdmFyIHIgPSAoYWggPDwgKDMyIC0gbnVtKSkgfCAoYWwgPj4+IG51bSk7XG4gIHJldHVybiByID4+PiAwO1xufVxuZXhwb3J0cy5zaHI2NF9sbyA9IHNocjY0X2xvO1xuIiwiaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIGltcGxlbWVudGF0aW9uIGZyb20gc3RhbmRhcmQgbm9kZS5qcyAndXRpbCcgbW9kdWxlXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5oZXJpdHMoY3Rvciwgc3VwZXJDdG9yKSB7XG4gICAgaWYgKHN1cGVyQ3Rvcikge1xuICAgICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3JcbiAgICAgIGN0b3IucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIGNvbnN0cnVjdG9yOiB7XG4gICAgICAgICAgdmFsdWU6IGN0b3IsXG4gICAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgICAgd3JpdGFibGU6IHRydWUsXG4gICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgfVxuICB9O1xufSBlbHNlIHtcbiAgLy8gb2xkIHNjaG9vbCBzaGltIGZvciBvbGQgYnJvd3NlcnNcbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbmhlcml0cyhjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAoc3VwZXJDdG9yKSB7XG4gICAgICBjdG9yLnN1cGVyXyA9IHN1cGVyQ3RvclxuICAgICAgdmFyIFRlbXBDdG9yID0gZnVuY3Rpb24gKCkge31cbiAgICAgIFRlbXBDdG9yLnByb3RvdHlwZSA9IHN1cGVyQ3Rvci5wcm90b3R5cGVcbiAgICAgIGN0b3IucHJvdG90eXBlID0gbmV3IFRlbXBDdG9yKClcbiAgICAgIGN0b3IucHJvdG90eXBlLmNvbnN0cnVjdG9yID0gY3RvclxuICAgIH1cbiAgfVxufVxuIiwiLyoqXG4gKiBbanMtc2hhM117QGxpbmsgaHR0cHM6Ly9naXRodWIuY29tL2VtbjE3OC9qcy1zaGEzfVxuICpcbiAqIEB2ZXJzaW9uIDAuOC4wXG4gKiBAYXV0aG9yIENoZW4sIFlpLUN5dWFuIFtlbW4xNzhAZ21haWwuY29tXVxuICogQGNvcHlyaWdodCBDaGVuLCBZaS1DeXVhbiAyMDE1LTIwMThcbiAqIEBsaWNlbnNlIE1JVFxuICovXG4vKmpzbGludCBiaXR3aXNlOiB0cnVlICovXG4oZnVuY3Rpb24gKCkge1xuICAndXNlIHN0cmljdCc7XG5cbiAgdmFyIElOUFVUX0VSUk9SID0gJ2lucHV0IGlzIGludmFsaWQgdHlwZSc7XG4gIHZhciBGSU5BTElaRV9FUlJPUiA9ICdmaW5hbGl6ZSBhbHJlYWR5IGNhbGxlZCc7XG4gIHZhciBXSU5ET1cgPSB0eXBlb2Ygd2luZG93ID09PSAnb2JqZWN0JztcbiAgdmFyIHJvb3QgPSBXSU5ET1cgPyB3aW5kb3cgOiB7fTtcbiAgaWYgKHJvb3QuSlNfU0hBM19OT19XSU5ET1cpIHtcbiAgICBXSU5ET1cgPSBmYWxzZTtcbiAgfVxuICB2YXIgV0VCX1dPUktFUiA9ICFXSU5ET1cgJiYgdHlwZW9mIHNlbGYgPT09ICdvYmplY3QnO1xuICB2YXIgTk9ERV9KUyA9ICFyb290LkpTX1NIQTNfTk9fTk9ERV9KUyAmJiB0eXBlb2YgcHJvY2VzcyA9PT0gJ29iamVjdCcgJiYgcHJvY2Vzcy52ZXJzaW9ucyAmJiBwcm9jZXNzLnZlcnNpb25zLm5vZGU7XG4gIGlmIChOT0RFX0pTKSB7XG4gICAgcm9vdCA9IGdsb2JhbDtcbiAgfSBlbHNlIGlmIChXRUJfV09SS0VSKSB7XG4gICAgcm9vdCA9IHNlbGY7XG4gIH1cbiAgdmFyIENPTU1PTl9KUyA9ICFyb290LkpTX1NIQTNfTk9fQ09NTU9OX0pTICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnICYmIG1vZHVsZS5leHBvcnRzO1xuICB2YXIgQU1EID0gdHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kO1xuICB2YXIgQVJSQVlfQlVGRkVSID0gIXJvb3QuSlNfU0hBM19OT19BUlJBWV9CVUZGRVIgJiYgdHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIEhFWF9DSEFSUyA9ICcwMTIzNDU2Nzg5YWJjZGVmJy5zcGxpdCgnJyk7XG4gIHZhciBTSEFLRV9QQURESU5HID0gWzMxLCA3OTM2LCAyMDMxNjE2LCA1MjAwOTM2OTZdO1xuICB2YXIgQ1NIQUtFX1BBRERJTkcgPSBbNCwgMTAyNCwgMjYyMTQ0LCA2NzEwODg2NF07XG4gIHZhciBLRUNDQUtfUEFERElORyA9IFsxLCAyNTYsIDY1NTM2LCAxNjc3NzIxNl07XG4gIHZhciBQQURESU5HID0gWzYsIDE1MzYsIDM5MzIxNiwgMTAwNjYzMjk2XTtcbiAgdmFyIFNISUZUID0gWzAsIDgsIDE2LCAyNF07XG4gIHZhciBSQyA9IFsxLCAwLCAzMjg5OCwgMCwgMzI5MDYsIDIxNDc0ODM2NDgsIDIxNDc1MTY0MTYsIDIxNDc0ODM2NDgsIDMyOTA3LCAwLCAyMTQ3NDgzNjQ5LFxuICAgIDAsIDIxNDc1MTY1NDUsIDIxNDc0ODM2NDgsIDMyNzc3LCAyMTQ3NDgzNjQ4LCAxMzgsIDAsIDEzNiwgMCwgMjE0NzUxNjQyNSwgMCxcbiAgICAyMTQ3NDgzNjU4LCAwLCAyMTQ3NTE2NTU1LCAwLCAxMzksIDIxNDc0ODM2NDgsIDMyOTA1LCAyMTQ3NDgzNjQ4LCAzMjc3MSxcbiAgICAyMTQ3NDgzNjQ4LCAzMjc3MCwgMjE0NzQ4MzY0OCwgMTI4LCAyMTQ3NDgzNjQ4LCAzMjc3OCwgMCwgMjE0NzQ4MzY1OCwgMjE0NzQ4MzY0OCxcbiAgICAyMTQ3NTE2NTQ1LCAyMTQ3NDgzNjQ4LCAzMjg5NiwgMjE0NzQ4MzY0OCwgMjE0NzQ4MzY0OSwgMCwgMjE0NzUxNjQyNCwgMjE0NzQ4MzY0OF07XG4gIHZhciBCSVRTID0gWzIyNCwgMjU2LCAzODQsIDUxMl07XG4gIHZhciBTSEFLRV9CSVRTID0gWzEyOCwgMjU2XTtcbiAgdmFyIE9VVFBVVF9UWVBFUyA9IFsnaGV4JywgJ2J1ZmZlcicsICdhcnJheUJ1ZmZlcicsICdhcnJheScsICdkaWdlc3QnXTtcbiAgdmFyIENTSEFLRV9CWVRFUEFEID0ge1xuICAgICcxMjgnOiAxNjgsXG4gICAgJzI1Nic6IDEzNlxuICB9O1xuXG4gIGlmIChyb290LkpTX1NIQTNfTk9fTk9ERV9KUyB8fCAhQXJyYXkuaXNBcnJheSkge1xuICAgIEFycmF5LmlzQXJyYXkgPSBmdW5jdGlvbiAob2JqKSB7XG4gICAgICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgfTtcbiAgfVxuXG4gIGlmIChBUlJBWV9CVUZGRVIgJiYgKHJvb3QuSlNfU0hBM19OT19BUlJBWV9CVUZGRVJfSVNfVklFVyB8fCAhQXJyYXlCdWZmZXIuaXNWaWV3KSkge1xuICAgIEFycmF5QnVmZmVyLmlzVmlldyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmouYnVmZmVyICYmIG9iai5idWZmZXIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyO1xuICAgIH07XG4gIH1cblxuICB2YXIgY3JlYXRlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZVNoYWtlT3V0cHV0TWV0aG9kID0gZnVuY3Rpb24gKGJpdHMsIHBhZGRpbmcsIG91dHB1dFR5cGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIG91dHB1dEJpdHMpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpLnVwZGF0ZShtZXNzYWdlKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nLCBvdXRwdXRUeXBlKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kc1snY3NoYWtlJyArIGJpdHNdLnVwZGF0ZShtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUttYWNPdXRwdXRNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZywgb3V0cHV0VHlwZSkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kc1sna21hYycgKyBiaXRzXS51cGRhdGUoa2V5LCBtZXNzYWdlLCBvdXRwdXRCaXRzLCBzKVtvdXRwdXRUeXBlXSgpO1xuICAgIH07XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU91dHB1dE1ldGhvZHMgPSBmdW5jdGlvbiAobWV0aG9kLCBjcmVhdGVNZXRob2QsIGJpdHMsIHBhZGRpbmcpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IE9VVFBVVF9UWVBFUy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHR5cGUgPSBPVVRQVVRfVFlQRVNbaV07XG4gICAgICBtZXRob2RbdHlwZV0gPSBjcmVhdGVNZXRob2QoYml0cywgcGFkZGluZywgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBtZXRob2Q7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBuZXcgS2VjY2FrKGJpdHMsIHBhZGRpbmcsIGJpdHMpO1xuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZSgpLnVwZGF0ZShtZXNzYWdlKTtcbiAgICB9O1xuICAgIHJldHVybiBjcmVhdGVPdXRwdXRNZXRob2RzKG1ldGhvZCwgY3JlYXRlT3V0cHV0TWV0aG9kLCBiaXRzLCBwYWRkaW5nKTtcbiAgfTtcblxuICB2YXIgY3JlYXRlU2hha2VNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciBtZXRob2QgPSBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZChiaXRzLCBwYWRkaW5nLCAnaGV4Jyk7XG4gICAgbWV0aG9kLmNyZWF0ZSA9IGZ1bmN0aW9uIChvdXRwdXRCaXRzKSB7XG4gICAgICByZXR1cm4gbmV3IEtlY2NhayhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKTtcbiAgICB9O1xuICAgIG1ldGhvZC51cGRhdGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgb3V0cHV0Qml0cykge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUob3V0cHV0Qml0cykudXBkYXRlKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgcmV0dXJuIGNyZWF0ZU91dHB1dE1ldGhvZHMobWV0aG9kLCBjcmVhdGVTaGFrZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUNzaGFrZU1ldGhvZCA9IGZ1bmN0aW9uIChiaXRzLCBwYWRkaW5nKSB7XG4gICAgdmFyIHcgPSBDU0hBS0VfQllURVBBRFtiaXRzXTtcbiAgICB2YXIgbWV0aG9kID0gY3JlYXRlQ3NoYWtlT3V0cHV0TWV0aG9kKGJpdHMsIHBhZGRpbmcsICdoZXgnKTtcbiAgICBtZXRob2QuY3JlYXRlID0gZnVuY3Rpb24gKG91dHB1dEJpdHMsIG4sIHMpIHtcbiAgICAgIGlmICghbiAmJiAhcykge1xuICAgICAgICByZXR1cm4gbWV0aG9kc1snc2hha2UnICsgYml0c10uY3JlYXRlKG91dHB1dEJpdHMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIG5ldyBLZWNjYWsoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykuYnl0ZXBhZChbbiwgc10sIHcpO1xuICAgICAgfVxuICAgIH07XG4gICAgbWV0aG9kLnVwZGF0ZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCBvdXRwdXRCaXRzLCBuLCBzKSB7XG4gICAgICByZXR1cm4gbWV0aG9kLmNyZWF0ZShvdXRwdXRCaXRzLCBuLCBzKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZUNzaGFrZU91dHB1dE1ldGhvZCwgYml0cywgcGFkZGluZyk7XG4gIH07XG5cbiAgdmFyIGNyZWF0ZUttYWNNZXRob2QgPSBmdW5jdGlvbiAoYml0cywgcGFkZGluZykge1xuICAgIHZhciB3ID0gQ1NIQUtFX0JZVEVQQURbYml0c107XG4gICAgdmFyIG1ldGhvZCA9IGNyZWF0ZUttYWNPdXRwdXRNZXRob2QoYml0cywgcGFkZGluZywgJ2hleCcpO1xuICAgIG1ldGhvZC5jcmVhdGUgPSBmdW5jdGlvbiAoa2V5LCBvdXRwdXRCaXRzLCBzKSB7XG4gICAgICByZXR1cm4gbmV3IEttYWMoYml0cywgcGFkZGluZywgb3V0cHV0Qml0cykuYnl0ZXBhZChbJ0tNQUMnLCBzXSwgdykuYnl0ZXBhZChba2V5XSwgdyk7XG4gICAgfTtcbiAgICBtZXRob2QudXBkYXRlID0gZnVuY3Rpb24gKGtleSwgbWVzc2FnZSwgb3V0cHV0Qml0cywgcykge1xuICAgICAgcmV0dXJuIG1ldGhvZC5jcmVhdGUoa2V5LCBvdXRwdXRCaXRzLCBzKS51cGRhdGUobWVzc2FnZSk7XG4gICAgfTtcbiAgICByZXR1cm4gY3JlYXRlT3V0cHV0TWV0aG9kcyhtZXRob2QsIGNyZWF0ZUttYWNPdXRwdXRNZXRob2QsIGJpdHMsIHBhZGRpbmcpO1xuICB9O1xuXG4gIHZhciBhbGdvcml0aG1zID0gW1xuICAgIHsgbmFtZTogJ2tlY2NhaycsIHBhZGRpbmc6IEtFQ0NBS19QQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ3NoYTMnLCBwYWRkaW5nOiBQQURESU5HLCBiaXRzOiBCSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ3NoYWtlJywgcGFkZGluZzogU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVTaGFrZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ2NzaGFrZScsIHBhZGRpbmc6IENTSEFLRV9QQURESU5HLCBiaXRzOiBTSEFLRV9CSVRTLCBjcmVhdGVNZXRob2Q6IGNyZWF0ZUNzaGFrZU1ldGhvZCB9LFxuICAgIHsgbmFtZTogJ2ttYWMnLCBwYWRkaW5nOiBDU0hBS0VfUEFERElORywgYml0czogU0hBS0VfQklUUywgY3JlYXRlTWV0aG9kOiBjcmVhdGVLbWFjTWV0aG9kIH1cbiAgXTtcblxuICB2YXIgbWV0aG9kcyA9IHt9LCBtZXRob2ROYW1lcyA9IFtdO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYWxnb3JpdGhtcy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBhbGdvcml0aG0gPSBhbGdvcml0aG1zW2ldO1xuICAgIHZhciBiaXRzID0gYWxnb3JpdGhtLmJpdHM7XG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBiaXRzLmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgbWV0aG9kTmFtZSA9IGFsZ29yaXRobS5uYW1lICsgJ18nICsgYml0c1tqXTtcbiAgICAgIG1ldGhvZE5hbWVzLnB1c2gobWV0aG9kTmFtZSk7XG4gICAgICBtZXRob2RzW21ldGhvZE5hbWVdID0gYWxnb3JpdGhtLmNyZWF0ZU1ldGhvZChiaXRzW2pdLCBhbGdvcml0aG0ucGFkZGluZyk7XG4gICAgICBpZiAoYWxnb3JpdGhtLm5hbWUgIT09ICdzaGEzJykge1xuICAgICAgICB2YXIgbmV3TWV0aG9kTmFtZSA9IGFsZ29yaXRobS5uYW1lICsgYml0c1tqXTtcbiAgICAgICAgbWV0aG9kTmFtZXMucHVzaChuZXdNZXRob2ROYW1lKTtcbiAgICAgICAgbWV0aG9kc1tuZXdNZXRob2ROYW1lXSA9IG1ldGhvZHNbbWV0aG9kTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gS2VjY2FrKGJpdHMsIHBhZGRpbmcsIG91dHB1dEJpdHMpIHtcbiAgICB0aGlzLmJsb2NrcyA9IFtdO1xuICAgIHRoaXMucyA9IFtdO1xuICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgdGhpcy5vdXRwdXRCaXRzID0gb3V0cHV0Qml0cztcbiAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcbiAgICB0aGlzLmZpbmFsaXplZCA9IGZhbHNlO1xuICAgIHRoaXMuYmxvY2sgPSAwO1xuICAgIHRoaXMuc3RhcnQgPSAwO1xuICAgIHRoaXMuYmxvY2tDb3VudCA9ICgxNjAwIC0gKGJpdHMgPDwgMSkpID4+IDU7XG4gICAgdGhpcy5ieXRlQ291bnQgPSB0aGlzLmJsb2NrQ291bnQgPDwgMjtcbiAgICB0aGlzLm91dHB1dEJsb2NrcyA9IG91dHB1dEJpdHMgPj4gNTtcbiAgICB0aGlzLmV4dHJhQnl0ZXMgPSAob3V0cHV0Qml0cyAmIDMxKSA+PiAzO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA1MDsgKytpKSB7XG4gICAgICB0aGlzLnNbaV0gPSAwO1xuICAgIH1cbiAgfVxuXG4gIEtlY2Nhay5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihGSU5BTElaRV9FUlJPUik7XG4gICAgfVxuICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2YgbWVzc2FnZTtcbiAgICBpZiAodHlwZSAhPT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICBpZiAobWVzc2FnZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICAgIH0gZWxzZSBpZiAoQVJSQVlfQlVGRkVSICYmIG1lc3NhZ2UuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgbWVzc2FnZSA9IG5ldyBVaW50OEFycmF5KG1lc3NhZ2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCFBcnJheS5pc0FycmF5KG1lc3NhZ2UpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhtZXNzYWdlKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihJTlBVVF9FUlJPUik7XG4gICAgICB9XG4gICAgICBub3RTdHJpbmcgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgYmxvY2tzID0gdGhpcy5ibG9ja3MsIGJ5dGVDb3VudCA9IHRoaXMuYnl0ZUNvdW50LCBsZW5ndGggPSBtZXNzYWdlLmxlbmd0aCxcbiAgICAgIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIGluZGV4ID0gMCwgcyA9IHRoaXMucywgaSwgY29kZTtcblxuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgaWYgKHRoaXMucmVzZXQpIHtcbiAgICAgICAgdGhpcy5yZXNldCA9IGZhbHNlO1xuICAgICAgICBibG9ja3NbMF0gPSB0aGlzLmJsb2NrO1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xuICAgICAgICAgIGJsb2Nrc1tpXSA9IDA7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChub3RTdHJpbmcpIHtcbiAgICAgICAgZm9yIChpID0gdGhpcy5zdGFydDsgaW5kZXggPCBsZW5ndGggJiYgaSA8IGJ5dGVDb3VudDsgKytpbmRleCkge1xuICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9IG1lc3NhZ2VbaW5kZXhdIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGkgPSB0aGlzLnN0YXJ0OyBpbmRleCA8IGxlbmd0aCAmJiBpIDwgYnl0ZUNvdW50OyArK2luZGV4KSB7XG4gICAgICAgICAgY29kZSA9IG1lc3NhZ2UuY2hhckNvZGVBdChpbmRleCk7XG4gICAgICAgICAgaWYgKGNvZGUgPCAweDgwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSBjb2RlIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhjMCB8IChjb2RlID4+IDYpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHhlMCB8IChjb2RlID4+IDEyKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgICBibG9ja3NbaSA+PiAyXSB8PSAoMHg4MCB8ICgoY29kZSA+PiA2KSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKGNvZGUgJiAweDNmKSkgPDwgU0hJRlRbaSsrICYgM107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvZGUgPSAweDEwMDAwICsgKCgoY29kZSAmIDB4M2ZmKSA8PCAxMCkgfCAobWVzc2FnZS5jaGFyQ29kZUF0KCsraW5kZXgpICYgMHgzZmYpKTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweGYwIHwgKGNvZGUgPj4gMTgpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDEyKSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICAgIGJsb2Nrc1tpID4+IDJdIHw9ICgweDgwIHwgKChjb2RlID4+IDYpICYgMHgzZikpIDw8IFNISUZUW2krKyAmIDNdO1xuICAgICAgICAgICAgYmxvY2tzW2kgPj4gMl0gfD0gKDB4ODAgfCAoY29kZSAmIDB4M2YpKSA8PCBTSElGVFtpKysgJiAzXTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMubGFzdEJ5dGVJbmRleCA9IGk7XG4gICAgICBpZiAoaSA+PSBieXRlQ291bnQpIHtcbiAgICAgICAgdGhpcy5zdGFydCA9IGkgLSBieXRlQ291bnQ7XG4gICAgICAgIHRoaXMuYmxvY2sgPSBibG9ja3NbYmxvY2tDb3VudF07XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBibG9ja0NvdW50OyArK2kpIHtcbiAgICAgICAgICBzW2ldIF49IGJsb2Nrc1tpXTtcbiAgICAgICAgfVxuICAgICAgICBmKHMpO1xuICAgICAgICB0aGlzLnJlc2V0ID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc3RhcnQgPSBpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmVuY29kZSA9IGZ1bmN0aW9uICh4LCByaWdodCkge1xuICAgIHZhciBvID0geCAmIDI1NSwgbiA9IDE7XG4gICAgdmFyIGJ5dGVzID0gW29dO1xuICAgIHggPSB4ID4+IDg7XG4gICAgbyA9IHggJiAyNTU7XG4gICAgd2hpbGUgKG8gPiAwKSB7XG4gICAgICBieXRlcy51bnNoaWZ0KG8pO1xuICAgICAgeCA9IHggPj4gODtcbiAgICAgIG8gPSB4ICYgMjU1O1xuICAgICAgKytuO1xuICAgIH1cbiAgICBpZiAocmlnaHQpIHtcbiAgICAgIGJ5dGVzLnB1c2gobik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJ5dGVzLnVuc2hpZnQobik7XG4gICAgfVxuICAgIHRoaXMudXBkYXRlKGJ5dGVzKTtcbiAgICByZXR1cm4gYnl0ZXMubGVuZ3RoO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuZW5jb2RlU3RyaW5nID0gZnVuY3Rpb24gKHN0cikge1xuICAgIHZhciBub3RTdHJpbmcsIHR5cGUgPSB0eXBlb2Ygc3RyO1xuICAgIGlmICh0eXBlICE9PSAnc3RyaW5nJykge1xuICAgICAgaWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgICAgIGlmIChzdHIgPT09IG51bGwpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICB9IGVsc2UgaWYgKEFSUkFZX0JVRkZFUiAmJiBzdHIuY29uc3RydWN0b3IgPT09IEFycmF5QnVmZmVyKSB7XG4gICAgICAgICAgc3RyID0gbmV3IFVpbnQ4QXJyYXkoc3RyKTtcbiAgICAgICAgfSBlbHNlIGlmICghQXJyYXkuaXNBcnJheShzdHIpKSB7XG4gICAgICAgICAgaWYgKCFBUlJBWV9CVUZGRVIgfHwgIUFycmF5QnVmZmVyLmlzVmlldyhzdHIpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5QVVRfRVJST1IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKElOUFVUX0VSUk9SKTtcbiAgICAgIH1cbiAgICAgIG5vdFN0cmluZyA9IHRydWU7XG4gICAgfVxuICAgIHZhciBieXRlcyA9IDAsIGxlbmd0aCA9IHN0ci5sZW5ndGg7XG4gICAgaWYgKG5vdFN0cmluZykge1xuICAgICAgYnl0ZXMgPSBsZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RyLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjb2RlID0gc3RyLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIGlmIChjb2RlIDwgMHg4MCkge1xuICAgICAgICAgIGJ5dGVzICs9IDE7XG4gICAgICAgIH0gZWxzZSBpZiAoY29kZSA8IDB4ODAwKSB7XG4gICAgICAgICAgYnl0ZXMgKz0gMjtcbiAgICAgICAgfSBlbHNlIGlmIChjb2RlIDwgMHhkODAwIHx8IGNvZGUgPj0gMHhlMDAwKSB7XG4gICAgICAgICAgYnl0ZXMgKz0gMztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb2RlID0gMHgxMDAwMCArICgoKGNvZGUgJiAweDNmZikgPDwgMTApIHwgKHN0ci5jaGFyQ29kZUF0KCsraSkgJiAweDNmZikpO1xuICAgICAgICAgIGJ5dGVzICs9IDQ7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgYnl0ZXMgKz0gdGhpcy5lbmNvZGUoYnl0ZXMgKiA4KTtcbiAgICB0aGlzLnVwZGF0ZShzdHIpO1xuICAgIHJldHVybiBieXRlcztcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmJ5dGVwYWQgPSBmdW5jdGlvbiAoc3Rycywgdykge1xuICAgIHZhciBieXRlcyA9IHRoaXMuZW5jb2RlKHcpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3Rycy5sZW5ndGg7ICsraSkge1xuICAgICAgYnl0ZXMgKz0gdGhpcy5lbmNvZGVTdHJpbmcoc3Ryc1tpXSk7XG4gICAgfVxuICAgIHZhciBwYWRkaW5nQnl0ZXMgPSB3IC0gYnl0ZXMgJSB3O1xuICAgIHZhciB6ZXJvcyA9IFtdO1xuICAgIHplcm9zLmxlbmd0aCA9IHBhZGRpbmdCeXRlcztcbiAgICB0aGlzLnVwZGF0ZSh6ZXJvcyk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBpZiAodGhpcy5maW5hbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5maW5hbGl6ZWQgPSB0cnVlO1xuICAgIHZhciBibG9ja3MgPSB0aGlzLmJsb2NrcywgaSA9IHRoaXMubGFzdEJ5dGVJbmRleCwgYmxvY2tDb3VudCA9IHRoaXMuYmxvY2tDb3VudCwgcyA9IHRoaXMucztcbiAgICBibG9ja3NbaSA+PiAyXSB8PSB0aGlzLnBhZGRpbmdbaSAmIDNdO1xuICAgIGlmICh0aGlzLmxhc3RCeXRlSW5kZXggPT09IHRoaXMuYnl0ZUNvdW50KSB7XG4gICAgICBibG9ja3NbMF0gPSBibG9ja3NbYmxvY2tDb3VudF07XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgYmxvY2tDb3VudCArIDE7ICsraSkge1xuICAgICAgICBibG9ja3NbaV0gPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBibG9ja3NbYmxvY2tDb3VudCAtIDFdIHw9IDB4ODAwMDAwMDA7XG4gICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQ7ICsraSkge1xuICAgICAgc1tpXSBePSBibG9ja3NbaV07XG4gICAgfVxuICAgIGYocyk7XG4gIH07XG5cbiAgS2VjY2FrLnByb3RvdHlwZS50b1N0cmluZyA9IEtlY2Nhay5wcm90b3R5cGUuaGV4ID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcbiAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgaGV4ID0gJycsIGJsb2NrO1xuICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuICAgICAgICBibG9jayA9IHNbaV07XG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDQpICYgMHgwRl0gKyBIRVhfQ0hBUlNbYmxvY2sgJiAweDBGXSArXG4gICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAxMikgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gOCkgJiAweDBGXSArXG4gICAgICAgICAgSEVYX0NIQVJTWyhibG9jayA+PiAyMCkgJiAweDBGXSArIEhFWF9DSEFSU1soYmxvY2sgPj4gMTYpICYgMHgwRl0gK1xuICAgICAgICAgIEhFWF9DSEFSU1soYmxvY2sgPj4gMjgpICYgMHgwRl0gKyBIRVhfQ0hBUlNbKGJsb2NrID4+IDI0KSAmIDB4MEZdO1xuICAgICAgfVxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGYocyk7XG4gICAgICAgIGkgPSAwO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZXh0cmFCeXRlcykge1xuICAgICAgYmxvY2sgPSBzW2ldO1xuICAgICAgaGV4ICs9IEhFWF9DSEFSU1soYmxvY2sgPj4gNCkgJiAweDBGXSArIEhFWF9DSEFSU1tibG9jayAmIDB4MEZdO1xuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAxKSB7XG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDEyKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiA4KSAmIDB4MEZdO1xuICAgICAgfVxuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAyKSB7XG4gICAgICAgIGhleCArPSBIRVhfQ0hBUlNbKGJsb2NrID4+IDIwKSAmIDB4MEZdICsgSEVYX0NIQVJTWyhibG9jayA+PiAxNikgJiAweDBGXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhleDtcbiAgfTtcblxuICBLZWNjYWsucHJvdG90eXBlLmFycmF5QnVmZmVyID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZmluYWxpemUoKTtcblxuICAgIHZhciBibG9ja0NvdW50ID0gdGhpcy5ibG9ja0NvdW50LCBzID0gdGhpcy5zLCBvdXRwdXRCbG9ja3MgPSB0aGlzLm91dHB1dEJsb2NrcyxcbiAgICAgIGV4dHJhQnl0ZXMgPSB0aGlzLmV4dHJhQnl0ZXMsIGkgPSAwLCBqID0gMDtcbiAgICB2YXIgYnl0ZXMgPSB0aGlzLm91dHB1dEJpdHMgPj4gMztcbiAgICB2YXIgYnVmZmVyO1xuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoKG91dHB1dEJsb2NrcyArIDEpIDw8IDIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBidWZmZXIgPSBuZXcgQXJyYXlCdWZmZXIoYnl0ZXMpO1xuICAgIH1cbiAgICB2YXIgYXJyYXkgPSBuZXcgVWludDMyQXJyYXkoYnVmZmVyKTtcbiAgICB3aGlsZSAoaiA8IG91dHB1dEJsb2Nrcykge1xuICAgICAgZm9yIChpID0gMDsgaSA8IGJsb2NrQ291bnQgJiYgaiA8IG91dHB1dEJsb2NrczsgKytpLCArK2opIHtcbiAgICAgICAgYXJyYXlbal0gPSBzW2ldO1xuICAgICAgfVxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGYocyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBhcnJheVtpXSA9IHNbaV07XG4gICAgICBidWZmZXIgPSBidWZmZXIuc2xpY2UoMCwgYnl0ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyO1xuICB9O1xuXG4gIEtlY2Nhay5wcm90b3R5cGUuYnVmZmVyID0gS2VjY2FrLnByb3RvdHlwZS5hcnJheUJ1ZmZlcjtcblxuICBLZWNjYWsucHJvdG90eXBlLmRpZ2VzdCA9IEtlY2Nhay5wcm90b3R5cGUuYXJyYXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5maW5hbGl6ZSgpO1xuXG4gICAgdmFyIGJsb2NrQ291bnQgPSB0aGlzLmJsb2NrQ291bnQsIHMgPSB0aGlzLnMsIG91dHB1dEJsb2NrcyA9IHRoaXMub3V0cHV0QmxvY2tzLFxuICAgICAgZXh0cmFCeXRlcyA9IHRoaXMuZXh0cmFCeXRlcywgaSA9IDAsIGogPSAwO1xuICAgIHZhciBhcnJheSA9IFtdLCBvZmZzZXQsIGJsb2NrO1xuICAgIHdoaWxlIChqIDwgb3V0cHV0QmxvY2tzKSB7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYmxvY2tDb3VudCAmJiBqIDwgb3V0cHV0QmxvY2tzOyArK2ksICsraikge1xuICAgICAgICBvZmZzZXQgPSBqIDw8IDI7XG4gICAgICAgIGJsb2NrID0gc1tpXTtcbiAgICAgICAgYXJyYXlbb2Zmc2V0XSA9IGJsb2NrICYgMHhGRjtcbiAgICAgICAgYXJyYXlbb2Zmc2V0ICsgMV0gPSAoYmxvY2sgPj4gOCkgJiAweEZGO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IChibG9jayA+PiAxNikgJiAweEZGO1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAzXSA9IChibG9jayA+PiAyNCkgJiAweEZGO1xuICAgICAgfVxuICAgICAgaWYgKGogJSBibG9ja0NvdW50ID09PSAwKSB7XG4gICAgICAgIGYocyk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChleHRyYUJ5dGVzKSB7XG4gICAgICBvZmZzZXQgPSBqIDw8IDI7XG4gICAgICBibG9jayA9IHNbaV07XG4gICAgICBhcnJheVtvZmZzZXRdID0gYmxvY2sgJiAweEZGO1xuICAgICAgaWYgKGV4dHJhQnl0ZXMgPiAxKSB7XG4gICAgICAgIGFycmF5W29mZnNldCArIDFdID0gKGJsb2NrID4+IDgpICYgMHhGRjtcbiAgICAgIH1cbiAgICAgIGlmIChleHRyYUJ5dGVzID4gMikge1xuICAgICAgICBhcnJheVtvZmZzZXQgKyAyXSA9IChibG9jayA+PiAxNikgJiAweEZGO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH07XG5cbiAgZnVuY3Rpb24gS21hYyhiaXRzLCBwYWRkaW5nLCBvdXRwdXRCaXRzKSB7XG4gICAgS2VjY2FrLmNhbGwodGhpcywgYml0cywgcGFkZGluZywgb3V0cHV0Qml0cyk7XG4gIH1cblxuICBLbWFjLnByb3RvdHlwZSA9IG5ldyBLZWNjYWsoKTtcblxuICBLbWFjLnByb3RvdHlwZS5maW5hbGl6ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmVuY29kZSh0aGlzLm91dHB1dEJpdHMsIHRydWUpO1xuICAgIHJldHVybiBLZWNjYWsucHJvdG90eXBlLmZpbmFsaXplLmNhbGwodGhpcyk7XG4gIH07XG5cbiAgdmFyIGYgPSBmdW5jdGlvbiAocykge1xuICAgIHZhciBoLCBsLCBuLCBjMCwgYzEsIGMyLCBjMywgYzQsIGM1LCBjNiwgYzcsIGM4LCBjOSxcbiAgICAgIGIwLCBiMSwgYjIsIGIzLCBiNCwgYjUsIGI2LCBiNywgYjgsIGI5LCBiMTAsIGIxMSwgYjEyLCBiMTMsIGIxNCwgYjE1LCBiMTYsIGIxNyxcbiAgICAgIGIxOCwgYjE5LCBiMjAsIGIyMSwgYjIyLCBiMjMsIGIyNCwgYjI1LCBiMjYsIGIyNywgYjI4LCBiMjksIGIzMCwgYjMxLCBiMzIsIGIzMyxcbiAgICAgIGIzNCwgYjM1LCBiMzYsIGIzNywgYjM4LCBiMzksIGI0MCwgYjQxLCBiNDIsIGI0MywgYjQ0LCBiNDUsIGI0NiwgYjQ3LCBiNDgsIGI0OTtcbiAgICBmb3IgKG4gPSAwOyBuIDwgNDg7IG4gKz0gMikge1xuICAgICAgYzAgPSBzWzBdIF4gc1sxMF0gXiBzWzIwXSBeIHNbMzBdIF4gc1s0MF07XG4gICAgICBjMSA9IHNbMV0gXiBzWzExXSBeIHNbMjFdIF4gc1szMV0gXiBzWzQxXTtcbiAgICAgIGMyID0gc1syXSBeIHNbMTJdIF4gc1syMl0gXiBzWzMyXSBeIHNbNDJdO1xuICAgICAgYzMgPSBzWzNdIF4gc1sxM10gXiBzWzIzXSBeIHNbMzNdIF4gc1s0M107XG4gICAgICBjNCA9IHNbNF0gXiBzWzE0XSBeIHNbMjRdIF4gc1szNF0gXiBzWzQ0XTtcbiAgICAgIGM1ID0gc1s1XSBeIHNbMTVdIF4gc1syNV0gXiBzWzM1XSBeIHNbNDVdO1xuICAgICAgYzYgPSBzWzZdIF4gc1sxNl0gXiBzWzI2XSBeIHNbMzZdIF4gc1s0Nl07XG4gICAgICBjNyA9IHNbN10gXiBzWzE3XSBeIHNbMjddIF4gc1szN10gXiBzWzQ3XTtcbiAgICAgIGM4ID0gc1s4XSBeIHNbMThdIF4gc1syOF0gXiBzWzM4XSBeIHNbNDhdO1xuICAgICAgYzkgPSBzWzldIF4gc1sxOV0gXiBzWzI5XSBeIHNbMzldIF4gc1s0OV07XG5cbiAgICAgIGggPSBjOCBeICgoYzIgPDwgMSkgfCAoYzMgPj4+IDMxKSk7XG4gICAgICBsID0gYzkgXiAoKGMzIDw8IDEpIHwgKGMyID4+PiAzMSkpO1xuICAgICAgc1swXSBePSBoO1xuICAgICAgc1sxXSBePSBsO1xuICAgICAgc1sxMF0gXj0gaDtcbiAgICAgIHNbMTFdIF49IGw7XG4gICAgICBzWzIwXSBePSBoO1xuICAgICAgc1syMV0gXj0gbDtcbiAgICAgIHNbMzBdIF49IGg7XG4gICAgICBzWzMxXSBePSBsO1xuICAgICAgc1s0MF0gXj0gaDtcbiAgICAgIHNbNDFdIF49IGw7XG4gICAgICBoID0gYzAgXiAoKGM0IDw8IDEpIHwgKGM1ID4+PiAzMSkpO1xuICAgICAgbCA9IGMxIF4gKChjNSA8PCAxKSB8IChjNCA+Pj4gMzEpKTtcbiAgICAgIHNbMl0gXj0gaDtcbiAgICAgIHNbM10gXj0gbDtcbiAgICAgIHNbMTJdIF49IGg7XG4gICAgICBzWzEzXSBePSBsO1xuICAgICAgc1syMl0gXj0gaDtcbiAgICAgIHNbMjNdIF49IGw7XG4gICAgICBzWzMyXSBePSBoO1xuICAgICAgc1szM10gXj0gbDtcbiAgICAgIHNbNDJdIF49IGg7XG4gICAgICBzWzQzXSBePSBsO1xuICAgICAgaCA9IGMyIF4gKChjNiA8PCAxKSB8IChjNyA+Pj4gMzEpKTtcbiAgICAgIGwgPSBjMyBeICgoYzcgPDwgMSkgfCAoYzYgPj4+IDMxKSk7XG4gICAgICBzWzRdIF49IGg7XG4gICAgICBzWzVdIF49IGw7XG4gICAgICBzWzE0XSBePSBoO1xuICAgICAgc1sxNV0gXj0gbDtcbiAgICAgIHNbMjRdIF49IGg7XG4gICAgICBzWzI1XSBePSBsO1xuICAgICAgc1szNF0gXj0gaDtcbiAgICAgIHNbMzVdIF49IGw7XG4gICAgICBzWzQ0XSBePSBoO1xuICAgICAgc1s0NV0gXj0gbDtcbiAgICAgIGggPSBjNCBeICgoYzggPDwgMSkgfCAoYzkgPj4+IDMxKSk7XG4gICAgICBsID0gYzUgXiAoKGM5IDw8IDEpIHwgKGM4ID4+PiAzMSkpO1xuICAgICAgc1s2XSBePSBoO1xuICAgICAgc1s3XSBePSBsO1xuICAgICAgc1sxNl0gXj0gaDtcbiAgICAgIHNbMTddIF49IGw7XG4gICAgICBzWzI2XSBePSBoO1xuICAgICAgc1syN10gXj0gbDtcbiAgICAgIHNbMzZdIF49IGg7XG4gICAgICBzWzM3XSBePSBsO1xuICAgICAgc1s0Nl0gXj0gaDtcbiAgICAgIHNbNDddIF49IGw7XG4gICAgICBoID0gYzYgXiAoKGMwIDw8IDEpIHwgKGMxID4+PiAzMSkpO1xuICAgICAgbCA9IGM3IF4gKChjMSA8PCAxKSB8IChjMCA+Pj4gMzEpKTtcbiAgICAgIHNbOF0gXj0gaDtcbiAgICAgIHNbOV0gXj0gbDtcbiAgICAgIHNbMThdIF49IGg7XG4gICAgICBzWzE5XSBePSBsO1xuICAgICAgc1syOF0gXj0gaDtcbiAgICAgIHNbMjldIF49IGw7XG4gICAgICBzWzM4XSBePSBoO1xuICAgICAgc1szOV0gXj0gbDtcbiAgICAgIHNbNDhdIF49IGg7XG4gICAgICBzWzQ5XSBePSBsO1xuXG4gICAgICBiMCA9IHNbMF07XG4gICAgICBiMSA9IHNbMV07XG4gICAgICBiMzIgPSAoc1sxMV0gPDwgNCkgfCAoc1sxMF0gPj4+IDI4KTtcbiAgICAgIGIzMyA9IChzWzEwXSA8PCA0KSB8IChzWzExXSA+Pj4gMjgpO1xuICAgICAgYjE0ID0gKHNbMjBdIDw8IDMpIHwgKHNbMjFdID4+PiAyOSk7XG4gICAgICBiMTUgPSAoc1syMV0gPDwgMykgfCAoc1syMF0gPj4+IDI5KTtcbiAgICAgIGI0NiA9IChzWzMxXSA8PCA5KSB8IChzWzMwXSA+Pj4gMjMpO1xuICAgICAgYjQ3ID0gKHNbMzBdIDw8IDkpIHwgKHNbMzFdID4+PiAyMyk7XG4gICAgICBiMjggPSAoc1s0MF0gPDwgMTgpIHwgKHNbNDFdID4+PiAxNCk7XG4gICAgICBiMjkgPSAoc1s0MV0gPDwgMTgpIHwgKHNbNDBdID4+PiAxNCk7XG4gICAgICBiMjAgPSAoc1syXSA8PCAxKSB8IChzWzNdID4+PiAzMSk7XG4gICAgICBiMjEgPSAoc1szXSA8PCAxKSB8IChzWzJdID4+PiAzMSk7XG4gICAgICBiMiA9IChzWzEzXSA8PCAxMikgfCAoc1sxMl0gPj4+IDIwKTtcbiAgICAgIGIzID0gKHNbMTJdIDw8IDEyKSB8IChzWzEzXSA+Pj4gMjApO1xuICAgICAgYjM0ID0gKHNbMjJdIDw8IDEwKSB8IChzWzIzXSA+Pj4gMjIpO1xuICAgICAgYjM1ID0gKHNbMjNdIDw8IDEwKSB8IChzWzIyXSA+Pj4gMjIpO1xuICAgICAgYjE2ID0gKHNbMzNdIDw8IDEzKSB8IChzWzMyXSA+Pj4gMTkpO1xuICAgICAgYjE3ID0gKHNbMzJdIDw8IDEzKSB8IChzWzMzXSA+Pj4gMTkpO1xuICAgICAgYjQ4ID0gKHNbNDJdIDw8IDIpIHwgKHNbNDNdID4+PiAzMCk7XG4gICAgICBiNDkgPSAoc1s0M10gPDwgMikgfCAoc1s0Ml0gPj4+IDMwKTtcbiAgICAgIGI0MCA9IChzWzVdIDw8IDMwKSB8IChzWzRdID4+PiAyKTtcbiAgICAgIGI0MSA9IChzWzRdIDw8IDMwKSB8IChzWzVdID4+PiAyKTtcbiAgICAgIGIyMiA9IChzWzE0XSA8PCA2KSB8IChzWzE1XSA+Pj4gMjYpO1xuICAgICAgYjIzID0gKHNbMTVdIDw8IDYpIHwgKHNbMTRdID4+PiAyNik7XG4gICAgICBiNCA9IChzWzI1XSA8PCAxMSkgfCAoc1syNF0gPj4+IDIxKTtcbiAgICAgIGI1ID0gKHNbMjRdIDw8IDExKSB8IChzWzI1XSA+Pj4gMjEpO1xuICAgICAgYjM2ID0gKHNbMzRdIDw8IDE1KSB8IChzWzM1XSA+Pj4gMTcpO1xuICAgICAgYjM3ID0gKHNbMzVdIDw8IDE1KSB8IChzWzM0XSA+Pj4gMTcpO1xuICAgICAgYjE4ID0gKHNbNDVdIDw8IDI5KSB8IChzWzQ0XSA+Pj4gMyk7XG4gICAgICBiMTkgPSAoc1s0NF0gPDwgMjkpIHwgKHNbNDVdID4+PiAzKTtcbiAgICAgIGIxMCA9IChzWzZdIDw8IDI4KSB8IChzWzddID4+PiA0KTtcbiAgICAgIGIxMSA9IChzWzddIDw8IDI4KSB8IChzWzZdID4+PiA0KTtcbiAgICAgIGI0MiA9IChzWzE3XSA8PCAyMykgfCAoc1sxNl0gPj4+IDkpO1xuICAgICAgYjQzID0gKHNbMTZdIDw8IDIzKSB8IChzWzE3XSA+Pj4gOSk7XG4gICAgICBiMjQgPSAoc1syNl0gPDwgMjUpIHwgKHNbMjddID4+PiA3KTtcbiAgICAgIGIyNSA9IChzWzI3XSA8PCAyNSkgfCAoc1syNl0gPj4+IDcpO1xuICAgICAgYjYgPSAoc1szNl0gPDwgMjEpIHwgKHNbMzddID4+PiAxMSk7XG4gICAgICBiNyA9IChzWzM3XSA8PCAyMSkgfCAoc1szNl0gPj4+IDExKTtcbiAgICAgIGIzOCA9IChzWzQ3XSA8PCAyNCkgfCAoc1s0Nl0gPj4+IDgpO1xuICAgICAgYjM5ID0gKHNbNDZdIDw8IDI0KSB8IChzWzQ3XSA+Pj4gOCk7XG4gICAgICBiMzAgPSAoc1s4XSA8PCAyNykgfCAoc1s5XSA+Pj4gNSk7XG4gICAgICBiMzEgPSAoc1s5XSA8PCAyNykgfCAoc1s4XSA+Pj4gNSk7XG4gICAgICBiMTIgPSAoc1sxOF0gPDwgMjApIHwgKHNbMTldID4+PiAxMik7XG4gICAgICBiMTMgPSAoc1sxOV0gPDwgMjApIHwgKHNbMThdID4+PiAxMik7XG4gICAgICBiNDQgPSAoc1syOV0gPDwgNykgfCAoc1syOF0gPj4+IDI1KTtcbiAgICAgIGI0NSA9IChzWzI4XSA8PCA3KSB8IChzWzI5XSA+Pj4gMjUpO1xuICAgICAgYjI2ID0gKHNbMzhdIDw8IDgpIHwgKHNbMzldID4+PiAyNCk7XG4gICAgICBiMjcgPSAoc1szOV0gPDwgOCkgfCAoc1szOF0gPj4+IDI0KTtcbiAgICAgIGI4ID0gKHNbNDhdIDw8IDE0KSB8IChzWzQ5XSA+Pj4gMTgpO1xuICAgICAgYjkgPSAoc1s0OV0gPDwgMTQpIHwgKHNbNDhdID4+PiAxOCk7XG5cbiAgICAgIHNbMF0gPSBiMCBeICh+YjIgJiBiNCk7XG4gICAgICBzWzFdID0gYjEgXiAofmIzICYgYjUpO1xuICAgICAgc1sxMF0gPSBiMTAgXiAofmIxMiAmIGIxNCk7XG4gICAgICBzWzExXSA9IGIxMSBeICh+YjEzICYgYjE1KTtcbiAgICAgIHNbMjBdID0gYjIwIF4gKH5iMjIgJiBiMjQpO1xuICAgICAgc1syMV0gPSBiMjEgXiAofmIyMyAmIGIyNSk7XG4gICAgICBzWzMwXSA9IGIzMCBeICh+YjMyICYgYjM0KTtcbiAgICAgIHNbMzFdID0gYjMxIF4gKH5iMzMgJiBiMzUpO1xuICAgICAgc1s0MF0gPSBiNDAgXiAofmI0MiAmIGI0NCk7XG4gICAgICBzWzQxXSA9IGI0MSBeICh+YjQzICYgYjQ1KTtcbiAgICAgIHNbMl0gPSBiMiBeICh+YjQgJiBiNik7XG4gICAgICBzWzNdID0gYjMgXiAofmI1ICYgYjcpO1xuICAgICAgc1sxMl0gPSBiMTIgXiAofmIxNCAmIGIxNik7XG4gICAgICBzWzEzXSA9IGIxMyBeICh+YjE1ICYgYjE3KTtcbiAgICAgIHNbMjJdID0gYjIyIF4gKH5iMjQgJiBiMjYpO1xuICAgICAgc1syM10gPSBiMjMgXiAofmIyNSAmIGIyNyk7XG4gICAgICBzWzMyXSA9IGIzMiBeICh+YjM0ICYgYjM2KTtcbiAgICAgIHNbMzNdID0gYjMzIF4gKH5iMzUgJiBiMzcpO1xuICAgICAgc1s0Ml0gPSBiNDIgXiAofmI0NCAmIGI0Nik7XG4gICAgICBzWzQzXSA9IGI0MyBeICh+YjQ1ICYgYjQ3KTtcbiAgICAgIHNbNF0gPSBiNCBeICh+YjYgJiBiOCk7XG4gICAgICBzWzVdID0gYjUgXiAofmI3ICYgYjkpO1xuICAgICAgc1sxNF0gPSBiMTQgXiAofmIxNiAmIGIxOCk7XG4gICAgICBzWzE1XSA9IGIxNSBeICh+YjE3ICYgYjE5KTtcbiAgICAgIHNbMjRdID0gYjI0IF4gKH5iMjYgJiBiMjgpO1xuICAgICAgc1syNV0gPSBiMjUgXiAofmIyNyAmIGIyOSk7XG4gICAgICBzWzM0XSA9IGIzNCBeICh+YjM2ICYgYjM4KTtcbiAgICAgIHNbMzVdID0gYjM1IF4gKH5iMzcgJiBiMzkpO1xuICAgICAgc1s0NF0gPSBiNDQgXiAofmI0NiAmIGI0OCk7XG4gICAgICBzWzQ1XSA9IGI0NSBeICh+YjQ3ICYgYjQ5KTtcbiAgICAgIHNbNl0gPSBiNiBeICh+YjggJiBiMCk7XG4gICAgICBzWzddID0gYjcgXiAofmI5ICYgYjEpO1xuICAgICAgc1sxNl0gPSBiMTYgXiAofmIxOCAmIGIxMCk7XG4gICAgICBzWzE3XSA9IGIxNyBeICh+YjE5ICYgYjExKTtcbiAgICAgIHNbMjZdID0gYjI2IF4gKH5iMjggJiBiMjApO1xuICAgICAgc1syN10gPSBiMjcgXiAofmIyOSAmIGIyMSk7XG4gICAgICBzWzM2XSA9IGIzNiBeICh+YjM4ICYgYjMwKTtcbiAgICAgIHNbMzddID0gYjM3IF4gKH5iMzkgJiBiMzEpO1xuICAgICAgc1s0Nl0gPSBiNDYgXiAofmI0OCAmIGI0MCk7XG4gICAgICBzWzQ3XSA9IGI0NyBeICh+YjQ5ICYgYjQxKTtcbiAgICAgIHNbOF0gPSBiOCBeICh+YjAgJiBiMik7XG4gICAgICBzWzldID0gYjkgXiAofmIxICYgYjMpO1xuICAgICAgc1sxOF0gPSBiMTggXiAofmIxMCAmIGIxMik7XG4gICAgICBzWzE5XSA9IGIxOSBeICh+YjExICYgYjEzKTtcbiAgICAgIHNbMjhdID0gYjI4IF4gKH5iMjAgJiBiMjIpO1xuICAgICAgc1syOV0gPSBiMjkgXiAofmIyMSAmIGIyMyk7XG4gICAgICBzWzM4XSA9IGIzOCBeICh+YjMwICYgYjMyKTtcbiAgICAgIHNbMzldID0gYjM5IF4gKH5iMzEgJiBiMzMpO1xuICAgICAgc1s0OF0gPSBiNDggXiAofmI0MCAmIGI0Mik7XG4gICAgICBzWzQ5XSA9IGI0OSBeICh+YjQxICYgYjQzKTtcblxuICAgICAgc1swXSBePSBSQ1tuXTtcbiAgICAgIHNbMV0gXj0gUkNbbiArIDFdO1xuICAgIH1cbiAgfTtcblxuICBpZiAoQ09NTU9OX0pTKSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBtZXRob2RzO1xuICB9IGVsc2Uge1xuICAgIGZvciAoaSA9IDA7IGkgPCBtZXRob2ROYW1lcy5sZW5ndGg7ICsraSkge1xuICAgICAgcm9vdFttZXRob2ROYW1lc1tpXV0gPSBtZXRob2RzW21ldGhvZE5hbWVzW2ldXTtcbiAgICB9XG4gICAgaWYgKEFNRCkge1xuICAgICAgZGVmaW5lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG1ldGhvZHM7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cbn0pKCk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGFzc2VydDtcblxuZnVuY3Rpb24gYXNzZXJ0KHZhbCwgbXNnKSB7XG4gIGlmICghdmFsKVxuICAgIHRocm93IG5ldyBFcnJvcihtc2cgfHwgJ0Fzc2VydGlvbiBmYWlsZWQnKTtcbn1cblxuYXNzZXJ0LmVxdWFsID0gZnVuY3Rpb24gYXNzZXJ0RXF1YWwobCwgciwgbXNnKSB7XG4gIGlmIChsICE9IHIpXG4gICAgdGhyb3cgbmV3IEVycm9yKG1zZyB8fCAoJ0Fzc2VydGlvbiBmYWlsZWQ6ICcgKyBsICsgJyAhPSAnICsgcikpO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4oZnVuY3Rpb24ocm9vdCkge1xuICAgIGNvbnN0IE1BWF9WQUxVRSA9IDB4N2ZmZmZmZmY7XG5cbiAgICAvLyBUaGUgU0hBMjU2IGFuZCBQQktERjIgaW1wbGVtZW50YXRpb24gYXJlIGZyb20gc2NyeXB0LWFzeW5jLWpzOlxuICAgIC8vIFNlZTogaHR0cHM6Ly9naXRodWIuY29tL2RjaGVzdC9zY3J5cHQtYXN5bmMtanNcbiAgICBmdW5jdGlvbiBTSEEyNTYobSkge1xuICAgICAgICBjb25zdCBLID0gbmV3IFVpbnQzMkFycmF5KFtcbiAgICAgICAgICAgMHg0MjhhMmY5OCwgMHg3MTM3NDQ5MSwgMHhiNWMwZmJjZiwgMHhlOWI1ZGJhNSwgMHgzOTU2YzI1YixcbiAgICAgICAgICAgMHg1OWYxMTFmMSwgMHg5MjNmODJhNCwgMHhhYjFjNWVkNSwgMHhkODA3YWE5OCwgMHgxMjgzNWIwMSxcbiAgICAgICAgICAgMHgyNDMxODViZSwgMHg1NTBjN2RjMywgMHg3MmJlNWQ3NCwgMHg4MGRlYjFmZSwgMHg5YmRjMDZhNyxcbiAgICAgICAgICAgMHhjMTliZjE3NCwgMHhlNDliNjljMSwgMHhlZmJlNDc4NiwgMHgwZmMxOWRjNiwgMHgyNDBjYTFjYyxcbiAgICAgICAgICAgMHgyZGU5MmM2ZiwgMHg0YTc0ODRhYSwgMHg1Y2IwYTlkYywgMHg3NmY5ODhkYSwgMHg5ODNlNTE1MixcbiAgICAgICAgICAgMHhhODMxYzY2ZCwgMHhiMDAzMjdjOCwgMHhiZjU5N2ZjNywgMHhjNmUwMGJmMywgMHhkNWE3OTE0NyxcbiAgICAgICAgICAgMHgwNmNhNjM1MSwgMHgxNDI5Mjk2NywgMHgyN2I3MGE4NSwgMHgyZTFiMjEzOCwgMHg0ZDJjNmRmYyxcbiAgICAgICAgICAgMHg1MzM4MGQxMywgMHg2NTBhNzM1NCwgMHg3NjZhMGFiYiwgMHg4MWMyYzkyZSwgMHg5MjcyMmM4NSxcbiAgICAgICAgICAgMHhhMmJmZThhMSwgMHhhODFhNjY0YiwgMHhjMjRiOGI3MCwgMHhjNzZjNTFhMywgMHhkMTkyZTgxOSxcbiAgICAgICAgICAgMHhkNjk5MDYyNCwgMHhmNDBlMzU4NSwgMHgxMDZhYTA3MCwgMHgxOWE0YzExNiwgMHgxZTM3NmMwOCxcbiAgICAgICAgICAgMHgyNzQ4Nzc0YywgMHgzNGIwYmNiNSwgMHgzOTFjMGNiMywgMHg0ZWQ4YWE0YSwgMHg1YjljY2E0ZixcbiAgICAgICAgICAgMHg2ODJlNmZmMywgMHg3NDhmODJlZSwgMHg3OGE1NjM2ZiwgMHg4NGM4NzgxNCwgMHg4Y2M3MDIwOCxcbiAgICAgICAgICAgMHg5MGJlZmZmYSwgMHhhNDUwNmNlYiwgMHhiZWY5YTNmNywgMHhjNjcxNzhmMlxuICAgICAgIF0pO1xuXG4gICAgICAgIGxldCBoMCA9IDB4NmEwOWU2NjcsIGgxID0gMHhiYjY3YWU4NSwgaDIgPSAweDNjNmVmMzcyLCBoMyA9IDB4YTU0ZmY1M2E7XG4gICAgICAgIGxldCBoNCA9IDB4NTEwZTUyN2YsIGg1ID0gMHg5YjA1Njg4YywgaDYgPSAweDFmODNkOWFiLCBoNyA9IDB4NWJlMGNkMTk7XG4gICAgICAgIGNvbnN0IHcgPSBuZXcgVWludDMyQXJyYXkoNjQpO1xuXG4gICAgICAgIGZ1bmN0aW9uIGJsb2NrcyhwKSB7XG4gICAgICAgICAgICBsZXQgb2ZmID0gMCwgbGVuID0gcC5sZW5ndGg7XG4gICAgICAgICAgICB3aGlsZSAobGVuID49IDY0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGEgPSBoMCwgYiA9IGgxLCBjID0gaDIsIGQgPSBoMywgZSA9IGg0LCBmID0gaDUsIGcgPSBoNiwgaCA9IGg3LCB1LCBpLCBqLCB0MSwgdDI7XG5cbiAgICAgICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgMTY7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICBqID0gb2ZmICsgaSo0O1xuICAgICAgICAgICAgICAgICAgICB3W2ldID0gKChwW2pdICYgMHhmZik8PDI0KSB8ICgocFtqKzFdICYgMHhmZik8PDE2KSB8XG4gICAgICAgICAgICAgICAgICAgICgocFtqKzJdICYgMHhmZik8PDgpIHwgKHBbaiszXSAmIDB4ZmYpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDE2OyBpIDwgNjQ7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB1ID0gd1tpLTJdO1xuICAgICAgICAgICAgICAgICAgICB0MSA9ICgodT4+PjE3KSB8ICh1PDwoMzItMTcpKSkgXiAoKHU+Pj4xOSkgfCAodTw8KDMyLTE5KSkpIF4gKHU+Pj4xMCk7XG5cbiAgICAgICAgICAgICAgICAgICAgdSA9IHdbaS0xNV07XG4gICAgICAgICAgICAgICAgICAgIHQyID0gKCh1Pj4+NykgfCAodTw8KDMyLTcpKSkgXiAoKHU+Pj4xOCkgfCAodTw8KDMyLTE4KSkpIF4gKHU+Pj4zKTtcblxuICAgICAgICAgICAgICAgICAgICB3W2ldID0gKCgodDEgKyB3W2ktN10pIHwgMCkgKyAoKHQyICsgd1tpLTE2XSkgfCAwKSkgfCAwO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHQxID0gKCgoKCgoZT4+PjYpIHwgKGU8PCgzMi02KSkpIF4gKChlPj4+MTEpIHwgKGU8PCgzMi0xMSkpKSBeXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZT4+PjI1KSB8IChlPDwoMzItMjUpKSkpICsgKChlICYgZikgXiAofmUgJiBnKSkpIHwgMCkgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAoKGggKyAoKEtbaV0gKyB3W2ldKSB8IDApKSB8IDApKSB8IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgdDIgPSAoKCgoYT4+PjIpIHwgKGE8PCgzMi0yKSkpIF4gKChhPj4+MTMpIHwgKGE8PCgzMi0xMykpKSBeXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAoKGE+Pj4yMikgfCAoYTw8KDMyLTIyKSkpKSArICgoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYykpKSB8IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgaCA9IGc7XG4gICAgICAgICAgICAgICAgICAgIGcgPSBmO1xuICAgICAgICAgICAgICAgICAgICBmID0gZTtcbiAgICAgICAgICAgICAgICAgICAgZSA9IChkICsgdDEpIHwgMDtcbiAgICAgICAgICAgICAgICAgICAgZCA9IGM7XG4gICAgICAgICAgICAgICAgICAgIGMgPSBiO1xuICAgICAgICAgICAgICAgICAgICBiID0gYTtcbiAgICAgICAgICAgICAgICAgICAgYSA9ICh0MSArIHQyKSB8IDA7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaDAgPSAoaDAgKyBhKSB8IDA7XG4gICAgICAgICAgICAgICAgaDEgPSAoaDEgKyBiKSB8IDA7XG4gICAgICAgICAgICAgICAgaDIgPSAoaDIgKyBjKSB8IDA7XG4gICAgICAgICAgICAgICAgaDMgPSAoaDMgKyBkKSB8IDA7XG4gICAgICAgICAgICAgICAgaDQgPSAoaDQgKyBlKSB8IDA7XG4gICAgICAgICAgICAgICAgaDUgPSAoaDUgKyBmKSB8IDA7XG4gICAgICAgICAgICAgICAgaDYgPSAoaDYgKyBnKSB8IDA7XG4gICAgICAgICAgICAgICAgaDcgPSAoaDcgKyBoKSB8IDA7XG5cbiAgICAgICAgICAgICAgICBvZmYgKz0gNjQ7XG4gICAgICAgICAgICAgICAgbGVuIC09IDY0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgYmxvY2tzKG0pO1xuXG4gICAgICAgIGxldCBpLCBieXRlc0xlZnQgPSBtLmxlbmd0aCAlIDY0LFxuICAgICAgICBiaXRMZW5IaSA9IChtLmxlbmd0aCAvIDB4MjAwMDAwMDApIHwgMCxcbiAgICAgICAgYml0TGVuTG8gPSBtLmxlbmd0aCA8PCAzLFxuICAgICAgICBudW1aZXJvcyA9IChieXRlc0xlZnQgPCA1NikgPyA1NiA6IDEyMCxcbiAgICAgICAgcCA9IG0uc2xpY2UobS5sZW5ndGggLSBieXRlc0xlZnQsIG0ubGVuZ3RoKTtcblxuICAgICAgICBwLnB1c2goMHg4MCk7XG4gICAgICAgIGZvciAoaSA9IGJ5dGVzTGVmdCArIDE7IGkgPCBudW1aZXJvczsgaSsrKSB7IHAucHVzaCgwKTsgfVxuICAgICAgICBwLnB1c2goKGJpdExlbkhpID4+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgcC5wdXNoKChiaXRMZW5IaSA+Pj4gMTYpICYgMHhmZik7XG4gICAgICAgIHAucHVzaCgoYml0TGVuSGkgPj4+IDgpICAmIDB4ZmYpO1xuICAgICAgICBwLnB1c2goKGJpdExlbkhpID4+PiAwKSAgJiAweGZmKTtcbiAgICAgICAgcC5wdXNoKChiaXRMZW5MbyA+Pj4gMjQpICYgMHhmZik7XG4gICAgICAgIHAucHVzaCgoYml0TGVuTG8gPj4+IDE2KSAmIDB4ZmYpO1xuICAgICAgICBwLnB1c2goKGJpdExlbkxvID4+PiA4KSAgJiAweGZmKTtcbiAgICAgICAgcC5wdXNoKChiaXRMZW5MbyA+Pj4gMCkgICYgMHhmZik7XG5cbiAgICAgICAgYmxvY2tzKHApO1xuXG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICAoaDAgPj4+IDI0KSAmIDB4ZmYsIChoMCA+Pj4gMTYpICYgMHhmZiwgKGgwID4+PiA4KSAmIDB4ZmYsIChoMCA+Pj4gMCkgJiAweGZmLFxuICAgICAgICAgICAgKGgxID4+PiAyNCkgJiAweGZmLCAoaDEgPj4+IDE2KSAmIDB4ZmYsIChoMSA+Pj4gOCkgJiAweGZmLCAoaDEgPj4+IDApICYgMHhmZixcbiAgICAgICAgICAgIChoMiA+Pj4gMjQpICYgMHhmZiwgKGgyID4+PiAxNikgJiAweGZmLCAoaDIgPj4+IDgpICYgMHhmZiwgKGgyID4+PiAwKSAmIDB4ZmYsXG4gICAgICAgICAgICAoaDMgPj4+IDI0KSAmIDB4ZmYsIChoMyA+Pj4gMTYpICYgMHhmZiwgKGgzID4+PiA4KSAmIDB4ZmYsIChoMyA+Pj4gMCkgJiAweGZmLFxuICAgICAgICAgICAgKGg0ID4+PiAyNCkgJiAweGZmLCAoaDQgPj4+IDE2KSAmIDB4ZmYsIChoNCA+Pj4gOCkgJiAweGZmLCAoaDQgPj4+IDApICYgMHhmZixcbiAgICAgICAgICAgIChoNSA+Pj4gMjQpICYgMHhmZiwgKGg1ID4+PiAxNikgJiAweGZmLCAoaDUgPj4+IDgpICYgMHhmZiwgKGg1ID4+PiAwKSAmIDB4ZmYsXG4gICAgICAgICAgICAoaDYgPj4+IDI0KSAmIDB4ZmYsIChoNiA+Pj4gMTYpICYgMHhmZiwgKGg2ID4+PiA4KSAmIDB4ZmYsIChoNiA+Pj4gMCkgJiAweGZmLFxuICAgICAgICAgICAgKGg3ID4+PiAyNCkgJiAweGZmLCAoaDcgPj4+IDE2KSAmIDB4ZmYsIChoNyA+Pj4gOCkgJiAweGZmLCAoaDcgPj4+IDApICYgMHhmZlxuICAgICAgICBdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIFBCS0RGMl9ITUFDX1NIQTI1Nl9PbmVJdGVyKHBhc3N3b3JkLCBzYWx0LCBka0xlbikge1xuICAgICAgICAvLyBjb21wcmVzcyBwYXNzd29yZCBpZiBpdCdzIGxvbmdlciB0aGFuIGhhc2ggYmxvY2sgbGVuZ3RoXG4gICAgICAgIHBhc3N3b3JkID0gKHBhc3N3b3JkLmxlbmd0aCA8PSA2NCkgPyBwYXNzd29yZCA6IFNIQTI1NihwYXNzd29yZCk7XG5cbiAgICAgICAgY29uc3QgaW5uZXJMZW4gPSA2NCArIHNhbHQubGVuZ3RoICsgNDtcbiAgICAgICAgY29uc3QgaW5uZXIgPSBuZXcgQXJyYXkoaW5uZXJMZW4pO1xuICAgICAgICBjb25zdCBvdXRlcktleSA9IG5ldyBBcnJheSg2NCk7XG5cbiAgICAgICAgbGV0IGk7XG4gICAgICAgIGxldCBkayA9IFtdO1xuXG4gICAgICAgIC8vIGlubmVyID0gKHBhc3N3b3JkIF4gaXBhZCkgfHwgc2FsdCB8fCBjb3VudGVyXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCA2NDsgaSsrKSB7IGlubmVyW2ldID0gMHgzNjsgfVxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFzc3dvcmQubGVuZ3RoOyBpKyspIHsgaW5uZXJbaV0gXj0gcGFzc3dvcmRbaV07IH1cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNhbHQubGVuZ3RoOyBpKyspIHsgaW5uZXJbNjQgKyBpXSA9IHNhbHRbaV07IH1cbiAgICAgICAgZm9yIChpID0gaW5uZXJMZW4gLSA0OyBpIDwgaW5uZXJMZW47IGkrKykgeyBpbm5lcltpXSA9IDA7IH1cblxuICAgICAgICAvLyBvdXRlcktleSA9IHBhc3N3b3JkIF4gb3BhZFxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgNjQ7IGkrKykgb3V0ZXJLZXlbaV0gPSAweDVjO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgcGFzc3dvcmQubGVuZ3RoOyBpKyspIG91dGVyS2V5W2ldIF49IHBhc3N3b3JkW2ldO1xuXG4gICAgICAgIC8vIGluY3JlbWVudHMgY291bnRlciBpbnNpZGUgaW5uZXJcbiAgICAgICAgZnVuY3Rpb24gaW5jcmVtZW50Q291bnRlcigpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSBpbm5lckxlbiAtIDE7IGkgPj0gaW5uZXJMZW4gLSA0OyBpLS0pIHtcbiAgICAgICAgICAgICAgICBpbm5lcltpXSsrO1xuICAgICAgICAgICAgICAgIGlmIChpbm5lcltpXSA8PSAweGZmKSByZXR1cm47XG4gICAgICAgICAgICAgICAgaW5uZXJbaV0gPSAwO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gb3V0cHV0IGJsb2NrcyA9IFNIQTI1NihvdXRlcktleSB8fCBTSEEyNTYoaW5uZXIpKSAuLi5cbiAgICAgICAgd2hpbGUgKGRrTGVuID49IDMyKSB7XG4gICAgICAgICAgICBpbmNyZW1lbnRDb3VudGVyKCk7XG4gICAgICAgICAgICBkayA9IGRrLmNvbmNhdChTSEEyNTYob3V0ZXJLZXkuY29uY2F0KFNIQTI1Nihpbm5lcikpKSk7XG4gICAgICAgICAgICBka0xlbiAtPSAzMjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGtMZW4gPiAwKSB7XG4gICAgICAgICAgICBpbmNyZW1lbnRDb3VudGVyKCk7XG4gICAgICAgICAgICBkayA9IGRrLmNvbmNhdChTSEEyNTYob3V0ZXJLZXkuY29uY2F0KFNIQTI1Nihpbm5lcikpKS5zbGljZSgwLCBka0xlbikpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGRrO1xuICAgIH1cblxuICAgIC8vIFRoZSBmb2xsb3dpbmcgaXMgYW4gYWRhcHRhdGlvbiBvZiBzY3J5cHRzeVxuICAgIC8vIFNlZTogaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2Uvc2NyeXB0c3lcbiAgICBmdW5jdGlvbiBibG9ja21peF9zYWxzYTgoQlksIFlpLCByLCB4LCBfWCkge1xuICAgICAgICBsZXQgaTtcblxuICAgICAgICBhcnJheWNvcHkoQlksICgyICogciAtIDEpICogMTYsIF9YLCAwLCAxNik7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCAyICogcjsgaSsrKSB7XG4gICAgICAgICAgICBibG9ja3hvcihCWSwgaSAqIDE2LCBfWCwgMTYpO1xuICAgICAgICAgICAgc2Fsc2EyMF84KF9YLCB4KTtcbiAgICAgICAgICAgIGFycmF5Y29weShfWCwgMCwgQlksIFlpICsgKGkgKiAxNiksIDE2KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCByOyBpKyspIHtcbiAgICAgICAgICAgIGFycmF5Y29weShCWSwgWWkgKyAoaSAqIDIpICogMTYsIEJZLCAoaSAqIDE2KSwgMTYpO1xuICAgICAgICB9XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHI7IGkrKykge1xuICAgICAgICAgICAgYXJyYXljb3B5KEJZLCBZaSArIChpICogMiArIDEpICogMTYsIEJZLCAoaSArIHIpICogMTYsIDE2KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIFIoYSwgYikge1xuICAgICAgICByZXR1cm4gKGEgPDwgYikgfCAoYSA+Pj4gKDMyIC0gYikpO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNhbHNhMjBfOChCLCB4KSB7XG4gICAgICAgIGFycmF5Y29weShCLCAwLCB4LCAwLCAxNik7XG5cbiAgICAgICAgZm9yIChsZXQgaSA9IDg7IGkgPiAwOyBpIC09IDIpIHtcbiAgICAgICAgICAgIHhbIDRdIF49IFIoeFsgMF0gKyB4WzEyXSwgNyk7XG4gICAgICAgICAgICB4WyA4XSBePSBSKHhbIDRdICsgeFsgMF0sIDkpO1xuICAgICAgICAgICAgeFsxMl0gXj0gUih4WyA4XSArIHhbIDRdLCAxMyk7XG4gICAgICAgICAgICB4WyAwXSBePSBSKHhbMTJdICsgeFsgOF0sIDE4KTtcbiAgICAgICAgICAgIHhbIDldIF49IFIoeFsgNV0gKyB4WyAxXSwgNyk7XG4gICAgICAgICAgICB4WzEzXSBePSBSKHhbIDldICsgeFsgNV0sIDkpO1xuICAgICAgICAgICAgeFsgMV0gXj0gUih4WzEzXSArIHhbIDldLCAxMyk7XG4gICAgICAgICAgICB4WyA1XSBePSBSKHhbIDFdICsgeFsxM10sIDE4KTtcbiAgICAgICAgICAgIHhbMTRdIF49IFIoeFsxMF0gKyB4WyA2XSwgNyk7XG4gICAgICAgICAgICB4WyAyXSBePSBSKHhbMTRdICsgeFsxMF0sIDkpO1xuICAgICAgICAgICAgeFsgNl0gXj0gUih4WyAyXSArIHhbMTRdLCAxMyk7XG4gICAgICAgICAgICB4WzEwXSBePSBSKHhbIDZdICsgeFsgMl0sIDE4KTtcbiAgICAgICAgICAgIHhbIDNdIF49IFIoeFsxNV0gKyB4WzExXSwgNyk7XG4gICAgICAgICAgICB4WyA3XSBePSBSKHhbIDNdICsgeFsxNV0sIDkpO1xuICAgICAgICAgICAgeFsxMV0gXj0gUih4WyA3XSArIHhbIDNdLCAxMyk7XG4gICAgICAgICAgICB4WzE1XSBePSBSKHhbMTFdICsgeFsgN10sIDE4KTtcbiAgICAgICAgICAgIHhbIDFdIF49IFIoeFsgMF0gKyB4WyAzXSwgNyk7XG4gICAgICAgICAgICB4WyAyXSBePSBSKHhbIDFdICsgeFsgMF0sIDkpO1xuICAgICAgICAgICAgeFsgM10gXj0gUih4WyAyXSArIHhbIDFdLCAxMyk7XG4gICAgICAgICAgICB4WyAwXSBePSBSKHhbIDNdICsgeFsgMl0sIDE4KTtcbiAgICAgICAgICAgIHhbIDZdIF49IFIoeFsgNV0gKyB4WyA0XSwgNyk7XG4gICAgICAgICAgICB4WyA3XSBePSBSKHhbIDZdICsgeFsgNV0sIDkpO1xuICAgICAgICAgICAgeFsgNF0gXj0gUih4WyA3XSArIHhbIDZdLCAxMyk7XG4gICAgICAgICAgICB4WyA1XSBePSBSKHhbIDRdICsgeFsgN10sIDE4KTtcbiAgICAgICAgICAgIHhbMTFdIF49IFIoeFsxMF0gKyB4WyA5XSwgNyk7XG4gICAgICAgICAgICB4WyA4XSBePSBSKHhbMTFdICsgeFsxMF0sIDkpO1xuICAgICAgICAgICAgeFsgOV0gXj0gUih4WyA4XSArIHhbMTFdLCAxMyk7XG4gICAgICAgICAgICB4WzEwXSBePSBSKHhbIDldICsgeFsgOF0sIDE4KTtcbiAgICAgICAgICAgIHhbMTJdIF49IFIoeFsxNV0gKyB4WzE0XSwgNyk7XG4gICAgICAgICAgICB4WzEzXSBePSBSKHhbMTJdICsgeFsxNV0sIDkpO1xuICAgICAgICAgICAgeFsxNF0gXj0gUih4WzEzXSArIHhbMTJdLCAxMyk7XG4gICAgICAgICAgICB4WzE1XSBePSBSKHhbMTRdICsgeFsxM10sIDE4KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTY7ICsraSkge1xuICAgICAgICAgICAgQltpXSArPSB4W2ldO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgLy8gbmFpdmUgYXBwcm9hY2guLi4gZ29pbmcgYmFjayB0byBsb29wIHVucm9sbGluZyBtYXkgeWllbGQgYWRkaXRpb25hbCBwZXJmb3JtYW5jZVxuICAgIGZ1bmN0aW9uIGJsb2NreG9yKFMsIFNpLCBELCBsZW4pIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgRFtpXSBePSBTW1NpICsgaV1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGFycmF5Y29weShzcmMsIHNyY1BvcywgZGVzdCwgZGVzdFBvcywgbGVuZ3RoKSB7XG4gICAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNoZWNrQnVmZmVyaXNoKG8pIHtcbiAgICAgICAgaWYgKCFvIHx8IHR5cGVvZihvLmxlbmd0aCkgIT09ICdudW1iZXInKSB7IHJldHVybiBmYWxzZTsgfVxuXG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgby5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3QgdiA9IG9baV07XG4gICAgICAgICAgICBpZiAodHlwZW9mKHYpICE9PSAnbnVtYmVyJyB8fCB2ICUgMSB8fCB2IDwgMCB8fCB2ID49IDI1Nikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGVuc3VyZUludGVnZXIodmFsdWUsIG5hbWUpIHtcbiAgICAgICAgaWYgKHR5cGVvZih2YWx1ZSkgIT09IFwibnVtYmVyXCIgfHwgKHZhbHVlICUgMSkpIHsgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkICcgKyBuYW1lKTsgfVxuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLy8gTiA9IENwdSBjb3N0LCByID0gTWVtb3J5IGNvc3QsIHAgPSBwYXJhbGxlbGl6YXRpb24gY29zdFxuICAgIC8vIGNhbGxiYWNrKGVycm9yLCBwcm9ncmVzcywga2V5KVxuICAgIGZ1bmN0aW9uIF9zY3J5cHQocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBjYWxsYmFjaykge1xuXG4gICAgICAgIE4gPSBlbnN1cmVJbnRlZ2VyKE4sICdOJyk7XG4gICAgICAgIHIgPSBlbnN1cmVJbnRlZ2VyKHIsICdyJyk7XG4gICAgICAgIHAgPSBlbnN1cmVJbnRlZ2VyKHAsICdwJyk7XG5cbiAgICAgICAgZGtMZW4gPSBlbnN1cmVJbnRlZ2VyKGRrTGVuLCAnZGtMZW4nKTtcblxuICAgICAgICBpZiAoTiA9PT0gMCB8fCAoTiAmIChOIC0gMSkpICE9PSAwKSB7IHRocm93IG5ldyBFcnJvcignTiBtdXN0IGJlIHBvd2VyIG9mIDInKTsgfVxuXG4gICAgICAgIGlmIChOID4gTUFYX1ZBTFVFIC8gMTI4IC8gcikgeyB0aHJvdyBuZXcgRXJyb3IoJ04gdG9vIGxhcmdlJyk7IH1cbiAgICAgICAgaWYgKHIgPiBNQVhfVkFMVUUgLyAxMjggLyBwKSB7IHRocm93IG5ldyBFcnJvcignciB0b28gbGFyZ2UnKTsgfVxuXG4gICAgICAgIGlmICghY2hlY2tCdWZmZXJpc2gocGFzc3dvcmQpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ3Bhc3N3b3JkIG11c3QgYmUgYW4gYXJyYXkgb3IgYnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgcGFzc3dvcmQgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChwYXNzd29yZCk7XG5cbiAgICAgICAgaWYgKCFjaGVja0J1ZmZlcmlzaChzYWx0KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdzYWx0IG11c3QgYmUgYW4gYXJyYXkgb3IgYnVmZmVyJyk7XG4gICAgICAgIH1cbiAgICAgICAgc2FsdCA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKHNhbHQpO1xuXG4gICAgICAgIGxldCBiID0gUEJLREYyX0hNQUNfU0hBMjU2X09uZUl0ZXIocGFzc3dvcmQsIHNhbHQsIHAgKiAxMjggKiByKTtcbiAgICAgICAgY29uc3QgQiA9IG5ldyBVaW50MzJBcnJheShwICogMzIgKiByKVxuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNvbnN0IGogPSBpICogNDtcbiAgICAgICAgICAgIEJbaV0gPSAoKGJbaiArIDNdICYgMHhmZikgPDwgMjQpIHxcbiAgICAgICAgICAgICAgICAgICAoKGJbaiArIDJdICYgMHhmZikgPDwgMTYpIHxcbiAgICAgICAgICAgICAgICAgICAoKGJbaiArIDFdICYgMHhmZikgPDwgOCkgfFxuICAgICAgICAgICAgICAgICAgICgoYltqICsgMF0gJiAweGZmKSA8PCAwKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGNvbnN0IFhZID0gbmV3IFVpbnQzMkFycmF5KDY0ICogcik7XG4gICAgICAgIGNvbnN0IFYgPSBuZXcgVWludDMyQXJyYXkoMzIgKiByICogTik7XG5cbiAgICAgICAgY29uc3QgWWkgPSAzMiAqIHI7XG5cbiAgICAgICAgLy8gc2NyYXRjaCBzcGFjZVxuICAgICAgICBjb25zdCB4ID0gbmV3IFVpbnQzMkFycmF5KDE2KTsgICAgICAgLy8gc2Fsc2EyMF84XG4gICAgICAgIGNvbnN0IF9YID0gbmV3IFVpbnQzMkFycmF5KDE2KTsgICAgICAvLyBibG9ja21peF9zYWxzYThcblxuICAgICAgICBjb25zdCB0b3RhbE9wcyA9IHAgKiBOICogMjtcbiAgICAgICAgbGV0IGN1cnJlbnRPcCA9IDA7XG4gICAgICAgIGxldCBsYXN0UGVyY2VudDEwID0gbnVsbDtcblxuICAgICAgICAvLyBTZXQgdGhpcyB0byB0cnVlIHRvIGFiYW5kb24gdGhlIHNjcnlwdCBvbiB0aGUgbmV4dCBzdGVwXG4gICAgICAgIGxldCBzdG9wID0gZmFsc2U7XG5cbiAgICAgICAgLy8gU3RhdGUgaW5mb3JtYXRpb25cbiAgICAgICAgbGV0IHN0YXRlID0gMDtcbiAgICAgICAgbGV0IGkwID0gMCwgaTE7XG4gICAgICAgIGxldCBCaTtcblxuICAgICAgICAvLyBIb3cgbWFueSBibG9ja21peF9zYWxzYTggY2FuIHdlIGRvIHBlciBzdGVwP1xuICAgICAgICBjb25zdCBsaW1pdCA9IGNhbGxiYWNrID8gcGFyc2VJbnQoMTAwMCAvIHIpOiAweGZmZmZmZmZmO1xuXG4gICAgICAgIC8vIFRyaWNrIGZyb20gc2NyeXB0LWFzeW5jOyBpZiB0aGVyZSBpcyBhIHNldEltbWVkaWF0ZSBzaGltIGluIHBsYWNlLCB1c2UgaXRcbiAgICAgICAgY29uc3QgbmV4dFRpY2sgPSAodHlwZW9mKHNldEltbWVkaWF0ZSkgIT09ICd1bmRlZmluZWQnKSA/IHNldEltbWVkaWF0ZSA6IHNldFRpbWVvdXQ7XG5cbiAgICAgICAgLy8gVGhpcyBpcyByZWFsbHkgYWxsIEkgY2hhbmdlZDsgbWFraW5nIHNjcnlwdHN5IGEgc3RhdGUgbWFjaGluZSBzbyB3ZSBvY2Nhc2lvbmFsbHlcbiAgICAgICAgLy8gc3RvcCBhbmQgZ2l2ZSBvdGhlciBldm50cyBvbiB0aGUgZXZudCBsb29wIGEgY2hhbmNlIHRvIHJ1bi4gflJpY01vb1xuICAgICAgICBjb25zdCBpbmNyZW1lbnRhbFNNaXggPSBmdW5jdGlvbigpIHtcbiAgICAgICAgICAgIGlmIChzdG9wKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG5ldyBFcnJvcignY2FuY2VsbGVkJyksIGN1cnJlbnRPcCAvIHRvdGFsT3BzKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbGV0IHN0ZXBzO1xuXG4gICAgICAgICAgICBzd2l0Y2ggKHN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAwOlxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IHA7IGkrKykuLi5cbiAgICAgICAgICAgICAgICAgICAgQmkgPSBpMCAqIDMyICogcjtcblxuICAgICAgICAgICAgICAgICAgICBhcnJheWNvcHkoQiwgQmksIFhZLCAwLCBZaSk7ICAgICAgICAgICAgICAgICAgICAgICAvLyBST01peCAtIDFcblxuICAgICAgICAgICAgICAgICAgICBzdGF0ZSA9IDE7ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIFJPTWl4IDJcbiAgICAgICAgICAgICAgICAgICAgaTEgPSAwO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB1cCB0byAxMDAwIHN0ZXBzIG9mIHRoZSBmaXJzdCBpbm5lciBzbWl4IGxvb3BcbiAgICAgICAgICAgICAgICAgICAgc3RlcHMgPSBOIC0gaTE7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGVwcyA+IGxpbWl0KSB7IHN0ZXBzID0gbGltaXQ7IH1cbiAgICAgICAgICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdGVwczsgaSsrKSB7ICAgICAgICAgICAgICAgICAgLy8gUk9NaXggLSAyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcnJheWNvcHkoWFksIDAsIFYsIChpMSArIGkpICogWWksIFlpKSAgICAgICAgIC8vIFJPTWl4IC0gM1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2ttaXhfc2Fsc2E4KFhZLCBZaSwgciwgeCwgX1gpOyAgICAgICAgICAgICAvLyBST01peCAtIDRcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIC8vIGZvciAodmFyIGkgPSAwOyBpIDwgTjsgaSsrKVxuICAgICAgICAgICAgICAgICAgICBpMSArPSBzdGVwcztcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudE9wICs9IHN0ZXBzO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2FsbCB0aGUgY2FsbGJhY2sgd2l0aCB0aGUgcHJvZ3Jlc3MgKG9wdGlvbmFsbHkgc3RvcHBpbmcgdXMpXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50MTAgPSBwYXJzZUludCgxMDAwICogY3VycmVudE9wIC8gdG90YWxPcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQxMCAhPT0gbGFzdFBlcmNlbnQxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSBjYWxsYmFjayhudWxsLCBjdXJyZW50T3AgLyB0b3RhbE9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGVyY2VudDEwID0gcGVyY2VudDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkxIDwgTikgeyBicmVhazsgfVxuXG4gICAgICAgICAgICAgICAgICAgIGkxID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBNb3ZlIHRvIFJPTWl4IDZcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSAyO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIEZhbGwgdGhyb3VnaFxuXG4gICAgICAgICAgICAgICAgY2FzZSAyOlxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJ1biB1cCB0byAxMDAwIHN0ZXBzIG9mIHRoZSBzZWNvbmQgaW5uZXIgc21peCBsb29wXG4gICAgICAgICAgICAgICAgICAgIHN0ZXBzID0gTiAtIGkxO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RlcHMgPiBsaW1pdCkgeyBzdGVwcyA9IGxpbWl0OyB9XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3RlcHM7IGkrKykgeyAgICAgICAgICAgICAgICAvLyBST01peCAtIDZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG9mZnNldCA9ICgyICogciAtIDEpICogMTY7ICAgICAgICAgICAgIC8vIFJPTWl4IC0gN1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgaiA9IFhZW29mZnNldF0gJiAoTiAtIDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgYmxvY2t4b3IoViwgaiAqIFlpLCBYWSwgWWkpOyAgICAgICAgICAgICAgICAgLy8gUk9NaXggLSA4IChpbm5lcilcbiAgICAgICAgICAgICAgICAgICAgICAgIGJsb2NrbWl4X3NhbHNhOChYWSwgWWksIHIsIHgsIF9YKTsgICAgICAgICAgIC8vIFJPTWl4IC0gOSAob3V0ZXIpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBmb3IgKHZhciBpID0gMDsgaSA8IE47IGkrKykuLi5cbiAgICAgICAgICAgICAgICAgICAgaTEgKz0gc3RlcHM7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRPcCArPSBzdGVwcztcblxuICAgICAgICAgICAgICAgICAgICAvLyBDYWxsIHRoZSBjYWxsYmFjayB3aXRoIHRoZSBwcm9ncmVzcyAob3B0aW9uYWxseSBzdG9wcGluZyB1cylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBwZXJjZW50MTAgPSBwYXJzZUludCgxMDAwICogY3VycmVudE9wIC8gdG90YWxPcHMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHBlcmNlbnQxMCAhPT0gbGFzdFBlcmNlbnQxMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0b3AgPSBjYWxsYmFjayhudWxsLCBjdXJyZW50T3AgLyB0b3RhbE9wcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0b3ApIHsgYnJlYWs7IH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGVyY2VudDEwID0gcGVyY2VudDEwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGkxIDwgTikgeyBicmVhazsgfVxuXG4gICAgICAgICAgICAgICAgICAgIGFycmF5Y29weShYWSwgMCwgQiwgQmksIFlpKTsgICAgICAgICAgICAgICAgICAgICAvLyBST01peCAtIDEwXG5cbiAgICAgICAgICAgICAgICAgICAgLy8gZm9yICh2YXIgaSA9IDA7IGkgPCBwOyBpKyspLi4uXG4gICAgICAgICAgICAgICAgICAgIGkwKys7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpMCA8IHApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0YXRlID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgYiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IEIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgoQltpXSA+PiAgMCkgJiAweGZmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgoQltpXSA+PiAgOCkgJiAweGZmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgoQltpXSA+PiAxNikgJiAweGZmKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGIucHVzaCgoQltpXSA+PiAyNCkgJiAweGZmKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBQQktERjJfSE1BQ19TSEEyNTZfT25lSXRlcihwYXNzd29yZCwgYiwgZGtMZW4pO1xuXG4gICAgICAgICAgICAgICAgICAgIC8vIFNlbmQgdGhlIHJlc3VsdCB0byB0aGUgY2FsbGJhY2tcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7IGNhbGxiYWNrKG51bGwsIDEuMCwgZGVyaXZlZEtleSk7IH1cblxuICAgICAgICAgICAgICAgICAgICAvLyBEb25lOyBkb24ndCBicmVhayAod2hpY2ggd291bGQgcmVzY2hlZHVsZSlcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIFNjaGVkdWxlIHRoZSBuZXh0IHN0ZXBzXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHsgbmV4dFRpY2soaW5jcmVtZW50YWxTTWl4KTsgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gUnVuIHRoZSBzbWl4IHN0YXRlIG1hY2hpbmUgdW50aWwgY29tcGxldGlvblxuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlcml2ZWRLZXkgPSBpbmNyZW1lbnRhbFNNaXgoKTtcbiAgICAgICAgICAgICAgICBpZiAoZGVyaXZlZEtleSAhPSB1bmRlZmluZWQpIHsgcmV0dXJuIGRlcml2ZWRLZXk7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIEJvb3RzdHJhcCB0aGUgYXN5bmMgaW5jcmVtZW50YWwgc21peFxuICAgICAgICBpbmNyZW1lbnRhbFNNaXgoKTtcbiAgICB9XG5cbiAgICBjb25zdCBsaWIgPSB7XG4gICAgICAgIHNjcnlwdDogZnVuY3Rpb24ocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBwcm9ncmVzc0NhbGxiYWNrKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICAgICAgbGV0IGxhc3RQcm9ncmVzcyA9IDA7XG4gICAgICAgICAgICAgICAgaWYgKHByb2dyZXNzQ2FsbGJhY2spIHsgcHJvZ3Jlc3NDYWxsYmFjaygwKTsgfVxuICAgICAgICAgICAgICAgIF9zY3J5cHQocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuLCBmdW5jdGlvbihlcnJvciwgcHJvZ3Jlc3MsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocHJvZ3Jlc3NDYWxsYmFjayAmJiBsYXN0UHJvZ3Jlc3MgIT09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcm9ncmVzc0NhbGxiYWNrKDEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShuZXcgVWludDhBcnJheShrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmIChwcm9ncmVzc0NhbGxiYWNrICYmIHByb2dyZXNzICE9PSBsYXN0UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RQcm9ncmVzcyA9IHByb2dyZXNzO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHByb2dyZXNzQ2FsbGJhY2socHJvZ3Jlc3MpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3luY1NjcnlwdDogZnVuY3Rpb24ocGFzc3dvcmQsIHNhbHQsIE4sIHIsIHAsIGRrTGVuKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkoX3NjcnlwdChwYXNzd29yZCwgc2FsdCwgTiwgciwgcCwgZGtMZW4pKTtcbiAgICAgICAgfVxuICAgIH07XG5cbiAgICAvLyBub2RlLmpzXG4gICAgaWYgKHR5cGVvZihleHBvcnRzKSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICBtb2R1bGUuZXhwb3J0cyA9IGxpYjtcblxuICAgIC8vIFJlcXVpcmVKUy9BTURcbiAgICAvLyBodHRwOi8vd3d3LnJlcXVpcmVqcy5vcmcvZG9jcy9hcGkuaHRtbFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9hbWRqcy9hbWRqcy1hcGkvd2lraS9BTURcbiAgICB9IGVsc2UgaWYgKHR5cGVvZihkZWZpbmUpID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcbiAgICAgICAgZGVmaW5lKGxpYik7XG5cbiAgICAvLyBXZWIgQnJvd3NlcnNcbiAgICB9IGVsc2UgaWYgKHJvb3QpIHtcblxuICAgICAgICAvLyBJZiB0aGVyZSB3YXMgYW4gZXhpc3RpbmcgbGlicmFyeSBcInNjcnlwdFwiLCBtYWtlIHN1cmUgaXQgaXMgc3RpbGwgYXZhaWxhYmxlXG4gICAgICAgIGlmIChyb290LnNjcnlwdCkge1xuICAgICAgICAgICAgcm9vdC5fc2NyeXB0ID0gcm9vdC5zY3J5cHQ7XG4gICAgICAgIH1cblxuICAgICAgICByb290LnNjcnlwdCA9IGxpYjtcbiAgICB9XG5cbn0pKHRoaXMpO1xuIiwiLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L2Jhbi10cy1jb21tZW50ICovXG5pbXBvcnQge1xuICBEaXN0cmlidXRlVG9QYXlvdXRNb2RFdmVudCxcbiAgRGlzdHJpYnV0ZVRvUGF5b3V0TW9kRXZlbnRKc29uLFxuICBwYXJzZURpc3RyaWJ1dGVUb1BheW91dE1vZEV2ZW50LFxufSBmcm9tICcuL21vZGVscy9kaXN0cmlidXRlLXRvLXBheW91dC1tb2QtZXZlbnQgY29weSdcbmltcG9ydCB7XG4gIERpc3RyaWJ1dGVUb1RpY2tldE1vZEV2ZW50LFxuICBEaXN0cmlidXRlVG9UaWNrZXRNb2RFdmVudEpzb24sXG4gIHBhcnNlRGlzdHJpYnV0ZVRvVGlja2V0TW9kRXZlbnQsXG59IGZyb20gJy4vbW9kZWxzL2Rpc3RyaWJ1dGUtdG8tdGlja2V0LW1vZC1ldmVudCdcbmltcG9ydCB7XG4gIHBhcnNlUGFydGljaXBhbnRKc29uLFxuICBQYXJ0aWNpcGFudCxcbiAgUGFydGljaXBhbnRKc29uLFxufSBmcm9tICcuL21vZGVscy9wYXJ0aWNpcGFudCdcbmltcG9ydCB7IHBhcnNlUGF5RXZlbnRKc29uLCBQYXlFdmVudCwgUGF5RXZlbnRKc29uIH0gZnJvbSAnLi9tb2RlbHMvcGF5LWV2ZW50J1xuaW1wb3J0IHtcbiAgcGFyc2VQcmludFJlc2VydmVzRXZlbnRKc29uLFxuICBQcmludFJlc2VydmVzRXZlbnQsXG4gIFByaW50UmVzZXJ2ZXNFdmVudEpzb24sXG59IGZyb20gJy4vbW9kZWxzL3ByaW50LXJlc2VydmVzLWV2ZW50J1xuaW1wb3J0IHsgcGFyc2VQcm9qZWN0SnNvbiwgUHJvamVjdCwgUHJvamVjdEpzb24gfSBmcm9tICcuL21vZGVscy9wcm9qZWN0J1xuaW1wb3J0IHtcbiAgcGFyc2VSZWRlZW1FdmVudEpzb24sXG4gIFJlZGVlbUV2ZW50LFxuICBSZWRlZW1FdmVudEpzb24sXG59IGZyb20gJy4vbW9kZWxzL3JlZGVlbS1ldmVudCdcbmltcG9ydCB7IHBhcnNlVGFwRXZlbnRKc29uLCBUYXBFdmVudCwgVGFwRXZlbnRKc29uIH0gZnJvbSAnLi9tb2RlbHMvdGFwLWV2ZW50J1xuXG5leHBvcnQgaW50ZXJmYWNlIFN1YmdyYXBoRW50aXRpZXMge1xuICBwcm9qZWN0OiBQcm9qZWN0XG4gIHBheUV2ZW50OiBQYXlFdmVudFxuICByZWRlZW1FdmVudDogUmVkZWVtRXZlbnRcbiAgcGFydGljaXBhbnQ6IFBhcnRpY2lwYW50XG4gIHRhcEV2ZW50OiBUYXBFdmVudFxuICBkaXN0cmlidXRlVG9QYXlvdXRNb2RFdmVudDogRGlzdHJpYnV0ZVRvUGF5b3V0TW9kRXZlbnRcbiAgZGlzdHJpYnV0ZVRvVGlja2V0TW9kRXZlbnQ6IERpc3RyaWJ1dGVUb1RpY2tldE1vZEV2ZW50XG4gIHByaW50UmVzZXJ2ZXNFdmVudDogUHJpbnRSZXNlcnZlc0V2ZW50XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgU3ViZ3JhcGhRdWVyeVJldHVyblR5cGVzIHtcbiAgcHJvamVjdDogeyBwcm9qZWN0czogUHJvamVjdEpzb25bXSB9XG4gIHBheUV2ZW50OiB7IHBheUV2ZW50czogUGF5RXZlbnRKc29uW10gfVxuICByZWRlZW1FdmVudDogeyByZWRlZW1FdmVudHM6IFJlZGVlbUV2ZW50SnNvbltdIH1cbiAgcGFydGljaXBhbnQ6IHsgcGFydGljaXBhbnRzOiBQYXJ0aWNpcGFudEpzb25bXSB9XG4gIHRhcEV2ZW50OiB7IHRhcEV2ZW50czogVGFwRXZlbnRKc29uW10gfVxuICBkaXN0cmlidXRlVG9UaWNrZXRNb2RFdmVudDoge1xuICAgIGRpc3RyaWJ1dGVUb1RpY2tldE1vZEV2ZW50czogRGlzdHJpYnV0ZVRvVGlja2V0TW9kRXZlbnRKc29uW11cbiAgfVxuICBkaXN0cmlidXRlVG9QYXlvdXRNb2RFdmVudDoge1xuICAgIGRpc3RyaWJ1dGVUb1BheW91dE1vZEV2ZW50czogRGlzdHJpYnV0ZVRvUGF5b3V0TW9kRXZlbnRKc29uW11cbiAgfVxuICBwcmludFJlc2VydmVzRXZlbnQ6IHtcbiAgICBwcmludFJlc2VydmVzRXZlbnRzOiBQcmludFJlc2VydmVzRXZlbnRKc29uW11cbiAgfVxufVxuXG5leHBvcnQgdHlwZSBFbnRpdHlLZXkgPSBrZXlvZiBTdWJncmFwaEVudGl0aWVzXG5cbmV4cG9ydCB0eXBlIE9yZGVyRGlyZWN0aW9uID0gJ2FzYycgfCAnZGVzYydcblxuZXhwb3J0IHR5cGUgV2hlcmVDb25maWcgPSB7XG4gIGtleTogc3RyaW5nXG4gIHZhbHVlOiBzdHJpbmcgfCBudW1iZXIgfCBib29sZWFuXG4gIG9wZXJhdG9yPzpcbiAgICB8ICdub3QnXG4gICAgfCAnZ3QnXG4gICAgfCAnbHQnXG4gICAgfCAnZ3RlJ1xuICAgIHwgJ2x0ZSdcbiAgICB8ICdpbidcbiAgICB8ICdub3RfaW4nXG4gICAgfCAnY29udGFpbnMnXG4gICAgfCAnbm90X2NvbnRhaW5zJ1xuICAgIHwgJ3N0YXJ0c193aXRoJ1xuICAgIHwgJ2VuZHNfd2l0aCdcbiAgICB8ICdub3Rfc3RhcnRzX3dpdGgnXG4gICAgfCAnbm90X2VuZHNfd2l0aCdcbn1cblxuZXhwb3J0IHR5cGUgQmxvY2tDb25maWcgPSB7XG4gIG51bWJlcj86IG51bWJlclxuICBoYXNoPzogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIEVudGl0eUtleXM8RSBleHRlbmRzIEVudGl0eUtleT4gPSBrZXlvZiBTdWJncmFwaEVudGl0aWVzW0VdXG5cbmV4cG9ydCBpbnRlcmZhY2UgR3JhcGhRdWVyeU9wdHM8RSBleHRlbmRzIEVudGl0eUtleSwgSyBleHRlbmRzIEVudGl0eUtleXM8RT4+IHtcbiAgZW50aXR5OiBFXG4gIGZpcnN0PzogbnVtYmVyXG4gIHNraXA/OiBudW1iZXJcbiAgb3JkZXJCeT86IGtleW9mIFN1YmdyYXBoRW50aXRpZXNbRV1cbiAgYmxvY2s/OiBCbG9ja0NvbmZpZ1xuXG4gIC8vIGBrZXlzYCBjYW4gYmUgYSBtaXggb2YgdGhlIGVudGl0eSdzIGtleXMgb3IgYW4gZW50aXR5IHNwZWNpZmllciB3aXRoIGl0cyBvd24ga2V5c1xuICBrZXlzOiAoXG4gICAgfCBLXG4gICAgfCB7XG4gICAgICAgIGVudGl0eTogRW50aXR5S2V5XG4gICAgICAgIGtleXM6IHN0cmluZ1tdIC8vIGhhcmQgdG8gdHlwZSBhY2N1cmF0ZSBuZXN0ZWQga2V5cy4gQWxsIGJldHMgYXJlIG9mZiB3aGVuIHRoaXMgaXMgdXNlZC5cbiAgICAgIH1cbiAgKVtdXG4gIG9yZGVyRGlyZWN0aW9uPzogT3JkZXJEaXJlY3Rpb25cbiAgd2hlcmU/OiBXaGVyZUNvbmZpZyB8IFdoZXJlQ29uZmlnW11cbn1cblxuLy8gaHR0cHM6Ly90aGVncmFwaC5jb20vZG9jcy9ncmFwaHFsLWFwaSNmaWx0ZXJpbmdcbmV4cG9ydCBjb25zdCBmb3JtYXRHcmFwaFF1ZXJ5ID0gPEUgZXh0ZW5kcyBFbnRpdHlLZXksIEsgZXh0ZW5kcyBFbnRpdHlLZXlzPEU+PihcbiAgb3B0czogR3JhcGhRdWVyeU9wdHM8RSwgSz4sXG4pOiBzdHJpbmcgPT4ge1xuICBsZXQgYXJncyA9ICcnXG5cbiAgY29uc3QgYWRkQXJnID0gKFxuICAgIG5hbWU6IHN0cmluZyxcbiAgICB2YWx1ZT86IHN0cmluZyB8IG51bWJlciB8IGtleW9mIFN1YmdyYXBoRW50aXRpZXNbRV0sXG4gICkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSByZXR1cm5cbiAgICBhcmdzICs9IChhcmdzLmxlbmd0aCA/ICcsICcgOiAnJykgKyBgJHtuYW1lfTogYCArIHZhbHVlXG4gIH1cblxuICBhZGRBcmcoJ2ZpcnN0Jywgb3B0cy5maXJzdClcbiAgYWRkQXJnKCdza2lwJywgb3B0cy5za2lwKVxuICBhZGRBcmcoJ29yZGVyQnknLCBvcHRzLm9yZGVyQnkpXG4gIGFkZEFyZygnb3JkZXJEaXJlY3Rpb24nLCBvcHRzLm9yZGVyRGlyZWN0aW9uKVxuICBpZiAob3B0cy5ibG9jaykge1xuICAgIGlmIChvcHRzLmJsb2NrLm51bWJlcikge1xuICAgICAgYWRkQXJnKCdibG9jaycsIGB7IG51bWJlcjogJHtvcHRzLmJsb2NrLm51bWJlcn0gfWApXG4gICAgfSBlbHNlIGlmIChvcHRzLmJsb2NrLmhhc2gpIHtcbiAgICAgIGFkZEFyZygnYmxvY2snLCBgeyBoYXNoOiAke29wdHMuYmxvY2suaGFzaH0gfWApXG4gICAgfVxuICB9XG4gIGFkZEFyZyhcbiAgICAnd2hlcmUnLFxuICAgIG9wdHMud2hlcmVcbiAgICAgID8gQXJyYXkuaXNBcnJheShvcHRzLndoZXJlKVxuICAgICAgICA/IGB7ICR7b3B0cy53aGVyZS5tYXAoXG4gICAgICAgICAgICAodykgPT5cbiAgICAgICAgICAgICAgYCR7dy5rZXl9JHt3Lm9wZXJhdG9yID8gJ18nICsgdy5vcGVyYXRvciA6ICcnfTogXCIke3cudmFsdWV9XCIgYCxcbiAgICAgICAgICApfSB9YFxuICAgICAgICA6IGB7ICR7b3B0cy53aGVyZS5rZXl9JHtcbiAgICAgICAgICAgIG9wdHMud2hlcmUub3BlcmF0b3IgPyAnXycgKyBvcHRzLndoZXJlLm9wZXJhdG9yIDogJydcbiAgICAgICAgICB9OiBcIiR7b3B0cy53aGVyZS52YWx1ZX1cIiB9YFxuICAgICAgOiB1bmRlZmluZWQsXG4gIClcblxuICByZXR1cm4gYHsgJHtvcHRzLmVudGl0eX1zJHthcmdzID8gYCgke2FyZ3N9KWAgOiAnJ30geyBpZCR7b3B0cy5rZXlzLnJlZHVjZShcbiAgICAoYWNjLCBrZXkpID0+XG4gICAgICB0eXBlb2Yga2V5ID09PSAnc3RyaW5nJyB8fFxuICAgICAgdHlwZW9mIGtleSA9PT0gJ251bWJlcicgfHxcbiAgICAgIHR5cGVvZiBrZXkgPT09ICdzeW1ib2wnXG4gICAgICAgID8gYWNjICsgJyAnICsga2V5LnRvU3RyaW5nKClcbiAgICAgICAgOiBhY2MgKyBgICR7a2V5LmVudGl0eX17ICR7a2V5LmtleXMubWFwKChrKSA9PiBrICsgJyAnKX0gfWAsXG4gICAgJycsXG4gICl9IH0gfWBcbn1cblxuY29uc3Qgc3ViZ3JhcGhVcmwgPVxuICAnaHR0cHM6Ly9hcGkuc3R1ZGlvLnRoZWdyYXBoLmNvbS9xdWVyeS85NTM0L2p1aWNlYm94LXJpbmtlYnkvdjAuMC4yJ1xuXG5leHBvcnQgY29uc3QgcXVlcnlTdWJncmFwaCA9IGFzeW5jIDxcbiAgRSBleHRlbmRzIEVudGl0eUtleSxcbiAgSyBleHRlbmRzIEVudGl0eUtleXM8RT4sXG4+KFxuICBvcHRzOiBHcmFwaFF1ZXJ5T3B0czxFLCBLPixcbik6IFByb21pc2U8U3ViZ3JhcGhRdWVyeVJldHVyblR5cGVzW0VdIHwgdW5kZWZpbmVkPiA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goc3ViZ3JhcGhVcmwsIHtcbiAgICAgIG1ldGhvZDogJ1BPU1QnLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL2pzb24nLFxuICAgICAgfSxcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcXVlcnk6IGZvcm1hdEdyYXBoUXVlcnkob3B0cyksXG4gICAgICB9KSxcbiAgICB9KVxuICAgIGNvbnN0IGRhdGEgPSAoYXdhaXQgcmVzLmpzb24oKSkgYXMgeyBkYXRhOiBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB9XG4gICAgcmV0dXJuIGRhdGEuZGF0YSBhcyBTdWJncmFwaFF1ZXJ5UmV0dXJuVHlwZXNbRV1cbiAgfSBjYXRjaCAoZXJyb3I6IHVua25vd24pIHtcbiAgICBjb25zb2xlLmxvZyhlcnJvcilcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgdHJpbUhleFplcm8gPSAoaGV4U3RyOiBzdHJpbmcpOiBzdHJpbmcgPT5cbiAgaGV4U3RyLnJlcGxhY2UoJzB4MCcsICcweCcpXG5cbmV4cG9ydCBmdW5jdGlvbiBmb3JtYXRHcmFwaFJlc3BvbnNlPEUgZXh0ZW5kcyBFbnRpdHlLZXk+KFxuICBlbnRpdHk6IEUsXG4gIHJlc3BvbnNlOiBTdWJncmFwaFF1ZXJ5UmV0dXJuVHlwZXNbRV0sXG4pOiBTdWJncmFwaEVudGl0aWVzW0VdW10ge1xuICBpZiAoIXJlc3BvbnNlIHx8IHR5cGVvZiByZXNwb25zZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuXG4gIC8vIFRoaXMgY29kZSB3b3JrcyBwZXJmZWN0bHksIGJ1dCB0aGVyZSdzIGFuIHVudXN1YWwgVHlwZVNjcmlwdCBpc3N1ZSB0aGF0XG4gIC8vIG1ha2VzIGl0IGFwcGVhciB0eXBlIHVuc2FmZS4uLlxuICAvL1xuICAvLyBGb3IgZXhhbXBsZSwgYHJlc3BvbnNlLnByb2plY3RzYCBpcyBhIFByb2plY3RKc29uW10sIGFzIGRpY3RhdGVkIGJ5XG4gIC8vIFN1YmdyYXBoUXVlcnlSZXR1cm5UeXBlc1sncHJvamVjdHMnXVxuICAvLyBXZSB0aGVuIG1hcCBvdmVyIHRoYXQgYXJyYXkgdG8gcmV0dXJuIGEgUHJvamVjdFtdLCBidXQgZm9yIHNvbWUgcmVhc29uLFxuICAvLyBUeXBlU2NyaXB0IGlzbid0IGVxdWF0aW5nIGBQcm9qZWN0YCB3aXRoIGBTdWJncmFwaEVudGl0aWVzWydwcm9qZWN0J11gLFxuICAvLyBldmVuIHRob3VnaCB0aGV5J3JlIHRoZSBzYW1lIHR5cGUuXG4gIC8vXG4gIC8vIElmIHlvdSB0aGluayB5b3UgY2FuIHNvbHZlIGl0IGFuZCByZW1vdmUgdGhlIEB0cy1pZ25vcmUsIGJlIG15IGd1ZXN0LlxuICAvLyBNeSBiZXN0IGd1ZXNzIGlzIGEgY29uZGl0aW9uYWwgcmVzb2x2ZXIgdHlwZSwgaWU6XG4gIC8vIHR5cGUgRW50aXR5UmVzb2x2ZXI8RSBleHRlbmRzIEVudGl0eUtleT4gPSBFIGV4dGVuZHMgJ3Byb2plY3QnID8gUHJvamVjdCA6IC4uLlxuICAvLyBpbiBmYXZvciBvZiB0aGUgbWFpbiBTdWJncmFwaEVudGl0aWVzIHR5cGUuIEkgdHJpZWQgaXQsIHRob3VnaCwgdG8gbm8gYXZhaWwuXG5cbiAgc3dpdGNoIChlbnRpdHkpIHtcbiAgICBjYXNlICdwcm9qZWN0JzpcbiAgICAgIGlmICgncHJvamVjdHMnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnByb2plY3RzLm1hcChwYXJzZVByb2plY3RKc29uKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdwYXlFdmVudCc6XG4gICAgICBpZiAoJ3BheUV2ZW50cycgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UucGF5RXZlbnRzLm1hcChwYXJzZVBheUV2ZW50SnNvbilcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAncmVkZWVtRXZlbnQnOlxuICAgICAgaWYgKCdyZWRlZW1FdmVudHMnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnJlZGVlbUV2ZW50cy5tYXAocGFyc2VSZWRlZW1FdmVudEpzb24pXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgJ3BhcnRpY2lwYW50JzpcbiAgICAgIGlmICgncGFydGljaXBhbnRzJyBpbiByZXNwb25zZSkge1xuICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgIHJldHVybiByZXNwb25zZS5wYXJ0aWNpcGFudHMubWFwKHBhcnNlUGFydGljaXBhbnRKc29uKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICd0YXBFdmVudCc6XG4gICAgICBpZiAoJ3RhcEV2ZW50cycgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UudGFwRXZlbnRzLm1hcChwYXJzZVRhcEV2ZW50SnNvbilcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gICAgY2FzZSAnZGlzdHJpYnV0ZVRvUGF5b3V0TW9kRXZlbnQnOlxuICAgICAgaWYgKCdkaXN0cmlidXRlVG9QYXlvdXRNb2RFdmVudHMnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmRpc3RyaWJ1dGVUb1BheW91dE1vZEV2ZW50cy5tYXAoXG4gICAgICAgICAgcGFyc2VEaXN0cmlidXRlVG9QYXlvdXRNb2RFdmVudCxcbiAgICAgICAgKVxuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICBjYXNlICdkaXN0cmlidXRlVG9UaWNrZXRNb2RFdmVudCc6XG4gICAgICBpZiAoJ2Rpc3RyaWJ1dGVUb1RpY2tldE1vZEV2ZW50cycgaW4gcmVzcG9uc2UpIHtcbiAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGlzdHJpYnV0ZVRvVGlja2V0TW9kRXZlbnRzLm1hcChcbiAgICAgICAgICBwYXJzZURpc3RyaWJ1dGVUb1RpY2tldE1vZEV2ZW50LFxuICAgICAgICApXG4gICAgICB9XG4gICAgICBicmVha1xuICAgIGNhc2UgJ3ByaW50UmVzZXJ2ZXNFdmVudCc6XG4gICAgICBpZiAoJ3ByaW50UmVzZXJ2ZXNFdmVudHMnIGluIHJlc3BvbnNlKSB7XG4gICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLnByaW50UmVzZXJ2ZXNFdmVudHMubWFwKHBhcnNlUHJpbnRSZXNlcnZlc0V2ZW50SnNvbilcbiAgICAgIH1cbiAgICAgIGJyZWFrXG4gIH1cblxuICByZXR1cm4gW11cbn1cbiIsImltcG9ydCB7IHF1ZXJ5U3ViZ3JhcGggfSBmcm9tICcuL2dyYXBoJ1xuaW1wb3J0IHsgdXRpbHMgfSBmcm9tICdldGhlcnMnXG5cbmNvbnN0IGdldElwZnNDaWRVcmwgPSAoaGFzaDogc3RyaW5nKSA9PlxuICAnaHR0cHM6Ly9qYngubXlwaW5hdGEuY2xvdWQvaXBmcy8nICsgaGFzaFxuXG50eXBlIFByb2plY3RNZXRhZGF0YSA9IFBhcnRpYWw8e1xuICBuYW1lOiBzdHJpbmdcbiAgZGVzY3JpcHRpb246IHN0cmluZ1xuICBsb2dvVXJpOiBzdHJpbmdcbiAgaW5mb1VyaTogc3RyaW5nXG59PlxuXG5jb25zdCBmZXRjaFByb2plY3RNZXRhZGF0YSA9IGFzeW5jIChcbiAgdXJpSGFzaDogc3RyaW5nLFxuKTogUHJvbWlzZTxQcm9qZWN0TWV0YWRhdGE+ID0+IHtcbiAgY29uc3QgdXJsID0gZ2V0SXBmc0NpZFVybCh1cmlIYXNoKVxuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybClcbiAgcmV0dXJuIGF3YWl0IHJlc3BvbnNlLmpzb24oKVxufVxuXG5mdW5jdGlvbiBpc0Fzc2V0Um91dGUodXJsOiBzdHJpbmcpOiBib29sZWFuIHtcbiAgcmV0dXJuIChcbiAgICB1cmwuaW5jbHVkZXMoJy9hc3NldHMvJykgfHxcbiAgICB1cmwuaW5jbHVkZXMoJy9zdGF0aWMvJykgfHxcbiAgICB1cmwuaW5jbHVkZXMoJy9yb2JvdHMudHh0JylcbiAgKVxufVxuXG5jbGFzcyBBdHRyaWJ1dGVSZXdyaXRlciB7XG4gIG5hbWU6IHN0cmluZ1xuICB2YWx1ZTogc3RyaW5nXG5cbiAgY29uc3RydWN0b3IobmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nKSB7XG4gICAgdGhpcy5uYW1lID0gbmFtZVxuICAgIHRoaXMudmFsdWUgPSB2YWx1ZVxuICB9XG5cbiAgZWxlbWVudChlbGVtZW50OiBFbGVtZW50KSB7XG4gICAgY29uc3QgYXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUodGhpcy5uYW1lKVxuICAgIGlmIChhdHRyaWJ1dGUpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHRoaXMubmFtZSwgdGhpcy52YWx1ZSlcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZVJlcXVlc3QocmVxdWVzdDogUmVxdWVzdCk6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgLy8gQXNzZXQgUm91dGVzXG4gIGlmIChpc0Fzc2V0Um91dGUocmVxdWVzdC51cmwpKSB7XG4gICAgY29uc3QgZmV0Y2hVcmwgPSByZXF1ZXN0LnVybC5yZXBsYWNlKFxuICAgICAgJ2h0dHBzOi8vbWV0YS10YWdzLmpub2gud29ya2Vycy5kZXYnLFxuICAgICAgJ2h0dHA6Ly8zYTcwLTczLTE4OS05OC0xMjMubmdyb2suaW8nLFxuICAgIClcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChmZXRjaFVybCwge1xuICAgICAgY2Y6IHtcbiAgICAgICAgY2FjaGVUdGw6IDAsXG4gICAgICB9LFxuICAgIH0pXG4gICAgcmV0dXJuIHJlc1xuICB9XG5cbiAgLy8gUHJvamVjdCBSb3V0ZXNcbiAgaWYgKHJlcXVlc3QudXJsLmluY2x1ZGVzKCdodHRwczovL21ldGEtdGFncy5qbm9oLndvcmtlcnMuZGV2L3AvJykpIHtcbiAgICAvLyBwYXJzZSB1cmxcbiAgICBjb25zdCBoYW5kbGUgPSByZXF1ZXN0LnVybC5yZXBsYWNlKFxuICAgICAgJ2h0dHBzOi8vbWV0YS10YWdzLmpub2gud29ya2Vycy5kZXYvcC8nLFxuICAgICAgJycsXG4gICAgKVxuICAgIC8vIGZldGNoIHByb2plY3RcbiAgICBjb25zdCBkYXRhID0gYXdhaXQgcXVlcnlTdWJncmFwaCh7XG4gICAgICBlbnRpdHk6ICdwcm9qZWN0JyxcbiAgICAgIGtleXM6IFsnaWQnLCAnaGFuZGxlJywgJ3VyaSddLFxuICAgICAgd2hlcmU6IHtcbiAgICAgICAga2V5OiAnaGFuZGxlJyxcbiAgICAgICAgdmFsdWU6IHV0aWxzLmZvcm1hdEJ5dGVzMzJTdHJpbmcoaGFuZGxlKSxcbiAgICAgIH0sXG4gICAgfSlcbiAgICBjb25zdCBwcm9qZWN0ID0gZGF0YT8ucHJvamVjdHNbMF1cbiAgICBpZiAocHJvamVjdCkge1xuICAgICAgY29uc3QgbWV0YWRhdGEgPSBhd2FpdCBmZXRjaFByb2plY3RNZXRhZGF0YShwcm9qZWN0LnVyaSlcbiAgICAgIGNvbnN0IHJld3JpdGVyID0gbmV3IEhUTUxSZXdyaXRlcigpXG4gICAgICAgIC5vbihcbiAgICAgICAgICAnbWV0YVtwcm9wZXJ0eT1cIm9nOnRpdGxlXCJdJyxcbiAgICAgICAgICBuZXcgQXR0cmlidXRlUmV3cml0ZXIoJ2NvbnRlbnQnLCBtZXRhZGF0YS5uYW1lID8/ICcnKSxcbiAgICAgICAgKVxuICAgICAgICAub24oXG4gICAgICAgICAgJ21ldGFbcHJvcGVydHk9XCJvZzpkZXNjcmlwdGlvblwiXScsXG4gICAgICAgICAgbmV3IEF0dHJpYnV0ZVJld3JpdGVyKCdjb250ZW50JywgbWV0YWRhdGEuZGVzY3JpcHRpb24gPz8gJycpLFxuICAgICAgICApXG4gICAgICAgIC5vbihcbiAgICAgICAgICAnbWV0YVtwcm9wZXJ0eT1cIm9nOnVybFwiXScsXG4gICAgICAgICAgbmV3IEF0dHJpYnV0ZVJld3JpdGVyKCdjb250ZW50JywgcmVxdWVzdC51cmwpLFxuICAgICAgICApXG4gICAgICAvLyBhZGQgbWV0YXRhZ3NcbiAgICAgIGNvbnN0IGZldGNoVXJsID0gJ2h0dHA6Ly8zYTcwLTczLTE4OS05OC0xMjMubmdyb2suaW8nXG4gICAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaChmZXRjaFVybCwge1xuICAgICAgICBjZjoge1xuICAgICAgICAgIGNhY2hlVHRsOiAwLFxuICAgICAgICB9LFxuICAgICAgfSlcbiAgICAgIHJldHVybiByZXdyaXRlci50cmFuc2Zvcm0ocmVzKVxuICAgIH1cbiAgfVxuICAvLyBhZGQgbWV0YXRhZ3NcbiAgY29uc3QgZmV0Y2hVcmwgPSAnaHR0cDovLzNhNzAtNzMtMTg5LTk4LTEyMy5uZ3Jvay5pbydcbiAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2goZmV0Y2hVcmwsIHtcbiAgICBjZjoge1xuICAgICAgY2FjaGVUdGw6IDAsXG4gICAgfSxcbiAgfSlcbiAgcmV0dXJuIHJlc1xufVxuIiwiaW1wb3J0IHsgaGFuZGxlUmVxdWVzdCB9IGZyb20gJy4vaGFuZGxlcidcblxuYWRkRXZlbnRMaXN0ZW5lcignZmV0Y2gnLCAoZXZlbnQpID0+IHtcbiAgZXZlbnQucmVzcG9uZFdpdGgoaGFuZGxlUmVxdWVzdChldmVudC5yZXF1ZXN0KSlcbn0pXG4iLCJpbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdldGhlcnMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgRGlzdHJpYnV0ZVRvUGF5b3V0TW9kRXZlbnQge1xuICBpZDogc3RyaW5nXG4gIHByb2plY3Q/OiBCaWdOdW1iZXJcbiAgZnVuZGluZ0N5Y2xlSWQ/OiBCaWdOdW1iZXJcbiAgcHJvamVjdElkPzogQmlnTnVtYmVyXG4gIG1vZEJlbmVmaWNpYXJ5OiBzdHJpbmdcbiAgbW9kUGVyY2VudD86IEJpZ051bWJlclxuICBtb2RQcmVmZXJVbnN0YWtlZDogYm9vbGVhblxuICBtb2RQcm9qZWN0SWQ/OiBCaWdOdW1iZXJcbiAgbW9kQWxsb2NhdG9yOiBzdHJpbmdcbiAgbW9kQ3V0PzogQmlnTnVtYmVyXG4gIGNhbGxlcjogc3RyaW5nXG4gIHRhcEV2ZW50OiBzdHJpbmdcbiAgdGltZXN0YW1wPzogbnVtYmVyXG4gIHR4SGFzaDogc3RyaW5nXG59XG5cbmV4cG9ydCB0eXBlIERpc3RyaWJ1dGVUb1BheW91dE1vZEV2ZW50SnNvbiA9IFJlY29yZDxcbiAga2V5b2YgRGlzdHJpYnV0ZVRvUGF5b3V0TW9kRXZlbnQsXG4gIHN0cmluZ1xuPlxuXG5leHBvcnQgY29uc3QgcGFyc2VEaXN0cmlidXRlVG9QYXlvdXRNb2RFdmVudCA9IChcbiAganNvbjogRGlzdHJpYnV0ZVRvUGF5b3V0TW9kRXZlbnRKc29uLFxuKTogRGlzdHJpYnV0ZVRvUGF5b3V0TW9kRXZlbnQgPT4gKHtcbiAgLi4uanNvbixcbiAgZnVuZGluZ0N5Y2xlSWQ6IGpzb24uZnVuZGluZ0N5Y2xlSWRcbiAgICA/IEJpZ051bWJlci5mcm9tKGpzb24uZnVuZGluZ0N5Y2xlSWQpXG4gICAgOiB1bmRlZmluZWQsXG4gIHByb2plY3Q6IGpzb24ucHJvamVjdCA/IEJpZ051bWJlci5mcm9tKGpzb24ucHJvamVjdCkgOiB1bmRlZmluZWQsXG4gIHByb2plY3RJZDoganNvbi5wcm9qZWN0SWQgPyBCaWdOdW1iZXIuZnJvbShqc29uLnByb2plY3RJZCkgOiB1bmRlZmluZWQsXG4gIG1vZFBlcmNlbnQ6IGpzb24ubW9kUGVyY2VudCA/IEJpZ051bWJlci5mcm9tKGpzb24ubW9kUGVyY2VudCkgOiB1bmRlZmluZWQsXG4gIG1vZFByb2plY3RJZDoganNvbi5tb2RQcm9qZWN0SWRcbiAgICA/IEJpZ051bWJlci5mcm9tKGpzb24ubW9kUHJvamVjdElkKVxuICAgIDogdW5kZWZpbmVkLFxuICBtb2RDdXQ6IGpzb24ubW9kQ3V0ID8gQmlnTnVtYmVyLmZyb20oanNvbi5tb2RDdXQpIDogdW5kZWZpbmVkLFxuICBtb2RQcmVmZXJVbnN0YWtlZDogISFqc29uLm1vZFByZWZlclVuc3Rha2VkLFxuICB0aW1lc3RhbXA6IGpzb24udGltZXN0YW1wID8gcGFyc2VJbnQoanNvbi50aW1lc3RhbXApIDogdW5kZWZpbmVkLFxufSlcbiIsImltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2V0aGVycydcblxuZXhwb3J0IGludGVyZmFjZSBEaXN0cmlidXRlVG9UaWNrZXRNb2RFdmVudCB7XG4gIGlkOiBzdHJpbmdcbiAgcHJvamVjdD86IEJpZ051bWJlclxuICBmdW5kaW5nQ3ljbGVJZD86IEJpZ051bWJlclxuICBwcm9qZWN0SWQ/OiBCaWdOdW1iZXJcbiAgbW9kQmVuZWZpY2lhcnk6IHN0cmluZ1xuICBtb2RQZXJjZW50PzogQmlnTnVtYmVyXG4gIG1vZFByZWZlclVuc3Rha2VkOiBib29sZWFuXG4gIG1vZEN1dD86IEJpZ051bWJlclxuICBjYWxsZXI6IHN0cmluZ1xuICBwcmludFJlc2VydmVzRXZlbnQ6IHN0cmluZ1xuICB0aW1lc3RhbXA/OiBudW1iZXJcbiAgdHhIYXNoOiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgRGlzdHJpYnV0ZVRvVGlja2V0TW9kRXZlbnRKc29uID0gUmVjb3JkPFxuICBrZXlvZiBEaXN0cmlidXRlVG9UaWNrZXRNb2RFdmVudCxcbiAgc3RyaW5nXG4+XG5cbmV4cG9ydCBjb25zdCBwYXJzZURpc3RyaWJ1dGVUb1RpY2tldE1vZEV2ZW50ID0gKFxuICBqc29uOiBEaXN0cmlidXRlVG9UaWNrZXRNb2RFdmVudEpzb24sXG4pOiBEaXN0cmlidXRlVG9UaWNrZXRNb2RFdmVudCA9PiAoe1xuICAuLi5qc29uLFxuICBmdW5kaW5nQ3ljbGVJZDoganNvbi5mdW5kaW5nQ3ljbGVJZFxuICAgID8gQmlnTnVtYmVyLmZyb20oanNvbi5mdW5kaW5nQ3ljbGVJZClcbiAgICA6IHVuZGVmaW5lZCxcbiAgcHJvamVjdDoganNvbi5wcm9qZWN0ID8gQmlnTnVtYmVyLmZyb20oanNvbi5wcm9qZWN0KSA6IHVuZGVmaW5lZCxcbiAgcHJvamVjdElkOiBqc29uLnByb2plY3RJZCA/IEJpZ051bWJlci5mcm9tKGpzb24ucHJvamVjdElkKSA6IHVuZGVmaW5lZCxcbiAgbW9kUGVyY2VudDoganNvbi5tb2RQZXJjZW50ID8gQmlnTnVtYmVyLmZyb20oanNvbi5tb2RQZXJjZW50KSA6IHVuZGVmaW5lZCxcbiAgbW9kQ3V0OiBqc29uLm1vZEN1dCA/IEJpZ051bWJlci5mcm9tKGpzb24ubW9kQ3V0KSA6IHVuZGVmaW5lZCxcbiAgbW9kUHJlZmVyVW5zdGFrZWQ6ICEhanNvbi5tb2RQcmVmZXJVbnN0YWtlZCxcbiAgdGltZXN0YW1wOiBqc29uLnRpbWVzdGFtcCA/IHBhcnNlSW50KGpzb24udGltZXN0YW1wKSA6IHVuZGVmaW5lZCxcbn0pXG4iLCJpbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdldGhlcnMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGFydGljaXBhbnQge1xuICBpZDogc3RyaW5nXG4gIHdhbGxldDogc3RyaW5nXG4gIHRvdGFsUGFpZD86IEJpZ051bWJlclxuICBwcm9qZWN0PzogQmlnTnVtYmVyXG4gIHRva2VuQmFsYW5jZT86IEJpZ051bWJlclxuICBsYXN0UGFpZFRpbWVzdGFtcD86IG51bWJlclxufVxuXG5leHBvcnQgdHlwZSBQYXJ0aWNpcGFudEpzb24gPSBSZWNvcmQ8a2V5b2YgUGFydGljaXBhbnQsIHN0cmluZz5cblxuZXhwb3J0IGNvbnN0IHBhcnNlUGFydGljaXBhbnRKc29uID0gKGpzb246IFBhcnRpY2lwYW50SnNvbik6IFBhcnRpY2lwYW50ID0+ICh7XG4gIC4uLmpzb24sXG4gIHRvdGFsUGFpZDoganNvbi50b3RhbFBhaWQgPyBCaWdOdW1iZXIuZnJvbShqc29uLnRvdGFsUGFpZCkgOiB1bmRlZmluZWQsXG4gIHByb2plY3Q6IGpzb24ucHJvamVjdCA/IEJpZ051bWJlci5mcm9tKGpzb24ucHJvamVjdCkgOiB1bmRlZmluZWQsXG4gIHRva2VuQmFsYW5jZToganNvbi50b2tlbkJhbGFuY2VcbiAgICA/IEJpZ051bWJlci5mcm9tKGpzb24udG9rZW5CYWxhbmNlKVxuICAgIDogdW5kZWZpbmVkLFxuICBsYXN0UGFpZFRpbWVzdGFtcDoganNvbi5sYXN0UGFpZFRpbWVzdGFtcFxuICAgID8gcGFyc2VJbnQoanNvbi5sYXN0UGFpZFRpbWVzdGFtcClcbiAgICA6IHVuZGVmaW5lZCxcbn0pXG4iLCJpbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdldGhlcnMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUGF5RXZlbnQge1xuICBpZD86IHN0cmluZ1xuICBmdW5kaW5nQ3ljbGVJZD86IEJpZ051bWJlclxuICBwcm9qZWN0PzogQmlnTnVtYmVyXG4gIGNhbGxlcjogc3RyaW5nXG4gIGJlbmVmaWNpYXJ5OiBzdHJpbmdcbiAgYW1vdW50OiBzdHJpbmdcbiAgbm90ZTogc3RyaW5nXG4gIHRpbWVzdGFtcD86IG51bWJlclxuICB0eEhhc2g6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBQYXlFdmVudEpzb24gPSBSZWNvcmQ8a2V5b2YgUGF5RXZlbnQsIHN0cmluZz4gJiB7XG4gIHByb2plY3Q6IHsgaWQ6IHN0cmluZyB9XG59XG5cbmV4cG9ydCBjb25zdCBwYXJzZVBheUV2ZW50SnNvbiA9IChqc29uOiBQYXlFdmVudEpzb24pOiBQYXlFdmVudCA9PiAoe1xuICAuLi5qc29uLFxuICBmdW5kaW5nQ3ljbGVJZDoganNvbi5mdW5kaW5nQ3ljbGVJZFxuICAgID8gQmlnTnVtYmVyLmZyb20oanNvbi5mdW5kaW5nQ3ljbGVJZClcbiAgICA6IHVuZGVmaW5lZCxcbiAgcHJvamVjdDoganNvbi5wcm9qZWN0Py5pZCA/IEJpZ051bWJlci5mcm9tKGpzb24ucHJvamVjdC5pZCkgOiB1bmRlZmluZWQsXG4gIHRpbWVzdGFtcDoganNvbi50aW1lc3RhbXAgPyBwYXJzZUludChqc29uLnRpbWVzdGFtcCkgOiB1bmRlZmluZWQsXG59KVxuIiwiaW1wb3J0IHsgQmlnTnVtYmVyIH0gZnJvbSAnZXRoZXJzJ1xuXG5leHBvcnQgaW50ZXJmYWNlIFByaW50UmVzZXJ2ZXNFdmVudCB7XG4gIGlkOiBzdHJpbmdcbiAgcHJvamVjdD86IEJpZ051bWJlclxuICBmdW5kaW5nQ3ljbGVJZD86IEJpZ051bWJlclxuICBiZW5lZmljaWFyeTogc3RyaW5nXG4gIGNvdW50PzogQmlnTnVtYmVyXG4gIGJlbmVmaWNpYXJ5VGlja2V0QW1vdW50PzogQmlnTnVtYmVyXG4gIGNhbGxlcjogc3RyaW5nXG4gIHRpbWVzdGFtcD86IG51bWJlclxuICB0eEhhc2g6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBQcmludFJlc2VydmVzRXZlbnRKc29uID0gUmVjb3JkPGtleW9mIFByaW50UmVzZXJ2ZXNFdmVudCwgc3RyaW5nPlxuXG5leHBvcnQgY29uc3QgcGFyc2VQcmludFJlc2VydmVzRXZlbnRKc29uID0gKFxuICBqc29uOiBQcmludFJlc2VydmVzRXZlbnRKc29uLFxuKTogUHJpbnRSZXNlcnZlc0V2ZW50ID0+ICh7XG4gIC4uLmpzb24sXG4gIHByb2plY3Q6IGpzb24ucHJvamVjdCA/IEJpZ051bWJlci5mcm9tKGpzb24ucHJvamVjdCkgOiB1bmRlZmluZWQsXG4gIGZ1bmRpbmdDeWNsZUlkOiBqc29uLmZ1bmRpbmdDeWNsZUlkXG4gICAgPyBCaWdOdW1iZXIuZnJvbShqc29uLmZ1bmRpbmdDeWNsZUlkKVxuICAgIDogdW5kZWZpbmVkLFxuICBiZW5lZmljaWFyeVRpY2tldEFtb3VudDoganNvbi5iZW5lZmljaWFyeVRpY2tldEFtb3VudFxuICAgID8gQmlnTnVtYmVyLmZyb20oanNvbi5iZW5lZmljaWFyeVRpY2tldEFtb3VudClcbiAgICA6IHVuZGVmaW5lZCxcbiAgY291bnQ6IGpzb24uY291bnQgPyBCaWdOdW1iZXIuZnJvbShqc29uLmNvdW50KSA6IHVuZGVmaW5lZCxcbiAgdGltZXN0YW1wOiBqc29uLnRpbWVzdGFtcCA/IHBhcnNlSW50KGpzb24udGltZXN0YW1wKSA6IHVuZGVmaW5lZCxcbn0pXG4iLCJpbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdAZXRoZXJzcHJvamVjdC9iaWdudW1iZXInXG5pbXBvcnQgeyB1dGlscyB9IGZyb20gJ2V0aGVycydcblxuaW1wb3J0IHsgUGFydGljaXBhbnQgfSBmcm9tICcuL3BhcnRpY2lwYW50J1xuXG5leHBvcnQgaW50ZXJmYWNlIFByb2plY3Qge1xuICBjcmVhdGVkQXQ/OiBudW1iZXJcbiAgaGFuZGxlPzogc3RyaW5nXG4gIGlkPzogQmlnTnVtYmVyXG4gIGNyZWF0b3I6IHN0cmluZ1xuICB1cmk6IHN0cmluZ1xuICBjdXJyZW50QmFsYW5jZT86IEJpZ051bWJlclxuICB0b3RhbFBhaWQ/OiBCaWdOdW1iZXJcbiAgdG90YWxSZWRlZW1lZD86IEJpZ051bWJlclxuICBwYXJ0aWNpcGFudHM/OiBQYXJ0aWNpcGFudFtdXG59XG5cbmV4cG9ydCB0eXBlIFByb2plY3RKc29uID0gUmVjb3JkPGtleW9mIFByb2plY3QsIHN0cmluZz4gJiB7XG4gIHBhcnRpY2lwYW50czogc3RyaW5nW11cbn1cblxuZXhwb3J0IGNvbnN0IHBhcnNlUHJvamVjdEpzb24gPSAocHJvamVjdDogUHJvamVjdEpzb24pOiBQcm9qZWN0ID0+ICh7XG4gIC4uLnByb2plY3QsXG4gIGlkOiBwcm9qZWN0LmlkID8gQmlnTnVtYmVyLmZyb20ocHJvamVjdC5pZCkgOiB1bmRlZmluZWQsXG4gIGNyZWF0ZWRBdDogcHJvamVjdC5jcmVhdGVkQXQgPyBwYXJzZUludChwcm9qZWN0LmNyZWF0ZWRBdCkgOiB1bmRlZmluZWQsXG4gIGhhbmRsZTogcHJvamVjdC5oYW5kbGUgPyB1dGlscy5wYXJzZUJ5dGVzMzJTdHJpbmcocHJvamVjdC5oYW5kbGUpIDogdW5kZWZpbmVkLFxuICBjdXJyZW50QmFsYW5jZTogcHJvamVjdC5jdXJyZW50QmFsYW5jZVxuICAgID8gQmlnTnVtYmVyLmZyb20ocHJvamVjdC5jdXJyZW50QmFsYW5jZSlcbiAgICA6IHVuZGVmaW5lZCxcbiAgdG90YWxQYWlkOiBwcm9qZWN0LnRvdGFsUGFpZCA/IEJpZ051bWJlci5mcm9tKHByb2plY3QudG90YWxQYWlkKSA6IHVuZGVmaW5lZCxcbiAgdG90YWxSZWRlZW1lZDogcHJvamVjdC50b3RhbFJlZGVlbWVkXG4gICAgPyBCaWdOdW1iZXIuZnJvbShwcm9qZWN0LnRvdGFsUmVkZWVtZWQpXG4gICAgOiB1bmRlZmluZWQsXG4gIHBhcnRpY2lwYW50czpcbiAgICBwcm9qZWN0LnBhcnRpY2lwYW50cz8ubWFwKChwKSA9PiB7XG4gICAgICBjb25zdCBwYXllcjogUmVjb3JkPGtleW9mIFBhcnRpY2lwYW50LCBzdHJpbmc+ID0gSlNPTi5wYXJzZShwKVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4ucGF5ZXIsXG4gICAgICAgIHRvdGFsUGFpZDogQmlnTnVtYmVyLmZyb20ocGF5ZXIudG90YWxQYWlkKSxcbiAgICAgICAgcHJvamVjdDogQmlnTnVtYmVyLmZyb20ocGF5ZXIucHJvamVjdCksXG4gICAgICAgIGxhc3RQYWlkVGltZXN0YW1wOiBwYXJzZUludChwYXllci5sYXN0UGFpZFRpbWVzdGFtcCksXG4gICAgICAgIHRva2VuQmFsYW5jZTogQmlnTnVtYmVyLmZyb20ocGF5ZXIudG9rZW5CYWxhbmNlKSxcbiAgICAgIH1cbiAgICB9KSA/PyBbXSxcbn0pXG4iLCJpbXBvcnQgeyBCaWdOdW1iZXIgfSBmcm9tICdldGhlcnMnXG5cbmV4cG9ydCBpbnRlcmZhY2UgUmVkZWVtRXZlbnQge1xuICBpZDogc3RyaW5nXG4gIGhvbGRlcjogc3RyaW5nXG4gIGJlbmVmaWNpYXJ5OiBzdHJpbmdcbiAgcHJvamVjdD86IEJpZ051bWJlclxuICBhbW91bnQ/OiBCaWdOdW1iZXJcbiAgcmV0dXJuQW1vdW50PzogQmlnTnVtYmVyXG4gIGNhbGxlcjogc3RyaW5nXG4gIHRpbWVzdGFtcD86IG51bWJlclxuICB0eEhhc2g6IHN0cmluZ1xufVxuXG5leHBvcnQgdHlwZSBSZWRlZW1FdmVudEpzb24gPSBSZWNvcmQ8a2V5b2YgUmVkZWVtRXZlbnQsIHN0cmluZz5cblxuZXhwb3J0IGNvbnN0IHBhcnNlUmVkZWVtRXZlbnRKc29uID0gKGpzb246IFJlZGVlbUV2ZW50SnNvbik6IFJlZGVlbUV2ZW50ID0+ICh7XG4gIC4uLmpzb24sXG4gIHByb2plY3Q6IGpzb24ucHJvamVjdCA/IEJpZ051bWJlci5mcm9tKGpzb24ucHJvamVjdCkgOiB1bmRlZmluZWQsXG4gIGFtb3VudDoganNvbi5hbW91bnQgPyBCaWdOdW1iZXIuZnJvbShqc29uLmFtb3VudCkgOiB1bmRlZmluZWQsXG4gIHJldHVybkFtb3VudDoganNvbi5yZXR1cm5BbW91bnRcbiAgICA/IEJpZ051bWJlci5mcm9tKGpzb24ucmV0dXJuQW1vdW50KVxuICAgIDogdW5kZWZpbmVkLFxuICB0aW1lc3RhbXA6IGpzb24udGltZXN0YW1wID8gcGFyc2VJbnQoanNvbi50aW1lc3RhbXApIDogdW5kZWZpbmVkLFxufSlcbiIsImltcG9ydCB7IEJpZ051bWJlciB9IGZyb20gJ2V0aGVycydcblxuZXhwb3J0IGludGVyZmFjZSBUYXBFdmVudCB7XG4gIGlkOiBzdHJpbmdcbiAgcHJvamVjdD86IEJpZ051bWJlclxuICBmdW5kaW5nQ3ljbGVJZD86IEJpZ051bWJlclxuICBiZW5lZmljaWFyeTogc3RyaW5nXG4gIGFtb3VudD86IEJpZ051bWJlclxuICBjdXJyZW5jeT86IEJpZ051bWJlclxuICBuZXRUcmFuc2ZlckFtb3VudD86IEJpZ051bWJlclxuICBiZW5lZmljaWFyeVRyYW5zZmVyQW1vdW50PzogQmlnTnVtYmVyXG4gIGdvdkZlZUFtb3VudD86IEJpZ051bWJlclxuICBjYWxsZXI6IHN0cmluZ1xuICB0aW1lc3RhbXA/OiBudW1iZXJcbiAgdHhIYXNoOiBzdHJpbmdcbn1cblxuZXhwb3J0IHR5cGUgVGFwRXZlbnRKc29uID0gUmVjb3JkPGtleW9mIFRhcEV2ZW50LCBzdHJpbmc+XG5cbmV4cG9ydCBjb25zdCBwYXJzZVRhcEV2ZW50SnNvbiA9IChqc29uOiBUYXBFdmVudEpzb24pOiBUYXBFdmVudCA9PiAoe1xuICAuLi5qc29uLFxuICBwcm9qZWN0OiBqc29uLnByb2plY3QgPyBCaWdOdW1iZXIuZnJvbShqc29uLnByb2plY3QpIDogdW5kZWZpbmVkLFxuICBmdW5kaW5nQ3ljbGVJZDoganNvbi5mdW5kaW5nQ3ljbGVJZFxuICAgID8gQmlnTnVtYmVyLmZyb20oanNvbi5mdW5kaW5nQ3ljbGVJZClcbiAgICA6IHVuZGVmaW5lZCxcbiAgYW1vdW50OiBqc29uLmFtb3VudCA/IEJpZ051bWJlci5mcm9tKGpzb24uYW1vdW50KSA6IHVuZGVmaW5lZCxcbiAgY3VycmVuY3k6IGpzb24uY3VycmVuY3kgPyBCaWdOdW1iZXIuZnJvbShqc29uLmN1cnJlbmN5KSA6IHVuZGVmaW5lZCxcbiAgbmV0VHJhbnNmZXJBbW91bnQ6IGpzb24ubmV0VHJhbnNmZXJBbW91bnRcbiAgICA/IEJpZ051bWJlci5mcm9tKGpzb24ubmV0VHJhbnNmZXJBbW91bnQpXG4gICAgOiB1bmRlZmluZWQsXG4gIGJlbmVmaWNpYXJ5VHJhbnNmZXJBbW91bnQ6IGpzb24uYmVuZWZpY2lhcnlUcmFuc2ZlckFtb3VudFxuICAgID8gQmlnTnVtYmVyLmZyb20oanNvbi5iZW5lZmljaWFyeVRyYW5zZmVyQW1vdW50KVxuICAgIDogdW5kZWZpbmVkLFxuICBnb3ZGZWVBbW91bnQ6IGpzb24uZ292RmVlQW1vdW50XG4gICAgPyBCaWdOdW1iZXIuZnJvbShqc29uLmdvdkZlZUFtb3VudClcbiAgICA6IHVuZGVmaW5lZCxcbiAgdGltZXN0YW1wOiBqc29uLnRpbWVzdGFtcCA/IHBhcnNlSW50KGpzb24udGltZXN0YW1wKSA6IHVuZGVmaW5lZCxcbn0pXG4iLCIvKiAoaWdub3JlZCkgKi8iXSwic291cmNlUm9vdCI6IiJ9